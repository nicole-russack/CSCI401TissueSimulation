{"ast":null,"code":"import { decompressSync, strFromU8 } from 'fflate';\nimport macro from 'vtk.js/Sources/macros';\nimport Endian from 'vtk.js/Sources/Common/Core/Endian';\nimport { DataTypeByteSize } from 'vtk.js/Sources/Common/Core/DataArray/Constants';\nimport { registerType } from 'vtk.js/Sources/IO/Core/DataAccessHelper';\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\n/* eslint-disable prefer-promise-reject-errors */\n\nlet requestCount = 0;\n\nfunction openAsyncXHR(method, url) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const xhr = new XMLHttpRequest();\n  xhr.open(method, url, true);\n\n  if (options.headers) {\n    Object.entries(options.headers).forEach(_ref => {\n      let [key, value] = _ref;\n      return xhr.setRequestHeader(key, value);\n    });\n  }\n\n  if (options.progressCallback) {\n    xhr.addEventListener('progress', options.progressCallback);\n  }\n\n  return xhr;\n}\n\nfunction fetchBinary(url) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (options && options.compression && options.compression !== 'gz') {\n    vtkErrorMacro('Supported algorithms are: [gz]');\n    vtkErrorMacro(`Unkown compression algorithm: ${options.compression}`);\n  }\n\n  return new Promise((resolve, reject) => {\n    const xhr = openAsyncXHR('GET', url, options);\n\n    xhr.onreadystatechange = e => {\n      if (xhr.readyState === 4) {\n        if (xhr.status === 200 || xhr.status === 0) {\n          if (options.compression) {\n            resolve(decompressSync(new Uint8Array(xhr.response)).buffer);\n          } else {\n            resolve(xhr.response);\n          }\n        } else {\n          reject({\n            xhr,\n            e\n          });\n        }\n      }\n    }; // Make request\n\n\n    xhr.responseType = 'arraybuffer';\n    xhr.send();\n  });\n}\n\nfunction fetchArray(instance, baseURL, array) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (array.ref && !array.ref.pending) {\n    return new Promise((resolve, reject) => {\n      let url = null;\n\n      if (array.ref.url) {\n        url = array.ref.url;\n      } else {\n        url = [baseURL, array.ref.basepath, options.compression ? `${array.ref.id}.gz` : array.ref.id].join('/');\n      }\n\n      const xhr = openAsyncXHR('GET', url, options);\n\n      xhr.onreadystatechange = e => {\n        if (xhr.readyState === 1) {\n          array.ref.pending = true;\n\n          if (++requestCount === 1 && instance?.invokeBusy) {\n            instance.invokeBusy(true);\n          }\n        }\n\n        if (xhr.readyState === 4) {\n          array.ref.pending = false;\n\n          if (xhr.status === 200 || xhr.status === 0) {\n            array.buffer = xhr.response;\n\n            if (options.compression) {\n              if (array.dataType === 'string' || array.dataType === 'JSON') {\n                array.buffer = strFromU8(decompressSync(new Uint8Array(array.buffer)));\n              } else {\n                array.buffer = decompressSync(new Uint8Array(array.buffer)).buffer;\n              }\n            }\n\n            if (array.ref.encode === 'JSON') {\n              array.values = JSON.parse(array.buffer);\n            } else {\n              if (Endian.ENDIANNESS !== array.ref.encode && Endian.ENDIANNESS) {\n                // Need to swap bytes\n                vtkDebugMacro(`Swap bytes of ${array.name}`);\n                Endian.swapBytes(array.buffer, DataTypeByteSize[array.dataType]);\n              }\n\n              array.values = macro.newTypedArray(array.dataType, array.buffer);\n            }\n\n            if (array.values.length !== array.size) {\n              vtkErrorMacro(`Error in FetchArray: ${array.name}, does not have the proper array size. Got ${array.values.length}, instead of ${array.size}`);\n            } // Done with the ref and work\n\n\n            delete array.ref;\n\n            if (--requestCount === 0 && instance?.invokeBusy) {\n              instance.invokeBusy(false);\n            }\n\n            if (instance?.modified) {\n              instance.modified();\n            }\n\n            resolve(array);\n          } else {\n            reject({\n              xhr,\n              e\n            });\n          }\n        }\n      }; // Make request\n\n\n      xhr.responseType = options.compression || array.dataType !== 'string' ? 'arraybuffer' : 'text';\n      xhr.send();\n    });\n  }\n\n  return Promise.resolve(array);\n} // ----------------------------------------------------------------------------\n\n\nfunction fetchJSON(instance, url) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return new Promise((resolve, reject) => {\n    const xhr = openAsyncXHR('GET', url, options);\n\n    xhr.onreadystatechange = e => {\n      if (xhr.readyState === 1) {\n        if (++requestCount === 1 && instance?.invokeBusy) {\n          instance.invokeBusy(true);\n        }\n      }\n\n      if (xhr.readyState === 4) {\n        if (--requestCount === 0 && instance?.invokeBusy) {\n          instance.invokeBusy(false);\n        }\n\n        if (xhr.status === 200 || xhr.status === 0) {\n          if (options.compression) {\n            resolve(JSON.parse(strFromU8(decompressSync(new Uint8Array(xhr.response)))));\n          } else {\n            resolve(JSON.parse(xhr.responseText));\n          }\n        } else {\n          reject({\n            xhr,\n            e\n          });\n        }\n      }\n    }; // Make request\n\n\n    xhr.responseType = options.compression ? 'arraybuffer' : 'text';\n    xhr.send();\n  });\n} // ----------------------------------------------------------------------------\n\n\nfunction fetchText(instance, url) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (options && options.compression && options.compression !== 'gz') {\n    vtkErrorMacro('Supported algorithms are: [gz]');\n    vtkErrorMacro(`Unkown compression algorithm: ${options.compression}`);\n  }\n\n  return new Promise((resolve, reject) => {\n    const xhr = openAsyncXHR('GET', url, options);\n\n    xhr.onreadystatechange = e => {\n      if (xhr.readyState === 1) {\n        if (++requestCount === 1 && instance?.invokeBusy) {\n          instance.invokeBusy(true);\n        }\n      }\n\n      if (xhr.readyState === 4) {\n        if (--requestCount === 0 && instance?.invokeBusy) {\n          instance.invokeBusy(false);\n        }\n\n        if (xhr.status === 200 || xhr.status === 0) {\n          if (options.compression) {\n            resolve(strFromU8(decompressSync(new Uint8Array(xhr.response))));\n          } else {\n            resolve(xhr.responseText);\n          }\n        } else {\n          reject({\n            xhr,\n            e\n          });\n        }\n      }\n    }; // Make request\n\n\n    xhr.responseType = options.compression ? 'arraybuffer' : 'text';\n    xhr.send();\n  });\n} // ----------------------------------------------------------------------------\n\n\nfunction fetchImage(instance, url) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n\n    if (options.crossOrigin) {\n      img.crossOrigin = options.crossOrigin;\n    }\n\n    img.onload = () => resolve(img);\n\n    img.onerror = reject;\n    img.src = url;\n  });\n}\n/* eslint-enable prefer-promise-reject-errors */\n// ----------------------------------------------------------------------------\n\n\nconst HttpDataAccessHelper = {\n  fetchArray,\n  fetchJSON,\n  fetchText,\n  fetchBinary,\n  // Only for HTTP\n  fetchImage\n};\nregisterType('http', options => HttpDataAccessHelper);\nexport default HttpDataAccessHelper;","map":{"version":3,"names":["decompressSync","strFromU8","macro","Endian","DataTypeByteSize","registerType","vtkErrorMacro","vtkDebugMacro","requestCount","openAsyncXHR","method","url","options","xhr","XMLHttpRequest","open","headers","Object","entries","forEach","key","value","setRequestHeader","progressCallback","addEventListener","fetchBinary","compression","Promise","resolve","reject","onreadystatechange","e","readyState","status","Uint8Array","response","buffer","responseType","send","fetchArray","instance","baseURL","array","ref","pending","basepath","id","join","invokeBusy","dataType","encode","values","JSON","parse","ENDIANNESS","name","swapBytes","newTypedArray","length","size","modified","fetchJSON","responseText","fetchText","fetchImage","img","Image","crossOrigin","onload","onerror","src","HttpDataAccessHelper"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/IO/Core/DataAccessHelper/HttpDataAccessHelper.js"],"sourcesContent":["import { decompressSync, strFromU8 } from 'fflate';\n\nimport macro from 'vtk.js/Sources/macros';\nimport Endian from 'vtk.js/Sources/Common/Core/Endian';\nimport { DataTypeByteSize } from 'vtk.js/Sources/Common/Core/DataArray/Constants';\nimport { registerType } from 'vtk.js/Sources/IO/Core/DataAccessHelper';\n\nconst { vtkErrorMacro, vtkDebugMacro } = macro;\n\n/* eslint-disable prefer-promise-reject-errors */\n\nlet requestCount = 0;\n\nfunction openAsyncXHR(method, url, options = {}) {\n  const xhr = new XMLHttpRequest();\n  xhr.open(method, url, true);\n\n  if (options.headers) {\n    Object.entries(options.headers).forEach(([key, value]) =>\n      xhr.setRequestHeader(key, value)\n    );\n  }\n\n  if (options.progressCallback) {\n    xhr.addEventListener('progress', options.progressCallback);\n  }\n\n  return xhr;\n}\n\nfunction fetchBinary(url, options = {}) {\n  if (options && options.compression && options.compression !== 'gz') {\n    vtkErrorMacro('Supported algorithms are: [gz]');\n    vtkErrorMacro(`Unkown compression algorithm: ${options.compression}`);\n  }\n\n  return new Promise((resolve, reject) => {\n    const xhr = openAsyncXHR('GET', url, options);\n\n    xhr.onreadystatechange = (e) => {\n      if (xhr.readyState === 4) {\n        if (xhr.status === 200 || xhr.status === 0) {\n          if (options.compression) {\n            resolve(decompressSync(new Uint8Array(xhr.response)).buffer);\n          } else {\n            resolve(xhr.response);\n          }\n        } else {\n          reject({ xhr, e });\n        }\n      }\n    };\n\n    // Make request\n    xhr.responseType = 'arraybuffer';\n    xhr.send();\n  });\n}\n\nfunction fetchArray(instance, baseURL, array, options = {}) {\n  if (array.ref && !array.ref.pending) {\n    return new Promise((resolve, reject) => {\n      let url = null;\n\n      if (array.ref.url) {\n        url = array.ref.url;\n      } else {\n        url = [\n          baseURL,\n          array.ref.basepath,\n          options.compression ? `${array.ref.id}.gz` : array.ref.id,\n        ].join('/');\n      }\n\n      const xhr = openAsyncXHR('GET', url, options);\n\n      xhr.onreadystatechange = (e) => {\n        if (xhr.readyState === 1) {\n          array.ref.pending = true;\n          if (++requestCount === 1 && instance?.invokeBusy) {\n            instance.invokeBusy(true);\n          }\n        }\n        if (xhr.readyState === 4) {\n          array.ref.pending = false;\n          if (xhr.status === 200 || xhr.status === 0) {\n            array.buffer = xhr.response;\n\n            if (options.compression) {\n              if (array.dataType === 'string' || array.dataType === 'JSON') {\n                array.buffer = strFromU8(\n                  decompressSync(new Uint8Array(array.buffer))\n                );\n              } else {\n                array.buffer = decompressSync(\n                  new Uint8Array(array.buffer)\n                ).buffer;\n              }\n            }\n\n            if (array.ref.encode === 'JSON') {\n              array.values = JSON.parse(array.buffer);\n            } else {\n              if (Endian.ENDIANNESS !== array.ref.encode && Endian.ENDIANNESS) {\n                // Need to swap bytes\n                vtkDebugMacro(`Swap bytes of ${array.name}`);\n                Endian.swapBytes(\n                  array.buffer,\n                  DataTypeByteSize[array.dataType]\n                );\n              }\n\n              array.values = macro.newTypedArray(array.dataType, array.buffer);\n            }\n\n            if (array.values.length !== array.size) {\n              vtkErrorMacro(\n                `Error in FetchArray: ${array.name}, does not have the proper array size. Got ${array.values.length}, instead of ${array.size}`\n              );\n            }\n\n            // Done with the ref and work\n            delete array.ref;\n            if (--requestCount === 0 && instance?.invokeBusy) {\n              instance.invokeBusy(false);\n            }\n            if (instance?.modified) {\n              instance.modified();\n            }\n            resolve(array);\n          } else {\n            reject({ xhr, e });\n          }\n        }\n      };\n\n      // Make request\n      xhr.responseType =\n        options.compression || array.dataType !== 'string'\n          ? 'arraybuffer'\n          : 'text';\n      xhr.send();\n    });\n  }\n\n  return Promise.resolve(array);\n}\n\n// ----------------------------------------------------------------------------\n\nfunction fetchJSON(instance, url, options = {}) {\n  return new Promise((resolve, reject) => {\n    const xhr = openAsyncXHR('GET', url, options);\n\n    xhr.onreadystatechange = (e) => {\n      if (xhr.readyState === 1) {\n        if (++requestCount === 1 && instance?.invokeBusy) {\n          instance.invokeBusy(true);\n        }\n      }\n      if (xhr.readyState === 4) {\n        if (--requestCount === 0 && instance?.invokeBusy) {\n          instance.invokeBusy(false);\n        }\n        if (xhr.status === 200 || xhr.status === 0) {\n          if (options.compression) {\n            resolve(\n              JSON.parse(\n                strFromU8(decompressSync(new Uint8Array(xhr.response)))\n              )\n            );\n          } else {\n            resolve(JSON.parse(xhr.responseText));\n          }\n        } else {\n          reject({ xhr, e });\n        }\n      }\n    };\n\n    // Make request\n    xhr.responseType = options.compression ? 'arraybuffer' : 'text';\n    xhr.send();\n  });\n}\n\n// ----------------------------------------------------------------------------\n\nfunction fetchText(instance, url, options = {}) {\n  if (options && options.compression && options.compression !== 'gz') {\n    vtkErrorMacro('Supported algorithms are: [gz]');\n    vtkErrorMacro(`Unkown compression algorithm: ${options.compression}`);\n  }\n\n  return new Promise((resolve, reject) => {\n    const xhr = openAsyncXHR('GET', url, options);\n\n    xhr.onreadystatechange = (e) => {\n      if (xhr.readyState === 1) {\n        if (++requestCount === 1 && instance?.invokeBusy) {\n          instance.invokeBusy(true);\n        }\n      }\n      if (xhr.readyState === 4) {\n        if (--requestCount === 0 && instance?.invokeBusy) {\n          instance.invokeBusy(false);\n        }\n        if (xhr.status === 200 || xhr.status === 0) {\n          if (options.compression) {\n            resolve(strFromU8(decompressSync(new Uint8Array(xhr.response))));\n          } else {\n            resolve(xhr.responseText);\n          }\n        } else {\n          reject({ xhr, e });\n        }\n      }\n    };\n\n    // Make request\n    xhr.responseType = options.compression ? 'arraybuffer' : 'text';\n    xhr.send();\n  });\n}\n\n// ----------------------------------------------------------------------------\n\nfunction fetchImage(instance, url, options = {}) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    if (options.crossOrigin) {\n      img.crossOrigin = options.crossOrigin;\n    }\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = url;\n  });\n}\n/* eslint-enable prefer-promise-reject-errors */\n\n// ----------------------------------------------------------------------------\n\nconst HttpDataAccessHelper = {\n  fetchArray,\n  fetchJSON,\n  fetchText,\n  fetchBinary, // Only for HTTP\n  fetchImage,\n};\n\nregisterType('http', (options) => HttpDataAccessHelper);\n\nexport default HttpDataAccessHelper;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}