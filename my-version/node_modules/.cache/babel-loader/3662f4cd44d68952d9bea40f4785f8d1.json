{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nconst {\n  vtkErrorMacro\n} = macro;\nconst PASS_TYPES = ['Build', 'Render']; // ----------------------------------------------------------------------------\n// vtkViewNode methods\n// ----------------------------------------------------------------------------\n\nfunction vtkViewNode(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkViewNode'); // Builds myself.\n\n  publicAPI.build = prepass => {}; // Renders myself\n\n\n  publicAPI.render = prepass => {};\n\n  publicAPI.traverse = renderPass => {\n    // we can choose to do special\n    // traversal here based on pass\n    const passTraversal = renderPass.getTraverseOperation();\n    const fn = publicAPI[passTraversal];\n\n    if (fn) {\n      fn(renderPass);\n      return;\n    } // default traversal\n\n\n    publicAPI.apply(renderPass, true);\n\n    for (let index = 0; index < model.children.length; index++) {\n      model.children[index].traverse(renderPass);\n    }\n\n    publicAPI.apply(renderPass, false);\n  };\n\n  publicAPI.apply = (renderPass, prepass) => {\n    const customRenderPass = publicAPI[renderPass.getOperation()];\n\n    if (customRenderPass) {\n      customRenderPass(prepass, renderPass);\n    }\n  };\n\n  publicAPI.getViewNodeFor = dataObject => {\n    if (model.renderable === dataObject) {\n      return publicAPI;\n    }\n\n    for (let index = 0; index < model.children.length; ++index) {\n      const child = model.children[index];\n      const vn = child.getViewNodeFor(dataObject);\n\n      if (vn) {\n        return vn;\n      }\n    }\n\n    return undefined;\n  };\n\n  publicAPI.getFirstAncestorOfType = type => {\n    if (!model._parent) {\n      return null;\n    }\n\n    if (model._parent.isA(type)) {\n      return model._parent;\n    }\n\n    return model._parent.getFirstAncestorOfType(type);\n  }; // add a missing node/child for the passed in renderables. This should\n  // be called only in between prepareNodes and removeUnusedNodes\n\n\n  publicAPI.addMissingNode = dobj => {\n    if (!dobj) {\n      return;\n    }\n\n    const result = model._renderableChildMap.get(dobj); // if found just mark as visited\n\n\n    if (result !== undefined) {\n      result.setVisited(true);\n    } else {\n      // otherwise create a node\n      const newNode = publicAPI.createViewNode(dobj);\n\n      if (newNode) {\n        newNode.setParent(publicAPI);\n        newNode.setVisited(true);\n\n        model._renderableChildMap.set(dobj, newNode);\n\n        model.children.push(newNode);\n      }\n    }\n  }; // add missing nodes/children for the passed in renderables. This should\n  // be called only in between prepareNodes and removeUnusedNodes\n\n\n  publicAPI.addMissingNodes = dataObjs => {\n    if (!dataObjs || !dataObjs.length) {\n      return;\n    }\n\n    for (let index = 0; index < dataObjs.length; ++index) {\n      const dobj = dataObjs[index];\n\n      const result = model._renderableChildMap.get(dobj); // if found just mark as visited\n\n\n      if (result !== undefined) {\n        result.setVisited(true);\n      } else {\n        // otherwise create a node\n        const newNode = publicAPI.createViewNode(dobj);\n\n        if (newNode) {\n          newNode.setParent(publicAPI);\n          newNode.setVisited(true);\n\n          model._renderableChildMap.set(dobj, newNode);\n\n          model.children.push(newNode);\n        }\n      }\n    }\n  }; // ability to add children that have no renderable use in the same manner\n  // as addMissingNodes This case is when a normal viewnode wants to\n  // delegate passes to a helper or child that doeasn't map to a clear\n  // renderable or any renderable\n\n\n  publicAPI.addMissingChildren = children => {\n    if (!children || !children.length) {\n      return;\n    }\n\n    for (let index = 0; index < children.length; ++index) {\n      const child = children[index];\n      const cindex = model.children.indexOf(child);\n\n      if (cindex === -1) {\n        child.setParent(publicAPI);\n        model.children.push(child);\n      }\n\n      child.setVisited(true);\n    }\n  };\n\n  publicAPI.prepareNodes = () => {\n    for (let index = 0; index < model.children.length; ++index) {\n      model.children[index].setVisited(false);\n    }\n  };\n\n  publicAPI.setVisited = val => {\n    model.visited = val;\n  };\n\n  publicAPI.removeUnusedNodes = () => {\n    let deleted = null;\n\n    for (let index = 0; index < model.children.length; ++index) {\n      const child = model.children[index];\n      const visited = child.getVisited();\n\n      if (!visited) {\n        const renderable = child.getRenderable();\n\n        if (renderable) {\n          model._renderableChildMap.delete(renderable);\n        }\n\n        if (!deleted) {\n          deleted = [];\n        }\n\n        deleted.push(child);\n      } else {\n        child.setVisited(false);\n      }\n    }\n\n    if (deleted) {\n      // slow does alloc but not as common\n      model.children = model.children.filter(el => !deleted.includes(el));\n    }\n  };\n\n  publicAPI.createViewNode = dataObj => {\n    if (!model.myFactory) {\n      vtkErrorMacro('Cannot create view nodes without my own factory');\n      return null;\n    }\n\n    const ret = model.myFactory.createNode(dataObj);\n\n    if (ret) {\n      ret.setRenderable(dataObj);\n    }\n\n    return ret;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  // _parent: null,\n  renderable: null,\n  myFactory: null,\n  children: [],\n  visited: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.event(publicAPI, model, 'event');\n  model._renderableChildMap = new Map();\n  macro.get(publicAPI, model, ['visited']);\n  macro.setGet(publicAPI, model, ['_parent', 'renderable', 'myFactory']);\n  macro.getArray(publicAPI, model, ['children']);\n  macro.moveToProtected(publicAPI, model, ['parent']); // Object methods\n\n  vtkViewNode(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\n\nconst newInstance = macro.newInstance(extend, 'vtkViewNode'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend,\n  PASS_TYPES\n};","map":{"version":3,"names":["macro","vtkErrorMacro","PASS_TYPES","vtkViewNode","publicAPI","model","classHierarchy","push","build","prepass","render","traverse","renderPass","passTraversal","getTraverseOperation","fn","apply","index","children","length","customRenderPass","getOperation","getViewNodeFor","dataObject","renderable","child","vn","undefined","getFirstAncestorOfType","type","_parent","isA","addMissingNode","dobj","result","_renderableChildMap","get","setVisited","newNode","createViewNode","setParent","set","addMissingNodes","dataObjs","addMissingChildren","cindex","indexOf","prepareNodes","val","visited","removeUnusedNodes","deleted","getVisited","getRenderable","delete","filter","el","includes","dataObj","myFactory","ret","createNode","setRenderable","DEFAULT_VALUES","extend","initialValues","Object","assign","obj","event","Map","setGet","getArray","moveToProtected","newInstance"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNode/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\n\nconst { vtkErrorMacro } = macro;\n\nconst PASS_TYPES = ['Build', 'Render'];\n\n// ----------------------------------------------------------------------------\n// vtkViewNode methods\n// ----------------------------------------------------------------------------\n\nfunction vtkViewNode(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkViewNode');\n\n  // Builds myself.\n  publicAPI.build = (prepass) => {};\n\n  // Renders myself\n  publicAPI.render = (prepass) => {};\n\n  publicAPI.traverse = (renderPass) => {\n    // we can choose to do special\n    // traversal here based on pass\n    const passTraversal = renderPass.getTraverseOperation();\n    const fn = publicAPI[passTraversal];\n    if (fn) {\n      fn(renderPass);\n      return;\n    }\n\n    // default traversal\n    publicAPI.apply(renderPass, true);\n\n    for (let index = 0; index < model.children.length; index++) {\n      model.children[index].traverse(renderPass);\n    }\n\n    publicAPI.apply(renderPass, false);\n  };\n\n  publicAPI.apply = (renderPass, prepass) => {\n    const customRenderPass = publicAPI[renderPass.getOperation()];\n    if (customRenderPass) {\n      customRenderPass(prepass, renderPass);\n    }\n  };\n\n  publicAPI.getViewNodeFor = (dataObject) => {\n    if (model.renderable === dataObject) {\n      return publicAPI;\n    }\n\n    for (let index = 0; index < model.children.length; ++index) {\n      const child = model.children[index];\n      const vn = child.getViewNodeFor(dataObject);\n      if (vn) {\n        return vn;\n      }\n    }\n    return undefined;\n  };\n\n  publicAPI.getFirstAncestorOfType = (type) => {\n    if (!model._parent) {\n      return null;\n    }\n    if (model._parent.isA(type)) {\n      return model._parent;\n    }\n    return model._parent.getFirstAncestorOfType(type);\n  };\n\n  // add a missing node/child for the passed in renderables. This should\n  // be called only in between prepareNodes and removeUnusedNodes\n  publicAPI.addMissingNode = (dobj) => {\n    if (!dobj) {\n      return;\n    }\n    const result = model._renderableChildMap.get(dobj);\n    // if found just mark as visited\n    if (result !== undefined) {\n      result.setVisited(true);\n    } else {\n      // otherwise create a node\n      const newNode = publicAPI.createViewNode(dobj);\n      if (newNode) {\n        newNode.setParent(publicAPI);\n        newNode.setVisited(true);\n        model._renderableChildMap.set(dobj, newNode);\n        model.children.push(newNode);\n      }\n    }\n  };\n\n  // add missing nodes/children for the passed in renderables. This should\n  // be called only in between prepareNodes and removeUnusedNodes\n  publicAPI.addMissingNodes = (dataObjs) => {\n    if (!dataObjs || !dataObjs.length) {\n      return;\n    }\n\n    for (let index = 0; index < dataObjs.length; ++index) {\n      const dobj = dataObjs[index];\n      const result = model._renderableChildMap.get(dobj);\n      // if found just mark as visited\n      if (result !== undefined) {\n        result.setVisited(true);\n      } else {\n        // otherwise create a node\n        const newNode = publicAPI.createViewNode(dobj);\n        if (newNode) {\n          newNode.setParent(publicAPI);\n          newNode.setVisited(true);\n          model._renderableChildMap.set(dobj, newNode);\n          model.children.push(newNode);\n        }\n      }\n    }\n  };\n\n  // ability to add children that have no renderable use in the same manner\n  // as addMissingNodes This case is when a normal viewnode wants to\n  // delegate passes to a helper or child that doeasn't map to a clear\n  // renderable or any renderable\n  publicAPI.addMissingChildren = (children) => {\n    if (!children || !children.length) {\n      return;\n    }\n\n    for (let index = 0; index < children.length; ++index) {\n      const child = children[index];\n      const cindex = model.children.indexOf(child);\n      if (cindex === -1) {\n        child.setParent(publicAPI);\n        model.children.push(child);\n      }\n      child.setVisited(true);\n    }\n  };\n\n  publicAPI.prepareNodes = () => {\n    for (let index = 0; index < model.children.length; ++index) {\n      model.children[index].setVisited(false);\n    }\n  };\n\n  publicAPI.setVisited = (val) => {\n    model.visited = val;\n  };\n\n  publicAPI.removeUnusedNodes = () => {\n    let deleted = null;\n    for (let index = 0; index < model.children.length; ++index) {\n      const child = model.children[index];\n      const visited = child.getVisited();\n      if (!visited) {\n        const renderable = child.getRenderable();\n        if (renderable) {\n          model._renderableChildMap.delete(renderable);\n        }\n        if (!deleted) {\n          deleted = [];\n        }\n        deleted.push(child);\n      } else {\n        child.setVisited(false);\n      }\n    }\n\n    if (deleted) {\n      // slow does alloc but not as common\n      model.children = model.children.filter((el) => !deleted.includes(el));\n    }\n  };\n\n  publicAPI.createViewNode = (dataObj) => {\n    if (!model.myFactory) {\n      vtkErrorMacro('Cannot create view nodes without my own factory');\n      return null;\n    }\n    const ret = model.myFactory.createNode(dataObj);\n    if (ret) {\n      ret.setRenderable(dataObj);\n    }\n    return ret;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // _parent: null,\n  renderable: null,\n  myFactory: null,\n  children: [],\n  visited: false,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.event(publicAPI, model, 'event');\n\n  model._renderableChildMap = new Map();\n\n  macro.get(publicAPI, model, ['visited']);\n  macro.setGet(publicAPI, model, ['_parent', 'renderable', 'myFactory']);\n  macro.getArray(publicAPI, model, ['children']);\n  macro.moveToProtected(publicAPI, model, ['parent']);\n\n  // Object methods\n  vtkViewNode(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkViewNode');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend, PASS_TYPES };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}