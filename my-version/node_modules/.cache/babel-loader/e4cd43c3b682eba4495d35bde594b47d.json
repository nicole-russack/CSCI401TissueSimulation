{"ast":null,"code":"import Constants from 'vtk.js/Sources/Common/Core/DataArray/Constants';\nimport * as macro from 'vtk.js/Sources/macros';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nconst {\n  vtkErrorMacro\n} = macro;\nconst {\n  DefaultDataType\n} = Constants; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n// Original source from https://www.npmjs.com/package/compute-range\n// Modified to accept type arrays\n\nfunction fastComputeRange(arr, offset, numberOfComponents) {\n  const len = arr.length;\n  let min;\n  let max;\n  let x;\n  let i;\n\n  if (len === 0) {\n    return {\n      min: Number.MAX_VALUE,\n      max: -Number.MAX_VALUE\n    };\n  }\n\n  min = arr[offset];\n  max = min;\n\n  for (i = offset; i < len; i += numberOfComponents) {\n    x = arr[i];\n\n    if (x < min) {\n      min = x;\n    } else if (x > max) {\n      max = x;\n    }\n  }\n\n  return {\n    min,\n    max\n  };\n}\n/**\n * @deprecated please use fastComputeRange instead\n */\n\n\nfunction createRangeHelper() {\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let count = 0;\n  let sum = 0;\n  return {\n    add(value) {\n      if (min > value) {\n        min = value;\n      }\n\n      if (max < value) {\n        max = value;\n      }\n\n      count++;\n      sum += value;\n    },\n\n    get() {\n      return {\n        min,\n        max,\n        count,\n        sum,\n        mean: sum / count\n      };\n    },\n\n    getRange() {\n      return {\n        min,\n        max\n      };\n    }\n\n  };\n}\n\nfunction computeRange(values) {\n  let component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let numberOfComponents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n  if (component < 0 && numberOfComponents > 1) {\n    // Compute magnitude\n    const size = values.length;\n    const numberOfValues = size / numberOfComponents;\n    const data = new Float64Array(numberOfValues);\n\n    for (let i = 0, j = 0; i < numberOfValues; ++i) {\n      for (let nextJ = j + numberOfComponents; j < nextJ; ++j) {\n        data[i] += values[j] * values[j];\n      }\n\n      data[i] **= 0.5;\n    }\n\n    return fastComputeRange(data, 0, 1);\n  }\n\n  return fastComputeRange(values, component < 0 ? 0 : component, numberOfComponents);\n}\n\nfunction ensureRangeSize(rangeArray) {\n  let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const ranges = rangeArray || []; // Pad ranges with null value to get the\n\n  while (ranges.length <= size) {\n    ranges.push(null);\n  }\n\n  return ranges;\n}\n\nfunction getDataType(typedArray) {\n  // Expects toString() to return \"[object ...Array]\"\n  return Object.prototype.toString.call(typedArray).slice(8, -1);\n}\n\nfunction getMaxNorm(normArray) {\n  const numComps = normArray.getNumberOfComponents();\n  let maxNorm = 0.0;\n  const tuple = new Array(numComps);\n\n  for (let i = 0; i < normArray.getNumberOfTuples(); ++i) {\n    normArray.getTuple(i, tuple);\n    const norm = vtkMath.norm(tuple, numComps);\n\n    if (norm > maxNorm) {\n      maxNorm = norm;\n    }\n  }\n\n  return maxNorm;\n} // ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\n\nexport const STATIC = {\n  computeRange,\n  createRangeHelper,\n  fastComputeRange,\n  getDataType,\n  getMaxNorm\n}; // ----------------------------------------------------------------------------\n// vtkDataArray methods\n// ----------------------------------------------------------------------------\n\nfunction vtkDataArray(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkDataArray');\n\n  function dataChange() {\n    model.ranges = null;\n    publicAPI.modified();\n  }\n  /**\n   * Resize model.values and copy the old values to the new array.\n   * @param {Number} requestedNumTuples Final expected number of tuples; must be >= 0\n   * @returns {Boolean} True if a resize occured, false otherwise\n   */\n\n\n  function resize(requestedNumTuples) {\n    if (requestedNumTuples < 0) {\n      return false;\n    }\n\n    const numComps = publicAPI.getNumberOfComponents();\n    const curNumTuples = model.values.length / (numComps > 0 ? numComps : 1);\n\n    if (requestedNumTuples === curNumTuples) {\n      return true;\n    }\n\n    if (requestedNumTuples > curNumTuples) {\n      // Requested size is bigger than current size.  Allocate enough\n      // memory to fit the requested size and be more than double the\n      // currently allocated memory.\n      const oldValues = model.values;\n      model.values = macro.newTypedArray(model.dataType, (requestedNumTuples + curNumTuples) * numComps);\n      model.values.set(oldValues);\n      return true;\n    } // Requested size is smaller than current size\n\n\n    model.size = requestedNumTuples * numComps;\n    dataChange();\n    return true;\n  }\n\n  publicAPI.initialize = () => {\n    resize(0);\n  };\n\n  publicAPI.getElementComponentSize = () => model.values.BYTES_PER_ELEMENT; // Description:\n  // Return the data component at the location specified by tupleIdx and\n  // compIdx.\n\n\n  publicAPI.getComponent = function (tupleIdx) {\n    let compIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return model.values[tupleIdx * model.numberOfComponents + compIdx];\n  }; // Description:\n  // Set the data component at the location specified by tupleIdx and compIdx\n  // to value.\n  // Note that i is less than NumberOfTuples and j is less than\n  //  NumberOfComponents. Make sure enough memory has been allocated\n  // (use SetNumberOfTuples() and SetNumberOfComponents()).\n\n\n  publicAPI.setComponent = (tupleIdx, compIdx, value) => {\n    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {\n      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;\n      dataChange();\n    }\n  };\n\n  publicAPI.getValue = valueIdx => {\n    const idx = valueIdx / model.numberOfComponents;\n    const comp = valueIdx % model.numberOfComponents;\n    return publicAPI.getComponent(idx, comp);\n  };\n\n  publicAPI.setValue = (valueIdx, value) => {\n    const idx = valueIdx / model.numberOfComponents;\n    const comp = valueIdx % model.numberOfComponents;\n    publicAPI.setComponent(idx, comp, value);\n  };\n\n  publicAPI.getData = () => model.size === model.values.length ? model.values : model.values.subarray(0, model.size);\n\n  publicAPI.getRange = function () {\n    let componentIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n    const rangeIdx = componentIndex < 0 ? model.numberOfComponents : componentIndex;\n    let range = null;\n\n    if (!model.ranges) {\n      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);\n    }\n\n    range = model.ranges[rangeIdx];\n\n    if (range) {\n      model.rangeTuple[0] = range.min;\n      model.rangeTuple[1] = range.max;\n      return model.rangeTuple;\n    } // Need to compute ranges...\n\n\n    range = computeRange(publicAPI.getData(), componentIndex, model.numberOfComponents);\n    model.ranges[rangeIdx] = range;\n    model.rangeTuple[0] = range.min;\n    model.rangeTuple[1] = range.max;\n    return model.rangeTuple;\n  };\n\n  publicAPI.setRange = (rangeValue, componentIndex) => {\n    if (!model.ranges) {\n      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);\n    }\n\n    const range = {\n      min: rangeValue.min,\n      max: rangeValue.max\n    };\n    model.ranges[componentIndex] = range;\n    model.rangeTuple[0] = range.min;\n    model.rangeTuple[1] = range.max;\n    return model.rangeTuple;\n  };\n\n  publicAPI.setTuple = (idx, tuple) => {\n    const offset = idx * model.numberOfComponents;\n\n    for (let i = 0; i < model.numberOfComponents; i++) {\n      model.values[offset + i] = tuple[i];\n    }\n  };\n\n  publicAPI.setTuples = (idx, tuples) => {\n    let i = idx * model.numberOfComponents;\n    const last = Math.min(tuples.length, model.size - i);\n\n    for (let j = 0; j < last;) {\n      model.values[i++] = tuples[j++];\n    }\n  };\n\n  publicAPI.insertTuple = (idx, tuple) => {\n    if (model.size <= idx * model.numberOfComponents) {\n      model.size = (idx + 1) * model.numberOfComponents;\n      resize(idx + 1);\n    }\n\n    publicAPI.setTuple(idx, tuple);\n    return idx;\n  };\n\n  publicAPI.insertTuples = (idx, tuples) => {\n    const end = idx + tuples.length / model.numberOfComponents;\n\n    if (model.size < end * model.numberOfComponents) {\n      model.size = end * model.numberOfComponents;\n      resize(end);\n    }\n\n    publicAPI.setTuples(idx, tuples);\n    return end;\n  };\n\n  publicAPI.insertNextTuple = tuple => {\n    const idx = model.size / model.numberOfComponents;\n    return publicAPI.insertTuple(idx, tuple);\n  };\n\n  publicAPI.insertNextTuples = tuples => {\n    const idx = model.size / model.numberOfComponents;\n    return publicAPI.insertTuples(idx, tuples);\n  };\n\n  publicAPI.getTuple = function (idx) {\n    let tupleToFill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const numberOfComponents = model.numberOfComponents || 1;\n    const offset = idx * numberOfComponents; // Check most common component sizes first\n    // to avoid doing a for loop if possible\n\n    switch (numberOfComponents) {\n      case 4:\n        tupleToFill[3] = model.values[offset + 3];\n      // eslint-disable-next-line no-fallthrough\n\n      case 3:\n        tupleToFill[2] = model.values[offset + 2];\n      // eslint-disable-next-line no-fallthrough\n\n      case 2:\n        tupleToFill[1] = model.values[offset + 1];\n      // eslint-disable-next-line no-fallthrough\n\n      case 1:\n        tupleToFill[0] = model.values[offset];\n        break;\n\n      default:\n        for (let i = numberOfComponents - 1; i >= 0; --i) {\n          tupleToFill[i] = model.values[offset + i];\n        }\n\n    }\n\n    return tupleToFill;\n  };\n\n  publicAPI.getTuples = (fromId, toId) => {\n    const from = (fromId ?? 0) * model.numberOfComponents;\n    const to = (toId ?? publicAPI.getNumberOfTuples()) * model.numberOfComponents;\n    const arr = publicAPI.getData().subarray(from, to);\n    return arr.length > 0 ? arr : null;\n  };\n\n  publicAPI.getTupleLocation = function () {\n    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return idx * model.numberOfComponents;\n  };\n\n  publicAPI.getNumberOfComponents = () => model.numberOfComponents;\n\n  publicAPI.getNumberOfValues = () => model.size;\n\n  publicAPI.getNumberOfTuples = () => model.size / model.numberOfComponents;\n\n  publicAPI.getDataType = () => model.dataType;\n  /* eslint-disable no-use-before-define */\n\n\n  publicAPI.newClone = () => newInstance({\n    empty: true,\n    name: model.name,\n    dataType: model.dataType,\n    numberOfComponents: model.numberOfComponents\n  });\n  /* eslint-enable no-use-before-define */\n\n\n  publicAPI.getName = () => {\n    if (!model.name) {\n      publicAPI.modified();\n      model.name = `vtkDataArray${publicAPI.getMTime()}`;\n    }\n\n    return model.name;\n  };\n\n  publicAPI.setData = (typedArray, numberOfComponents) => {\n    model.values = typedArray;\n    model.size = typedArray.length;\n    model.dataType = getDataType(typedArray);\n\n    if (numberOfComponents) {\n      model.numberOfComponents = numberOfComponents;\n    }\n\n    if (model.size % model.numberOfComponents !== 0) {\n      model.numberOfComponents = 1;\n    }\n\n    dataChange();\n  }; // Override serialization support\n\n\n  publicAPI.getState = () => {\n    if (model.deleted) {\n      return null;\n    }\n\n    const jsonArchive = { ...model,\n      vtkClass: publicAPI.getClassName()\n    }; // Convert typed array to regular array\n\n    jsonArchive.values = Array.from(jsonArchive.values);\n    delete jsonArchive.buffer; // Clean any empty data\n\n    Object.keys(jsonArchive).forEach(keyName => {\n      if (!jsonArchive[keyName]) {\n        delete jsonArchive[keyName];\n      }\n    }); // Sort resulting object by key name\n\n    const sortedObj = {};\n    Object.keys(jsonArchive).sort().forEach(name => {\n      sortedObj[name] = jsonArchive[name];\n    }); // Remove mtime\n\n    if (sortedObj.mtime) {\n      delete sortedObj.mtime;\n    }\n\n    return sortedObj;\n  };\n\n  publicAPI.deepCopy = other => {\n    publicAPI.shallowCopy(other);\n    publicAPI.setData(other.getData().slice());\n  };\n\n  publicAPI.interpolateTuple = (idx, source1, source1Idx, source2, source2Idx, t) => {\n    const numberOfComponents = model.numberOfComponents || 1;\n\n    if (numberOfComponents !== source1.getNumberOfComponents() || numberOfComponents !== source2.getNumberOfComponents()) {\n      vtkErrorMacro('numberOfComponents must match');\n    }\n\n    const tuple1 = source1.getTuple(source1Idx);\n    const tuple2 = source2.getTuple(source2Idx);\n    const out = [];\n    out.length = numberOfComponents; // Check most common component sizes first\n    // to avoid doing a for loop if possible\n\n    switch (numberOfComponents) {\n      case 4:\n        out[3] = tuple1[3] + (tuple2[3] - tuple1[3]) * t;\n      // eslint-disable-next-line no-fallthrough\n\n      case 3:\n        out[2] = tuple1[2] + (tuple2[2] - tuple1[2]) * t;\n      // eslint-disable-next-line no-fallthrough\n\n      case 2:\n        out[1] = tuple1[1] + (tuple2[1] - tuple1[1]) * t;\n      // eslint-disable-next-line no-fallthrough\n\n      case 1:\n        out[0] = tuple1[0] + (tuple2[0] - tuple1[0]) * t;\n        break;\n\n      default:\n        for (let i = 0; i < numberOfComponents; i++) {\n          out[i] = tuple1[i] + (tuple2[i] - tuple1[i]) * t;\n        }\n\n    }\n\n    return publicAPI.insertTuple(idx, out);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n// size: The current size of the dataArray.\n// NOTE: The underlying typed array may be larger than 'size'.\n\n\nconst DEFAULT_VALUES = {\n  name: '',\n  numberOfComponents: 1,\n  dataType: DefaultDataType,\n  rangeTuple: [0, 0] // size: undefined,\n  // values: null,\n  // ranges: null,\n\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  if (!model.empty && !model.values && !model.size) {\n    throw new TypeError('Cannot create vtkDataArray object without: size > 0, values');\n  }\n\n  if (!model.values) {\n    model.values = macro.newTypedArray(model.dataType, model.size);\n  } else if (Array.isArray(model.values)) {\n    model.values = macro.newTypedArrayFrom(model.dataType, model.values);\n  }\n\n  if (model.values) {\n    // Takes the size if provided (can be lower than `model.values`) otherwise the actual length of `values`.\n    model.size = model.size ?? model.values.length;\n    model.dataType = getDataType(model.values);\n  } // Object methods\n\n\n  macro.obj(publicAPI, model);\n  macro.set(publicAPI, model, ['name', 'numberOfComponents']); // Object specific methods\n\n  vtkDataArray(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkDataArray'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend,\n  ...STATIC,\n  ...Constants\n};","map":{"version":3,"names":["Constants","macro","vtkMath","vtkErrorMacro","DefaultDataType","fastComputeRange","arr","offset","numberOfComponents","len","length","min","max","x","i","Number","MAX_VALUE","createRangeHelper","count","sum","add","value","get","mean","getRange","computeRange","values","component","size","numberOfValues","data","Float64Array","j","nextJ","ensureRangeSize","rangeArray","ranges","push","getDataType","typedArray","Object","prototype","toString","call","slice","getMaxNorm","normArray","numComps","getNumberOfComponents","maxNorm","tuple","Array","getNumberOfTuples","getTuple","norm","STATIC","vtkDataArray","publicAPI","model","classHierarchy","dataChange","modified","resize","requestedNumTuples","curNumTuples","oldValues","newTypedArray","dataType","set","initialize","getElementComponentSize","BYTES_PER_ELEMENT","getComponent","tupleIdx","compIdx","setComponent","getValue","valueIdx","idx","comp","setValue","getData","subarray","componentIndex","rangeIdx","range","rangeTuple","setRange","rangeValue","setTuple","setTuples","tuples","last","Math","insertTuple","insertTuples","end","insertNextTuple","insertNextTuples","tupleToFill","getTuples","fromId","toId","from","to","getTupleLocation","getNumberOfValues","newClone","newInstance","empty","name","getName","getMTime","setData","getState","deleted","jsonArchive","vtkClass","getClassName","buffer","keys","forEach","keyName","sortedObj","sort","mtime","deepCopy","other","shallowCopy","interpolateTuple","source1","source1Idx","source2","source2Idx","t","tuple1","tuple2","out","DEFAULT_VALUES","extend","initialValues","assign","TypeError","isArray","newTypedArrayFrom","obj"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Common/Core/DataArray/index.js"],"sourcesContent":["import Constants from 'vtk.js/Sources/Common/Core/DataArray/Constants';\nimport * as macro from 'vtk.js/Sources/macros';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\n\nconst { vtkErrorMacro } = macro;\nconst { DefaultDataType } = Constants;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n// Original source from https://www.npmjs.com/package/compute-range\n// Modified to accept type arrays\nfunction fastComputeRange(arr, offset, numberOfComponents) {\n  const len = arr.length;\n  let min;\n  let max;\n  let x;\n  let i;\n\n  if (len === 0) {\n    return { min: Number.MAX_VALUE, max: -Number.MAX_VALUE };\n  }\n  min = arr[offset];\n  max = min;\n  for (i = offset; i < len; i += numberOfComponents) {\n    x = arr[i];\n    if (x < min) {\n      min = x;\n    } else if (x > max) {\n      max = x;\n    }\n  }\n  return { min, max };\n}\n\n/**\n * @deprecated please use fastComputeRange instead\n */\nfunction createRangeHelper() {\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let count = 0;\n  let sum = 0;\n\n  return {\n    add(value) {\n      if (min > value) {\n        min = value;\n      }\n      if (max < value) {\n        max = value;\n      }\n      count++;\n      sum += value;\n    },\n    get() {\n      return { min, max, count, sum, mean: sum / count };\n    },\n    getRange() {\n      return { min, max };\n    },\n  };\n}\n\nfunction computeRange(values, component = 0, numberOfComponents = 1) {\n  if (component < 0 && numberOfComponents > 1) {\n    // Compute magnitude\n    const size = values.length;\n    const numberOfValues = size / numberOfComponents;\n    const data = new Float64Array(numberOfValues);\n    for (let i = 0, j = 0; i < numberOfValues; ++i) {\n      for (let nextJ = j + numberOfComponents; j < nextJ; ++j) {\n        data[i] += values[j] * values[j];\n      }\n      data[i] **= 0.5;\n    }\n    return fastComputeRange(data, 0, 1);\n  }\n\n  return fastComputeRange(\n    values,\n    component < 0 ? 0 : component,\n    numberOfComponents\n  );\n}\n\nfunction ensureRangeSize(rangeArray, size = 0) {\n  const ranges = rangeArray || [];\n  // Pad ranges with null value to get the\n  while (ranges.length <= size) {\n    ranges.push(null);\n  }\n  return ranges;\n}\n\nfunction getDataType(typedArray) {\n  // Expects toString() to return \"[object ...Array]\"\n  return Object.prototype.toString.call(typedArray).slice(8, -1);\n}\n\nfunction getMaxNorm(normArray) {\n  const numComps = normArray.getNumberOfComponents();\n  let maxNorm = 0.0;\n  const tuple = new Array(numComps);\n  for (let i = 0; i < normArray.getNumberOfTuples(); ++i) {\n    normArray.getTuple(i, tuple);\n    const norm = vtkMath.norm(tuple, numComps);\n    if (norm > maxNorm) {\n      maxNorm = norm;\n    }\n  }\n  return maxNorm;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nexport const STATIC = {\n  computeRange,\n  createRangeHelper,\n  fastComputeRange,\n  getDataType,\n  getMaxNorm,\n};\n\n// ----------------------------------------------------------------------------\n// vtkDataArray methods\n// ----------------------------------------------------------------------------\n\nfunction vtkDataArray(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkDataArray');\n\n  function dataChange() {\n    model.ranges = null;\n    publicAPI.modified();\n  }\n\n  /**\n   * Resize model.values and copy the old values to the new array.\n   * @param {Number} requestedNumTuples Final expected number of tuples; must be >= 0\n   * @returns {Boolean} True if a resize occured, false otherwise\n   */\n  function resize(requestedNumTuples) {\n    if (requestedNumTuples < 0) {\n      return false;\n    }\n\n    const numComps = publicAPI.getNumberOfComponents();\n    const curNumTuples = model.values.length / (numComps > 0 ? numComps : 1);\n    if (requestedNumTuples === curNumTuples) {\n      return true;\n    }\n\n    if (requestedNumTuples > curNumTuples) {\n      // Requested size is bigger than current size.  Allocate enough\n      // memory to fit the requested size and be more than double the\n      // currently allocated memory.\n      const oldValues = model.values;\n      model.values = macro.newTypedArray(\n        model.dataType,\n        (requestedNumTuples + curNumTuples) * numComps\n      );\n      model.values.set(oldValues);\n      return true;\n    }\n\n    // Requested size is smaller than current size\n    model.size = requestedNumTuples * numComps;\n    dataChange();\n    return true;\n  }\n\n  publicAPI.initialize = () => {\n    resize(0);\n  };\n\n  publicAPI.getElementComponentSize = () => model.values.BYTES_PER_ELEMENT;\n\n  // Description:\n  // Return the data component at the location specified by tupleIdx and\n  // compIdx.\n  publicAPI.getComponent = (tupleIdx, compIdx = 0) =>\n    model.values[tupleIdx * model.numberOfComponents + compIdx];\n\n  // Description:\n  // Set the data component at the location specified by tupleIdx and compIdx\n  // to value.\n  // Note that i is less than NumberOfTuples and j is less than\n  //  NumberOfComponents. Make sure enough memory has been allocated\n  // (use SetNumberOfTuples() and SetNumberOfComponents()).\n  publicAPI.setComponent = (tupleIdx, compIdx, value) => {\n    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {\n      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;\n      dataChange();\n    }\n  };\n\n  publicAPI.getValue = (valueIdx) => {\n    const idx = valueIdx / model.numberOfComponents;\n    const comp = valueIdx % model.numberOfComponents;\n    return publicAPI.getComponent(idx, comp);\n  };\n\n  publicAPI.setValue = (valueIdx, value) => {\n    const idx = valueIdx / model.numberOfComponents;\n    const comp = valueIdx % model.numberOfComponents;\n    publicAPI.setComponent(idx, comp, value);\n  };\n\n  publicAPI.getData = () =>\n    model.size === model.values.length\n      ? model.values\n      : model.values.subarray(0, model.size);\n\n  publicAPI.getRange = (componentIndex = -1) => {\n    const rangeIdx =\n      componentIndex < 0 ? model.numberOfComponents : componentIndex;\n    let range = null;\n\n    if (!model.ranges) {\n      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);\n    }\n    range = model.ranges[rangeIdx];\n\n    if (range) {\n      model.rangeTuple[0] = range.min;\n      model.rangeTuple[1] = range.max;\n      return model.rangeTuple;\n    }\n\n    // Need to compute ranges...\n    range = computeRange(\n      publicAPI.getData(),\n      componentIndex,\n      model.numberOfComponents\n    );\n    model.ranges[rangeIdx] = range;\n    model.rangeTuple[0] = range.min;\n    model.rangeTuple[1] = range.max;\n    return model.rangeTuple;\n  };\n\n  publicAPI.setRange = (rangeValue, componentIndex) => {\n    if (!model.ranges) {\n      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);\n    }\n    const range = { min: rangeValue.min, max: rangeValue.max };\n\n    model.ranges[componentIndex] = range;\n    model.rangeTuple[0] = range.min;\n    model.rangeTuple[1] = range.max;\n\n    return model.rangeTuple;\n  };\n\n  publicAPI.setTuple = (idx, tuple) => {\n    const offset = idx * model.numberOfComponents;\n    for (let i = 0; i < model.numberOfComponents; i++) {\n      model.values[offset + i] = tuple[i];\n    }\n  };\n\n  publicAPI.setTuples = (idx, tuples) => {\n    let i = idx * model.numberOfComponents;\n    const last = Math.min(tuples.length, model.size - i);\n    for (let j = 0; j < last; ) {\n      model.values[i++] = tuples[j++];\n    }\n  };\n\n  publicAPI.insertTuple = (idx, tuple) => {\n    if (model.size <= idx * model.numberOfComponents) {\n      model.size = (idx + 1) * model.numberOfComponents;\n      resize(idx + 1);\n    }\n    publicAPI.setTuple(idx, tuple);\n    return idx;\n  };\n\n  publicAPI.insertTuples = (idx, tuples) => {\n    const end = idx + tuples.length / model.numberOfComponents;\n    if (model.size < end * model.numberOfComponents) {\n      model.size = end * model.numberOfComponents;\n      resize(end);\n    }\n    publicAPI.setTuples(idx, tuples);\n    return end;\n  };\n\n  publicAPI.insertNextTuple = (tuple) => {\n    const idx = model.size / model.numberOfComponents;\n    return publicAPI.insertTuple(idx, tuple);\n  };\n\n  publicAPI.insertNextTuples = (tuples) => {\n    const idx = model.size / model.numberOfComponents;\n    return publicAPI.insertTuples(idx, tuples);\n  };\n\n  publicAPI.getTuple = (idx, tupleToFill = []) => {\n    const numberOfComponents = model.numberOfComponents || 1;\n    const offset = idx * numberOfComponents;\n    // Check most common component sizes first\n    // to avoid doing a for loop if possible\n    switch (numberOfComponents) {\n      case 4:\n        tupleToFill[3] = model.values[offset + 3];\n      // eslint-disable-next-line no-fallthrough\n      case 3:\n        tupleToFill[2] = model.values[offset + 2];\n      // eslint-disable-next-line no-fallthrough\n      case 2:\n        tupleToFill[1] = model.values[offset + 1];\n      // eslint-disable-next-line no-fallthrough\n      case 1:\n        tupleToFill[0] = model.values[offset];\n        break;\n      default:\n        for (let i = numberOfComponents - 1; i >= 0; --i) {\n          tupleToFill[i] = model.values[offset + i];\n        }\n    }\n    return tupleToFill;\n  };\n\n  publicAPI.getTuples = (fromId, toId) => {\n    const from = (fromId ?? 0) * model.numberOfComponents;\n    const to =\n      (toId ?? publicAPI.getNumberOfTuples()) * model.numberOfComponents;\n    const arr = publicAPI.getData().subarray(from, to);\n    return arr.length > 0 ? arr : null;\n  };\n\n  publicAPI.getTupleLocation = (idx = 1) => idx * model.numberOfComponents;\n  publicAPI.getNumberOfComponents = () => model.numberOfComponents;\n  publicAPI.getNumberOfValues = () => model.size;\n  publicAPI.getNumberOfTuples = () => model.size / model.numberOfComponents;\n  publicAPI.getDataType = () => model.dataType;\n  /* eslint-disable no-use-before-define */\n  publicAPI.newClone = () =>\n    newInstance({\n      empty: true,\n      name: model.name,\n      dataType: model.dataType,\n      numberOfComponents: model.numberOfComponents,\n    });\n  /* eslint-enable no-use-before-define */\n\n  publicAPI.getName = () => {\n    if (!model.name) {\n      publicAPI.modified();\n      model.name = `vtkDataArray${publicAPI.getMTime()}`;\n    }\n    return model.name;\n  };\n\n  publicAPI.setData = (typedArray, numberOfComponents) => {\n    model.values = typedArray;\n    model.size = typedArray.length;\n    model.dataType = getDataType(typedArray);\n    if (numberOfComponents) {\n      model.numberOfComponents = numberOfComponents;\n    }\n    if (model.size % model.numberOfComponents !== 0) {\n      model.numberOfComponents = 1;\n    }\n    dataChange();\n  };\n\n  // Override serialization support\n  publicAPI.getState = () => {\n    if (model.deleted) {\n      return null;\n    }\n    const jsonArchive = { ...model, vtkClass: publicAPI.getClassName() };\n\n    // Convert typed array to regular array\n    jsonArchive.values = Array.from(jsonArchive.values);\n    delete jsonArchive.buffer;\n\n    // Clean any empty data\n    Object.keys(jsonArchive).forEach((keyName) => {\n      if (!jsonArchive[keyName]) {\n        delete jsonArchive[keyName];\n      }\n    });\n\n    // Sort resulting object by key name\n    const sortedObj = {};\n    Object.keys(jsonArchive)\n      .sort()\n      .forEach((name) => {\n        sortedObj[name] = jsonArchive[name];\n      });\n\n    // Remove mtime\n    if (sortedObj.mtime) {\n      delete sortedObj.mtime;\n    }\n\n    return sortedObj;\n  };\n\n  publicAPI.deepCopy = (other) => {\n    publicAPI.shallowCopy(other);\n    publicAPI.setData(other.getData().slice());\n  };\n\n  publicAPI.interpolateTuple = (\n    idx,\n    source1,\n    source1Idx,\n    source2,\n    source2Idx,\n    t\n  ) => {\n    const numberOfComponents = model.numberOfComponents || 1;\n    if (\n      numberOfComponents !== source1.getNumberOfComponents() ||\n      numberOfComponents !== source2.getNumberOfComponents()\n    ) {\n      vtkErrorMacro('numberOfComponents must match');\n    }\n\n    const tuple1 = source1.getTuple(source1Idx);\n    const tuple2 = source2.getTuple(source2Idx);\n    const out = [];\n    out.length = numberOfComponents;\n\n    // Check most common component sizes first\n    // to avoid doing a for loop if possible\n    switch (numberOfComponents) {\n      case 4:\n        out[3] = tuple1[3] + (tuple2[3] - tuple1[3]) * t;\n      // eslint-disable-next-line no-fallthrough\n      case 3:\n        out[2] = tuple1[2] + (tuple2[2] - tuple1[2]) * t;\n      // eslint-disable-next-line no-fallthrough\n      case 2:\n        out[1] = tuple1[1] + (tuple2[1] - tuple1[1]) * t;\n      // eslint-disable-next-line no-fallthrough\n      case 1:\n        out[0] = tuple1[0] + (tuple2[0] - tuple1[0]) * t;\n        break;\n      default:\n        for (let i = 0; i < numberOfComponents; i++) {\n          out[i] = tuple1[i] + (tuple2[i] - tuple1[i]) * t;\n        }\n    }\n\n    return publicAPI.insertTuple(idx, out);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n// size: The current size of the dataArray.\n// NOTE: The underlying typed array may be larger than 'size'.\nconst DEFAULT_VALUES = {\n  name: '',\n  numberOfComponents: 1,\n  dataType: DefaultDataType,\n  rangeTuple: [0, 0],\n  // size: undefined,\n  // values: null,\n  // ranges: null,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  if (!model.empty && !model.values && !model.size) {\n    throw new TypeError(\n      'Cannot create vtkDataArray object without: size > 0, values'\n    );\n  }\n\n  if (!model.values) {\n    model.values = macro.newTypedArray(model.dataType, model.size);\n  } else if (Array.isArray(model.values)) {\n    model.values = macro.newTypedArrayFrom(model.dataType, model.values);\n  }\n\n  if (model.values) {\n    // Takes the size if provided (can be lower than `model.values`) otherwise the actual length of `values`.\n    model.size = model.size ?? model.values.length;\n    model.dataType = getDataType(model.values);\n  }\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  macro.set(publicAPI, model, ['name', 'numberOfComponents']);\n\n  // Object specific methods\n  vtkDataArray(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkDataArray');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend, ...STATIC, ...Constants };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}