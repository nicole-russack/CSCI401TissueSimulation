{"ast":null,"code":"import { mat4, vec3 } from 'gl-matrix';\nimport * as macro from 'vtk.js/Sources/macros';\nimport vtkCamera from 'vtk.js/Sources/Rendering/Core/Camera';\nimport vtkLight from 'vtk.js/Sources/Rendering/Core/Light';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkViewport from 'vtk.js/Sources/Rendering/Core/Viewport';\nimport vtkBoundingBox from 'vtk.js/Sources/Common/DataModel/BoundingBox';\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\n\nfunction notImplemented(method) {\n  return () => vtkErrorMacro(`vtkRenderer::${method} - NOT IMPLEMENTED`);\n} // ----------------------------------------------------------------------------\n// vtkRenderer methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkRenderer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkRenderer'); // Events\n\n  const COMPUTE_VISIBLE_PROP_BOUNDS_EVENT = {\n    type: 'ComputeVisiblePropBoundsEvent',\n    renderer: publicAPI\n  };\n  const RESET_CAMERA_CLIPPING_RANGE_EVENT = {\n    type: 'ResetCameraClippingRangeEvent',\n    renderer: publicAPI\n  };\n  const RESET_CAMERA_EVENT = {\n    type: 'ResetCameraEvent',\n    renderer: publicAPI\n  };\n\n  publicAPI.updateCamera = () => {\n    if (!model.activeCamera) {\n      vtkDebugMacro('No cameras are on, creating one.'); // the get method will automagically create a camera\n      // and reset it since one hasn't been specified yet.\n\n      publicAPI.getActiveCameraAndResetIfCreated();\n    } // update the viewing transformation\n\n\n    model.activeCamera.render(publicAPI);\n    return true;\n  };\n\n  publicAPI.updateLightsGeometryToFollowCamera = () => {\n    // only update the light's geometry if this Renderer is tracking\n    // this lights.  That allows one renderer to view the lights that\n    // another renderer is setting up.\n    const camera = publicAPI.getActiveCameraAndResetIfCreated();\n    model.lights.forEach(light => {\n      if (light.lightTypeIsSceneLight()) {// Do nothing. Don't reset the transform matrix because applications\n        // may have set a custom matrix. Only reset the transform matrix in\n        // vtkLight::SetLightTypeToSceneLight()\n      } else if (light.lightTypeIsHeadLight()) {\n        // update position and orientation of light to match camera.\n        light.setPositionFrom(camera.getPositionByReference());\n        light.setFocalPointFrom(camera.getFocalPointByReference());\n        light.modified(camera.getMTime());\n      } else if (light.lightTypeIsCameraLight()) {\n        light.setTransformMatrix(camera.getCameraLightTransformMatrix(mat4.create()));\n      } else {\n        vtkErrorMacro('light has unknown light type', light.get());\n      }\n    });\n  };\n\n  publicAPI.updateLightGeometry = () => {\n    if (model.lightFollowCamera) {\n      // only update the light's geometry if this Renderer is tracking\n      // this lights.  That allows one renderer to view the lights that\n      // another renderer is setting up.\n      return publicAPI.updateLightsGeometryToFollowCamera();\n    }\n\n    return true;\n  };\n\n  publicAPI.allocateTime = notImplemented('allocateTime');\n  publicAPI.updateGeometry = notImplemented('updateGeometry');\n\n  publicAPI.getVTKWindow = () => model._renderWindow;\n\n  publicAPI.setLayer = layer => {\n    vtkDebugMacro(publicAPI.getClassName(), publicAPI, 'setting Layer to ', layer);\n\n    if (model.layer !== layer) {\n      model.layer = layer;\n      publicAPI.modified();\n    }\n\n    publicAPI.setPreserveColorBuffer(!!layer);\n  };\n\n  publicAPI.setActiveCamera = camera => {\n    if (model.activeCamera === camera) {\n      return false;\n    }\n\n    model.activeCamera = camera;\n    publicAPI.modified();\n    publicAPI.invokeEvent({\n      type: 'ActiveCameraEvent',\n      camera\n    });\n    return true;\n  };\n\n  publicAPI.makeCamera = () => {\n    const camera = vtkCamera.newInstance();\n    publicAPI.invokeEvent({\n      type: 'CreateCameraEvent',\n      camera\n    });\n    return camera;\n  }; // Replace the set/get macro method\n\n\n  publicAPI.getActiveCamera = () => {\n    if (!model.activeCamera) {\n      model.activeCamera = publicAPI.makeCamera();\n    }\n\n    return model.activeCamera;\n  };\n\n  publicAPI.getActiveCameraAndResetIfCreated = () => {\n    if (!model.activeCamera) {\n      publicAPI.getActiveCamera();\n      publicAPI.resetCamera();\n    }\n\n    return model.activeCamera;\n  };\n\n  publicAPI.getActors = () => {\n    model.actors = [];\n    model.props.forEach(prop => {\n      model.actors = model.actors.concat(prop.getActors());\n    });\n    return model.actors;\n  };\n\n  publicAPI.addActor = publicAPI.addViewProp;\n\n  publicAPI.removeActor = actor => {\n    model.actors = model.actors.filter(a => a !== actor);\n    publicAPI.removeViewProp(actor);\n    publicAPI.modified();\n  };\n\n  publicAPI.removeAllActors = () => {\n    const actors = publicAPI.getActors();\n    actors.forEach(actor => {\n      publicAPI.removeViewProp(actor);\n    });\n    model.actors = [];\n    publicAPI.modified();\n  };\n\n  publicAPI.getVolumes = () => {\n    model.volumes = [];\n    model.props.forEach(prop => {\n      model.volumes = model.volumes.concat(prop.getVolumes());\n    });\n    return model.volumes;\n  };\n\n  publicAPI.addVolume = publicAPI.addViewProp;\n\n  publicAPI.removeVolume = volume => {\n    model.volumes = model.volumes.filter(v => v !== volume);\n    publicAPI.removeViewProp(volume);\n    publicAPI.modified();\n  };\n\n  publicAPI.removeAllVolumes = () => {\n    const volumes = publicAPI.getVolumes();\n    volumes.forEach(volume => {\n      publicAPI.removeViewProp(volume);\n    });\n    model.volumes = [];\n    publicAPI.modified();\n  };\n\n  publicAPI.addLight = light => {\n    model.lights = [].concat(model.lights, light);\n    publicAPI.modified();\n  };\n\n  publicAPI.removeLight = light => {\n    model.lights = model.lights.filter(l => l !== light);\n    publicAPI.modified();\n  };\n\n  publicAPI.removeAllLights = () => {\n    model.lights = [];\n    publicAPI.modified();\n  };\n\n  publicAPI.setLightCollection = lights => {\n    model.lights = lights;\n    publicAPI.modified();\n  };\n\n  publicAPI.makeLight = vtkLight.newInstance;\n\n  publicAPI.createLight = () => {\n    if (!model.automaticLightCreation) {\n      return;\n    }\n\n    if (model._createdLight) {\n      publicAPI.removeLight(model._createdLight);\n\n      model._createdLight.delete();\n\n      model._createdLight = null;\n    }\n\n    model._createdLight = publicAPI.makeLight();\n    publicAPI.addLight(model._createdLight);\n\n    model._createdLight.setLightTypeToHeadLight(); // set these values just to have a good default should LightFollowCamera\n    // be turned off.\n\n\n    model._createdLight.setPosition(publicAPI.getActiveCamera().getPosition());\n\n    model._createdLight.setFocalPoint(publicAPI.getActiveCamera().getFocalPoint());\n  }; // requires the aspect ratio of the viewport as X/Y\n\n\n  publicAPI.normalizedDisplayToWorld = (x, y, z, aspect) => {\n    let vpd = publicAPI.normalizedDisplayToProjection(x, y, z);\n    vpd = publicAPI.projectionToView(vpd[0], vpd[1], vpd[2], aspect);\n    return publicAPI.viewToWorld(vpd[0], vpd[1], vpd[2]);\n  }; // requires the aspect ratio of the viewport as X/Y\n\n\n  publicAPI.worldToNormalizedDisplay = (x, y, z, aspect) => {\n    let vpd = publicAPI.worldToView(x, y, z);\n    vpd = publicAPI.viewToProjection(vpd[0], vpd[1], vpd[2], aspect);\n    return publicAPI.projectionToNormalizedDisplay(vpd[0], vpd[1], vpd[2]);\n  }; // requires the aspect ratio of the viewport as X/Y\n\n\n  publicAPI.viewToWorld = (x, y, z) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0');\n      return [0, 0, 0];\n    } // get the view matrix from the active camera\n\n\n    const matrix = model.activeCamera.getViewMatrix();\n    mat4.invert(matrix, matrix);\n    mat4.transpose(matrix, matrix); // Transform point to world coordinates\n\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n\n  publicAPI.projectionToView = (x, y, z, aspect) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0');\n      return [0, 0, 0];\n    } // get the projection transformation from the active camera\n\n\n    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);\n    mat4.invert(matrix, matrix);\n    mat4.transpose(matrix, matrix); // Transform point to world coordinates\n\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  }; // Convert world point coordinates to view coordinates.\n\n\n  publicAPI.worldToView = (x, y, z) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('WorldToView: no active camera, cannot compute view to world, returning 0,0,0');\n      return [0, 0, 0];\n    } // get the view transformation from the active camera\n\n\n    const matrix = model.activeCamera.getViewMatrix();\n    mat4.transpose(matrix, matrix);\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  }; // Convert world point coordinates to view coordinates.\n  // requires the aspect ratio of the viewport as X/Y\n\n\n  publicAPI.viewToProjection = (x, y, z, aspect) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0');\n      return [0, 0, 0];\n    } // get the projeciton transformation from the active camera\n\n\n    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);\n    mat4.transpose(matrix, matrix);\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n\n  publicAPI.computeVisiblePropBounds = () => {\n    model.allBounds[0] = vtkBoundingBox.INIT_BOUNDS[0];\n    model.allBounds[1] = vtkBoundingBox.INIT_BOUNDS[1];\n    model.allBounds[2] = vtkBoundingBox.INIT_BOUNDS[2];\n    model.allBounds[3] = vtkBoundingBox.INIT_BOUNDS[3];\n    model.allBounds[4] = vtkBoundingBox.INIT_BOUNDS[4];\n    model.allBounds[5] = vtkBoundingBox.INIT_BOUNDS[5];\n    let nothingVisible = true;\n    publicAPI.invokeEvent(COMPUTE_VISIBLE_PROP_BOUNDS_EVENT); // loop through all props\n\n    for (let index = 0; index < model.props.length; ++index) {\n      const prop = model.props[index];\n\n      if (prop.getVisibility() && prop.getUseBounds()) {\n        const bounds = prop.getBounds();\n\n        if (bounds && vtkMath.areBoundsInitialized(bounds)) {\n          nothingVisible = false;\n\n          if (bounds[0] < model.allBounds[0]) {\n            model.allBounds[0] = bounds[0];\n          }\n\n          if (bounds[1] > model.allBounds[1]) {\n            model.allBounds[1] = bounds[1];\n          }\n\n          if (bounds[2] < model.allBounds[2]) {\n            model.allBounds[2] = bounds[2];\n          }\n\n          if (bounds[3] > model.allBounds[3]) {\n            model.allBounds[3] = bounds[3];\n          }\n\n          if (bounds[4] < model.allBounds[4]) {\n            model.allBounds[4] = bounds[4];\n          }\n\n          if (bounds[5] > model.allBounds[5]) {\n            model.allBounds[5] = bounds[5];\n          }\n        }\n      }\n    }\n\n    if (nothingVisible) {\n      vtkMath.uninitializeBounds(model.allBounds);\n      vtkDebugMacro(\"Can't compute bounds, no 3D props are visible\");\n    }\n\n    return model.allBounds;\n  };\n\n  publicAPI.resetCamera = function () {\n    let bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();\n    const center = [0, 0, 0];\n\n    if (!vtkMath.areBoundsInitialized(boundsToUse)) {\n      vtkDebugMacro('Cannot reset camera!');\n      return false;\n    }\n\n    let vn = null;\n\n    if (publicAPI.getActiveCamera()) {\n      vn = model.activeCamera.getViewPlaneNormal();\n    } else {\n      vtkErrorMacro('Trying to reset non-existent camera');\n      return false;\n    } // Reset the perspective zoom factors, otherwise subsequent zooms will cause\n    // the view angle to become very small and cause bad depth sorting.\n\n\n    model.activeCamera.setViewAngle(30.0);\n    center[0] = (boundsToUse[0] + boundsToUse[1]) / 2.0;\n    center[1] = (boundsToUse[2] + boundsToUse[3]) / 2.0;\n    center[2] = (boundsToUse[4] + boundsToUse[5]) / 2.0;\n    let w1 = boundsToUse[1] - boundsToUse[0];\n    let w2 = boundsToUse[3] - boundsToUse[2];\n    let w3 = boundsToUse[5] - boundsToUse[4];\n    w1 *= w1;\n    w2 *= w2;\n    w3 *= w3;\n    let radius = w1 + w2 + w3; // If we have just a single point, pick a radius of 1.0\n\n    radius = radius === 0 ? 1.0 : radius; // compute the radius of the enclosing sphere\n\n    radius = Math.sqrt(radius) * 0.5; // default so that the bounding sphere fits within the view fustrum\n    // compute the distance from the intersection of the view frustum with the\n    // bounding sphere. Basically in 2D draw a circle representing the bounding\n    // sphere in 2D then draw a horizontal line going out from the center of\n    // the circle. That is the camera view. Then draw a line from the camera\n    // position to the point where it intersects the circle. (it will be tangent\n    // to the circle at this point, this is important, only go to the tangent\n    // point, do not draw all the way to the view plane). Then draw the radius\n    // from the tangent point to the center of the circle. You will note that\n    // this forms a right triangle with one side being the radius, another being\n    // the target distance for the camera, then just find the target dist using\n    // a sin.\n\n    const angle = vtkMath.radiansFromDegrees(model.activeCamera.getViewAngle());\n    const parallelScale = radius;\n    const distance = radius / Math.sin(angle * 0.5); // check view-up vector against view plane normal\n\n    const vup = model.activeCamera.getViewUp();\n\n    if (Math.abs(vtkMath.dot(vup, vn)) > 0.999) {\n      vtkWarningMacro('Resetting view-up since view plane normal is parallel');\n      model.activeCamera.setViewUp(-vup[2], vup[0], vup[1]);\n    } // update the camera\n\n\n    model.activeCamera.setFocalPoint(center[0], center[1], center[2]);\n    model.activeCamera.setPosition(center[0] + distance * vn[0], center[1] + distance * vn[1], center[2] + distance * vn[2]);\n    publicAPI.resetCameraClippingRange(boundsToUse); // setup default parallel scale\n\n    model.activeCamera.setParallelScale(parallelScale); // update reasonable world to physical values\n\n    model.activeCamera.setPhysicalScale(radius);\n    model.activeCamera.setPhysicalTranslation(-center[0], -center[1], -center[2]); // Here to let parallel/distributed compositing intercept\n    // and do the right thing.\n\n    publicAPI.invokeEvent(RESET_CAMERA_EVENT);\n    return true;\n  };\n\n  publicAPI.resetCameraClippingRange = function () {\n    let bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();\n\n    if (!vtkMath.areBoundsInitialized(boundsToUse)) {\n      vtkDebugMacro('Cannot reset camera clipping range!');\n      return false;\n    } // Make sure we have an active camera\n\n\n    publicAPI.getActiveCameraAndResetIfCreated();\n\n    if (!model.activeCamera) {\n      vtkErrorMacro('Trying to reset clipping range of non-existent camera');\n      return false;\n    } // Get the exact range for the bounds\n\n\n    const range = model.activeCamera.computeClippingRange(boundsToUse); // do not let far - near be less than 0.1 of the window height\n    // this is for cases such as 2D images which may have zero range\n\n    let minGap = 0.0;\n\n    if (model.activeCamera.getParallelProjection()) {\n      minGap = 0.2 * model.activeCamera.getParallelScale();\n    } else {\n      const angle = vtkMath.radiansFromDegrees(model.activeCamera.getViewAngle());\n      minGap = 0.2 * Math.tan(angle / 2.0) * range[1];\n    }\n\n    if (range[1] - range[0] < minGap) {\n      minGap = minGap - range[1] + range[0];\n      range[1] += minGap / 2.0;\n      range[0] -= minGap / 2.0;\n    } // Do not let the range behind the camera throw off the calculation.\n\n\n    if (range[0] < 0.0) {\n      range[0] = 0.0;\n    } // Give ourselves a little breathing room\n\n\n    range[0] = 0.99 * range[0] - (range[1] - range[0]) * model.clippingRangeExpansion;\n    range[1] = 1.01 * range[1] + (range[1] - range[0]) * model.clippingRangeExpansion; // Make sure near is not bigger than far\n\n    range[0] = range[0] >= range[1] ? 0.01 * range[1] : range[0]; // Make sure near is at least some fraction of far - this prevents near\n    // from being behind the camera or too close in front. How close is too\n    // close depends on the resolution of the depth buffer\n\n    if (!model.nearClippingPlaneTolerance) {\n      model.nearClippingPlaneTolerance = 0.01;\n    } // make sure the front clipping range is not too far from the far clippnig\n    // range, this is to make sure that the zbuffer resolution is effectively\n    // used\n\n\n    if (range[0] < model.nearClippingPlaneTolerance * range[1]) {\n      range[0] = model.nearClippingPlaneTolerance * range[1];\n    }\n\n    model.activeCamera.setClippingRange(range[0], range[1]); // Here to let parallel/distributed compositing intercept\n    // and do the right thing.\n\n    publicAPI.invokeEvent(RESET_CAMERA_CLIPPING_RANGE_EVENT);\n    return false;\n  };\n\n  publicAPI.setRenderWindow = renderWindow => {\n    if (renderWindow !== model._renderWindow) {\n      model._vtkWindow = renderWindow;\n      model._renderWindow = renderWindow;\n    }\n  };\n\n  publicAPI.visibleActorCount = () => model.props.filter(prop => prop.getVisibility()).length;\n\n  publicAPI.visibleVolumeCount = publicAPI.visibleActorCount;\n\n  publicAPI.getMTime = () => {\n    let m1 = model.mtime;\n    const m2 = model.activeCamera ? model.activeCamera.getMTime() : 0;\n\n    if (m2 > m1) {\n      m1 = m2;\n    }\n\n    const m3 = model._createdLight ? model._createdLight.getMTime() : 0;\n\n    if (m3 > m1) {\n      m1 = m3;\n    }\n\n    return m1;\n  };\n\n  publicAPI.getTransparent = () => !!model.preserveColorBuffer;\n\n  publicAPI.isActiveCameraCreated = () => !!model.activeCamera;\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  pickedProp: null,\n  activeCamera: null,\n  allBounds: [],\n  ambient: [1, 1, 1],\n  allocatedRenderTime: 100,\n  timeFactor: 1,\n  automaticLightCreation: true,\n  twoSidedLighting: true,\n  lastRenderTimeInSeconds: -1,\n  renderWindow: null,\n  lights: [],\n  actors: [],\n  volumes: [],\n  lightFollowCamera: true,\n  numberOfPropsRendered: 0,\n  propArray: null,\n  pathArray: null,\n  layer: 0,\n  preserveColorBuffer: false,\n  preserveDepthBuffer: false,\n  computeVisiblePropBounds: vtkMath.createUninitializedBounds(),\n  interactive: true,\n  nearClippingPlaneTolerance: 0,\n  clippingRangeExpansion: 0.05,\n  erase: true,\n  draw: true,\n  useShadows: false,\n  useDepthPeeling: false,\n  occlusionRatio: 0,\n  maximumNumberOfPeels: 4,\n  selector: null,\n  delegate: null,\n  texturedBackground: false,\n  backgroundTexture: null,\n  environmentTexture: null,\n  environmentTextureDiffuseStrength: 1,\n  environmentTextureSpecularStrength: 1,\n  useEnvironmentTextureAsBackground: false,\n  pass: 0\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewport.extend(publicAPI, model, initialValues); // make sure background has 4 entries. Default to opaque black\n\n  if (!model.background) model.background = [0, 0, 0, 1];\n\n  while (model.background.length < 3) model.background.push(0);\n\n  if (model.background.length === 3) model.background.push(1); // Build VTK API\n\n  macro.get(publicAPI, model, ['_renderWindow', 'allocatedRenderTime', 'timeFactor', 'lastRenderTimeInSeconds', 'numberOfPropsRendered', 'lastRenderingUsedDepthPeeling', 'selector']);\n  macro.setGet(publicAPI, model, ['twoSidedLighting', 'lightFollowCamera', 'automaticLightCreation', 'erase', 'draw', 'nearClippingPlaneTolerance', 'clippingRangeExpansion', 'backingStore', 'interactive', 'layer', 'preserveColorBuffer', 'preserveDepthBuffer', 'useDepthPeeling', 'occlusionRatio', 'maximumNumberOfPeels', 'delegate', 'backgroundTexture', 'texturedBackground', 'environmentTexture', 'environmentTextureDiffuseStrength', 'environmentTextureSpecularStrength', 'useEnvironmentTextureAsBackground', 'useShadows', 'pass']);\n  macro.getArray(publicAPI, model, ['actors', 'volumes', 'lights']);\n  macro.setGetArray(publicAPI, model, ['background'], 4, 1.0);\n  macro.moveToProtected(publicAPI, model, ['renderWindow']); // Object methods\n\n  vtkRenderer(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkRenderer'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["mat4","vec3","macro","vtkCamera","vtkLight","vtkMath","vtkViewport","vtkBoundingBox","vtkDebugMacro","vtkErrorMacro","vtkWarningMacro","notImplemented","method","vtkRenderer","publicAPI","model","classHierarchy","push","COMPUTE_VISIBLE_PROP_BOUNDS_EVENT","type","renderer","RESET_CAMERA_CLIPPING_RANGE_EVENT","RESET_CAMERA_EVENT","updateCamera","activeCamera","getActiveCameraAndResetIfCreated","render","updateLightsGeometryToFollowCamera","camera","lights","forEach","light","lightTypeIsSceneLight","lightTypeIsHeadLight","setPositionFrom","getPositionByReference","setFocalPointFrom","getFocalPointByReference","modified","getMTime","lightTypeIsCameraLight","setTransformMatrix","getCameraLightTransformMatrix","create","get","updateLightGeometry","lightFollowCamera","allocateTime","updateGeometry","getVTKWindow","_renderWindow","setLayer","layer","getClassName","setPreserveColorBuffer","setActiveCamera","invokeEvent","makeCamera","newInstance","getActiveCamera","resetCamera","getActors","actors","props","prop","concat","addActor","addViewProp","removeActor","actor","filter","a","removeViewProp","removeAllActors","getVolumes","volumes","addVolume","removeVolume","volume","v","removeAllVolumes","addLight","removeLight","l","removeAllLights","setLightCollection","makeLight","createLight","automaticLightCreation","_createdLight","delete","setLightTypeToHeadLight","setPosition","getPosition","setFocalPoint","getFocalPoint","normalizedDisplayToWorld","x","y","z","aspect","vpd","normalizedDisplayToProjection","projectionToView","viewToWorld","worldToNormalizedDisplay","worldToView","viewToProjection","projectionToNormalizedDisplay","matrix","getViewMatrix","invert","transpose","result","Float64Array","transformMat4","getProjectionMatrix","computeVisiblePropBounds","allBounds","INIT_BOUNDS","nothingVisible","index","length","getVisibility","getUseBounds","bounds","getBounds","areBoundsInitialized","uninitializeBounds","boundsToUse","center","vn","getViewPlaneNormal","setViewAngle","w1","w2","w3","radius","Math","sqrt","angle","radiansFromDegrees","getViewAngle","parallelScale","distance","sin","vup","getViewUp","abs","dot","setViewUp","resetCameraClippingRange","setParallelScale","setPhysicalScale","setPhysicalTranslation","range","computeClippingRange","minGap","getParallelProjection","getParallelScale","tan","clippingRangeExpansion","nearClippingPlaneTolerance","setClippingRange","setRenderWindow","renderWindow","_vtkWindow","visibleActorCount","visibleVolumeCount","m1","mtime","m2","m3","getTransparent","preserveColorBuffer","isActiveCameraCreated","DEFAULT_VALUES","pickedProp","ambient","allocatedRenderTime","timeFactor","twoSidedLighting","lastRenderTimeInSeconds","numberOfPropsRendered","propArray","pathArray","preserveDepthBuffer","createUninitializedBounds","interactive","erase","draw","useShadows","useDepthPeeling","occlusionRatio","maximumNumberOfPeels","selector","delegate","texturedBackground","backgroundTexture","environmentTexture","environmentTextureDiffuseStrength","environmentTextureSpecularStrength","useEnvironmentTextureAsBackground","pass","extend","initialValues","Object","assign","background","setGet","getArray","setGetArray","moveToProtected"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/Core/Renderer/index.js"],"sourcesContent":["import { mat4, vec3 } from 'gl-matrix';\n\nimport * as macro from 'vtk.js/Sources/macros';\nimport vtkCamera from 'vtk.js/Sources/Rendering/Core/Camera';\nimport vtkLight from 'vtk.js/Sources/Rendering/Core/Light';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkViewport from 'vtk.js/Sources/Rendering/Core/Viewport';\nimport vtkBoundingBox from 'vtk.js/Sources/Common/DataModel/BoundingBox';\n\nconst { vtkDebugMacro, vtkErrorMacro, vtkWarningMacro } = macro;\n\nfunction notImplemented(method) {\n  return () => vtkErrorMacro(`vtkRenderer::${method} - NOT IMPLEMENTED`);\n}\n\n// ----------------------------------------------------------------------------\n// vtkRenderer methods\n// ----------------------------------------------------------------------------\n\nfunction vtkRenderer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkRenderer');\n\n  // Events\n  const COMPUTE_VISIBLE_PROP_BOUNDS_EVENT = {\n    type: 'ComputeVisiblePropBoundsEvent',\n    renderer: publicAPI,\n  };\n  const RESET_CAMERA_CLIPPING_RANGE_EVENT = {\n    type: 'ResetCameraClippingRangeEvent',\n    renderer: publicAPI,\n  };\n  const RESET_CAMERA_EVENT = {\n    type: 'ResetCameraEvent',\n    renderer: publicAPI,\n  };\n\n  publicAPI.updateCamera = () => {\n    if (!model.activeCamera) {\n      vtkDebugMacro('No cameras are on, creating one.');\n      // the get method will automagically create a camera\n      // and reset it since one hasn't been specified yet.\n      publicAPI.getActiveCameraAndResetIfCreated();\n    }\n\n    // update the viewing transformation\n    model.activeCamera.render(publicAPI);\n\n    return true;\n  };\n\n  publicAPI.updateLightsGeometryToFollowCamera = () => {\n    // only update the light's geometry if this Renderer is tracking\n    // this lights.  That allows one renderer to view the lights that\n    // another renderer is setting up.\n    const camera = publicAPI.getActiveCameraAndResetIfCreated();\n\n    model.lights.forEach((light) => {\n      if (light.lightTypeIsSceneLight()) {\n        // Do nothing. Don't reset the transform matrix because applications\n        // may have set a custom matrix. Only reset the transform matrix in\n        // vtkLight::SetLightTypeToSceneLight()\n      } else if (light.lightTypeIsHeadLight()) {\n        // update position and orientation of light to match camera.\n        light.setPositionFrom(camera.getPositionByReference());\n        light.setFocalPointFrom(camera.getFocalPointByReference());\n        light.modified(camera.getMTime());\n      } else if (light.lightTypeIsCameraLight()) {\n        light.setTransformMatrix(\n          camera.getCameraLightTransformMatrix(mat4.create())\n        );\n      } else {\n        vtkErrorMacro('light has unknown light type', light.get());\n      }\n    });\n  };\n\n  publicAPI.updateLightGeometry = () => {\n    if (model.lightFollowCamera) {\n      // only update the light's geometry if this Renderer is tracking\n      // this lights.  That allows one renderer to view the lights that\n      // another renderer is setting up.\n      return publicAPI.updateLightsGeometryToFollowCamera();\n    }\n    return true;\n  };\n\n  publicAPI.allocateTime = notImplemented('allocateTime');\n  publicAPI.updateGeometry = notImplemented('updateGeometry');\n\n  publicAPI.getVTKWindow = () => model._renderWindow;\n\n  publicAPI.setLayer = (layer) => {\n    vtkDebugMacro(\n      publicAPI.getClassName(),\n      publicAPI,\n      'setting Layer to ',\n      layer\n    );\n    if (model.layer !== layer) {\n      model.layer = layer;\n      publicAPI.modified();\n    }\n    publicAPI.setPreserveColorBuffer(!!layer);\n  };\n\n  publicAPI.setActiveCamera = (camera) => {\n    if (model.activeCamera === camera) {\n      return false;\n    }\n\n    model.activeCamera = camera;\n    publicAPI.modified();\n    publicAPI.invokeEvent({ type: 'ActiveCameraEvent', camera });\n    return true;\n  };\n\n  publicAPI.makeCamera = () => {\n    const camera = vtkCamera.newInstance();\n    publicAPI.invokeEvent({ type: 'CreateCameraEvent', camera });\n    return camera;\n  };\n\n  // Replace the set/get macro method\n  publicAPI.getActiveCamera = () => {\n    if (!model.activeCamera) {\n      model.activeCamera = publicAPI.makeCamera();\n    }\n    return model.activeCamera;\n  };\n\n  publicAPI.getActiveCameraAndResetIfCreated = () => {\n    if (!model.activeCamera) {\n      publicAPI.getActiveCamera();\n      publicAPI.resetCamera();\n    }\n    return model.activeCamera;\n  };\n\n  publicAPI.getActors = () => {\n    model.actors = [];\n    model.props.forEach((prop) => {\n      model.actors = model.actors.concat(prop.getActors());\n    });\n    return model.actors;\n  };\n  publicAPI.addActor = publicAPI.addViewProp;\n  publicAPI.removeActor = (actor) => {\n    model.actors = model.actors.filter((a) => a !== actor);\n    publicAPI.removeViewProp(actor);\n    publicAPI.modified();\n  };\n  publicAPI.removeAllActors = () => {\n    const actors = publicAPI.getActors();\n    actors.forEach((actor) => {\n      publicAPI.removeViewProp(actor);\n    });\n    model.actors = [];\n    publicAPI.modified();\n  };\n\n  publicAPI.getVolumes = () => {\n    model.volumes = [];\n    model.props.forEach((prop) => {\n      model.volumes = model.volumes.concat(prop.getVolumes());\n    });\n    return model.volumes;\n  };\n  publicAPI.addVolume = publicAPI.addViewProp;\n  publicAPI.removeVolume = (volume) => {\n    model.volumes = model.volumes.filter((v) => v !== volume);\n    publicAPI.removeViewProp(volume);\n    publicAPI.modified();\n  };\n  publicAPI.removeAllVolumes = () => {\n    const volumes = publicAPI.getVolumes();\n    volumes.forEach((volume) => {\n      publicAPI.removeViewProp(volume);\n    });\n    model.volumes = [];\n    publicAPI.modified();\n  };\n\n  publicAPI.addLight = (light) => {\n    model.lights = [].concat(model.lights, light);\n    publicAPI.modified();\n  };\n  publicAPI.removeLight = (light) => {\n    model.lights = model.lights.filter((l) => l !== light);\n    publicAPI.modified();\n  };\n  publicAPI.removeAllLights = () => {\n    model.lights = [];\n    publicAPI.modified();\n  };\n  publicAPI.setLightCollection = (lights) => {\n    model.lights = lights;\n    publicAPI.modified();\n  };\n\n  publicAPI.makeLight = vtkLight.newInstance;\n\n  publicAPI.createLight = () => {\n    if (!model.automaticLightCreation) {\n      return;\n    }\n\n    if (model._createdLight) {\n      publicAPI.removeLight(model._createdLight);\n      model._createdLight.delete();\n      model._createdLight = null;\n    }\n\n    model._createdLight = publicAPI.makeLight();\n    publicAPI.addLight(model._createdLight);\n\n    model._createdLight.setLightTypeToHeadLight();\n\n    // set these values just to have a good default should LightFollowCamera\n    // be turned off.\n    model._createdLight.setPosition(publicAPI.getActiveCamera().getPosition());\n    model._createdLight.setFocalPoint(\n      publicAPI.getActiveCamera().getFocalPoint()\n    );\n  };\n\n  // requires the aspect ratio of the viewport as X/Y\n  publicAPI.normalizedDisplayToWorld = (x, y, z, aspect) => {\n    let vpd = publicAPI.normalizedDisplayToProjection(x, y, z);\n    vpd = publicAPI.projectionToView(vpd[0], vpd[1], vpd[2], aspect);\n\n    return publicAPI.viewToWorld(vpd[0], vpd[1], vpd[2]);\n  };\n\n  // requires the aspect ratio of the viewport as X/Y\n  publicAPI.worldToNormalizedDisplay = (x, y, z, aspect) => {\n    let vpd = publicAPI.worldToView(x, y, z);\n    vpd = publicAPI.viewToProjection(vpd[0], vpd[1], vpd[2], aspect);\n\n    return publicAPI.projectionToNormalizedDisplay(vpd[0], vpd[1], vpd[2]);\n  };\n\n  // requires the aspect ratio of the viewport as X/Y\n  publicAPI.viewToWorld = (x, y, z) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro(\n        'ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0'\n      );\n      return [0, 0, 0];\n    }\n\n    // get the view matrix from the active camera\n    const matrix = model.activeCamera.getViewMatrix();\n\n    mat4.invert(matrix, matrix);\n    mat4.transpose(matrix, matrix);\n\n    // Transform point to world coordinates\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n\n  publicAPI.projectionToView = (x, y, z, aspect) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro(\n        'ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0'\n      );\n      return [0, 0, 0];\n    }\n\n    // get the projection transformation from the active camera\n    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);\n\n    mat4.invert(matrix, matrix);\n    mat4.transpose(matrix, matrix);\n\n    // Transform point to world coordinates\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n\n  // Convert world point coordinates to view coordinates.\n  publicAPI.worldToView = (x, y, z) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro(\n        'WorldToView: no active camera, cannot compute view to world, returning 0,0,0'\n      );\n      return [0, 0, 0];\n    }\n\n    // get the view transformation from the active camera\n    const matrix = model.activeCamera.getViewMatrix();\n    mat4.transpose(matrix, matrix);\n\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n\n  // Convert world point coordinates to view coordinates.\n  // requires the aspect ratio of the viewport as X/Y\n  publicAPI.viewToProjection = (x, y, z, aspect) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro(\n        'ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0'\n      );\n      return [0, 0, 0];\n    }\n\n    // get the projeciton transformation from the active camera\n    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);\n    mat4.transpose(matrix, matrix);\n\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n\n  publicAPI.computeVisiblePropBounds = () => {\n    model.allBounds[0] = vtkBoundingBox.INIT_BOUNDS[0];\n    model.allBounds[1] = vtkBoundingBox.INIT_BOUNDS[1];\n    model.allBounds[2] = vtkBoundingBox.INIT_BOUNDS[2];\n    model.allBounds[3] = vtkBoundingBox.INIT_BOUNDS[3];\n    model.allBounds[4] = vtkBoundingBox.INIT_BOUNDS[4];\n    model.allBounds[5] = vtkBoundingBox.INIT_BOUNDS[5];\n    let nothingVisible = true;\n\n    publicAPI.invokeEvent(COMPUTE_VISIBLE_PROP_BOUNDS_EVENT);\n\n    // loop through all props\n    for (let index = 0; index < model.props.length; ++index) {\n      const prop = model.props[index];\n      if (prop.getVisibility() && prop.getUseBounds()) {\n        const bounds = prop.getBounds();\n        if (bounds && vtkMath.areBoundsInitialized(bounds)) {\n          nothingVisible = false;\n\n          if (bounds[0] < model.allBounds[0]) {\n            model.allBounds[0] = bounds[0];\n          }\n          if (bounds[1] > model.allBounds[1]) {\n            model.allBounds[1] = bounds[1];\n          }\n          if (bounds[2] < model.allBounds[2]) {\n            model.allBounds[2] = bounds[2];\n          }\n          if (bounds[3] > model.allBounds[3]) {\n            model.allBounds[3] = bounds[3];\n          }\n          if (bounds[4] < model.allBounds[4]) {\n            model.allBounds[4] = bounds[4];\n          }\n          if (bounds[5] > model.allBounds[5]) {\n            model.allBounds[5] = bounds[5];\n          }\n        }\n      }\n    }\n\n    if (nothingVisible) {\n      vtkMath.uninitializeBounds(model.allBounds);\n      vtkDebugMacro(\"Can't compute bounds, no 3D props are visible\");\n    }\n\n    return model.allBounds;\n  };\n\n  publicAPI.resetCamera = (bounds = null) => {\n    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();\n    const center = [0, 0, 0];\n\n    if (!vtkMath.areBoundsInitialized(boundsToUse)) {\n      vtkDebugMacro('Cannot reset camera!');\n      return false;\n    }\n\n    let vn = null;\n\n    if (publicAPI.getActiveCamera()) {\n      vn = model.activeCamera.getViewPlaneNormal();\n    } else {\n      vtkErrorMacro('Trying to reset non-existent camera');\n      return false;\n    }\n\n    // Reset the perspective zoom factors, otherwise subsequent zooms will cause\n    // the view angle to become very small and cause bad depth sorting.\n    model.activeCamera.setViewAngle(30.0);\n\n    center[0] = (boundsToUse[0] + boundsToUse[1]) / 2.0;\n    center[1] = (boundsToUse[2] + boundsToUse[3]) / 2.0;\n    center[2] = (boundsToUse[4] + boundsToUse[5]) / 2.0;\n\n    let w1 = boundsToUse[1] - boundsToUse[0];\n    let w2 = boundsToUse[3] - boundsToUse[2];\n    let w3 = boundsToUse[5] - boundsToUse[4];\n    w1 *= w1;\n    w2 *= w2;\n    w3 *= w3;\n    let radius = w1 + w2 + w3;\n\n    // If we have just a single point, pick a radius of 1.0\n    radius = radius === 0 ? 1.0 : radius;\n\n    // compute the radius of the enclosing sphere\n    radius = Math.sqrt(radius) * 0.5;\n\n    // default so that the bounding sphere fits within the view fustrum\n\n    // compute the distance from the intersection of the view frustum with the\n    // bounding sphere. Basically in 2D draw a circle representing the bounding\n    // sphere in 2D then draw a horizontal line going out from the center of\n    // the circle. That is the camera view. Then draw a line from the camera\n    // position to the point where it intersects the circle. (it will be tangent\n    // to the circle at this point, this is important, only go to the tangent\n    // point, do not draw all the way to the view plane). Then draw the radius\n    // from the tangent point to the center of the circle. You will note that\n    // this forms a right triangle with one side being the radius, another being\n    // the target distance for the camera, then just find the target dist using\n    // a sin.\n    const angle = vtkMath.radiansFromDegrees(model.activeCamera.getViewAngle());\n    const parallelScale = radius;\n    const distance = radius / Math.sin(angle * 0.5);\n\n    // check view-up vector against view plane normal\n    const vup = model.activeCamera.getViewUp();\n    if (Math.abs(vtkMath.dot(vup, vn)) > 0.999) {\n      vtkWarningMacro('Resetting view-up since view plane normal is parallel');\n      model.activeCamera.setViewUp(-vup[2], vup[0], vup[1]);\n    }\n\n    // update the camera\n    model.activeCamera.setFocalPoint(center[0], center[1], center[2]);\n    model.activeCamera.setPosition(\n      center[0] + distance * vn[0],\n      center[1] + distance * vn[1],\n      center[2] + distance * vn[2]\n    );\n\n    publicAPI.resetCameraClippingRange(boundsToUse);\n\n    // setup default parallel scale\n    model.activeCamera.setParallelScale(parallelScale);\n\n    // update reasonable world to physical values\n    model.activeCamera.setPhysicalScale(radius);\n    model.activeCamera.setPhysicalTranslation(\n      -center[0],\n      -center[1],\n      -center[2]\n    );\n\n    // Here to let parallel/distributed compositing intercept\n    // and do the right thing.\n    publicAPI.invokeEvent(RESET_CAMERA_EVENT);\n\n    return true;\n  };\n\n  publicAPI.resetCameraClippingRange = (bounds = null) => {\n    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();\n\n    if (!vtkMath.areBoundsInitialized(boundsToUse)) {\n      vtkDebugMacro('Cannot reset camera clipping range!');\n      return false;\n    }\n\n    // Make sure we have an active camera\n    publicAPI.getActiveCameraAndResetIfCreated();\n    if (!model.activeCamera) {\n      vtkErrorMacro('Trying to reset clipping range of non-existent camera');\n      return false;\n    }\n\n    // Get the exact range for the bounds\n    const range = model.activeCamera.computeClippingRange(boundsToUse);\n\n    // do not let far - near be less than 0.1 of the window height\n    // this is for cases such as 2D images which may have zero range\n    let minGap = 0.0;\n    if (model.activeCamera.getParallelProjection()) {\n      minGap = 0.2 * model.activeCamera.getParallelScale();\n    } else {\n      const angle = vtkMath.radiansFromDegrees(\n        model.activeCamera.getViewAngle()\n      );\n      minGap = 0.2 * Math.tan(angle / 2.0) * range[1];\n    }\n\n    if (range[1] - range[0] < minGap) {\n      minGap = minGap - range[1] + range[0];\n      range[1] += minGap / 2.0;\n      range[0] -= minGap / 2.0;\n    }\n\n    // Do not let the range behind the camera throw off the calculation.\n    if (range[0] < 0.0) {\n      range[0] = 0.0;\n    }\n\n    // Give ourselves a little breathing room\n    range[0] =\n      0.99 * range[0] - (range[1] - range[0]) * model.clippingRangeExpansion;\n    range[1] =\n      1.01 * range[1] + (range[1] - range[0]) * model.clippingRangeExpansion;\n\n    // Make sure near is not bigger than far\n    range[0] = range[0] >= range[1] ? 0.01 * range[1] : range[0];\n\n    // Make sure near is at least some fraction of far - this prevents near\n    // from being behind the camera or too close in front. How close is too\n    // close depends on the resolution of the depth buffer\n    if (!model.nearClippingPlaneTolerance) {\n      model.nearClippingPlaneTolerance = 0.01;\n    }\n\n    // make sure the front clipping range is not too far from the far clippnig\n    // range, this is to make sure that the zbuffer resolution is effectively\n    // used\n    if (range[0] < model.nearClippingPlaneTolerance * range[1]) {\n      range[0] = model.nearClippingPlaneTolerance * range[1];\n    }\n    model.activeCamera.setClippingRange(range[0], range[1]);\n\n    // Here to let parallel/distributed compositing intercept\n    // and do the right thing.\n    publicAPI.invokeEvent(RESET_CAMERA_CLIPPING_RANGE_EVENT);\n    return false;\n  };\n\n  publicAPI.setRenderWindow = (renderWindow) => {\n    if (renderWindow !== model._renderWindow) {\n      model._vtkWindow = renderWindow;\n      model._renderWindow = renderWindow;\n    }\n  };\n\n  publicAPI.visibleActorCount = () =>\n    model.props.filter((prop) => prop.getVisibility()).length;\n  publicAPI.visibleVolumeCount = publicAPI.visibleActorCount;\n\n  publicAPI.getMTime = () => {\n    let m1 = model.mtime;\n    const m2 = model.activeCamera ? model.activeCamera.getMTime() : 0;\n    if (m2 > m1) {\n      m1 = m2;\n    }\n    const m3 = model._createdLight ? model._createdLight.getMTime() : 0;\n    if (m3 > m1) {\n      m1 = m3;\n    }\n    return m1;\n  };\n\n  publicAPI.getTransparent = () => !!model.preserveColorBuffer;\n\n  publicAPI.isActiveCameraCreated = () => !!model.activeCamera;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  pickedProp: null,\n  activeCamera: null,\n\n  allBounds: [],\n  ambient: [1, 1, 1],\n\n  allocatedRenderTime: 100,\n  timeFactor: 1,\n\n  automaticLightCreation: true,\n\n  twoSidedLighting: true,\n  lastRenderTimeInSeconds: -1,\n\n  renderWindow: null,\n  lights: [],\n  actors: [],\n  volumes: [],\n\n  lightFollowCamera: true,\n\n  numberOfPropsRendered: 0,\n\n  propArray: null,\n\n  pathArray: null,\n\n  layer: 0,\n  preserveColorBuffer: false,\n  preserveDepthBuffer: false,\n\n  computeVisiblePropBounds: vtkMath.createUninitializedBounds(),\n\n  interactive: true,\n\n  nearClippingPlaneTolerance: 0,\n  clippingRangeExpansion: 0.05,\n\n  erase: true,\n  draw: true,\n\n  useShadows: false,\n\n  useDepthPeeling: false,\n  occlusionRatio: 0,\n  maximumNumberOfPeels: 4,\n\n  selector: null,\n  delegate: null,\n\n  texturedBackground: false,\n  backgroundTexture: null,\n\n  environmentTexture: null,\n  environmentTextureDiffuseStrength: 1,\n  environmentTextureSpecularStrength: 1,\n  useEnvironmentTextureAsBackground: false,\n\n  pass: 0,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewport.extend(publicAPI, model, initialValues);\n\n  // make sure background has 4 entries. Default to opaque black\n  if (!model.background) model.background = [0, 0, 0, 1];\n  while (model.background.length < 3) model.background.push(0);\n  if (model.background.length === 3) model.background.push(1);\n\n  // Build VTK API\n  macro.get(publicAPI, model, [\n    '_renderWindow',\n\n    'allocatedRenderTime',\n    'timeFactor',\n\n    'lastRenderTimeInSeconds',\n    'numberOfPropsRendered',\n    'lastRenderingUsedDepthPeeling',\n\n    'selector',\n  ]);\n  macro.setGet(publicAPI, model, [\n    'twoSidedLighting',\n    'lightFollowCamera',\n    'automaticLightCreation',\n    'erase',\n    'draw',\n    'nearClippingPlaneTolerance',\n    'clippingRangeExpansion',\n    'backingStore',\n    'interactive',\n    'layer',\n    'preserveColorBuffer',\n    'preserveDepthBuffer',\n    'useDepthPeeling',\n    'occlusionRatio',\n    'maximumNumberOfPeels',\n    'delegate',\n    'backgroundTexture',\n    'texturedBackground',\n    'environmentTexture',\n    'environmentTextureDiffuseStrength',\n    'environmentTextureSpecularStrength',\n    'useEnvironmentTextureAsBackground',\n    'useShadows',\n    'pass',\n  ]);\n  macro.getArray(publicAPI, model, ['actors', 'volumes', 'lights']);\n  macro.setGetArray(publicAPI, model, ['background'], 4, 1.0);\n  macro.moveToProtected(publicAPI, model, ['renderWindow']);\n\n  // Object methods\n  vtkRenderer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkRenderer');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}