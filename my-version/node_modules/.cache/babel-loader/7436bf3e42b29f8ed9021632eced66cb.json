{"ast":null,"code":"import { create } from 'xmlbuilder2';\nimport { decompressSync } from 'fflate';\nimport DataAccessHelper from 'vtk.js/Sources/IO/Core/DataAccessHelper';\nimport Base64 from 'vtk.js/Sources/Common/Core/Base64';\nimport macro from 'vtk.js/Sources/macros';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nimport BinaryHelper from 'vtk.js/Sources/IO/Core/BinaryHelper'; // Enable data soure for DataAccessHelper\n\nimport 'vtk.js/Sources/IO/Core/DataAccessHelper/LiteHttpDataAccessHelper'; // Just need HTTP\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HttpDataAccessHelper'; // HTTP + zip\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HtmlDataAccessHelper'; // html + base64 + zip\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/JSZipDataAccessHelper'; // zip\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nexport function findAllTags(node, tagName) {\n  return [...node.getElementsByTagName(tagName)];\n}\nexport function findFirstTag(node, tagName) {\n  return findAllTags(node, tagName)[0];\n}\n\nfunction parseXML(xmlStr) {\n  // see xmlbuilder2 docs on the object format\n  return create(xmlStr);\n}\n\nfunction extractAppendedData(buffer) {\n  // search for appended data tag\n  const prefixRegex = /^\\s*<AppendedData\\s+encoding=\"raw\">\\s*_/m;\n  const suffixRegex = /\\n\\s*<\\/AppendedData>/m;\n  return BinaryHelper.extractBinary(buffer, prefixRegex, suffixRegex);\n} // ----------------------------------------------------------------------------\n\n\nconst TYPED_ARRAY = {\n  Int8: Int8Array,\n  UInt8: Uint8Array,\n  Int16: Int16Array,\n  UInt16: Uint16Array,\n  Int32: Int32Array,\n  UInt32: Uint32Array,\n  Int64: Int32Array,\n  // Not supported with JavaScript will cause error in binary\n  UInt64: Uint32Array,\n  // Not supported with JavaScript will cause error in binary\n  Float32: Float32Array,\n  Float64: Float64Array\n}; // ----------------------------------------------------------------------------\n\nconst TYPED_ARRAY_BYTES = {\n  Int8: 1,\n  UInt8: 1,\n  Int16: 2,\n  UInt16: 2,\n  Int32: 4,\n  UInt32: 4,\n  Int64: 8,\n  // Not supported with JavaScript will cause error in binary\n  UInt64: 8,\n  // Not supported with JavaScript will cause error in binary\n  Float32: 4,\n  Float64: 8\n}; // ----------------------------------------------------------------------------\n\nfunction integer64to32(array) {\n  const maxIdx = array.length - 1; // Skip last\n\n  return array.filter((v, i) => i < maxIdx && i % 2 === 0);\n} // ----------------------------------------------------------------------------\n\n\nfunction readerHeader(uint8, headerType) {\n  // We do not handle endianness or if more than 32 bits are needed to encode the data\n  if (headerType === 'UInt64') {\n    const offset = 8;\n    let uint32 = new Uint32Array(uint8.buffer, 0, 6);\n    const nbBlocks = uint32[0];\n    const s1 = uint32[2];\n    const s2 = uint32[4];\n    const resultArray = [offset, nbBlocks, s1, s2];\n    uint32 = new Uint32Array(uint8.buffer, 3 * 8, nbBlocks * 2);\n\n    for (let i = 0; i < nbBlocks; i++) {\n      resultArray.push(uint32[i * 2]);\n    }\n\n    return resultArray;\n  } // UInt32\n\n\n  let uint32 = new Uint32Array(uint8.buffer, 0, 3);\n  const offset = 4;\n  const nbBlocks = uint32[0];\n  const s1 = uint32[1];\n  const s2 = uint32[2];\n  const resultArray = [offset, nbBlocks, s1, s2];\n  uint32 = new Uint32Array(uint8.buffer, 3 * 4, nbBlocks);\n\n  for (let i = 0; i < nbBlocks; i++) {\n    resultArray.push(uint32[i]);\n  }\n\n  return resultArray;\n} // ----------------------------------------------------------------------------\n\n\nfunction uncompressBlock(compressedUint8, output) {\n  const uncompressedBlock = decompressSync(compressedUint8);\n  output.uint8.set(uncompressedBlock, output.offset);\n  output.offset += uncompressedBlock.length;\n} // ----------------------------------------------------------------------------\n\n\nfunction processDataArray(size, dataArrayElem, compressor, byteOrder, headerType, binaryBuffer) {\n  const dataType = dataArrayElem.getAttribute('type');\n  const name = dataArrayElem.getAttribute('Name');\n  const format = dataArrayElem.getAttribute('format'); // binary, ascii, appended\n\n  const numberOfComponents = Number(dataArrayElem.getAttribute('NumberOfComponents') || '1');\n  let values = null;\n\n  if (format === 'ascii') {\n    values = new TYPED_ARRAY[dataType](size * numberOfComponents);\n    let offset = 0;\n    dataArrayElem.firstChild.nodeValue.split(/[\\\\t \\\\n]+/).forEach(token => {\n      if (token.trim().length) {\n        values[offset++] = Number(token);\n      }\n    });\n  } else if (format === 'binary') {\n    const uint8 = new Uint8Array(Base64.toArrayBuffer(dataArrayElem.firstChild.nodeValue.trim()));\n\n    if (compressor === 'vtkZLibDataCompressor') {\n      const buffer = new ArrayBuffer(TYPED_ARRAY_BYTES[dataType] * size * numberOfComponents);\n      values = new TYPED_ARRAY[dataType](buffer);\n      const output = {\n        offset: 0,\n        uint8: new Uint8Array(buffer)\n      }; // ----------------------------------------------------------------------\n      // Layout of the data\n      // header[N, s1, s1, blockSize1, ..., blockSizeN], [padding???], block[compressedData], ..., block[compressedData]\n      // [header] N, s1 and s2 are uint 32 or 64 (defined by header_type=\"UInt64\" attribute on the root node)\n      // [header] s1: uncompress size of each block except the last one\n      // [header] s2: uncompress size of the last blocks\n      // [header] blockSize: size of the block in compressed space that represent to bloc to inflate in zlib. (This also give the offset to the next block)\n      // ----------------------------------------------------------------------\n      // Header reading\n\n      const header = readerHeader(uint8, headerType);\n      const nbBlocks = header[1];\n      let offset = uint8.length - (header.reduce((a, b) => a + b, 0) - (header[0] + header[1] + header[2] + header[3]));\n\n      for (let i = 0; i < nbBlocks; i++) {\n        const blockSize = header[4 + i];\n        const compressedBlock = new Uint8Array(uint8.buffer, offset, blockSize);\n        uncompressBlock(compressedBlock, output);\n        offset += blockSize;\n      } // Handle (u)int64 hoping for no overflow...\n\n\n      if (dataType.indexOf('Int64') !== -1) {\n        values = integer64to32(values);\n      }\n    } else {\n      values = new TYPED_ARRAY[dataType](uint8.buffer, TYPED_ARRAY_BYTES[headerType]); // Skip the count\n      // Handle (u)int64 hoping no overflow...\n\n      if (dataType.indexOf('Int64') !== -1) {\n        values = integer64to32(values);\n      }\n    }\n  } else if (format === 'appended') {\n    let offset = Number(dataArrayElem.getAttribute('offset')); // read header\n    // NOTE: this will incorrectly read the size if headerType is (U)Int64 and\n    // the value requires (U)Int64.\n\n    let header;\n\n    if (offset % TYPED_ARRAY_BYTES[headerType] === 0) {\n      header = new TYPED_ARRAY[headerType](binaryBuffer, offset, 1);\n    } else {\n      header = new TYPED_ARRAY[headerType](binaryBuffer.slice(offset, offset + TYPED_ARRAY_BYTES[headerType]));\n    }\n\n    let arraySize = header[0] / TYPED_ARRAY_BYTES[dataType]; // if we are dealing with Uint64, we need to get double the values since\n    // TYPED_ARRAY[Uint64] is Uint32.\n\n    if (dataType.indexOf('Int64') !== -1) {\n      arraySize *= 2;\n    }\n\n    offset += TYPED_ARRAY_BYTES[headerType]; // read values\n    // if offset is aligned to dataType, use view. Otherwise, slice due to misalignment.\n\n    if (offset % TYPED_ARRAY_BYTES[dataType] === 0) {\n      values = new TYPED_ARRAY[dataType](binaryBuffer, offset, arraySize);\n    } else {\n      values = new TYPED_ARRAY[dataType](binaryBuffer.slice(offset, offset + header[0]));\n    } // remove higher order 32 bits assuming they're not used.\n\n\n    if (dataType.indexOf('Int64') !== -1) {\n      values = integer64to32(values);\n    }\n  } else {\n    console.error('Format not supported', format);\n  }\n\n  return {\n    name,\n    values,\n    numberOfComponents\n  };\n} // ----------------------------------------------------------------------------\n\n\nfunction processCells(size, containerElem, compressor, byteOrder, headerType, binaryBuffer) {\n  const arrayElems = {};\n  const dataArrayElems = containerElem.getElementsByTagName('DataArray');\n\n  for (let elIdx = 0; elIdx < dataArrayElems.length; elIdx++) {\n    const el = dataArrayElems[elIdx];\n    arrayElems[el.getAttribute('Name')] = el;\n  }\n\n  const offsets = processDataArray(size, arrayElems.offsets, compressor, byteOrder, headerType, binaryBuffer).values;\n  const connectivitySize = offsets[offsets.length - 1];\n  const connectivity = processDataArray(connectivitySize, arrayElems.connectivity, compressor, byteOrder, headerType, binaryBuffer).values;\n  const values = new Uint32Array(size + connectivitySize);\n  let writeOffset = 0;\n  let previousOffset = 0;\n  offsets.forEach(v => {\n    const cellSize = v - previousOffset;\n    values[writeOffset++] = cellSize;\n\n    for (let i = 0; i < cellSize; i++) {\n      values[writeOffset++] = connectivity[previousOffset + i];\n    } // save previous offset\n\n\n    previousOffset = v;\n  });\n  return values;\n} // ----------------------------------------------------------------------------\n\n\nfunction processFieldData(size, fieldElem, fieldContainer, compressor, byteOrder, headerType, binaryBuffer) {\n  if (fieldElem) {\n    const attributes = ['Scalars', 'Vectors', 'Normals', 'Tensors', 'TCoords'];\n    const nameBinding = {};\n    attributes.forEach(attrName => {\n      const arrayName = fieldElem.getAttribute(attrName);\n\n      if (arrayName) {\n        nameBinding[arrayName] = fieldContainer[`set${attrName}`];\n      }\n    });\n    const dataArrayElems = fieldElem.getElementsByTagName('DataArray');\n    const nbArrays = dataArrayElems.length;\n\n    for (let idx = 0; idx < nbArrays; idx++) {\n      const array = dataArrayElems[idx];\n      const dataArray = vtkDataArray.newInstance(processDataArray(size, array, compressor, byteOrder, headerType, binaryBuffer));\n      const name = dataArray.getName();\n      (nameBinding[name] || fieldContainer.addArray)(dataArray);\n    }\n  }\n} // ----------------------------------------------------------------------------\n\n\nfunction handleFieldDataArrays(fieldDataElem, compressor, byteOrder, headerType, binaryBuffer) {\n  return [...fieldDataElem.getElementsByTagName('DataArray')].map(daElem => vtkDataArray.newInstance(processDataArray(Number(daElem.getAttribute('NumberOfTuples')), daElem, compressor, byteOrder, headerType, binaryBuffer)));\n} // ----------------------------------------------------------------------------\n// vtkXMLReader methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkXMLReader(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkXMLReader'); // Create default dataAccessHelper if not available\n\n  if (!model.dataAccessHelper) {\n    model.dataAccessHelper = DataAccessHelper.get('http');\n  } // Internal method to fetch Array\n\n\n  function fetchData(url) {\n    let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return model.dataAccessHelper.fetchBinary(url, option);\n  } // Set DataSet url\n\n\n  publicAPI.setUrl = function (url) {\n    let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    model.url = url; // Remove the file in the URL\n\n    const path = url.split('/');\n    path.pop();\n    model.baseURL = path.join('/'); // Fetch metadata\n\n    return publicAPI.loadData(option);\n  }; // Fetch the actual data arrays\n\n\n  publicAPI.loadData = function () {\n    let option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return fetchData(model.url, option).then(publicAPI.parseAsArrayBuffer);\n  };\n\n  publicAPI.parseAsArrayBuffer = arrayBuffer => {\n    if (!arrayBuffer) {\n      return false;\n    }\n\n    if (arrayBuffer !== model.rawDataBuffer) {\n      publicAPI.modified();\n    } else {\n      return true;\n    }\n\n    const {\n      text: content,\n      binaryBuffer\n    } = extractAppendedData(arrayBuffer);\n    model.rawDataBuffer = arrayBuffer;\n    model.binaryBuffer = binaryBuffer; // Parse data here...\n\n    const doc = parseXML(content);\n    const rootElem = doc.root().node;\n    const type = rootElem.getAttribute('type');\n    const compressor = rootElem.getAttribute('compressor');\n    const byteOrder = rootElem.getAttribute('byte_order'); // default to UInt32. I think version 0.1 vtp/vti files default to UInt32.\n\n    const headerType = rootElem.getAttribute('header_type') || 'UInt32';\n\n    if (compressor && compressor !== 'vtkZLibDataCompressor') {\n      console.error('Invalid compressor', compressor);\n      return false;\n    }\n\n    if (byteOrder && byteOrder !== 'LittleEndian') {\n      console.error('Only LittleEndian encoding is supported');\n      return false;\n    }\n\n    if (type !== model.dataType) {\n      console.error('Invalid data type', type, 'expecting', model.dataType);\n      return false;\n    } // appended format\n\n\n    if (findFirstTag(rootElem, 'AppendedData')) {\n      const appendedDataElem = findFirstTag(rootElem, 'AppendedData');\n      const encoding = appendedDataElem.getAttribute('encoding');\n      const arrayElems = findAllTags(rootElem, 'DataArray');\n      let appendedBuffer = model.binaryBuffer;\n\n      if (encoding === 'base64') {\n        // substr(1) is to remove the '_' prefix\n        appendedBuffer = appendedDataElem.textContent.trim().substr(1);\n      } // get data array chunks\n\n\n      const dataArrays = [];\n\n      for (let i = 0; i < arrayElems.length; ++i) {\n        const offset = Number(arrayElems[i].getAttribute('offset'));\n        let nextOffset = 0;\n\n        if (i === arrayElems.length - 1) {\n          nextOffset = appendedBuffer.length || appendedBuffer.byteLength;\n        } else {\n          nextOffset = Number(arrayElems[i + 1].getAttribute('offset'));\n        }\n\n        if (encoding === 'base64') {\n          dataArrays.push(new Uint8Array(Base64.toArrayBuffer(appendedBuffer.substring(offset, nextOffset))));\n        } else {\n          // encoding === 'raw'\n          // Need to slice the ArrayBuffer so readerHeader() works properly\n          dataArrays.push(new Uint8Array(appendedBuffer.slice(offset, nextOffset)));\n        }\n      }\n\n      if (compressor === 'vtkZLibDataCompressor') {\n        for (let arrayidx = 0; arrayidx < dataArrays.length; ++arrayidx) {\n          const dataArray = dataArrays[arrayidx]; // Header reading\n          // Refer to processDataArray() above for info on header fields\n\n          const header = readerHeader(dataArray, headerType);\n          const nbBlocks = header[1];\n          let compressedOffset = dataArray.length - (header.reduce((a, b) => a + b, 0) - (header[0] + header[1] + header[2] + header[3]));\n          let buffer = null;\n\n          if (nbBlocks > 0) {\n            // If the last block's size is labeled as 0, that means the last block\n            // really has size header[2].\n            if (header[3] === 0) {\n              buffer = new ArrayBuffer(header[2] * nbBlocks);\n            } else {\n              buffer = new ArrayBuffer(header[2] * (nbBlocks - 1) + header[3]);\n            }\n          } else {\n            // if there is no blocks, then default to a zero array of size 0.\n            buffer = new ArrayBuffer(0);\n          } // uncompressed buffer\n\n\n          const uncompressed = new Uint8Array(buffer);\n          const output = {\n            offset: 0,\n            uint8: uncompressed\n          };\n\n          for (let i = 0; i < nbBlocks; i++) {\n            const blockSize = header[4 + i];\n            const compressedBlock = new Uint8Array(dataArray.buffer, compressedOffset, blockSize);\n            uncompressBlock(compressedBlock, output);\n            compressedOffset += blockSize;\n          }\n\n          const data = new Uint8Array(uncompressed.length + TYPED_ARRAY_BYTES[headerType]); // set length header\n          // TODO this does not work for lengths that are greater than the max Uint32 value.\n\n          new TYPED_ARRAY[headerType](data.buffer, 0, 1)[0] = uncompressed.length;\n          data.set(uncompressed, TYPED_ARRAY_BYTES[headerType]);\n          dataArrays[arrayidx] = data;\n        }\n      }\n\n      const bufferLength = dataArrays.reduce((acc, arr) => acc + arr.length, 0);\n      const buffer = new ArrayBuffer(bufferLength);\n      const view = new Uint8Array(buffer);\n\n      for (let i = 0, offset = 0; i < dataArrays.length; ++i) {\n        // set correct offsets\n        arrayElems[i].setAttribute('offset', offset); // set final buffer data\n\n        view.set(dataArrays[i], offset);\n        offset += dataArrays[i].length;\n      }\n\n      model.binaryBuffer = buffer;\n\n      if (!model.binaryBuffer) {\n        console.error('Processing appended data format: requires binaryBuffer to parse');\n        return false;\n      }\n    }\n\n    publicAPI.parseXML(rootElem, type, compressor, byteOrder, headerType);\n    const datasetElem = rootElem.getElementsByTagName(type)[0];\n    const fieldDataElem = datasetElem.getElementsByTagName('FieldData')[0];\n\n    if (fieldDataElem) {\n      const fieldDataArrays = handleFieldDataArrays(fieldDataElem, compressor, byteOrder, headerType, model.binaryBuffer);\n\n      for (let i = 0; i < model.output.length; i++) {\n        const fieldData = model.output[i].getFieldData();\n\n        for (let j = 0; j < fieldDataArrays.length; j++) {\n          fieldData.addArray(fieldDataArrays[j]);\n        }\n      }\n    }\n\n    return true;\n  };\n\n  publicAPI.requestData = (inData, outData) => {\n    publicAPI.parseAsArrayBuffer(model.rawDataBuffer);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {// baseURL: null,\n  // dataAccessHelper: null,\n  // url: null,\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['url', 'baseURL']);\n  macro.setGet(publicAPI, model, ['dataAccessHelper']);\n  macro.algo(publicAPI, model, 0, 1); // vtkXMLReader methods\n\n  vtkXMLReader(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport default {\n  extend,\n  processDataArray,\n  processFieldData,\n  processCells\n};","map":{"version":3,"names":["create","decompressSync","DataAccessHelper","Base64","macro","vtkDataArray","BinaryHelper","findAllTags","node","tagName","getElementsByTagName","findFirstTag","parseXML","xmlStr","extractAppendedData","buffer","prefixRegex","suffixRegex","extractBinary","TYPED_ARRAY","Int8","Int8Array","UInt8","Uint8Array","Int16","Int16Array","UInt16","Uint16Array","Int32","Int32Array","UInt32","Uint32Array","Int64","UInt64","Float32","Float32Array","Float64","Float64Array","TYPED_ARRAY_BYTES","integer64to32","array","maxIdx","length","filter","v","i","readerHeader","uint8","headerType","offset","uint32","nbBlocks","s1","s2","resultArray","push","uncompressBlock","compressedUint8","output","uncompressedBlock","set","processDataArray","size","dataArrayElem","compressor","byteOrder","binaryBuffer","dataType","getAttribute","name","format","numberOfComponents","Number","values","firstChild","nodeValue","split","forEach","token","trim","toArrayBuffer","ArrayBuffer","header","reduce","a","b","blockSize","compressedBlock","indexOf","slice","arraySize","console","error","processCells","containerElem","arrayElems","dataArrayElems","elIdx","el","offsets","connectivitySize","connectivity","writeOffset","previousOffset","cellSize","processFieldData","fieldElem","fieldContainer","attributes","nameBinding","attrName","arrayName","nbArrays","idx","dataArray","newInstance","getName","addArray","handleFieldDataArrays","fieldDataElem","map","daElem","vtkXMLReader","publicAPI","model","classHierarchy","dataAccessHelper","get","fetchData","url","option","fetchBinary","setUrl","path","pop","baseURL","join","loadData","then","parseAsArrayBuffer","arrayBuffer","rawDataBuffer","modified","text","content","doc","rootElem","root","type","appendedDataElem","encoding","appendedBuffer","textContent","substr","dataArrays","nextOffset","byteLength","substring","arrayidx","compressedOffset","uncompressed","data","bufferLength","acc","arr","view","setAttribute","datasetElem","fieldDataArrays","fieldData","getFieldData","j","requestData","inData","outData","DEFAULT_VALUES","extend","initialValues","Object","assign","obj","setGet","algo"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/IO/XML/XMLReader/index.js"],"sourcesContent":["import { create } from 'xmlbuilder2';\nimport { decompressSync } from 'fflate';\n\nimport DataAccessHelper from 'vtk.js/Sources/IO/Core/DataAccessHelper';\nimport Base64 from 'vtk.js/Sources/Common/Core/Base64';\nimport macro from 'vtk.js/Sources/macros';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nimport BinaryHelper from 'vtk.js/Sources/IO/Core/BinaryHelper';\n\n// Enable data soure for DataAccessHelper\nimport 'vtk.js/Sources/IO/Core/DataAccessHelper/LiteHttpDataAccessHelper'; // Just need HTTP\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HttpDataAccessHelper'; // HTTP + zip\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HtmlDataAccessHelper'; // html + base64 + zip\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/JSZipDataAccessHelper'; // zip\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nexport function findAllTags(node, tagName) {\n  return [...node.getElementsByTagName(tagName)];\n}\n\nexport function findFirstTag(node, tagName) {\n  return findAllTags(node, tagName)[0];\n}\n\nfunction parseXML(xmlStr) {\n  // see xmlbuilder2 docs on the object format\n  return create(xmlStr);\n}\n\nfunction extractAppendedData(buffer) {\n  // search for appended data tag\n  const prefixRegex = /^\\s*<AppendedData\\s+encoding=\"raw\">\\s*_/m;\n  const suffixRegex = /\\n\\s*<\\/AppendedData>/m;\n  return BinaryHelper.extractBinary(buffer, prefixRegex, suffixRegex);\n}\n\n// ----------------------------------------------------------------------------\n\nconst TYPED_ARRAY = {\n  Int8: Int8Array,\n  UInt8: Uint8Array,\n  Int16: Int16Array,\n  UInt16: Uint16Array,\n  Int32: Int32Array,\n  UInt32: Uint32Array,\n  Int64: Int32Array, // Not supported with JavaScript will cause error in binary\n  UInt64: Uint32Array, // Not supported with JavaScript will cause error in binary\n  Float32: Float32Array,\n  Float64: Float64Array,\n};\n\n// ----------------------------------------------------------------------------\n\nconst TYPED_ARRAY_BYTES = {\n  Int8: 1,\n  UInt8: 1,\n  Int16: 2,\n  UInt16: 2,\n  Int32: 4,\n  UInt32: 4,\n  Int64: 8, // Not supported with JavaScript will cause error in binary\n  UInt64: 8, // Not supported with JavaScript will cause error in binary\n  Float32: 4,\n  Float64: 8,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction integer64to32(array) {\n  const maxIdx = array.length - 1; // Skip last\n  return array.filter((v, i) => i < maxIdx && i % 2 === 0);\n}\n\n// ----------------------------------------------------------------------------\n\nfunction readerHeader(uint8, headerType) {\n  // We do not handle endianness or if more than 32 bits are needed to encode the data\n  if (headerType === 'UInt64') {\n    const offset = 8;\n    let uint32 = new Uint32Array(uint8.buffer, 0, 6);\n    const nbBlocks = uint32[0];\n    const s1 = uint32[2];\n    const s2 = uint32[4];\n    const resultArray = [offset, nbBlocks, s1, s2];\n    uint32 = new Uint32Array(uint8.buffer, 3 * 8, nbBlocks * 2);\n    for (let i = 0; i < nbBlocks; i++) {\n      resultArray.push(uint32[i * 2]);\n    }\n    return resultArray;\n  }\n  // UInt32\n  let uint32 = new Uint32Array(uint8.buffer, 0, 3);\n  const offset = 4;\n  const nbBlocks = uint32[0];\n  const s1 = uint32[1];\n  const s2 = uint32[2];\n  const resultArray = [offset, nbBlocks, s1, s2];\n  uint32 = new Uint32Array(uint8.buffer, 3 * 4, nbBlocks);\n  for (let i = 0; i < nbBlocks; i++) {\n    resultArray.push(uint32[i]);\n  }\n  return resultArray;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction uncompressBlock(compressedUint8, output) {\n  const uncompressedBlock = decompressSync(compressedUint8);\n  output.uint8.set(uncompressedBlock, output.offset);\n  output.offset += uncompressedBlock.length;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction processDataArray(\n  size,\n  dataArrayElem,\n  compressor,\n  byteOrder,\n  headerType,\n  binaryBuffer\n) {\n  const dataType = dataArrayElem.getAttribute('type');\n  const name = dataArrayElem.getAttribute('Name');\n  const format = dataArrayElem.getAttribute('format'); // binary, ascii, appended\n  const numberOfComponents = Number(\n    dataArrayElem.getAttribute('NumberOfComponents') || '1'\n  );\n  let values = null;\n\n  if (format === 'ascii') {\n    values = new TYPED_ARRAY[dataType](size * numberOfComponents);\n    let offset = 0;\n    dataArrayElem.firstChild.nodeValue.split(/[\\\\t \\\\n]+/).forEach((token) => {\n      if (token.trim().length) {\n        values[offset++] = Number(token);\n      }\n    });\n  } else if (format === 'binary') {\n    const uint8 = new Uint8Array(\n      Base64.toArrayBuffer(dataArrayElem.firstChild.nodeValue.trim())\n    );\n    if (compressor === 'vtkZLibDataCompressor') {\n      const buffer = new ArrayBuffer(\n        TYPED_ARRAY_BYTES[dataType] * size * numberOfComponents\n      );\n      values = new TYPED_ARRAY[dataType](buffer);\n      const output = {\n        offset: 0,\n        uint8: new Uint8Array(buffer),\n      };\n      // ----------------------------------------------------------------------\n      // Layout of the data\n      // header[N, s1, s1, blockSize1, ..., blockSizeN], [padding???], block[compressedData], ..., block[compressedData]\n      // [header] N, s1 and s2 are uint 32 or 64 (defined by header_type=\"UInt64\" attribute on the root node)\n      // [header] s1: uncompress size of each block except the last one\n      // [header] s2: uncompress size of the last blocks\n      // [header] blockSize: size of the block in compressed space that represent to bloc to inflate in zlib. (This also give the offset to the next block)\n      // ----------------------------------------------------------------------\n      // Header reading\n      const header = readerHeader(uint8, headerType);\n      const nbBlocks = header[1];\n      let offset =\n        uint8.length -\n        (header.reduce((a, b) => a + b, 0) -\n          (header[0] + header[1] + header[2] + header[3]));\n      for (let i = 0; i < nbBlocks; i++) {\n        const blockSize = header[4 + i];\n        const compressedBlock = new Uint8Array(uint8.buffer, offset, blockSize);\n        uncompressBlock(compressedBlock, output);\n        offset += blockSize;\n      }\n\n      // Handle (u)int64 hoping for no overflow...\n      if (dataType.indexOf('Int64') !== -1) {\n        values = integer64to32(values);\n      }\n    } else {\n      values = new TYPED_ARRAY[dataType](\n        uint8.buffer,\n        TYPED_ARRAY_BYTES[headerType]\n      ); // Skip the count\n\n      // Handle (u)int64 hoping no overflow...\n      if (dataType.indexOf('Int64') !== -1) {\n        values = integer64to32(values);\n      }\n    }\n  } else if (format === 'appended') {\n    let offset = Number(dataArrayElem.getAttribute('offset'));\n    // read header\n    // NOTE: this will incorrectly read the size if headerType is (U)Int64 and\n    // the value requires (U)Int64.\n    let header;\n    if (offset % TYPED_ARRAY_BYTES[headerType] === 0) {\n      header = new TYPED_ARRAY[headerType](binaryBuffer, offset, 1);\n    } else {\n      header = new TYPED_ARRAY[headerType](\n        binaryBuffer.slice(offset, offset + TYPED_ARRAY_BYTES[headerType])\n      );\n    }\n    let arraySize = header[0] / TYPED_ARRAY_BYTES[dataType];\n\n    // if we are dealing with Uint64, we need to get double the values since\n    // TYPED_ARRAY[Uint64] is Uint32.\n    if (dataType.indexOf('Int64') !== -1) {\n      arraySize *= 2;\n    }\n\n    offset += TYPED_ARRAY_BYTES[headerType];\n\n    // read values\n    // if offset is aligned to dataType, use view. Otherwise, slice due to misalignment.\n    if (offset % TYPED_ARRAY_BYTES[dataType] === 0) {\n      values = new TYPED_ARRAY[dataType](binaryBuffer, offset, arraySize);\n    } else {\n      values = new TYPED_ARRAY[dataType](\n        binaryBuffer.slice(offset, offset + header[0])\n      );\n    }\n    // remove higher order 32 bits assuming they're not used.\n    if (dataType.indexOf('Int64') !== -1) {\n      values = integer64to32(values);\n    }\n  } else {\n    console.error('Format not supported', format);\n  }\n\n  return { name, values, numberOfComponents };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction processCells(\n  size,\n  containerElem,\n  compressor,\n  byteOrder,\n  headerType,\n  binaryBuffer\n) {\n  const arrayElems = {};\n  const dataArrayElems = containerElem.getElementsByTagName('DataArray');\n  for (let elIdx = 0; elIdx < dataArrayElems.length; elIdx++) {\n    const el = dataArrayElems[elIdx];\n    arrayElems[el.getAttribute('Name')] = el;\n  }\n\n  const offsets = processDataArray(\n    size,\n    arrayElems.offsets,\n    compressor,\n    byteOrder,\n    headerType,\n    binaryBuffer\n  ).values;\n  const connectivitySize = offsets[offsets.length - 1];\n  const connectivity = processDataArray(\n    connectivitySize,\n    arrayElems.connectivity,\n    compressor,\n    byteOrder,\n    headerType,\n    binaryBuffer\n  ).values;\n  const values = new Uint32Array(size + connectivitySize);\n  let writeOffset = 0;\n  let previousOffset = 0;\n  offsets.forEach((v) => {\n    const cellSize = v - previousOffset;\n    values[writeOffset++] = cellSize;\n\n    for (let i = 0; i < cellSize; i++) {\n      values[writeOffset++] = connectivity[previousOffset + i];\n    }\n\n    // save previous offset\n    previousOffset = v;\n  });\n\n  return values;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction processFieldData(\n  size,\n  fieldElem,\n  fieldContainer,\n  compressor,\n  byteOrder,\n  headerType,\n  binaryBuffer\n) {\n  if (fieldElem) {\n    const attributes = ['Scalars', 'Vectors', 'Normals', 'Tensors', 'TCoords'];\n    const nameBinding = {};\n    attributes.forEach((attrName) => {\n      const arrayName = fieldElem.getAttribute(attrName);\n      if (arrayName) {\n        nameBinding[arrayName] = fieldContainer[`set${attrName}`];\n      }\n    });\n\n    const dataArrayElems = fieldElem.getElementsByTagName('DataArray');\n    const nbArrays = dataArrayElems.length;\n    for (let idx = 0; idx < nbArrays; idx++) {\n      const array = dataArrayElems[idx];\n      const dataArray = vtkDataArray.newInstance(\n        processDataArray(\n          size,\n          array,\n          compressor,\n          byteOrder,\n          headerType,\n          binaryBuffer\n        )\n      );\n      const name = dataArray.getName();\n      (nameBinding[name] || fieldContainer.addArray)(dataArray);\n    }\n  }\n}\n\n// ----------------------------------------------------------------------------\nfunction handleFieldDataArrays(\n  fieldDataElem,\n  compressor,\n  byteOrder,\n  headerType,\n  binaryBuffer\n) {\n  return [...fieldDataElem.getElementsByTagName('DataArray')].map((daElem) =>\n    vtkDataArray.newInstance(\n      processDataArray(\n        Number(daElem.getAttribute('NumberOfTuples')),\n        daElem,\n        compressor,\n        byteOrder,\n        headerType,\n        binaryBuffer\n      )\n    )\n  );\n}\n\n// ----------------------------------------------------------------------------\n// vtkXMLReader methods\n// ----------------------------------------------------------------------------\n\nfunction vtkXMLReader(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkXMLReader');\n\n  // Create default dataAccessHelper if not available\n  if (!model.dataAccessHelper) {\n    model.dataAccessHelper = DataAccessHelper.get('http');\n  }\n\n  // Internal method to fetch Array\n  function fetchData(url, option = {}) {\n    return model.dataAccessHelper.fetchBinary(url, option);\n  }\n\n  // Set DataSet url\n  publicAPI.setUrl = (url, option = {}) => {\n    model.url = url;\n\n    // Remove the file in the URL\n    const path = url.split('/');\n    path.pop();\n    model.baseURL = path.join('/');\n\n    // Fetch metadata\n    return publicAPI.loadData(option);\n  };\n\n  // Fetch the actual data arrays\n  publicAPI.loadData = (option = {}) =>\n    fetchData(model.url, option).then(publicAPI.parseAsArrayBuffer);\n\n  publicAPI.parseAsArrayBuffer = (arrayBuffer) => {\n    if (!arrayBuffer) {\n      return false;\n    }\n    if (arrayBuffer !== model.rawDataBuffer) {\n      publicAPI.modified();\n    } else {\n      return true;\n    }\n\n    const { text: content, binaryBuffer } = extractAppendedData(arrayBuffer);\n    model.rawDataBuffer = arrayBuffer;\n    model.binaryBuffer = binaryBuffer;\n\n    // Parse data here...\n    const doc = parseXML(content);\n    const rootElem = doc.root().node;\n    const type = rootElem.getAttribute('type');\n    const compressor = rootElem.getAttribute('compressor');\n    const byteOrder = rootElem.getAttribute('byte_order');\n    // default to UInt32. I think version 0.1 vtp/vti files default to UInt32.\n    const headerType = rootElem.getAttribute('header_type') || 'UInt32';\n\n    if (compressor && compressor !== 'vtkZLibDataCompressor') {\n      console.error('Invalid compressor', compressor);\n      return false;\n    }\n\n    if (byteOrder && byteOrder !== 'LittleEndian') {\n      console.error('Only LittleEndian encoding is supported');\n      return false;\n    }\n\n    if (type !== model.dataType) {\n      console.error('Invalid data type', type, 'expecting', model.dataType);\n      return false;\n    }\n\n    // appended format\n    if (findFirstTag(rootElem, 'AppendedData')) {\n      const appendedDataElem = findFirstTag(rootElem, 'AppendedData');\n      const encoding = appendedDataElem.getAttribute('encoding');\n      const arrayElems = findAllTags(rootElem, 'DataArray');\n\n      let appendedBuffer = model.binaryBuffer;\n\n      if (encoding === 'base64') {\n        // substr(1) is to remove the '_' prefix\n        appendedBuffer = appendedDataElem.textContent.trim().substr(1);\n      }\n\n      // get data array chunks\n      const dataArrays = [];\n      for (let i = 0; i < arrayElems.length; ++i) {\n        const offset = Number(arrayElems[i].getAttribute('offset'));\n        let nextOffset = 0;\n        if (i === arrayElems.length - 1) {\n          nextOffset = appendedBuffer.length || appendedBuffer.byteLength;\n        } else {\n          nextOffset = Number(arrayElems[i + 1].getAttribute('offset'));\n        }\n\n        if (encoding === 'base64') {\n          dataArrays.push(\n            new Uint8Array(\n              Base64.toArrayBuffer(appendedBuffer.substring(offset, nextOffset))\n            )\n          );\n        } else {\n          // encoding === 'raw'\n          // Need to slice the ArrayBuffer so readerHeader() works properly\n          dataArrays.push(\n            new Uint8Array(appendedBuffer.slice(offset, nextOffset))\n          );\n        }\n      }\n\n      if (compressor === 'vtkZLibDataCompressor') {\n        for (let arrayidx = 0; arrayidx < dataArrays.length; ++arrayidx) {\n          const dataArray = dataArrays[arrayidx];\n\n          // Header reading\n          // Refer to processDataArray() above for info on header fields\n          const header = readerHeader(dataArray, headerType);\n          const nbBlocks = header[1];\n          let compressedOffset =\n            dataArray.length -\n            (header.reduce((a, b) => a + b, 0) -\n              (header[0] + header[1] + header[2] + header[3]));\n\n          let buffer = null;\n          if (nbBlocks > 0) {\n            // If the last block's size is labeled as 0, that means the last block\n            // really has size header[2].\n            if (header[3] === 0) {\n              buffer = new ArrayBuffer(header[2] * nbBlocks);\n            } else {\n              buffer = new ArrayBuffer(header[2] * (nbBlocks - 1) + header[3]);\n            }\n          } else {\n            // if there is no blocks, then default to a zero array of size 0.\n            buffer = new ArrayBuffer(0);\n          }\n\n          // uncompressed buffer\n          const uncompressed = new Uint8Array(buffer);\n          const output = {\n            offset: 0,\n            uint8: uncompressed,\n          };\n\n          for (let i = 0; i < nbBlocks; i++) {\n            const blockSize = header[4 + i];\n            const compressedBlock = new Uint8Array(\n              dataArray.buffer,\n              compressedOffset,\n              blockSize\n            );\n            uncompressBlock(compressedBlock, output);\n            compressedOffset += blockSize;\n          }\n\n          const data = new Uint8Array(\n            uncompressed.length + TYPED_ARRAY_BYTES[headerType]\n          );\n          // set length header\n          // TODO this does not work for lengths that are greater than the max Uint32 value.\n          new TYPED_ARRAY[headerType](data.buffer, 0, 1)[0] =\n            uncompressed.length;\n          data.set(uncompressed, TYPED_ARRAY_BYTES[headerType]);\n\n          dataArrays[arrayidx] = data;\n        }\n      }\n\n      const bufferLength = dataArrays.reduce((acc, arr) => acc + arr.length, 0);\n      const buffer = new ArrayBuffer(bufferLength);\n      const view = new Uint8Array(buffer);\n\n      for (let i = 0, offset = 0; i < dataArrays.length; ++i) {\n        // set correct offsets\n        arrayElems[i].setAttribute('offset', offset);\n        // set final buffer data\n        view.set(dataArrays[i], offset);\n        offset += dataArrays[i].length;\n      }\n\n      model.binaryBuffer = buffer;\n\n      if (!model.binaryBuffer) {\n        console.error(\n          'Processing appended data format: requires binaryBuffer to parse'\n        );\n        return false;\n      }\n    }\n\n    publicAPI.parseXML(rootElem, type, compressor, byteOrder, headerType);\n\n    const datasetElem = rootElem.getElementsByTagName(type)[0];\n    const fieldDataElem = datasetElem.getElementsByTagName('FieldData')[0];\n\n    if (fieldDataElem) {\n      const fieldDataArrays = handleFieldDataArrays(\n        fieldDataElem,\n        compressor,\n        byteOrder,\n        headerType,\n        model.binaryBuffer\n      );\n\n      for (let i = 0; i < model.output.length; i++) {\n        const fieldData = model.output[i].getFieldData();\n        for (let j = 0; j < fieldDataArrays.length; j++) {\n          fieldData.addArray(fieldDataArrays[j]);\n        }\n      }\n    }\n\n    return true;\n  };\n\n  publicAPI.requestData = (inData, outData) => {\n    publicAPI.parseAsArrayBuffer(model.rawDataBuffer);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // baseURL: null,\n  // dataAccessHelper: null,\n  // url: null,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['url', 'baseURL']);\n  macro.setGet(publicAPI, model, ['dataAccessHelper']);\n  macro.algo(publicAPI, model, 0, 1);\n\n  // vtkXMLReader methods\n  vtkXMLReader(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport default { extend, processDataArray, processFieldData, processCells };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}