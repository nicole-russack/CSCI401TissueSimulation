{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport vtkCell from 'vtk.js/Sources/Common/DataModel/Cell';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkLine from 'vtk.js/Sources/Common/DataModel/Line';\nimport vtkPlane from 'vtk.js/Sources/Common/DataModel/Plane'; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction computeNormalDirection(v1, v2, v3, n) {\n  // order is important!!! maintain consistency with triangle vertex order\n  const ax = v3[0] - v2[0];\n  const ay = v3[1] - v2[1];\n  const az = v3[2] - v2[2];\n  const bx = v1[0] - v2[0];\n  const by = v1[1] - v2[1];\n  const bz = v1[2] - v2[2];\n  n[0] = ay * bz - az * by;\n  n[1] = az * bx - ax * bz;\n  n[2] = ax * by - ay * bx;\n}\n\nfunction computeNormal(v1, v2, v3, n) {\n  computeNormalDirection(v1, v2, v3, n);\n  const length = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);\n\n  if (length !== 0.0) {\n    n[0] /= length;\n    n[1] /= length;\n    n[2] /= length;\n  }\n}\n\nfunction intersectWithTriangle(p1, q1, r1, p2, q2, r2) {\n  let tolerance = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1e-6;\n  let coplanar = false;\n  const pt1 = [];\n  const pt2 = [];\n  const surfaceId = [];\n  const n1 = [];\n  const n2 = []; // Compute supporting plane normals.\n\n  computeNormal(p1, q1, r1, n1);\n  computeNormal(p2, q2, r2, n2);\n  const s1 = -vtkMath.dot(n1, p1);\n  const s2 = -vtkMath.dot(n2, p2); // Compute signed distances of points p1, q1, r1 from supporting\n  // plane of second triangle.\n\n  const dist1 = [vtkMath.dot(n2, p1) + s2, vtkMath.dot(n2, q1) + s2, vtkMath.dot(n2, r1) + s2]; // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n\n  if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 1!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  } // Do the same for p2, q2, r2 and supporting plane of first\n  // triangle.\n\n\n  const dist2 = [vtkMath.dot(n1, p2) + s1, vtkMath.dot(n1, q2) + s1, vtkMath.dot(n1, r2) + s1]; // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n\n  if (dist2[0] * dist2[1] > tolerance && dist2[0] * dist2[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 2!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  } // Check for coplanarity of the supporting planes.\n\n\n  if (Math.abs(n1[0] - n2[0]) < 1e-9 && Math.abs(n1[1] - n2[1]) < 1e-9 && Math.abs(n1[2] - n2[2]) < 1e-9 && Math.abs(s1 - s2) < 1e-9) {\n    coplanar = true; // vtkDebugMacro(<<\"Coplanar!\");\n\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  } // There are more efficient ways to find the intersection line (if\n  // it exists), but this is clear enough.\n\n\n  const pts1 = [p1, q1, r1];\n  const pts2 = [p2, q2, r2]; // Find line of intersection (L = p + t*v) between two planes.\n\n  const n1n2 = vtkMath.dot(n1, n2);\n  const a = (s1 - s2 * n1n2) / (n1n2 * n1n2 - 1.0);\n  const b = (s2 - s1 * n1n2) / (n1n2 * n1n2 - 1.0);\n  const p = [a * n1[0] + b * n2[0], a * n1[1] + b * n2[1], a * n1[2] + b * n2[2]];\n  const v = vtkMath.cross(n1, n2, []);\n  vtkMath.normalize(v);\n  let index1 = 0;\n  let index2 = 0;\n  const t1 = [];\n  const t2 = [];\n  let ts1 = 50;\n  let ts2 = 50;\n\n  for (let i = 0; i < 3; i++) {\n    const id1 = i;\n    const id2 = (i + 1) % 3; // Find t coordinate on line of intersection between two planes.\n\n    const val1 = vtkPlane.intersectWithLine(pts1[id1], pts1[id2], p2, n2);\n\n    if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {\n      if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {\n        ts1 = index1;\n      }\n\n      t1[index1++] = vtkMath.dot(val1.x, v) - vtkMath.dot(p, v);\n    }\n\n    const val2 = vtkPlane.intersectWithLine(pts2[id1], pts2[id2], p1, n1);\n\n    if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {\n      if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {\n        ts2 = index2;\n      }\n\n      t2[index2++] = vtkMath.dot(val2.x, v) - vtkMath.dot(p, v);\n    }\n  } // If the value of the index is greater than 2, the intersecting point\n  // actually is intersected by all three edges. In this case, set the two\n  // edges to the two edges where the intersecting point is not the end point\n\n\n  if (index1 > 2) {\n    index1--; // swap\n\n    const t12 = t1[2];\n    t1[2] = t1[ts1];\n    t1[ts1] = t12;\n  }\n\n  if (index2 > 2) {\n    index2--;\n    const t22 = t2[2];\n    t2[2] = t2[ts2];\n    t2[ts2] = t22;\n  } // Check if only one edge or all edges intersect the supporting\n  // planes intersection.\n\n\n  if (index1 !== 2 || index2 !== 2) {\n    // vtkDebugMacro(<<\"Only one edge intersecting!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  } // Check for NaNs\n\n\n  if (Number.isNaN(t1[0]) || Number.isNaN(t1[1]) || Number.isNaN(t2[0]) || Number.isNaN(t2[1])) {\n    // vtkWarningMacro(<<\"NaNs!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n\n  if (t1[0] > t1[1]) {\n    // swap\n    const t11 = t1[1];\n    t1[1] = t1[0];\n    t1[0] = t11;\n  }\n\n  if (t2[0] > t2[1]) {\n    // swap\n    const t21 = t2[1];\n    t2[1] = t2[0];\n    t2[0] = t21;\n  } // Handle the different interval configuration cases.\n\n\n  let tt1;\n  let tt2;\n\n  if (t1[1] < t2[0] || t2[1] < t1[0]) {\n    // vtkDebugMacro(<<\"No Overlap!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    }; // No overlap\n  }\n\n  if (t1[0] < t2[0]) {\n    if (t1[1] < t2[1]) {\n      // First point on surface 2, second point on surface 1\n      surfaceId[0] = 2;\n      surfaceId[1] = 1;\n      tt1 = t2[0];\n      tt2 = t1[1];\n    } else {\n      // Both points belong to lines on surface 2\n      surfaceId[0] = 2;\n      surfaceId[1] = 2;\n      tt1 = t2[0];\n      tt2 = t2[1];\n    }\n  } // t1[0] >= t2[0]\n  else if (t1[1] < t2[1]) {\n    // Both points belong to lines on surface 1\n    surfaceId[0] = 1;\n    surfaceId[1] = 1;\n    tt1 = t1[0];\n    tt2 = t1[1];\n  } else {\n    // First point on surface 1, second point on surface 2\n    surfaceId[0] = 1;\n    surfaceId[1] = 2;\n    tt1 = t1[0];\n    tt2 = t2[1];\n  } // Create actual intersection points.\n\n\n  vtkMath.multiplyAccumulate(p, v, tt1, pt1);\n  vtkMath.multiplyAccumulate(p, v, tt2, pt2);\n  return {\n    intersect: true,\n    coplanar,\n    pt1,\n    pt2,\n    surfaceId\n  };\n} // ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\n\nexport const STATIC = {\n  computeNormalDirection,\n  computeNormal,\n  intersectWithTriangle\n}; // ----------------------------------------------------------------------------\n// vtkTriangle methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTriangle(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkTriangle');\n\n  publicAPI.getCellDimension = () => 2;\n\n  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {\n    const outObj = {\n      subId: 0,\n      t: Number.MAX_VALUE,\n      intersect: 0,\n      betweenPoints: false\n    };\n    pcoords[2] = 0.0;\n    const closestPoint = [];\n    const tol2 = tol * tol; // Get normal for triangle\n\n    const pt1 = [];\n    const pt2 = [];\n    const pt3 = [];\n    model.points.getPoint(0, pt1);\n    model.points.getPoint(1, pt2);\n    model.points.getPoint(2, pt3);\n    const n = [];\n    const weights = [];\n    computeNormal(pt1, pt2, pt3, n);\n\n    if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {\n      // Intersect plane of triangle with line\n      const plane = vtkPlane.intersectWithLine(p1, p2, pt1, n);\n      outObj.betweenPoints = plane.betweenPoints;\n      outObj.t = plane.t;\n      x[0] = plane.x[0];\n      x[1] = plane.x[1];\n      x[2] = plane.x[2];\n\n      if (!plane.intersection) {\n        pcoords[0] = 0.0;\n        pcoords[1] = 0.0;\n        outObj.intersect = 0;\n        return outObj;\n      } // Evaluate position\n\n\n      const inside = publicAPI.evaluatePosition(x, closestPoint, pcoords, weights);\n\n      if (inside.evaluation >= 0) {\n        if (inside.dist2 <= tol2) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n\n        outObj.intersect = inside.evaluation;\n        return outObj;\n      }\n    } // Normals are null, so the triangle is degenerated and\n    // we still need to check intersection between line and\n    // the longest edge.\n\n\n    const dist2Pt1Pt2 = vtkMath.distance2BetweenPoints(pt1, pt2);\n    const dist2Pt2Pt3 = vtkMath.distance2BetweenPoints(pt2, pt3);\n    const dist2Pt3Pt1 = vtkMath.distance2BetweenPoints(pt3, pt1);\n\n    if (!model.line) {\n      model.line = vtkLine.newInstance();\n    }\n\n    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {\n      model.line.getPoints().setPoint(0, pt1);\n      model.line.getPoints().setPoint(1, pt2);\n    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {\n      model.line.getPoints().setPoint(0, pt2);\n      model.line.getPoints().setPoint(1, pt3);\n    } else {\n      model.line.getPoints().setPoint(0, pt3);\n      model.line.getPoints().setPoint(1, pt1);\n    }\n\n    const intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);\n    outObj.betweenPoints = intersectLine.betweenPoints;\n    outObj.t = intersectLine.t;\n\n    if (intersectLine.intersect) {\n      const pt3Pt1 = [];\n      const pt3Pt2 = [];\n      const pt3X = []; // Compute r and s manually, using dot and norm.\n\n      for (let i = 0; i < 3; i++) {\n        pt3Pt1[i] = pt1[i] - pt3[i];\n        pt3Pt2[i] = pt2[i] - pt3[i];\n        pt3X[i] = x[i] - pt3[i];\n      }\n\n      pcoords[0] = vtkMath.dot(pt3X, pt3Pt1) / dist2Pt3Pt1;\n      pcoords[1] = vtkMath.dot(pt3X, pt3Pt2) / dist2Pt2Pt3;\n      outObj.intersect = 1;\n      return outObj;\n    }\n\n    pcoords[0] = 0.0;\n    pcoords[1] = 0.0;\n    outObj.intersect = 0;\n    return outObj;\n  };\n\n  publicAPI.evaluatePosition = (x, closestPoint, pcoords, weights) => {\n    // will return obj\n    const outObj = {\n      subId: 0,\n      dist2: 0,\n      evaluation: -1\n    };\n    let i;\n    let j;\n    const pt1 = [];\n    const pt2 = [];\n    const pt3 = [];\n    const n = [];\n    let fabsn;\n    const rhs = [];\n    const c1 = [];\n    const c2 = [];\n    let det = 0;\n    let idx = 0;\n    const indices = [];\n    let dist2Point;\n    let dist2Line1;\n    let dist2Line2;\n    let closest = [];\n    const closestPoint1 = [];\n    const closestPoint2 = [];\n    const cp = [];\n    outObj.subId = 0;\n    pcoords[2] = 0.0; // Get normal for triangle, only the normal direction is needed, i.e. the\n    // normal need not be normalized (unit length)\n    //\n\n    model.points.getPoint(1, pt1);\n    model.points.getPoint(2, pt2);\n    model.points.getPoint(0, pt3);\n    computeNormalDirection(pt1, pt2, pt3, n); // Project point to plane\n\n    vtkPlane.generalizedProjectPoint(x, pt1, n, cp); // Construct matrices.  Since we have over determined system, need to find\n    // which 2 out of 3 equations to use to develop equations. (Any 2 should\n    // work since we've projected point to plane.)\n\n    let maxComponent = 0.0;\n\n    for (i = 0; i < 3; i++) {\n      // trying to avoid an expensive call to fabs()\n      if (n[i] < 0) {\n        fabsn = -n[i];\n      } else {\n        fabsn = n[i];\n      }\n\n      if (fabsn > maxComponent) {\n        maxComponent = fabsn;\n        idx = i;\n      }\n    }\n\n    for (j = 0, i = 0; i < 3; i++) {\n      if (i !== idx) {\n        indices[j++] = i;\n      }\n    }\n\n    for (i = 0; i < 2; i++) {\n      rhs[i] = cp[indices[i]] - pt3[indices[i]];\n      c1[i] = pt1[indices[i]] - pt3[indices[i]];\n      c2[i] = pt2[indices[i]] - pt3[indices[i]];\n    }\n\n    det = vtkMath.determinant2x2(c1, c2);\n\n    if (det === 0.0) {\n      pcoords[0] = 0.0;\n      pcoords[1] = 0.0;\n      outObj.evaluation = -1;\n      return outObj;\n    }\n\n    pcoords[0] = vtkMath.determinant2x2(rhs, c2) / det;\n    pcoords[1] = vtkMath.determinant2x2(c1, rhs) / det; // Okay, now find closest point to element\n\n    weights[0] = 1 - (pcoords[0] + pcoords[1]);\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n\n    if (weights[0] >= 0.0 && weights[0] <= 1.0 && weights[1] >= 0.0 && weights[1] <= 1.0 && weights[2] >= 0.0 && weights[2] <= 1.0) {\n      // projection distance\n      if (closestPoint) {\n        outObj.dist2 = vtkMath.distance2BetweenPoints(cp, x);\n        closestPoint[0] = cp[0];\n        closestPoint[1] = cp[1];\n        closestPoint[2] = cp[2];\n      }\n\n      outObj.evaluation = 1;\n    } else {\n      let t;\n\n      if (closestPoint) {\n        if (weights[1] < 0.0 && weights[2] < 0.0) {\n          dist2Point = vtkMath.distance2BetweenPoints(x, pt3);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt3, pt2, t, closestPoint2);\n\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt3;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[2] < 0.0 && weights[0] < 0.0) {\n          dist2Point = vtkMath.distance2BetweenPoints(x, pt1);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt1;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[1] < 0.0 && weights[0] < 0.0) {\n          dist2Point = vtkMath.distance2BetweenPoints(x, pt2);\n          dist2Line1 = vtkLine.distanceToLine(x, pt2, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt2;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[0] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(x, pt1, pt2, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        } else if (weights[1] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(x, pt2, pt3, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        } else if (weights[2] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(x, pt1, pt3, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        }\n      }\n\n      outObj.evaluation = 0;\n    }\n\n    return outObj;\n  };\n\n  publicAPI.evaluateLocation = (pcoords, x, weights) => {\n    const p0 = [];\n    const p1 = [];\n    const p2 = [];\n    model.points.getPoint(0, p0);\n    model.points.getPoint(1, p1);\n    model.points.getPoint(2, p2);\n    const u3 = 1.0 - pcoords[0] - pcoords[1];\n\n    for (let i = 0; i < 3; i++) {\n      x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];\n    }\n\n    weights[0] = u3;\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n  };\n\n  publicAPI.getParametricDistance = pcoords => {\n    let pDist;\n    let pDistMax = 0.0;\n    const pc = [];\n    pc[0] = pcoords[0];\n    pc[1] = pcoords[1];\n    pc[2] = 1.0 - pcoords[0] - pcoords[1];\n\n    for (let i = 0; i < 3; i++) {\n      if (pc[i] < 0.0) {\n        pDist = -pc[i];\n      } else if (pc[i] > 1.0) {\n        pDist = pc[i] - 1.0;\n      } else {\n        // inside the cell in the parametric direction\n        pDist = 0.0;\n      }\n\n      if (pDist > pDistMax) {\n        pDistMax = pDist;\n      }\n    }\n\n    return pDistMax;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  vtkTriangle(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkTriangle'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend,\n  ...STATIC\n};","map":{"version":3,"names":["macro","vtkCell","vtkMath","vtkLine","vtkPlane","computeNormalDirection","v1","v2","v3","n","ax","ay","az","bx","by","bz","computeNormal","length","Math","sqrt","intersectWithTriangle","p1","q1","r1","p2","q2","r2","tolerance","coplanar","pt1","pt2","surfaceId","n1","n2","s1","dot","s2","dist1","intersect","dist2","abs","pts1","pts2","n1n2","a","b","p","v","cross","normalize","index1","index2","t1","t2","ts1","ts2","i","id1","id2","val1","intersectWithLine","intersection","t","x","val2","t12","t22","Number","isNaN","t11","t21","tt1","tt2","multiplyAccumulate","STATIC","vtkTriangle","publicAPI","model","classHierarchy","push","getCellDimension","tol","pcoords","outObj","subId","MAX_VALUE","betweenPoints","closestPoint","tol2","pt3","points","getPoint","weights","plane","inside","evaluatePosition","evaluation","dist2Pt1Pt2","distance2BetweenPoints","dist2Pt2Pt3","dist2Pt3Pt1","line","newInstance","getPoints","setPoint","intersectLine","pt3Pt1","pt3Pt2","pt3X","j","fabsn","rhs","c1","c2","det","idx","indices","dist2Point","dist2Line1","dist2Line2","closest","closestPoint1","closestPoint2","cp","generalizedProjectPoint","maxComponent","determinant2x2","distanceToLine","lineDistance","distance","evaluateLocation","p0","u3","getParametricDistance","pDist","pDistMax","pc","DEFAULT_VALUES","extend","initialValues","Object","assign"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Common/DataModel/Triangle/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport vtkCell from 'vtk.js/Sources/Common/DataModel/Cell';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkLine from 'vtk.js/Sources/Common/DataModel/Line';\nimport vtkPlane from 'vtk.js/Sources/Common/DataModel/Plane';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction computeNormalDirection(v1, v2, v3, n) {\n  // order is important!!! maintain consistency with triangle vertex order\n  const ax = v3[0] - v2[0];\n  const ay = v3[1] - v2[1];\n  const az = v3[2] - v2[2];\n  const bx = v1[0] - v2[0];\n  const by = v1[1] - v2[1];\n  const bz = v1[2] - v2[2];\n\n  n[0] = ay * bz - az * by;\n  n[1] = az * bx - ax * bz;\n  n[2] = ax * by - ay * bx;\n}\n\nfunction computeNormal(v1, v2, v3, n) {\n  computeNormalDirection(v1, v2, v3, n);\n  const length = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);\n  if (length !== 0.0) {\n    n[0] /= length;\n    n[1] /= length;\n    n[2] /= length;\n  }\n}\n\nfunction intersectWithTriangle(p1, q1, r1, p2, q2, r2, tolerance = 1e-6) {\n  let coplanar = false;\n  const pt1 = [];\n  const pt2 = [];\n  const surfaceId = [];\n\n  const n1 = [];\n  const n2 = [];\n\n  // Compute supporting plane normals.\n  computeNormal(p1, q1, r1, n1);\n  computeNormal(p2, q2, r2, n2);\n  const s1 = -vtkMath.dot(n1, p1);\n  const s2 = -vtkMath.dot(n2, p2);\n\n  // Compute signed distances of points p1, q1, r1 from supporting\n  // plane of second triangle.\n  const dist1 = [\n    vtkMath.dot(n2, p1) + s2,\n    vtkMath.dot(n2, q1) + s2,\n    vtkMath.dot(n2, r1) + s2,\n  ];\n\n  // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n  if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 1!\");\n    return { intersect: false, coplanar, pt1, pt2, surfaceId };\n  }\n  // Do the same for p2, q2, r2 and supporting plane of first\n  // triangle.\n  const dist2 = [\n    vtkMath.dot(n1, p2) + s1,\n    vtkMath.dot(n1, q2) + s1,\n    vtkMath.dot(n1, r2) + s1,\n  ];\n\n  // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n  if (dist2[0] * dist2[1] > tolerance && dist2[0] * dist2[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 2!\");\n    return { intersect: false, coplanar, pt1, pt2, surfaceId };\n  }\n  // Check for coplanarity of the supporting planes.\n  if (\n    Math.abs(n1[0] - n2[0]) < 1e-9 &&\n    Math.abs(n1[1] - n2[1]) < 1e-9 &&\n    Math.abs(n1[2] - n2[2]) < 1e-9 &&\n    Math.abs(s1 - s2) < 1e-9\n  ) {\n    coplanar = true;\n    // vtkDebugMacro(<<\"Coplanar!\");\n    return { intersect: false, coplanar, pt1, pt2, surfaceId };\n  }\n\n  // There are more efficient ways to find the intersection line (if\n  // it exists), but this is clear enough.\n  const pts1 = [p1, q1, r1];\n  const pts2 = [p2, q2, r2];\n\n  // Find line of intersection (L = p + t*v) between two planes.\n  const n1n2 = vtkMath.dot(n1, n2);\n  const a = (s1 - s2 * n1n2) / (n1n2 * n1n2 - 1.0);\n  const b = (s2 - s1 * n1n2) / (n1n2 * n1n2 - 1.0);\n  const p = [\n    a * n1[0] + b * n2[0],\n    a * n1[1] + b * n2[1],\n    a * n1[2] + b * n2[2],\n  ];\n  const v = vtkMath.cross(n1, n2, []);\n  vtkMath.normalize(v);\n\n  let index1 = 0;\n  let index2 = 0;\n  const t1 = [];\n  const t2 = [];\n  let ts1 = 50;\n  let ts2 = 50;\n  for (let i = 0; i < 3; i++) {\n    const id1 = i;\n    const id2 = (i + 1) % 3;\n\n    // Find t coordinate on line of intersection between two planes.\n    const val1 = vtkPlane.intersectWithLine(pts1[id1], pts1[id2], p2, n2);\n    if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {\n      if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {\n        ts1 = index1;\n      }\n      t1[index1++] = vtkMath.dot(val1.x, v) - vtkMath.dot(p, v);\n    }\n\n    const val2 = vtkPlane.intersectWithLine(pts2[id1], pts2[id2], p1, n1);\n    if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {\n      if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {\n        ts2 = index2;\n      }\n      t2[index2++] = vtkMath.dot(val2.x, v) - vtkMath.dot(p, v);\n    }\n  }\n\n  // If the value of the index is greater than 2, the intersecting point\n  // actually is intersected by all three edges. In this case, set the two\n  // edges to the two edges where the intersecting point is not the end point\n  if (index1 > 2) {\n    index1--;\n    // swap\n    const t12 = t1[2];\n    t1[2] = t1[ts1];\n    t1[ts1] = t12;\n  }\n  if (index2 > 2) {\n    index2--;\n    const t22 = t2[2];\n    t2[2] = t2[ts2];\n    t2[ts2] = t22;\n  }\n  // Check if only one edge or all edges intersect the supporting\n  // planes intersection.\n  if (index1 !== 2 || index2 !== 2) {\n    // vtkDebugMacro(<<\"Only one edge intersecting!\");\n    return { intersect: false, coplanar, pt1, pt2, surfaceId };\n  }\n\n  // Check for NaNs\n  if (\n    Number.isNaN(t1[0]) ||\n    Number.isNaN(t1[1]) ||\n    Number.isNaN(t2[0]) ||\n    Number.isNaN(t2[1])\n  ) {\n    // vtkWarningMacro(<<\"NaNs!\");\n    return { intersect: false, coplanar, pt1, pt2, surfaceId };\n  }\n\n  if (t1[0] > t1[1]) {\n    // swap\n    const t11 = t1[1];\n    t1[1] = t1[0];\n    t1[0] = t11;\n  }\n  if (t2[0] > t2[1]) {\n    // swap\n    const t21 = t2[1];\n    t2[1] = t2[0];\n    t2[0] = t21;\n  }\n  // Handle the different interval configuration cases.\n  let tt1;\n  let tt2;\n  if (t1[1] < t2[0] || t2[1] < t1[0]) {\n    // vtkDebugMacro(<<\"No Overlap!\");\n    return { intersect: false, coplanar, pt1, pt2, surfaceId }; // No overlap\n  }\n  if (t1[0] < t2[0]) {\n    if (t1[1] < t2[1]) {\n      // First point on surface 2, second point on surface 1\n      surfaceId[0] = 2;\n      surfaceId[1] = 1;\n      tt1 = t2[0];\n      tt2 = t1[1];\n    } else {\n      // Both points belong to lines on surface 2\n      surfaceId[0] = 2;\n      surfaceId[1] = 2;\n      tt1 = t2[0];\n      tt2 = t2[1];\n    }\n  } // t1[0] >= t2[0]\n  else if (t1[1] < t2[1]) {\n    // Both points belong to lines on surface 1\n    surfaceId[0] = 1;\n    surfaceId[1] = 1;\n    tt1 = t1[0];\n    tt2 = t1[1];\n  } else {\n    // First point on surface 1, second point on surface 2\n    surfaceId[0] = 1;\n    surfaceId[1] = 2;\n    tt1 = t1[0];\n    tt2 = t2[1];\n  }\n\n  // Create actual intersection points.\n  vtkMath.multiplyAccumulate(p, v, tt1, pt1);\n  vtkMath.multiplyAccumulate(p, v, tt2, pt2);\n\n  return { intersect: true, coplanar, pt1, pt2, surfaceId };\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nexport const STATIC = {\n  computeNormalDirection,\n  computeNormal,\n  intersectWithTriangle,\n};\n\n// ----------------------------------------------------------------------------\n// vtkTriangle methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTriangle(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkTriangle');\n\n  publicAPI.getCellDimension = () => 2;\n  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {\n    const outObj = {\n      subId: 0,\n      t: Number.MAX_VALUE,\n      intersect: 0,\n      betweenPoints: false,\n    };\n    pcoords[2] = 0.0;\n    const closestPoint = [];\n    const tol2 = tol * tol;\n\n    // Get normal for triangle\n    const pt1 = [];\n    const pt2 = [];\n    const pt3 = [];\n    model.points.getPoint(0, pt1);\n    model.points.getPoint(1, pt2);\n    model.points.getPoint(2, pt3);\n    const n = [];\n    const weights = [];\n    computeNormal(pt1, pt2, pt3, n);\n    if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {\n      // Intersect plane of triangle with line\n      const plane = vtkPlane.intersectWithLine(p1, p2, pt1, n);\n      outObj.betweenPoints = plane.betweenPoints;\n      outObj.t = plane.t;\n      x[0] = plane.x[0];\n      x[1] = plane.x[1];\n      x[2] = plane.x[2];\n      if (!plane.intersection) {\n        pcoords[0] = 0.0;\n        pcoords[1] = 0.0;\n        outObj.intersect = 0;\n        return outObj;\n      }\n\n      // Evaluate position\n      const inside = publicAPI.evaluatePosition(\n        x,\n        closestPoint,\n        pcoords,\n        weights\n      );\n      if (inside.evaluation >= 0) {\n        if (inside.dist2 <= tol2) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        outObj.intersect = inside.evaluation;\n        return outObj;\n      }\n    }\n\n    // Normals are null, so the triangle is degenerated and\n    // we still need to check intersection between line and\n    // the longest edge.\n    const dist2Pt1Pt2 = vtkMath.distance2BetweenPoints(pt1, pt2);\n    const dist2Pt2Pt3 = vtkMath.distance2BetweenPoints(pt2, pt3);\n    const dist2Pt3Pt1 = vtkMath.distance2BetweenPoints(pt3, pt1);\n    if (!model.line) {\n      model.line = vtkLine.newInstance();\n    }\n    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {\n      model.line.getPoints().setPoint(0, pt1);\n      model.line.getPoints().setPoint(1, pt2);\n    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {\n      model.line.getPoints().setPoint(0, pt2);\n      model.line.getPoints().setPoint(1, pt3);\n    } else {\n      model.line.getPoints().setPoint(0, pt3);\n      model.line.getPoints().setPoint(1, pt1);\n    }\n\n    const intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);\n    outObj.betweenPoints = intersectLine.betweenPoints;\n    outObj.t = intersectLine.t;\n    if (intersectLine.intersect) {\n      const pt3Pt1 = [];\n      const pt3Pt2 = [];\n      const pt3X = [];\n      // Compute r and s manually, using dot and norm.\n      for (let i = 0; i < 3; i++) {\n        pt3Pt1[i] = pt1[i] - pt3[i];\n        pt3Pt2[i] = pt2[i] - pt3[i];\n        pt3X[i] = x[i] - pt3[i];\n      }\n      pcoords[0] = vtkMath.dot(pt3X, pt3Pt1) / dist2Pt3Pt1;\n      pcoords[1] = vtkMath.dot(pt3X, pt3Pt2) / dist2Pt2Pt3;\n      outObj.intersect = 1;\n      return outObj;\n    }\n\n    pcoords[0] = 0.0;\n    pcoords[1] = 0.0;\n    outObj.intersect = 0;\n    return outObj;\n  };\n\n  publicAPI.evaluatePosition = (x, closestPoint, pcoords, weights) => {\n    // will return obj\n    const outObj = { subId: 0, dist2: 0, evaluation: -1 };\n    let i;\n    let j;\n    const pt1 = [];\n    const pt2 = [];\n    const pt3 = [];\n    const n = [];\n    let fabsn;\n    const rhs = [];\n    const c1 = [];\n    const c2 = [];\n    let det = 0;\n    let idx = 0;\n    const indices = [];\n    let dist2Point;\n    let dist2Line1;\n    let dist2Line2;\n    let closest = [];\n    const closestPoint1 = [];\n    const closestPoint2 = [];\n    const cp = [];\n\n    outObj.subId = 0;\n    pcoords[2] = 0.0;\n\n    // Get normal for triangle, only the normal direction is needed, i.e. the\n    // normal need not be normalized (unit length)\n    //\n    model.points.getPoint(1, pt1);\n    model.points.getPoint(2, pt2);\n    model.points.getPoint(0, pt3);\n\n    computeNormalDirection(pt1, pt2, pt3, n);\n\n    // Project point to plane\n    vtkPlane.generalizedProjectPoint(x, pt1, n, cp);\n\n    // Construct matrices.  Since we have over determined system, need to find\n    // which 2 out of 3 equations to use to develop equations. (Any 2 should\n    // work since we've projected point to plane.)\n    let maxComponent = 0.0;\n    for (i = 0; i < 3; i++) {\n      // trying to avoid an expensive call to fabs()\n      if (n[i] < 0) {\n        fabsn = -n[i];\n      } else {\n        fabsn = n[i];\n      }\n      if (fabsn > maxComponent) {\n        maxComponent = fabsn;\n        idx = i;\n      }\n    }\n\n    for (j = 0, i = 0; i < 3; i++) {\n      if (i !== idx) {\n        indices[j++] = i;\n      }\n    }\n\n    for (i = 0; i < 2; i++) {\n      rhs[i] = cp[indices[i]] - pt3[indices[i]];\n      c1[i] = pt1[indices[i]] - pt3[indices[i]];\n      c2[i] = pt2[indices[i]] - pt3[indices[i]];\n    }\n    det = vtkMath.determinant2x2(c1, c2);\n    if (det === 0.0) {\n      pcoords[0] = 0.0;\n      pcoords[1] = 0.0;\n      outObj.evaluation = -1;\n      return outObj;\n    }\n\n    pcoords[0] = vtkMath.determinant2x2(rhs, c2) / det;\n    pcoords[1] = vtkMath.determinant2x2(c1, rhs) / det;\n\n    // Okay, now find closest point to element\n    weights[0] = 1 - (pcoords[0] + pcoords[1]);\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n\n    if (\n      weights[0] >= 0.0 &&\n      weights[0] <= 1.0 &&\n      weights[1] >= 0.0 &&\n      weights[1] <= 1.0 &&\n      weights[2] >= 0.0 &&\n      weights[2] <= 1.0\n    ) {\n      // projection distance\n      if (closestPoint) {\n        outObj.dist2 = vtkMath.distance2BetweenPoints(cp, x);\n        closestPoint[0] = cp[0];\n        closestPoint[1] = cp[1];\n        closestPoint[2] = cp[2];\n      }\n      outObj.evaluation = 1;\n    } else {\n      let t;\n      if (closestPoint) {\n        if (weights[1] < 0.0 && weights[2] < 0.0) {\n          dist2Point = vtkMath.distance2BetweenPoints(x, pt3);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt3, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt3;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[2] < 0.0 && weights[0] < 0.0) {\n          dist2Point = vtkMath.distance2BetweenPoints(x, pt1);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt1;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[1] < 0.0 && weights[0] < 0.0) {\n          dist2Point = vtkMath.distance2BetweenPoints(x, pt2);\n          dist2Line1 = vtkLine.distanceToLine(x, pt2, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt2;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[0] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(\n            x,\n            pt1,\n            pt2,\n            closestPoint\n          );\n          outObj.dist2 = lineDistance.distance;\n        } else if (weights[1] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(\n            x,\n            pt2,\n            pt3,\n            closestPoint\n          );\n          outObj.dist2 = lineDistance.distance;\n        } else if (weights[2] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(\n            x,\n            pt1,\n            pt3,\n            closestPoint\n          );\n          outObj.dist2 = lineDistance.distance;\n        }\n      }\n      outObj.evaluation = 0;\n    }\n\n    return outObj;\n  };\n\n  publicAPI.evaluateLocation = (pcoords, x, weights) => {\n    const p0 = [];\n    const p1 = [];\n    const p2 = [];\n    model.points.getPoint(0, p0);\n    model.points.getPoint(1, p1);\n    model.points.getPoint(2, p2);\n    const u3 = 1.0 - pcoords[0] - pcoords[1];\n\n    for (let i = 0; i < 3; i++) {\n      x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];\n    }\n\n    weights[0] = u3;\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n  };\n\n  publicAPI.getParametricDistance = (pcoords) => {\n    let pDist;\n    let pDistMax = 0.0;\n    const pc = [];\n    pc[0] = pcoords[0];\n    pc[1] = pcoords[1];\n    pc[2] = 1.0 - pcoords[0] - pcoords[1];\n\n    for (let i = 0; i < 3; i++) {\n      if (pc[i] < 0.0) {\n        pDist = -pc[i];\n      } else if (pc[i] > 1.0) {\n        pDist = pc[i] - 1.0;\n      } else {\n        // inside the cell in the parametric direction\n        pDist = 0.0;\n      }\n      if (pDist > pDistMax) {\n        pDistMax = pDist;\n      }\n    }\n    return pDistMax;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  vtkCell.extend(publicAPI, model, initialValues);\n\n  vtkTriangle(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkTriangle');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend, ...STATIC };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}