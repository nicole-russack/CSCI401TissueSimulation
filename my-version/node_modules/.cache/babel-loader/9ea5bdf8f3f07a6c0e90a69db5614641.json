{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport vtkAbstractMapper3D from 'vtk.js/Sources/Rendering/Core/AbstractMapper3D';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nimport vtkImageData from 'vtk.js/Sources/Common/DataModel/ImageData';\nimport vtkLookupTable from 'vtk.js/Sources/Common/Core/LookupTable';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkScalarsToColors from 'vtk.js/Sources/Common/Core/ScalarsToColors/Constants'; // Need to go inside Constants otherwise dependency loop\n\nimport CoincidentTopologyHelper from 'vtk.js/Sources/Rendering/Core/Mapper/CoincidentTopologyHelper';\nimport Constants from 'vtk.js/Sources/Rendering/Core/Mapper/Constants';\nimport vtkDataSet from 'vtk.js/Sources/Common/DataModel/DataSet';\nimport { PassTypes } from 'vtk.js/Sources/Rendering/OpenGL/HardwareSelector/Constants';\nconst {\n  FieldAssociations\n} = vtkDataSet;\nconst {\n  staticOffsetAPI,\n  otherStaticMethods\n} = CoincidentTopologyHelper;\nconst {\n  ColorMode,\n  ScalarMode,\n  GetArray\n} = Constants;\nconst {\n  VectorMode\n} = vtkScalarsToColors;\nconst {\n  VtkDataTypes\n} = vtkDataArray; // ----------------------------------------------------------------------------\n\nfunction notImplemented(method) {\n  return () => macro.vtkErrorMacro(`vtkMapper::${method} - NOT IMPLEMENTED`);\n} // ----------------------------------------------------------------------------\n// vtkMapper methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMapper');\n\n  publicAPI.getBounds = () => {\n    const input = publicAPI.getInputData();\n\n    if (!input) {\n      model.bounds = vtkMath.createUninitializedBounds();\n    } else {\n      if (!model.static) {\n        publicAPI.update();\n      }\n\n      model.bounds = input.getBounds();\n    }\n\n    return model.bounds;\n  };\n\n  publicAPI.setForceCompileOnly = v => {\n    model.forceCompileOnly = v; // make sure we do NOT call modified()\n  };\n\n  publicAPI.createDefaultLookupTable = () => {\n    model.lookupTable = vtkLookupTable.newInstance();\n  };\n\n  publicAPI.getColorModeAsString = () => macro.enumToString(ColorMode, model.colorMode);\n\n  publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);\n\n  publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);\n\n  publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);\n\n  publicAPI.getScalarModeAsString = () => macro.enumToString(ScalarMode, model.scalarMode);\n\n  publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);\n\n  publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);\n\n  publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);\n\n  publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);\n\n  publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);\n\n  publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);\n\n  publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {\n    // make sure we have an input\n    if (!input || !model.scalarVisibility) {\n      return {\n        scalars: null,\n        cellFLag: false\n      };\n    }\n\n    let scalars = null;\n    let cellFlag = false; // get and scalar data according to scalar mode\n\n    if (scalarMode === ScalarMode.DEFAULT) {\n      scalars = input.getPointData().getScalars();\n\n      if (!scalars) {\n        scalars = input.getCellData().getScalars();\n        cellFlag = true;\n      }\n    } else if (scalarMode === ScalarMode.USE_POINT_DATA) {\n      scalars = input.getPointData().getScalars();\n    } else if (scalarMode === ScalarMode.USE_CELL_DATA) {\n      scalars = input.getCellData().getScalars();\n      cellFlag = true;\n    } else if (scalarMode === ScalarMode.USE_POINT_FIELD_DATA) {\n      const pd = input.getPointData();\n\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = pd.getArrayByIndex(arrayId);\n      } else {\n        scalars = pd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_CELL_FIELD_DATA) {\n      const cd = input.getCellData();\n      cellFlag = true;\n\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = cd.getArrayByIndex(arrayId);\n      } else {\n        scalars = cd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_FIELD_DATA) {\n      const fd = input.getFieldData();\n\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = fd.getArrayByIndex(arrayId);\n      } else {\n        scalars = fd.getArrayByName(arrayName);\n      }\n    }\n\n    return {\n      scalars,\n      cellFlag\n    };\n  };\n\n  publicAPI.mapScalars = (input, alpha) => {\n    const scalars = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;\n\n    if (!scalars) {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      model.colorMapColors = null;\n      return;\n    } // we want to only recompute when something has changed\n\n\n    const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;\n    if (model.colorBuildString === toString) return;\n\n    if (!model.useLookupTableScalarRange) {\n      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);\n    } // Decide between texture color or vertex color.\n    // Cell data always uses vertex color.\n    // Only point data can use both texture and vertex coloring.\n\n\n    if (publicAPI.canUseTextureMapForColoring(input)) {\n      publicAPI.mapScalarsToTexture(scalars, alpha);\n    } else {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      const lut = publicAPI.getLookupTable();\n\n      if (lut) {\n        // Ensure that the lookup table is built\n        lut.build();\n        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);\n      }\n    }\n\n    model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;\n  }; //-----------------------------------------------------------------------------\n\n\n  publicAPI.scalarToTextureCoordinate = (scalarValue, // Input scalar\n  rangeMin, // range[0]\n  invRangeWidth) => {\n    // 1/(range[1]-range[0])\n    let texCoordS = 0.5; // Scalar value is arbitrary when NaN\n\n    let texCoordT = 1.0; // 1.0 in t coordinate means NaN\n\n    if (!vtkMath.isNan(scalarValue)) {\n      // 0.0 in t coordinate means not NaN.  So why am I setting it to 0.49?\n      // Because when you are mapping scalars and you have a NaN adjacent to\n      // anything else, the interpolation everywhere should be NaN.  Thus, I\n      // want the NaN color everywhere except right on the non-NaN neighbors.\n      // To simulate this, I set the t coord for the real numbers close to\n      // the threshold so that the interpolation almost immediately looks up\n      // the NaN value.\n      texCoordT = 0.49;\n      texCoordS = (scalarValue - rangeMin) * invRangeWidth; // Some implementations apparently don't handle relatively large\n      // numbers (compared to the range [0.0, 1.0]) very well. In fact,\n      // values above 1122.0f appear to cause texture wrap-around on\n      // some systems even when edge clamping is enabled. Why 1122.0f? I\n      // don't know. For safety, we'll clamp at +/- 1000. This will\n      // result in incorrect images when the texture value should be\n      // above or below 1000, but I don't have a better solution.\n\n      if (texCoordS > 1000.0) {\n        texCoordS = 1000.0;\n      } else if (texCoordS < -1000.0) {\n        texCoordS = -1000.0;\n      }\n    }\n\n    return {\n      texCoordS,\n      texCoordT\n    };\n  }; //-----------------------------------------------------------------------------\n\n\n  publicAPI.createColorTextureCoordinates = (input, output, numScalars, numComps, component, range, tableRange, tableNumberOfColors, useLogScale) => {\n    // We have to change the range used for computing texture\n    // coordinates slightly to accommodate the special above- and\n    // below-range colors that are the first and last texels,\n    // respectively.\n    const scalarTexelWidth = (range[1] - range[0]) / tableNumberOfColors;\n    const paddedRange = [];\n    paddedRange[0] = range[0] - scalarTexelWidth;\n    paddedRange[1] = range[1] + scalarTexelWidth;\n    const invRangeWidth = 1.0 / (paddedRange[1] - paddedRange[0]);\n    const outputV = output.getData();\n    const inputV = input.getData();\n    let count = 0;\n    let outputCount = 0;\n\n    if (component < 0 || component >= numComps) {\n      for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {\n        let sum = 0;\n\n        for (let compIdx = 0; compIdx < numComps; ++compIdx) {\n          sum += inputV[count] * inputV[count];\n          count++;\n        }\n\n        let magnitude = Math.sqrt(sum);\n\n        if (useLogScale) {\n          magnitude = vtkLookupTable.applyLogScale(magnitude, tableRange, range);\n        }\n\n        const outputs = publicAPI.scalarToTextureCoordinate(magnitude, paddedRange[0], invRangeWidth);\n        outputV[outputCount] = outputs.texCoordS;\n        outputV[outputCount + 1] = outputs.texCoordT;\n        outputCount += 2;\n      }\n    } else {\n      count += component;\n\n      for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {\n        let inputValue = inputV[count];\n\n        if (useLogScale) {\n          inputValue = vtkLookupTable.applyLogScale(inputValue, tableRange, range);\n        }\n\n        const outputs = publicAPI.scalarToTextureCoordinate(inputValue, paddedRange[0], invRangeWidth);\n        outputV[outputCount] = outputs.texCoordS;\n        outputV[outputCount + 1] = outputs.texCoordT;\n        outputCount += 2;\n        count += numComps;\n      }\n    }\n  };\n\n  publicAPI.mapScalarsToTexture = (scalars, alpha) => {\n    const range = model.lookupTable.getRange();\n    const useLogScale = model.lookupTable.usingLogScale();\n\n    if (useLogScale) {\n      // convert range to log.\n      vtkLookupTable.getLogRange(range, range);\n    }\n\n    const origAlpha = model.lookupTable.getAlpha(); // Get rid of vertex color array.  Only texture or vertex coloring\n    // can be active at one time.  The existence of the array is the\n    // signal to use that technique.\n\n    model.colorMapColors = null; // If the lookup table has changed, then recreate the color texture map.\n    // Set a new lookup table changes this->MTime.\n\n    if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {\n      model.lookupTable.setAlpha(alpha);\n      model.colorTextureMap = null; // Get the texture map from the lookup table.\n      // Create a dummy ramp of scalars.\n      // In the future, we could extend vtkScalarsToColors.\n\n      model.lookupTable.build();\n      let numberOfColors = model.lookupTable.getNumberOfAvailableColors();\n\n      if (numberOfColors > 4094) {\n        numberOfColors = 4094;\n      }\n\n      numberOfColors += 2;\n      const k = (range[1] - range[0]) / (numberOfColors - 1 - 2);\n      const newArray = new Float64Array(numberOfColors * 2);\n\n      for (let i = 0; i < numberOfColors; ++i) {\n        newArray[i] = range[0] + i * k - k; // minus k to start at below range color\n\n        if (useLogScale) {\n          newArray[i] = 10.0 ** newArray[i];\n        }\n      } // Dimension on NaN.\n\n\n      for (let i = 0; i < numberOfColors; ++i) {\n        newArray[i + numberOfColors] = NaN;\n      }\n\n      model.colorTextureMap = vtkImageData.newInstance();\n      model.colorTextureMap.setExtent(0, numberOfColors - 1, 0, 1, 0, 0);\n      const tmp = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: newArray\n      });\n      model.colorTextureMap.getPointData().setScalars(model.lookupTable.mapScalars(tmp, model.colorMode, 0));\n      model.lookupTable.setAlpha(origAlpha);\n    } // Create new coordinates if necessary.\n    // Need to compare lookup table in case the range has changed.\n\n\n    if (!model.colorCoordinates || publicAPI.getMTime() > model.colorCoordinates.getMTime() || publicAPI.getInputData(0).getMTime() > model.colorCoordinates.getMTime() || model.lookupTable.getMTime() > model.colorCoordinates.getMTime()) {\n      // Get rid of old colors\n      model.colorCoordinates = null; // Now create the color texture coordinates.\n\n      const numComps = scalars.getNumberOfComponents();\n      const num = scalars.getNumberOfTuples(); // const fArray = new FloatArray(num * 2);\n\n      model.colorCoordinates = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        values: new Float32Array(num * 2)\n      });\n      let scalarComponent = model.lookupTable.getVectorComponent(); // Although I like the feature of applying magnitude to single component\n      // scalars, it is not how the old MapScalars for vertex coloring works.\n\n      if (model.lookupTable.getVectorMode() === VectorMode.MAGNITUDE && scalars.getNumberOfComponents() > 1) {\n        scalarComponent = -1;\n      }\n\n      publicAPI.createColorTextureCoordinates(scalars, model.colorCoordinates, num, numComps, scalarComponent, range, model.lookupTable.getRange(), model.colorTextureMap.getPointData().getScalars().getNumberOfTuples() / 2 - 2, useLogScale);\n    }\n  };\n\n  publicAPI.getIsOpaque = () => {\n    const lut = publicAPI.getLookupTable();\n\n    if (lut) {\n      // Ensure that the lookup table is built\n      lut.build();\n      return lut.isOpaque();\n    }\n\n    return true;\n  };\n\n  publicAPI.canUseTextureMapForColoring = input => {\n    if (!model.interpolateScalarsBeforeMapping) {\n      return false; // user doesn't want us to use texture maps at all.\n    } // index color does not use textures\n\n\n    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {\n      return false;\n    }\n\n    const gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);\n    const scalars = gasResult.scalars;\n\n    if (!scalars) {\n      // no scalars on this dataset, we don't care if texture is used at all.\n      return false;\n    }\n\n    if (gasResult.cellFlag) {\n      return false; // cell data colors, don't use textures.\n    }\n\n    if (model.colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || model.colorMode === ColorMode.DIRECT_SCALARS) {\n      // Don't use texture is direct coloring using RGB unsigned chars is\n      // requested.\n      return false;\n    }\n\n    return true;\n  };\n\n  publicAPI.clearColorArrays = () => {\n    model.colorMapColors = null;\n    model.colorCoordinates = null;\n    model.colorTextureMap = null;\n  };\n\n  publicAPI.getLookupTable = () => {\n    if (!model.lookupTable) {\n      publicAPI.createDefaultLookupTable();\n    }\n\n    return model.lookupTable;\n  };\n\n  publicAPI.getMTime = () => {\n    let mt = model.mtime;\n\n    if (model.lookupTable !== null) {\n      const time = model.lookupTable.getMTime();\n      mt = time > mt ? time : mt;\n    }\n\n    return mt;\n  };\n\n  publicAPI.getPrimitiveCount = () => {\n    const input = publicAPI.getInputData();\n    const pcount = {\n      points: input.getPoints().getNumberOfValues() / 3,\n      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),\n      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),\n      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()\n    };\n    return pcount;\n  };\n\n  publicAPI.acquireInvertibleLookupTable = notImplemented('AcquireInvertibleLookupTable');\n  publicAPI.valueToColor = notImplemented('ValueToColor');\n  publicAPI.colorToValue = notImplemented('ColorToValue');\n  publicAPI.useInvertibleColorFor = notImplemented('UseInvertibleColorFor');\n  publicAPI.clearInvertibleColor = notImplemented('ClearInvertibleColor');\n\n  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {\n    /* eslint-disable no-bitwise */\n    if (!selector || !model.selectionWebGLIdsToVTKIds || !model.populateSelectionSettings) {\n      return;\n    }\n\n    const rawLowData = selector.getRawPixelBuffer(PassTypes.ID_LOW24);\n    const rawHighData = selector.getRawPixelBuffer(PassTypes.ID_HIGH24);\n    const currentPass = selector.getCurrentPass();\n    const fieldAssociation = selector.getFieldAssociation();\n    let idMap = null;\n\n    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      idMap = model.selectionWebGLIdsToVTKIds.points;\n    } else if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_CELLS) {\n      idMap = model.selectionWebGLIdsToVTKIds.cells;\n    }\n\n    if (!idMap) {\n      return;\n    }\n\n    pixelOffsets.forEach(pos => {\n      if (currentPass === PassTypes.ID_LOW24) {\n        let inValue = 0;\n\n        if (rawHighData) {\n          inValue += rawHighData[pos];\n          inValue *= 256;\n        }\n\n        inValue += rawLowData[pos + 2];\n        inValue *= 256;\n        inValue += rawLowData[pos + 1];\n        inValue *= 256;\n        inValue += rawLowData[pos];\n        const outValue = idMap[inValue];\n        const lowData = selector.getPixelBuffer(PassTypes.ID_LOW24);\n        lowData[pos] = outValue & 0xff;\n        lowData[pos + 1] = (outValue & 0xff00) >> 8;\n        lowData[pos + 2] = (outValue & 0xff0000) >> 16;\n      } else if (currentPass === PassTypes.ID_HIGH24 && rawHighData) {\n        let inValue = 0;\n        inValue += rawHighData[pos];\n        inValue *= 256;\n        inValue += rawLowData[pos];\n        inValue *= 256;\n        inValue += rawLowData[pos + 1];\n        inValue *= 256;\n        inValue += rawLowData[pos + 2];\n        const outValue = idMap[inValue];\n        const highData = selector.getPixelBuffer(PassTypes.ID_HIGH24);\n        highData[pos] = (outValue & 0xff000000) >> 24;\n      }\n    });\n    /* eslint-enable no-bitwise */\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  colorMapColors: null,\n  // Same as this->Colors\n  static: false,\n  lookupTable: null,\n  scalarVisibility: true,\n  scalarRange: [0, 1],\n  useLookupTableScalarRange: false,\n  colorMode: 0,\n  scalarMode: 0,\n  arrayAccessMode: 1,\n  // By_NAME\n  renderTime: 0,\n  colorByArrayName: null,\n  fieldDataTupleId: -1,\n  populateSelectionSettings: true,\n  selectionWebGLIdsToVTKIds: null,\n  interpolateScalarsBeforeMapping: false,\n  colorCoordinates: null,\n  colorTextureMap: null,\n  forceCompileOnly: 0,\n  useInvertibleColors: false,\n  invertibleScalars: null,\n  viewSpecificProperties: null,\n  customShaderAttributes: []\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkAbstractMapper3D.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['colorCoordinates', 'colorMapColors', 'colorTextureMap']);\n  macro.setGet(publicAPI, model, ['colorByArrayName', 'arrayAccessMode', 'colorMode', 'fieldDataTupleId', 'interpolateScalarsBeforeMapping', 'lookupTable', 'populateSelectionSettings', 'renderTime', 'scalarMode', 'scalarVisibility', 'selectionWebGLIdsToVTKIds', 'static', 'useLookupTableScalarRange', 'viewSpecificProperties', 'customShaderAttributes' // point data array names that will be transferred to the VBO\n  ]);\n  macro.setGetArray(publicAPI, model, ['scalarRange'], 2);\n\n  if (!model.viewSpecificProperties) {\n    model.viewSpecificProperties = {};\n  }\n\n  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model); // Object methods\n\n  vtkMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkMapper'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend,\n  ...staticOffsetAPI,\n  ...otherStaticMethods,\n  ...Constants\n};","map":{"version":3,"names":["macro","vtkAbstractMapper3D","vtkDataArray","vtkImageData","vtkLookupTable","vtkMath","vtkScalarsToColors","CoincidentTopologyHelper","Constants","vtkDataSet","PassTypes","FieldAssociations","staticOffsetAPI","otherStaticMethods","ColorMode","ScalarMode","GetArray","VectorMode","VtkDataTypes","notImplemented","method","vtkErrorMacro","vtkMapper","publicAPI","model","classHierarchy","push","getBounds","input","getInputData","bounds","createUninitializedBounds","static","update","setForceCompileOnly","v","forceCompileOnly","createDefaultLookupTable","lookupTable","newInstance","getColorModeAsString","enumToString","colorMode","setColorModeToDefault","setColorMode","setColorModeToMapScalars","setColorModeToDirectScalars","getScalarModeAsString","scalarMode","setScalarModeToDefault","setScalarMode","setScalarModeToUsePointData","setScalarModeToUseCellData","setScalarModeToUsePointFieldData","setScalarModeToUseCellFieldData","setScalarModeToUseFieldData","getAbstractScalars","arrayAccessMode","arrayId","arrayName","scalarVisibility","scalars","cellFLag","cellFlag","DEFAULT","getPointData","getScalars","getCellData","USE_POINT_DATA","USE_CELL_DATA","USE_POINT_FIELD_DATA","pd","BY_ID","getArrayByIndex","getArrayByName","USE_CELL_FIELD_DATA","cd","USE_FIELD_DATA","fd","getFieldData","mapScalars","alpha","colorByArrayName","colorCoordinates","colorTextureMap","colorMapColors","toString","getMTime","colorBuildString","useLookupTableScalarRange","getLookupTable","setRange","scalarRange","canUseTextureMapForColoring","mapScalarsToTexture","lut","build","fieldDataTupleId","scalarToTextureCoordinate","scalarValue","rangeMin","invRangeWidth","texCoordS","texCoordT","isNan","createColorTextureCoordinates","output","numScalars","numComps","component","range","tableRange","tableNumberOfColors","useLogScale","scalarTexelWidth","paddedRange","outputV","getData","inputV","count","outputCount","scalarIdx","sum","compIdx","magnitude","Math","sqrt","applyLogScale","outputs","inputValue","getRange","usingLogScale","getLogRange","origAlpha","getAlpha","setAlpha","numberOfColors","getNumberOfAvailableColors","k","newArray","Float64Array","i","NaN","setExtent","tmp","numberOfComponents","values","setScalars","getNumberOfComponents","num","getNumberOfTuples","Float32Array","scalarComponent","getVectorComponent","getVectorMode","MAGNITUDE","getIsOpaque","isOpaque","interpolateScalarsBeforeMapping","getIndexedLookup","gasResult","getDataType","UNSIGNED_CHAR","DIRECT_SCALARS","clearColorArrays","mt","mtime","time","getPrimitiveCount","pcount","points","getPoints","getNumberOfValues","verts","getVerts","getNumberOfCells","lines","getLines","triangles","getPolys","acquireInvertibleLookupTable","valueToColor","colorToValue","useInvertibleColorFor","clearInvertibleColor","processSelectorPixelBuffers","selector","pixelOffsets","selectionWebGLIdsToVTKIds","populateSelectionSettings","rawLowData","getRawPixelBuffer","ID_LOW24","rawHighData","ID_HIGH24","currentPass","getCurrentPass","fieldAssociation","getFieldAssociation","idMap","FIELD_ASSOCIATION_POINTS","FIELD_ASSOCIATION_CELLS","cells","forEach","pos","inValue","outValue","lowData","getPixelBuffer","highData","DEFAULT_VALUES","renderTime","useInvertibleColors","invertibleScalars","viewSpecificProperties","customShaderAttributes","extend","initialValues","Object","assign","get","setGet","setGetArray","implementCoincidentTopologyMethods"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/Core/Mapper/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport vtkAbstractMapper3D from 'vtk.js/Sources/Rendering/Core/AbstractMapper3D';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nimport vtkImageData from 'vtk.js/Sources/Common/DataModel/ImageData';\nimport vtkLookupTable from 'vtk.js/Sources/Common/Core/LookupTable';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkScalarsToColors from 'vtk.js/Sources/Common/Core/ScalarsToColors/Constants'; // Need to go inside Constants otherwise dependency loop\n\nimport CoincidentTopologyHelper from 'vtk.js/Sources/Rendering/Core/Mapper/CoincidentTopologyHelper';\nimport Constants from 'vtk.js/Sources/Rendering/Core/Mapper/Constants';\n\nimport vtkDataSet from 'vtk.js/Sources/Common/DataModel/DataSet';\n\nimport { PassTypes } from 'vtk.js/Sources/Rendering/OpenGL/HardwareSelector/Constants';\n\nconst { FieldAssociations } = vtkDataSet;\n\nconst { staticOffsetAPI, otherStaticMethods } = CoincidentTopologyHelper;\n\nconst { ColorMode, ScalarMode, GetArray } = Constants;\nconst { VectorMode } = vtkScalarsToColors;\nconst { VtkDataTypes } = vtkDataArray;\n\n// ----------------------------------------------------------------------------\n\nfunction notImplemented(method) {\n  return () => macro.vtkErrorMacro(`vtkMapper::${method} - NOT IMPLEMENTED`);\n}\n\n// ----------------------------------------------------------------------------\n// vtkMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMapper');\n\n  publicAPI.getBounds = () => {\n    const input = publicAPI.getInputData();\n    if (!input) {\n      model.bounds = vtkMath.createUninitializedBounds();\n    } else {\n      if (!model.static) {\n        publicAPI.update();\n      }\n      model.bounds = input.getBounds();\n    }\n    return model.bounds;\n  };\n\n  publicAPI.setForceCompileOnly = (v) => {\n    model.forceCompileOnly = v;\n    // make sure we do NOT call modified()\n  };\n\n  publicAPI.createDefaultLookupTable = () => {\n    model.lookupTable = vtkLookupTable.newInstance();\n  };\n\n  publicAPI.getColorModeAsString = () =>\n    macro.enumToString(ColorMode, model.colorMode);\n\n  publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);\n  publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);\n  publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);\n\n  publicAPI.getScalarModeAsString = () =>\n    macro.enumToString(ScalarMode, model.scalarMode);\n\n  publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);\n  publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);\n  publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);\n  publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);\n  publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);\n  publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);\n\n  publicAPI.getAbstractScalars = (\n    input,\n    scalarMode,\n    arrayAccessMode,\n    arrayId,\n    arrayName\n  ) => {\n    // make sure we have an input\n    if (!input || !model.scalarVisibility) {\n      return { scalars: null, cellFLag: false };\n    }\n\n    let scalars = null;\n    let cellFlag = false;\n\n    // get and scalar data according to scalar mode\n    if (scalarMode === ScalarMode.DEFAULT) {\n      scalars = input.getPointData().getScalars();\n      if (!scalars) {\n        scalars = input.getCellData().getScalars();\n        cellFlag = true;\n      }\n    } else if (scalarMode === ScalarMode.USE_POINT_DATA) {\n      scalars = input.getPointData().getScalars();\n    } else if (scalarMode === ScalarMode.USE_CELL_DATA) {\n      scalars = input.getCellData().getScalars();\n      cellFlag = true;\n    } else if (scalarMode === ScalarMode.USE_POINT_FIELD_DATA) {\n      const pd = input.getPointData();\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = pd.getArrayByIndex(arrayId);\n      } else {\n        scalars = pd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_CELL_FIELD_DATA) {\n      const cd = input.getCellData();\n      cellFlag = true;\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = cd.getArrayByIndex(arrayId);\n      } else {\n        scalars = cd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_FIELD_DATA) {\n      const fd = input.getFieldData();\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = fd.getArrayByIndex(arrayId);\n      } else {\n        scalars = fd.getArrayByName(arrayName);\n      }\n    }\n\n    return { scalars, cellFlag };\n  };\n\n  publicAPI.mapScalars = (input, alpha) => {\n    const scalars = publicAPI.getAbstractScalars(\n      input,\n      model.scalarMode,\n      model.arrayAccessMode,\n      model.arrayId,\n      model.colorByArrayName\n    ).scalars;\n\n    if (!scalars) {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      model.colorMapColors = null;\n      return;\n    }\n\n    // we want to only recompute when something has changed\n    const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;\n    if (model.colorBuildString === toString) return;\n\n    if (!model.useLookupTableScalarRange) {\n      publicAPI\n        .getLookupTable()\n        .setRange(model.scalarRange[0], model.scalarRange[1]);\n    }\n\n    // Decide between texture color or vertex color.\n    // Cell data always uses vertex color.\n    // Only point data can use both texture and vertex coloring.\n    if (publicAPI.canUseTextureMapForColoring(input)) {\n      publicAPI.mapScalarsToTexture(scalars, alpha);\n    } else {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n\n      const lut = publicAPI.getLookupTable();\n      if (lut) {\n        // Ensure that the lookup table is built\n        lut.build();\n        model.colorMapColors = lut.mapScalars(\n          scalars,\n          model.colorMode,\n          model.fieldDataTupleId\n        );\n      }\n    }\n    model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;\n  };\n\n  //-----------------------------------------------------------------------------\n  publicAPI.scalarToTextureCoordinate = (\n    scalarValue, // Input scalar\n    rangeMin, // range[0]\n    invRangeWidth\n  ) => {\n    // 1/(range[1]-range[0])\n    let texCoordS = 0.5; // Scalar value is arbitrary when NaN\n    let texCoordT = 1.0; // 1.0 in t coordinate means NaN\n    if (!vtkMath.isNan(scalarValue)) {\n      // 0.0 in t coordinate means not NaN.  So why am I setting it to 0.49?\n      // Because when you are mapping scalars and you have a NaN adjacent to\n      // anything else, the interpolation everywhere should be NaN.  Thus, I\n      // want the NaN color everywhere except right on the non-NaN neighbors.\n      // To simulate this, I set the t coord for the real numbers close to\n      // the threshold so that the interpolation almost immediately looks up\n      // the NaN value.\n      texCoordT = 0.49;\n\n      texCoordS = (scalarValue - rangeMin) * invRangeWidth;\n\n      // Some implementations apparently don't handle relatively large\n      // numbers (compared to the range [0.0, 1.0]) very well. In fact,\n      // values above 1122.0f appear to cause texture wrap-around on\n      // some systems even when edge clamping is enabled. Why 1122.0f? I\n      // don't know. For safety, we'll clamp at +/- 1000. This will\n      // result in incorrect images when the texture value should be\n      // above or below 1000, but I don't have a better solution.\n      if (texCoordS > 1000.0) {\n        texCoordS = 1000.0;\n      } else if (texCoordS < -1000.0) {\n        texCoordS = -1000.0;\n      }\n    }\n    return { texCoordS, texCoordT };\n  };\n\n  //-----------------------------------------------------------------------------\n  publicAPI.createColorTextureCoordinates = (\n    input,\n    output,\n    numScalars,\n    numComps,\n    component,\n    range,\n    tableRange,\n    tableNumberOfColors,\n    useLogScale\n  ) => {\n    // We have to change the range used for computing texture\n    // coordinates slightly to accommodate the special above- and\n    // below-range colors that are the first and last texels,\n    // respectively.\n    const scalarTexelWidth = (range[1] - range[0]) / tableNumberOfColors;\n\n    const paddedRange = [];\n    paddedRange[0] = range[0] - scalarTexelWidth;\n    paddedRange[1] = range[1] + scalarTexelWidth;\n    const invRangeWidth = 1.0 / (paddedRange[1] - paddedRange[0]);\n\n    const outputV = output.getData();\n    const inputV = input.getData();\n\n    let count = 0;\n    let outputCount = 0;\n    if (component < 0 || component >= numComps) {\n      for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {\n        let sum = 0;\n        for (let compIdx = 0; compIdx < numComps; ++compIdx) {\n          sum += inputV[count] * inputV[count];\n          count++;\n        }\n        let magnitude = Math.sqrt(sum);\n        if (useLogScale) {\n          magnitude = vtkLookupTable.applyLogScale(\n            magnitude,\n            tableRange,\n            range\n          );\n        }\n        const outputs = publicAPI.scalarToTextureCoordinate(\n          magnitude,\n          paddedRange[0],\n          invRangeWidth\n        );\n        outputV[outputCount] = outputs.texCoordS;\n        outputV[outputCount + 1] = outputs.texCoordT;\n        outputCount += 2;\n      }\n    } else {\n      count += component;\n      for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {\n        let inputValue = inputV[count];\n        if (useLogScale) {\n          inputValue = vtkLookupTable.applyLogScale(\n            inputValue,\n            tableRange,\n            range\n          );\n        }\n        const outputs = publicAPI.scalarToTextureCoordinate(\n          inputValue,\n          paddedRange[0],\n          invRangeWidth\n        );\n        outputV[outputCount] = outputs.texCoordS;\n        outputV[outputCount + 1] = outputs.texCoordT;\n        outputCount += 2;\n        count += numComps;\n      }\n    }\n  };\n\n  publicAPI.mapScalarsToTexture = (scalars, alpha) => {\n    const range = model.lookupTable.getRange();\n    const useLogScale = model.lookupTable.usingLogScale();\n    if (useLogScale) {\n      // convert range to log.\n      vtkLookupTable.getLogRange(range, range);\n    }\n\n    const origAlpha = model.lookupTable.getAlpha();\n\n    // Get rid of vertex color array.  Only texture or vertex coloring\n    // can be active at one time.  The existence of the array is the\n    // signal to use that technique.\n    model.colorMapColors = null;\n\n    // If the lookup table has changed, then recreate the color texture map.\n    // Set a new lookup table changes this->MTime.\n    if (\n      model.colorTextureMap == null ||\n      publicAPI.getMTime() > model.colorTextureMap.getMTime() ||\n      model.lookupTable.getMTime() > model.colorTextureMap.getMTime() ||\n      model.lookupTable.getAlpha() !== alpha\n    ) {\n      model.lookupTable.setAlpha(alpha);\n      model.colorTextureMap = null;\n\n      // Get the texture map from the lookup table.\n      // Create a dummy ramp of scalars.\n      // In the future, we could extend vtkScalarsToColors.\n      model.lookupTable.build();\n      let numberOfColors = model.lookupTable.getNumberOfAvailableColors();\n      if (numberOfColors > 4094) {\n        numberOfColors = 4094;\n      }\n      numberOfColors += 2;\n      const k = (range[1] - range[0]) / (numberOfColors - 1 - 2);\n\n      const newArray = new Float64Array(numberOfColors * 2);\n\n      for (let i = 0; i < numberOfColors; ++i) {\n        newArray[i] = range[0] + i * k - k; // minus k to start at below range color\n        if (useLogScale) {\n          newArray[i] = 10.0 ** newArray[i];\n        }\n      }\n      // Dimension on NaN.\n      for (let i = 0; i < numberOfColors; ++i) {\n        newArray[i + numberOfColors] = NaN;\n      }\n\n      model.colorTextureMap = vtkImageData.newInstance();\n      model.colorTextureMap.setExtent(0, numberOfColors - 1, 0, 1, 0, 0);\n\n      const tmp = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: newArray,\n      });\n\n      model.colorTextureMap\n        .getPointData()\n        .setScalars(model.lookupTable.mapScalars(tmp, model.colorMode, 0));\n      model.lookupTable.setAlpha(origAlpha);\n    }\n\n    // Create new coordinates if necessary.\n    // Need to compare lookup table in case the range has changed.\n    if (\n      !model.colorCoordinates ||\n      publicAPI.getMTime() > model.colorCoordinates.getMTime() ||\n      publicAPI.getInputData(0).getMTime() >\n        model.colorCoordinates.getMTime() ||\n      model.lookupTable.getMTime() > model.colorCoordinates.getMTime()\n    ) {\n      // Get rid of old colors\n      model.colorCoordinates = null;\n\n      // Now create the color texture coordinates.\n      const numComps = scalars.getNumberOfComponents();\n      const num = scalars.getNumberOfTuples();\n\n      // const fArray = new FloatArray(num * 2);\n      model.colorCoordinates = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        values: new Float32Array(num * 2),\n      });\n\n      let scalarComponent = model.lookupTable.getVectorComponent();\n      // Although I like the feature of applying magnitude to single component\n      // scalars, it is not how the old MapScalars for vertex coloring works.\n      if (\n        model.lookupTable.getVectorMode() === VectorMode.MAGNITUDE &&\n        scalars.getNumberOfComponents() > 1\n      ) {\n        scalarComponent = -1;\n      }\n\n      publicAPI.createColorTextureCoordinates(\n        scalars,\n        model.colorCoordinates,\n        num,\n        numComps,\n        scalarComponent,\n        range,\n        model.lookupTable.getRange(),\n        model.colorTextureMap.getPointData().getScalars().getNumberOfTuples() /\n          2 -\n          2,\n        useLogScale\n      );\n    }\n  };\n\n  publicAPI.getIsOpaque = () => {\n    const lut = publicAPI.getLookupTable();\n    if (lut) {\n      // Ensure that the lookup table is built\n      lut.build();\n      return lut.isOpaque();\n    }\n    return true;\n  };\n\n  publicAPI.canUseTextureMapForColoring = (input) => {\n    if (!model.interpolateScalarsBeforeMapping) {\n      return false; // user doesn't want us to use texture maps at all.\n    }\n\n    // index color does not use textures\n    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {\n      return false;\n    }\n\n    const gasResult = publicAPI.getAbstractScalars(\n      input,\n      model.scalarMode,\n      model.arrayAccessMode,\n      model.arrayId,\n      model.colorByArrayName\n    );\n    const scalars = gasResult.scalars;\n\n    if (!scalars) {\n      // no scalars on this dataset, we don't care if texture is used at all.\n      return false;\n    }\n\n    if (gasResult.cellFlag) {\n      return false; // cell data colors, don't use textures.\n    }\n\n    if (\n      (model.colorMode === ColorMode.DEFAULT &&\n        scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR) ||\n      model.colorMode === ColorMode.DIRECT_SCALARS\n    ) {\n      // Don't use texture is direct coloring using RGB unsigned chars is\n      // requested.\n      return false;\n    }\n\n    return true;\n  };\n\n  publicAPI.clearColorArrays = () => {\n    model.colorMapColors = null;\n    model.colorCoordinates = null;\n    model.colorTextureMap = null;\n  };\n\n  publicAPI.getLookupTable = () => {\n    if (!model.lookupTable) {\n      publicAPI.createDefaultLookupTable();\n    }\n    return model.lookupTable;\n  };\n\n  publicAPI.getMTime = () => {\n    let mt = model.mtime;\n    if (model.lookupTable !== null) {\n      const time = model.lookupTable.getMTime();\n      mt = time > mt ? time : mt;\n    }\n    return mt;\n  };\n\n  publicAPI.getPrimitiveCount = () => {\n    const input = publicAPI.getInputData();\n    const pcount = {\n      points: input.getPoints().getNumberOfValues() / 3,\n      verts:\n        input.getVerts().getNumberOfValues() -\n        input.getVerts().getNumberOfCells(),\n      lines:\n        input.getLines().getNumberOfValues() -\n        2 * input.getLines().getNumberOfCells(),\n      triangles:\n        input.getPolys().getNumberOfValues() -\n        3 * input.getPolys().getNumberOfCells(),\n    };\n    return pcount;\n  };\n\n  publicAPI.acquireInvertibleLookupTable = notImplemented(\n    'AcquireInvertibleLookupTable'\n  );\n  publicAPI.valueToColor = notImplemented('ValueToColor');\n  publicAPI.colorToValue = notImplemented('ColorToValue');\n  publicAPI.useInvertibleColorFor = notImplemented('UseInvertibleColorFor');\n  publicAPI.clearInvertibleColor = notImplemented('ClearInvertibleColor');\n\n  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {\n    /* eslint-disable no-bitwise */\n    if (\n      !selector ||\n      !model.selectionWebGLIdsToVTKIds ||\n      !model.populateSelectionSettings\n    ) {\n      return;\n    }\n\n    const rawLowData = selector.getRawPixelBuffer(PassTypes.ID_LOW24);\n    const rawHighData = selector.getRawPixelBuffer(PassTypes.ID_HIGH24);\n    const currentPass = selector.getCurrentPass();\n    const fieldAssociation = selector.getFieldAssociation();\n\n    let idMap = null;\n    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      idMap = model.selectionWebGLIdsToVTKIds.points;\n    } else if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_CELLS) {\n      idMap = model.selectionWebGLIdsToVTKIds.cells;\n    }\n\n    if (!idMap) {\n      return;\n    }\n\n    pixelOffsets.forEach((pos) => {\n      if (currentPass === PassTypes.ID_LOW24) {\n        let inValue = 0;\n        if (rawHighData) {\n          inValue += rawHighData[pos];\n          inValue *= 256;\n        }\n        inValue += rawLowData[pos + 2];\n        inValue *= 256;\n        inValue += rawLowData[pos + 1];\n        inValue *= 256;\n        inValue += rawLowData[pos];\n\n        const outValue = idMap[inValue];\n        const lowData = selector.getPixelBuffer(PassTypes.ID_LOW24);\n        lowData[pos] = outValue & 0xff;\n        lowData[pos + 1] = (outValue & 0xff00) >> 8;\n        lowData[pos + 2] = (outValue & 0xff0000) >> 16;\n      } else if (currentPass === PassTypes.ID_HIGH24 && rawHighData) {\n        let inValue = 0;\n        inValue += rawHighData[pos];\n        inValue *= 256;\n        inValue += rawLowData[pos];\n        inValue *= 256;\n        inValue += rawLowData[pos + 1];\n        inValue *= 256;\n        inValue += rawLowData[pos + 2];\n\n        const outValue = idMap[inValue];\n        const highData = selector.getPixelBuffer(PassTypes.ID_HIGH24);\n        highData[pos] = (outValue & 0xff000000) >> 24;\n      }\n    });\n    /* eslint-enable no-bitwise */\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  colorMapColors: null, // Same as this->Colors\n\n  static: false,\n  lookupTable: null,\n\n  scalarVisibility: true,\n  scalarRange: [0, 1],\n  useLookupTableScalarRange: false,\n\n  colorMode: 0,\n  scalarMode: 0,\n  arrayAccessMode: 1, // By_NAME\n\n  renderTime: 0,\n\n  colorByArrayName: null,\n\n  fieldDataTupleId: -1,\n\n  populateSelectionSettings: true,\n  selectionWebGLIdsToVTKIds: null,\n\n  interpolateScalarsBeforeMapping: false,\n  colorCoordinates: null,\n  colorTextureMap: null,\n\n  forceCompileOnly: 0,\n\n  useInvertibleColors: false,\n  invertibleScalars: null,\n\n  viewSpecificProperties: null,\n\n  customShaderAttributes: [],\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkAbstractMapper3D.extend(publicAPI, model, initialValues);\n\n  macro.get(publicAPI, model, [\n    'colorCoordinates',\n    'colorMapColors',\n    'colorTextureMap',\n  ]);\n  macro.setGet(publicAPI, model, [\n    'colorByArrayName',\n    'arrayAccessMode',\n    'colorMode',\n    'fieldDataTupleId',\n    'interpolateScalarsBeforeMapping',\n    'lookupTable',\n    'populateSelectionSettings',\n    'renderTime',\n    'scalarMode',\n    'scalarVisibility',\n    'selectionWebGLIdsToVTKIds',\n    'static',\n    'useLookupTableScalarRange',\n    'viewSpecificProperties',\n    'customShaderAttributes', // point data array names that will be transferred to the VBO\n  ]);\n  macro.setGetArray(publicAPI, model, ['scalarRange'], 2);\n\n  if (!model.viewSpecificProperties) {\n    model.viewSpecificProperties = {};\n  }\n\n  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);\n\n  // Object methods\n  vtkMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkMapper');\n\n// ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend,\n  ...staticOffsetAPI,\n  ...otherStaticMethods,\n  ...Constants,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}