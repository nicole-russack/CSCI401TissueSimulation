{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport vtkCellArrayBufferObject from 'vtk.js/Sources/Rendering/OpenGL/CellArrayBufferObject';\nimport vtkShaderProgram from 'vtk.js/Sources/Rendering/OpenGL/ShaderProgram';\nimport vtkVertexArrayObject from 'vtk.js/Sources/Rendering/OpenGL/VertexArrayObject';\nimport { Representation } from 'vtk.js/Sources/Rendering/Core/Property/Constants';\nexport const primTypes = {\n  Start: 0,\n  Points: 0,\n  Lines: 1,\n  Tris: 2,\n  TriStrips: 3,\n  TrisEdges: 4,\n  TriStripsEdges: 5,\n  End: 6\n}; // ----------------------------------------------------------------------------\n// vtkOpenGLHelper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLHelper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLHelper');\n\n  publicAPI.setOpenGLRenderWindow = win => {\n    model.context = win.getContext();\n    model.program.setContext(model.context);\n    model.VAO.setOpenGLRenderWindow(win);\n    model.CABO.setOpenGLRenderWindow(win);\n  };\n\n  publicAPI.releaseGraphicsResources = oglwin => {\n    model.VAO.releaseGraphicsResources();\n    model.CABO.releaseGraphicsResources();\n    model.CABO.setElementCount(0);\n  };\n\n  publicAPI.drawArrays = (ren, actor, rep, oglMapper) => {\n    // Are there any entries\n    if (model.CABO.getElementCount()) {\n      // are we drawing edges\n      const mode = publicAPI.getOpenGLMode(rep);\n      const wideLines = publicAPI.haveWideLines(ren, actor);\n      const gl = model.context;\n      const depthMask = gl.getParameter(gl.DEPTH_WRITEMASK);\n\n      if (model.pointPicking) {\n        gl.depthMask(false);\n      }\n\n      const drawingLines = mode === gl.LINES;\n\n      if (drawingLines && wideLines) {\n        publicAPI.updateShaders(ren, actor, oglMapper);\n        gl.drawArraysInstanced(mode, 0, model.CABO.getElementCount(), 2 * Math.ceil(actor.getProperty().getLineWidth()));\n      } else {\n        gl.lineWidth(actor.getProperty().getLineWidth());\n        publicAPI.updateShaders(ren, actor, oglMapper);\n        gl.drawArrays(mode, 0, model.CABO.getElementCount()); // reset the line width\n\n        gl.lineWidth(1);\n      }\n\n      const stride = (mode === gl.POINTS ? 1 : 0) || (mode === gl.LINES ? 2 : 3);\n\n      if (model.pointPicking) {\n        gl.depthMask(depthMask);\n      }\n\n      return model.CABO.getElementCount() / stride;\n    }\n\n    return 0;\n  };\n\n  publicAPI.getOpenGLMode = rep => {\n    if (model.pointPicking) {\n      return model.context.POINTS;\n    }\n\n    const type = model.primitiveType;\n\n    if (rep === Representation.POINTS || type === primTypes.Points) {\n      return model.context.POINTS;\n    }\n\n    if (rep === Representation.WIREFRAME || type === primTypes.Lines || type === primTypes.TrisEdges || type === primTypes.TriStripsEdges) {\n      return model.context.LINES;\n    }\n\n    return model.context.TRIANGLES;\n  };\n\n  publicAPI.haveWideLines = (ren, actor) => {\n    if (actor.getProperty().getLineWidth() > 1.0) {\n      // we have wide lines, but the OpenGL implementation may\n      // actually support them, check the range to see if we\n      // really need have to implement our own wide lines\n      if (model.CABO.getOpenGLRenderWindow()) {\n        if (model.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth() >= actor.getProperty().getLineWidth()) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  publicAPI.getNeedToRebuildShaders = (ren, actor, oglMapper) => {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // mapper modified (lighting complexity)\n    if (oglMapper.getNeedToRebuildShaders(publicAPI, ren, actor) || publicAPI.getProgram() === 0 || publicAPI.getShaderSourceTime().getMTime() < oglMapper.getMTime() || publicAPI.getShaderSourceTime().getMTime() < actor.getMTime()) {\n      return true;\n    }\n\n    return false;\n  };\n\n  publicAPI.updateShaders = (ren, actor, oglMapper) => {\n    // has something changed that would require us to recreate the shader?\n    if (publicAPI.getNeedToRebuildShaders(ren, actor, oglMapper)) {\n      const shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      oglMapper.buildShaders(shaders, ren, actor); // compile and bind the program if needed\n\n      const newShader = model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry); // if the shader changed reinitialize the VAO\n\n      if (newShader !== publicAPI.getProgram()) {\n        publicAPI.setProgram(newShader); // reset the VAO as the shader has changed\n\n        publicAPI.getVAO().releaseGraphicsResources();\n      }\n\n      publicAPI.getShaderSourceTime().modified();\n    } else {\n      model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(publicAPI.getProgram());\n    }\n\n    publicAPI.getVAO().bind();\n    oglMapper.setMapperShaderParameters(publicAPI, ren, actor);\n    oglMapper.setPropertyShaderParameters(publicAPI, ren, actor);\n    oglMapper.setCameraShaderParameters(publicAPI, ren, actor);\n    oglMapper.setLightingShaderParameters(publicAPI, ren, actor);\n    oglMapper.invokeShaderCallbacks(publicAPI, ren, actor);\n  };\n\n  publicAPI.setMapperShaderParameters = (ren, actor, size) => {\n    if (publicAPI.haveWideLines(ren, actor)) {\n      publicAPI.getProgram().setUniform2f('viewportSize', size.usize, size.vsize);\n      const lineWidth = parseFloat(actor.getProperty().getLineWidth());\n      const halfLineWidth = lineWidth / 2.0;\n      publicAPI.getProgram().setUniformf('lineWidthStepSize', lineWidth / Math.ceil(lineWidth));\n      publicAPI.getProgram().setUniformf('halfLineWidth', halfLineWidth);\n    }\n\n    if (model.primitiveType === primTypes.Points || actor.getProperty().getRepresentation() === Representation.POINTS) {\n      publicAPI.getProgram().setUniformf('pointSize', actor.getProperty().getPointSize());\n    } else if (model.pointPicking) {\n      publicAPI.getProgram().setUniformf('pointSize', publicAPI.getPointPickingPrimitiveSize());\n    }\n  };\n\n  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex; // Always set point size in case we need picking\n\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', ['//VTK::PositionVC::Dec', 'uniform float pointSize;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['//VTK::PositionVC::Impl', '  gl_PointSize = pointSize;'], false).result; // for lines, make sure we add the width code\n\n    if (publicAPI.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES && publicAPI.haveWideLines(ren, actor)) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', ['//VTK::PositionVC::Dec', 'uniform vec2 viewportSize;', 'uniform float lineWidthStepSize;', 'uniform float halfLineWidth;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['//VTK::PositionVC::Impl', ' if (halfLineWidth > 0.0)', '   {', '   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;', '   vec4 tmpPos = gl_Position;', '   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;', '   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];', '   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];', '   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);', '   }']).result;\n    }\n\n    shaders.Vertex = VSSource;\n  };\n\n  publicAPI.getPointPickingPrimitiveSize = () => {\n    if (model.primitiveType === primTypes.Points) {\n      return 2;\n    }\n\n    if (model.primitiveType === primTypes.Lines) {\n      return 4;\n    }\n\n    return 6;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  context: null,\n  program: null,\n  shaderSourceTime: null,\n  VAO: null,\n  attributeUpdateTime: null,\n  CABO: null,\n  primitiveType: 0,\n  pointPicking: false\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  model.shaderSourceTime = {};\n  macro.obj(model.shaderSourceTime);\n  model.attributeUpdateTime = {};\n  macro.obj(model.attributeUpdateTime);\n  macro.setGet(publicAPI, model, ['program', 'shaderSourceTime', 'VAO', 'attributeUpdateTime', 'CABO', 'primitiveType', 'pointPicking']);\n  model.program = vtkShaderProgram.newInstance();\n  model.VAO = vtkVertexArrayObject.newInstance();\n  model.CABO = vtkCellArrayBufferObject.newInstance(); // Object methods\n\n  vtkOpenGLHelper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend,\n  primTypes\n};","map":{"version":3,"names":["macro","vtkCellArrayBufferObject","vtkShaderProgram","vtkVertexArrayObject","Representation","primTypes","Start","Points","Lines","Tris","TriStrips","TrisEdges","TriStripsEdges","End","vtkOpenGLHelper","publicAPI","model","classHierarchy","push","setOpenGLRenderWindow","win","context","getContext","program","setContext","VAO","CABO","releaseGraphicsResources","oglwin","setElementCount","drawArrays","ren","actor","rep","oglMapper","getElementCount","mode","getOpenGLMode","wideLines","haveWideLines","gl","depthMask","getParameter","DEPTH_WRITEMASK","pointPicking","drawingLines","LINES","updateShaders","drawArraysInstanced","Math","ceil","getProperty","getLineWidth","lineWidth","stride","POINTS","type","primitiveType","WIREFRAME","TRIANGLES","getOpenGLRenderWindow","getHardwareMaximumLineWidth","getNeedToRebuildShaders","getProgram","getShaderSourceTime","getMTime","shaders","Vertex","Fragment","Geometry","buildShaders","newShader","getShaderCache","readyShaderProgramArray","setProgram","getVAO","modified","readyShaderProgram","bind","setMapperShaderParameters","setPropertyShaderParameters","setCameraShaderParameters","setLightingShaderParameters","invokeShaderCallbacks","size","setUniform2f","usize","vsize","parseFloat","halfLineWidth","setUniformf","getRepresentation","getPointSize","getPointPickingPrimitiveSize","replaceShaderPositionVC","VSSource","substitute","result","DEFAULT_VALUES","shaderSourceTime","attributeUpdateTime","extend","initialValues","Object","assign","obj","setGet","newInstance"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/OpenGL/Helper/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport vtkCellArrayBufferObject from 'vtk.js/Sources/Rendering/OpenGL/CellArrayBufferObject';\nimport vtkShaderProgram from 'vtk.js/Sources/Rendering/OpenGL/ShaderProgram';\nimport vtkVertexArrayObject from 'vtk.js/Sources/Rendering/OpenGL/VertexArrayObject';\n\nimport { Representation } from 'vtk.js/Sources/Rendering/Core/Property/Constants';\n\nexport const primTypes = {\n  Start: 0,\n  Points: 0,\n  Lines: 1,\n  Tris: 2,\n  TriStrips: 3,\n  TrisEdges: 4,\n  TriStripsEdges: 5,\n  End: 6,\n};\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLHelper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLHelper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLHelper');\n\n  publicAPI.setOpenGLRenderWindow = (win) => {\n    model.context = win.getContext();\n    model.program.setContext(model.context);\n    model.VAO.setOpenGLRenderWindow(win);\n    model.CABO.setOpenGLRenderWindow(win);\n  };\n\n  publicAPI.releaseGraphicsResources = (oglwin) => {\n    model.VAO.releaseGraphicsResources();\n    model.CABO.releaseGraphicsResources();\n    model.CABO.setElementCount(0);\n  };\n\n  publicAPI.drawArrays = (ren, actor, rep, oglMapper) => {\n    // Are there any entries\n    if (model.CABO.getElementCount()) {\n      // are we drawing edges\n      const mode = publicAPI.getOpenGLMode(rep);\n      const wideLines = publicAPI.haveWideLines(ren, actor);\n      const gl = model.context;\n      const depthMask = gl.getParameter(gl.DEPTH_WRITEMASK);\n      if (model.pointPicking) {\n        gl.depthMask(false);\n      }\n      const drawingLines = mode === gl.LINES;\n      if (drawingLines && wideLines) {\n        publicAPI.updateShaders(ren, actor, oglMapper);\n        gl.drawArraysInstanced(\n          mode,\n          0,\n          model.CABO.getElementCount(),\n          2 * Math.ceil(actor.getProperty().getLineWidth())\n        );\n      } else {\n        gl.lineWidth(actor.getProperty().getLineWidth());\n        publicAPI.updateShaders(ren, actor, oglMapper);\n        gl.drawArrays(mode, 0, model.CABO.getElementCount());\n        // reset the line width\n        gl.lineWidth(1);\n      }\n      const stride =\n        (mode === gl.POINTS ? 1 : 0) || (mode === gl.LINES ? 2 : 3);\n      if (model.pointPicking) {\n        gl.depthMask(depthMask);\n      }\n      return model.CABO.getElementCount() / stride;\n    }\n    return 0;\n  };\n\n  publicAPI.getOpenGLMode = (rep) => {\n    if (model.pointPicking) {\n      return model.context.POINTS;\n    }\n    const type = model.primitiveType;\n    if (rep === Representation.POINTS || type === primTypes.Points) {\n      return model.context.POINTS;\n    }\n    if (\n      rep === Representation.WIREFRAME ||\n      type === primTypes.Lines ||\n      type === primTypes.TrisEdges ||\n      type === primTypes.TriStripsEdges\n    ) {\n      return model.context.LINES;\n    }\n    return model.context.TRIANGLES;\n  };\n\n  publicAPI.haveWideLines = (ren, actor) => {\n    if (actor.getProperty().getLineWidth() > 1.0) {\n      // we have wide lines, but the OpenGL implementation may\n      // actually support them, check the range to see if we\n      // really need have to implement our own wide lines\n      if (model.CABO.getOpenGLRenderWindow()) {\n        if (\n          model.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth() >=\n          actor.getProperty().getLineWidth()\n        ) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  };\n\n  publicAPI.getNeedToRebuildShaders = (ren, actor, oglMapper) => {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // mapper modified (lighting complexity)\n    if (\n      oglMapper.getNeedToRebuildShaders(publicAPI, ren, actor) ||\n      publicAPI.getProgram() === 0 ||\n      publicAPI.getShaderSourceTime().getMTime() < oglMapper.getMTime() ||\n      publicAPI.getShaderSourceTime().getMTime() < actor.getMTime()\n    ) {\n      return true;\n    }\n    return false;\n  };\n\n  publicAPI.updateShaders = (ren, actor, oglMapper) => {\n    // has something changed that would require us to recreate the shader?\n    if (publicAPI.getNeedToRebuildShaders(ren, actor, oglMapper)) {\n      const shaders = { Vertex: null, Fragment: null, Geometry: null };\n      oglMapper.buildShaders(shaders, ren, actor);\n\n      // compile and bind the program if needed\n      const newShader = model.CABO.getOpenGLRenderWindow()\n        .getShaderCache()\n        .readyShaderProgramArray(\n          shaders.Vertex,\n          shaders.Fragment,\n          shaders.Geometry\n        );\n\n      // if the shader changed reinitialize the VAO\n      if (newShader !== publicAPI.getProgram()) {\n        publicAPI.setProgram(newShader);\n        // reset the VAO as the shader has changed\n        publicAPI.getVAO().releaseGraphicsResources();\n      }\n\n      publicAPI.getShaderSourceTime().modified();\n    } else {\n      model.CABO.getOpenGLRenderWindow()\n        .getShaderCache()\n        .readyShaderProgram(publicAPI.getProgram());\n    }\n\n    publicAPI.getVAO().bind();\n\n    oglMapper.setMapperShaderParameters(publicAPI, ren, actor);\n    oglMapper.setPropertyShaderParameters(publicAPI, ren, actor);\n    oglMapper.setCameraShaderParameters(publicAPI, ren, actor);\n    oglMapper.setLightingShaderParameters(publicAPI, ren, actor);\n\n    oglMapper.invokeShaderCallbacks(publicAPI, ren, actor);\n  };\n\n  publicAPI.setMapperShaderParameters = (ren, actor, size) => {\n    if (publicAPI.haveWideLines(ren, actor)) {\n      publicAPI\n        .getProgram()\n        .setUniform2f('viewportSize', size.usize, size.vsize);\n      const lineWidth = parseFloat(actor.getProperty().getLineWidth());\n      const halfLineWidth = lineWidth / 2.0;\n      publicAPI\n        .getProgram()\n        .setUniformf('lineWidthStepSize', lineWidth / Math.ceil(lineWidth));\n      publicAPI.getProgram().setUniformf('halfLineWidth', halfLineWidth);\n    }\n    if (\n      model.primitiveType === primTypes.Points ||\n      actor.getProperty().getRepresentation() === Representation.POINTS\n    ) {\n      publicAPI\n        .getProgram()\n        .setUniformf('pointSize', actor.getProperty().getPointSize());\n    } else if (model.pointPicking) {\n      publicAPI\n        .getProgram()\n        .setUniformf('pointSize', publicAPI.getPointPickingPrimitiveSize());\n    }\n  };\n\n  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n\n    // Always set point size in case we need picking\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', [\n      '//VTK::PositionVC::Dec',\n      'uniform float pointSize;',\n    ]).result;\n    VSSource = vtkShaderProgram.substitute(\n      VSSource,\n      '//VTK::PositionVC::Impl',\n      ['//VTK::PositionVC::Impl', '  gl_PointSize = pointSize;'],\n      false\n    ).result;\n\n    // for lines, make sure we add the width code\n    if (\n      publicAPI.getOpenGLMode(actor.getProperty().getRepresentation()) ===\n        model.context.LINES &&\n      publicAPI.haveWideLines(ren, actor)\n    ) {\n      VSSource = vtkShaderProgram.substitute(\n        VSSource,\n        '//VTK::PositionVC::Dec',\n        [\n          '//VTK::PositionVC::Dec',\n          'uniform vec2 viewportSize;',\n          'uniform float lineWidthStepSize;',\n          'uniform float halfLineWidth;',\n        ]\n      ).result;\n      VSSource = vtkShaderProgram.substitute(\n        VSSource,\n        '//VTK::PositionVC::Impl',\n        [\n          '//VTK::PositionVC::Impl',\n          ' if (halfLineWidth > 0.0)',\n          '   {',\n          '   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;',\n          '   vec4 tmpPos = gl_Position;',\n          '   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;',\n          '   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];',\n          '   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];',\n          '   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);',\n          '   }',\n        ]\n      ).result;\n    }\n    shaders.Vertex = VSSource;\n  };\n\n  publicAPI.getPointPickingPrimitiveSize = () => {\n    if (model.primitiveType === primTypes.Points) {\n      return 2;\n    }\n    if (model.primitiveType === primTypes.Lines) {\n      return 4;\n    }\n    return 6;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  program: null,\n  shaderSourceTime: null,\n  VAO: null,\n  attributeUpdateTime: null,\n  CABO: null,\n  primitiveType: 0,\n  pointPicking: false,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n\n  model.shaderSourceTime = {};\n  macro.obj(model.shaderSourceTime);\n\n  model.attributeUpdateTime = {};\n  macro.obj(model.attributeUpdateTime);\n\n  macro.setGet(publicAPI, model, [\n    'program',\n    'shaderSourceTime',\n    'VAO',\n    'attributeUpdateTime',\n    'CABO',\n    'primitiveType',\n    'pointPicking',\n  ]);\n\n  model.program = vtkShaderProgram.newInstance();\n  model.VAO = vtkVertexArrayObject.newInstance();\n  model.CABO = vtkCellArrayBufferObject.newInstance();\n\n  // Object methods\n  vtkOpenGLHelper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend, primTypes };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}