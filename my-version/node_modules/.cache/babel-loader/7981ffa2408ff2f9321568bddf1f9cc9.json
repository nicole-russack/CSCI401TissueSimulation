{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport { ObjectType } from 'vtk.js/Sources/Rendering/OpenGL/BufferObject/Constants'; // ----------------------------------------------------------------------------\n// vtkOpenGLVertexArrayObject methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLVertexArrayObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLVertexArrayObject'); // Public API methods\n\n  publicAPI.exposedMethod = () => {// This is a publicly exposed method of this object\n  };\n\n  publicAPI.initialize = () => {\n    model.instancingExtension = null;\n\n    if (!model._openGLRenderWindow.getWebgl2()) {\n      model.instancingExtension = model.context.getExtension('ANGLE_instanced_arrays');\n    }\n\n    if (!model.forceEmulation && model._openGLRenderWindow && model._openGLRenderWindow.getWebgl2()) {\n      model.extension = null;\n      model.supported = true;\n      model.handleVAO = model.context.createVertexArray();\n    } else {\n      model.extension = model.context.getExtension('OES_vertex_array_object'); // Start setting up VAO\n\n      if (!model.forceEmulation && model.extension) {\n        model.supported = true;\n        model.handleVAO = model.extension.createVertexArrayOES();\n      } else {\n        model.supported = false;\n      }\n    }\n  };\n\n  publicAPI.isReady = () => // We either probed and allocated a VAO, or are falling back as the current\n  // hardware does not support VAOs.\n  model.handleVAO !== 0 || model.supported === false;\n\n  publicAPI.bind = () => {\n    // Either simply bind the VAO, or emulate behavior by binding all attributes.\n    if (!publicAPI.isReady()) {\n      publicAPI.initialize();\n    }\n\n    if (publicAPI.isReady() && model.supported) {\n      if (model.extension) {\n        model.extension.bindVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.bindVertexArray(model.handleVAO);\n      }\n    } else if (publicAPI.isReady()) {\n      const gl = model.context;\n\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);\n\n        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          const attrIt = buff.attributes[iatt];\n          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;\n\n          for (let i = 0; i < matrixCount; ++i) {\n            gl.enableVertexAttribArray(attrIt.index + i);\n            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);\n\n            if (attrIt.divisor > 0) {\n              if (model.instancingExtension) {\n                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 1);\n              } else {\n                gl.vertexAttribDivisor(attrIt.index + i, 1);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n  publicAPI.release = () => {\n    // Either simply release the VAO, or emulate behavior by releasing all attributes.\n    if (publicAPI.isReady() && model.supported) {\n      if (model.extension) {\n        model.extension.bindVertexArrayOES(null);\n      } else {\n        model.context.bindVertexArray(null);\n      }\n    } else if (publicAPI.isReady()) {\n      const gl = model.context;\n\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);\n\n        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          const attrIt = buff.attributes[iatt];\n          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;\n\n          for (let i = 0; i < matrixCount; ++i) {\n            gl.enableVertexAttribArray(attrIt.index + i);\n            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);\n\n            if (attrIt.divisor > 0) {\n              if (model.instancingExtension) {\n                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 0);\n              } else {\n                gl.vertexAttribDivisor(attrIt.index + i, 0);\n              }\n            }\n\n            gl.disableVertexAttribArray(attrIt.index + i);\n          }\n        }\n      }\n    }\n  };\n\n  publicAPI.shaderProgramChanged = () => {\n    publicAPI.release();\n\n    if (model.handleVAO) {\n      if (model.extension) {\n        model.extension.deleteVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.deleteVertexArray(model.handleVAO);\n      }\n    }\n\n    model.handleVAO = 0;\n    model.handleProgram = 0;\n  };\n\n  publicAPI.releaseGraphicsResources = () => {\n    publicAPI.shaderProgramChanged();\n\n    if (model.handleVAO) {\n      if (model.extension) {\n        model.extension.deleteVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.deleteVertexArray(model.handleVAO);\n      }\n    }\n\n    model.handleVAO = 0;\n    model.supported = true;\n    model.handleProgram = 0;\n  };\n\n  publicAPI.addAttributeArray = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize) => publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, 0, false);\n\n  publicAPI.addAttributeArrayWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, isMatrix) => {\n    if (!program) {\n      return false;\n    } // Check the program is bound, and the buffer is valid.\n\n\n    if (!program.isBound() || buffer.getHandle() === 0 || buffer.getType() !== ObjectType.ARRAY_BUFFER) {\n      return false;\n    } // Perform initialization if necessary, ensure program matches VAOs.\n\n\n    if (model.handleProgram === 0) {\n      model.handleProgram = program.getHandle();\n    }\n\n    if (!publicAPI.isReady()) {\n      publicAPI.initialize();\n    }\n\n    if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {\n      return false;\n    }\n\n    const gl = model.context;\n    const attribs = {};\n    attribs.name = name;\n    attribs.index = gl.getAttribLocation(model.handleProgram, name);\n    attribs.offset = offset;\n    attribs.stride = stride;\n    attribs.type = elementType;\n    attribs.size = elementTupleSize;\n    attribs.normalize = normalize;\n    attribs.isMatrix = isMatrix;\n    attribs.divisor = divisor;\n\n    if (attribs.Index === -1) {\n      return false;\n    } // Always make the call as even the first use wants the attrib pointer setting\n    // up when we are emulating.\n\n\n    buffer.bind();\n    gl.enableVertexAttribArray(attribs.index);\n    gl.vertexAttribPointer(attribs.index, attribs.size, attribs.type, attribs.normalize, attribs.stride, attribs.offset);\n\n    if (divisor > 0) {\n      if (model.instancingExtension) {\n        model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);\n      } else {\n        gl.vertexAttribDivisor(attribs.index, 1);\n      }\n    }\n\n    attribs.buffer = buffer.getHandle(); // If vertex array objects are not supported then build up our list.\n\n    if (!model.supported) {\n      // find the buffer\n      let buffFound = false;\n\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n\n        if (buff.buffer === attribs.buffer) {\n          buffFound = true;\n          let found = false;\n\n          for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n            const attrIt = buff.attributes[iatt];\n\n            if (attrIt.name === name) {\n              found = true;\n              buff.attributes[iatt] = attribs;\n            }\n          }\n\n          if (!found) {\n            buff.attributes.push(attribs);\n          }\n        }\n      }\n\n      if (!buffFound) {\n        model.buffers.push({\n          buffer: attribs.buffer,\n          attributes: [attribs]\n        });\n      }\n    }\n\n    return true;\n  };\n\n  publicAPI.addAttributeMatrixWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor) => {\n    // bind the first row of values\n    const result = publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, true);\n\n    if (!result) {\n      return result;\n    }\n\n    const gl = model.context;\n    const index = gl.getAttribLocation(model.handleProgram, name);\n\n    for (let i = 1; i < elementTupleSize; i++) {\n      gl.enableVertexAttribArray(index + i);\n      gl.vertexAttribPointer(index + i, elementTupleSize, elementType, normalize, stride, offset + stride * i / elementTupleSize);\n\n      if (divisor > 0) {\n        if (model.instancingExtension) {\n          model.instancingExtension.vertexAttribDivisorANGLE(index + i, 1);\n        } else {\n          gl.vertexAttribDivisor(index + i, 1);\n        }\n      }\n    }\n\n    return true;\n  };\n\n  publicAPI.removeAttributeArray = name => {\n    if (!publicAPI.isReady() || model.handleProgram === 0) {\n      return false;\n    } // If we don't have real VAOs find the entry and remove it too.\n\n\n    if (!model.supported) {\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n\n        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          const attrIt = buff.attributes[iatt];\n\n          if (attrIt.name === name) {\n            buff.attributes.splice(iatt, 1);\n\n            if (!buff.attributes.length) {\n              model.buffers.splice(ibuff, 1);\n            }\n\n            return true;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  publicAPI.setOpenGLRenderWindow = rw => {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  forceEmulation: false,\n  handleVAO: 0,\n  handleProgram: 0,\n  supported: true,\n  buffers: null,\n  context: null // _openGLRenderWindow: null,\n\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Internal objects initialization\n\n  model.buffers = []; // Object methods\n\n  macro.obj(publicAPI, model); // Create get-only macros\n\n  macro.get(publicAPI, model, ['supported']); // Create get-set macros\n\n  macro.setGet(publicAPI, model, ['forceEmulation']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkOpenGLVertexArrayObject(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkOpenGLVertexArrayObject'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["macro","ObjectType","vtkOpenGLVertexArrayObject","publicAPI","model","classHierarchy","push","exposedMethod","initialize","instancingExtension","_openGLRenderWindow","getWebgl2","context","getExtension","forceEmulation","extension","supported","handleVAO","createVertexArray","createVertexArrayOES","isReady","bind","bindVertexArrayOES","bindVertexArray","gl","ibuff","buffers","length","buff","bindBuffer","ARRAY_BUFFER","buffer","iatt","attributes","attrIt","matrixCount","isMatrix","size","i","enableVertexAttribArray","index","vertexAttribPointer","type","normalize","stride","offset","divisor","vertexAttribDivisorANGLE","vertexAttribDivisor","release","disableVertexAttribArray","shaderProgramChanged","deleteVertexArrayOES","deleteVertexArray","handleProgram","releaseGraphicsResources","addAttributeArray","program","name","elementType","elementTupleSize","addAttributeArrayWithDivisor","isBound","getHandle","getType","attribs","getAttribLocation","Index","buffFound","found","addAttributeMatrixWithDivisor","result","removeAttributeArray","splice","setOpenGLRenderWindow","rw","getContext","DEFAULT_VALUES","extend","initialValues","Object","assign","obj","get","setGet","newInstance"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/OpenGL/VertexArrayObject/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport { ObjectType } from 'vtk.js/Sources/Rendering/OpenGL/BufferObject/Constants';\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLVertexArrayObject methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLVertexArrayObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLVertexArrayObject');\n\n  // Public API methods\n  publicAPI.exposedMethod = () => {\n    // This is a publicly exposed method of this object\n  };\n\n  publicAPI.initialize = () => {\n    model.instancingExtension = null;\n    if (!model._openGLRenderWindow.getWebgl2()) {\n      model.instancingExtension = model.context.getExtension(\n        'ANGLE_instanced_arrays'\n      );\n    }\n    if (\n      !model.forceEmulation &&\n      model._openGLRenderWindow &&\n      model._openGLRenderWindow.getWebgl2()\n    ) {\n      model.extension = null;\n      model.supported = true;\n      model.handleVAO = model.context.createVertexArray();\n    } else {\n      model.extension = model.context.getExtension('OES_vertex_array_object');\n      // Start setting up VAO\n      if (!model.forceEmulation && model.extension) {\n        model.supported = true;\n        model.handleVAO = model.extension.createVertexArrayOES();\n      } else {\n        model.supported = false;\n      }\n    }\n  };\n\n  publicAPI.isReady = () =>\n    // We either probed and allocated a VAO, or are falling back as the current\n    // hardware does not support VAOs.\n    model.handleVAO !== 0 || model.supported === false;\n\n  publicAPI.bind = () => {\n    // Either simply bind the VAO, or emulate behavior by binding all attributes.\n    if (!publicAPI.isReady()) {\n      publicAPI.initialize();\n    }\n    if (publicAPI.isReady() && model.supported) {\n      if (model.extension) {\n        model.extension.bindVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.bindVertexArray(model.handleVAO);\n      }\n    } else if (publicAPI.isReady()) {\n      const gl = model.context;\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);\n        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          const attrIt = buff.attributes[iatt];\n          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;\n          for (let i = 0; i < matrixCount; ++i) {\n            gl.enableVertexAttribArray(attrIt.index + i);\n            gl.vertexAttribPointer(\n              attrIt.index + i,\n              attrIt.size,\n              attrIt.type,\n              attrIt.normalize,\n              attrIt.stride,\n              attrIt.offset + (attrIt.stride * i) / attrIt.size\n            );\n            if (attrIt.divisor > 0) {\n              if (model.instancingExtension) {\n                model.instancingExtension.vertexAttribDivisorANGLE(\n                  attrIt.index + i,\n                  1\n                );\n              } else {\n                gl.vertexAttribDivisor(attrIt.index + i, 1);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n  publicAPI.release = () => {\n    // Either simply release the VAO, or emulate behavior by releasing all attributes.\n    if (publicAPI.isReady() && model.supported) {\n      if (model.extension) {\n        model.extension.bindVertexArrayOES(null);\n      } else {\n        model.context.bindVertexArray(null);\n      }\n    } else if (publicAPI.isReady()) {\n      const gl = model.context;\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);\n        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          const attrIt = buff.attributes[iatt];\n          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;\n          for (let i = 0; i < matrixCount; ++i) {\n            gl.enableVertexAttribArray(attrIt.index + i);\n            gl.vertexAttribPointer(\n              attrIt.index + i,\n              attrIt.size,\n              attrIt.type,\n              attrIt.normalize,\n              attrIt.stride,\n              attrIt.offset + (attrIt.stride * i) / attrIt.size\n            );\n            if (attrIt.divisor > 0) {\n              if (model.instancingExtension) {\n                model.instancingExtension.vertexAttribDivisorANGLE(\n                  attrIt.index + i,\n                  0\n                );\n              } else {\n                gl.vertexAttribDivisor(attrIt.index + i, 0);\n              }\n            }\n            gl.disableVertexAttribArray(attrIt.index + i);\n          }\n        }\n      }\n    }\n  };\n\n  publicAPI.shaderProgramChanged = () => {\n    publicAPI.release();\n    if (model.handleVAO) {\n      if (model.extension) {\n        model.extension.deleteVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.deleteVertexArray(model.handleVAO);\n      }\n    }\n    model.handleVAO = 0;\n    model.handleProgram = 0;\n  };\n\n  publicAPI.releaseGraphicsResources = () => {\n    publicAPI.shaderProgramChanged();\n    if (model.handleVAO) {\n      if (model.extension) {\n        model.extension.deleteVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.deleteVertexArray(model.handleVAO);\n      }\n    }\n    model.handleVAO = 0;\n    model.supported = true;\n    model.handleProgram = 0;\n  };\n\n  publicAPI.addAttributeArray = (\n    program,\n    buffer,\n    name,\n    offset,\n    stride,\n    elementType,\n    elementTupleSize,\n    normalize\n  ) =>\n    publicAPI.addAttributeArrayWithDivisor(\n      program,\n      buffer,\n      name,\n      offset,\n      stride,\n      elementType,\n      elementTupleSize,\n      normalize,\n      0,\n      false\n    );\n\n  publicAPI.addAttributeArrayWithDivisor = (\n    program,\n    buffer,\n    name,\n    offset,\n    stride,\n    elementType,\n    elementTupleSize,\n    normalize,\n    divisor,\n    isMatrix\n  ) => {\n    if (!program) {\n      return false;\n    }\n\n    // Check the program is bound, and the buffer is valid.\n    if (\n      !program.isBound() ||\n      buffer.getHandle() === 0 ||\n      buffer.getType() !== ObjectType.ARRAY_BUFFER\n    ) {\n      return false;\n    }\n\n    // Perform initialization if necessary, ensure program matches VAOs.\n    if (model.handleProgram === 0) {\n      model.handleProgram = program.getHandle();\n    }\n    if (!publicAPI.isReady()) {\n      publicAPI.initialize();\n    }\n    if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {\n      return false;\n    }\n\n    const gl = model.context;\n\n    const attribs = {};\n    attribs.name = name;\n    attribs.index = gl.getAttribLocation(model.handleProgram, name);\n    attribs.offset = offset;\n    attribs.stride = stride;\n    attribs.type = elementType;\n    attribs.size = elementTupleSize;\n    attribs.normalize = normalize;\n    attribs.isMatrix = isMatrix;\n    attribs.divisor = divisor;\n\n    if (attribs.Index === -1) {\n      return false;\n    }\n\n    // Always make the call as even the first use wants the attrib pointer setting\n    // up when we are emulating.\n    buffer.bind();\n    gl.enableVertexAttribArray(attribs.index);\n    gl.vertexAttribPointer(\n      attribs.index,\n      attribs.size,\n      attribs.type,\n      attribs.normalize,\n      attribs.stride,\n      attribs.offset\n    );\n\n    if (divisor > 0) {\n      if (model.instancingExtension) {\n        model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);\n      } else {\n        gl.vertexAttribDivisor(attribs.index, 1);\n      }\n    }\n\n    attribs.buffer = buffer.getHandle();\n\n    // If vertex array objects are not supported then build up our list.\n    if (!model.supported) {\n      // find the buffer\n      let buffFound = false;\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        if (buff.buffer === attribs.buffer) {\n          buffFound = true;\n          let found = false;\n          for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n            const attrIt = buff.attributes[iatt];\n            if (attrIt.name === name) {\n              found = true;\n              buff.attributes[iatt] = attribs;\n            }\n          }\n          if (!found) {\n            buff.attributes.push(attribs);\n          }\n        }\n      }\n      if (!buffFound) {\n        model.buffers.push({ buffer: attribs.buffer, attributes: [attribs] });\n      }\n    }\n    return true;\n  };\n\n  publicAPI.addAttributeMatrixWithDivisor = (\n    program,\n    buffer,\n    name,\n    offset,\n    stride,\n    elementType,\n    elementTupleSize,\n    normalize,\n    divisor\n  ) => {\n    // bind the first row of values\n    const result = publicAPI.addAttributeArrayWithDivisor(\n      program,\n      buffer,\n      name,\n      offset,\n      stride,\n      elementType,\n      elementTupleSize,\n      normalize,\n      divisor,\n      true\n    );\n\n    if (!result) {\n      return result;\n    }\n\n    const gl = model.context;\n\n    const index = gl.getAttribLocation(model.handleProgram, name);\n\n    for (let i = 1; i < elementTupleSize; i++) {\n      gl.enableVertexAttribArray(index + i);\n      gl.vertexAttribPointer(\n        index + i,\n        elementTupleSize,\n        elementType,\n        normalize,\n        stride,\n        offset + (stride * i) / elementTupleSize\n      );\n      if (divisor > 0) {\n        if (model.instancingExtension) {\n          model.instancingExtension.vertexAttribDivisorANGLE(index + i, 1);\n        } else {\n          gl.vertexAttribDivisor(index + i, 1);\n        }\n      }\n    }\n\n    return true;\n  };\n\n  publicAPI.removeAttributeArray = (name) => {\n    if (!publicAPI.isReady() || model.handleProgram === 0) {\n      return false;\n    }\n\n    // If we don't have real VAOs find the entry and remove it too.\n    if (!model.supported) {\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          const attrIt = buff.attributes[iatt];\n          if (attrIt.name === name) {\n            buff.attributes.splice(iatt, 1);\n            if (!buff.attributes.length) {\n              model.buffers.splice(ibuff, 1);\n            }\n            return true;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  publicAPI.setOpenGLRenderWindow = (rw) => {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  forceEmulation: false,\n  handleVAO: 0,\n  handleProgram: 0,\n  supported: true,\n  buffers: null,\n  context: null,\n  // _openGLRenderWindow: null,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Internal objects initialization\n  model.buffers = [];\n\n  // Object methods\n  macro.obj(publicAPI, model);\n\n  // Create get-only macros\n  macro.get(publicAPI, model, ['supported']);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['forceEmulation']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkOpenGLVertexArrayObject(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(\n  extend,\n  'vtkOpenGLVertexArrayObject'\n);\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}