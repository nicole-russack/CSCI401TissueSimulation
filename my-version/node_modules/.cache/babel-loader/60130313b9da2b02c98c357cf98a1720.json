{"ast":null,"code":"import vtkShaderProgram from 'vtk.js/Sources/Rendering/OpenGL/ShaderProgram';\n\nfunction implementReplaceShaderCoincidentOffset(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  publicAPI.replaceShaderCoincidentOffset = (shaders, ren, actor) => {\n    const cp = publicAPI.getCoincidentParameters(ren, actor); // if we need an offset handle it here\n    // The value of .000016 is suitable for depth buffers\n    // of at least 16 bit depth. We do not query the depth\n    // right now because we would need some mechanism to\n    // cache the result taking into account FBO changes etc.\n\n    if (cp && (cp.factor !== 0.0 || cp.offset !== 0.0)) {\n      let FSSource = shaders.Fragment;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Coincident::Dec', ['uniform float cfactor;', 'uniform float coffset;']).result;\n\n      if (model.context.getExtension('EXT_frag_depth')) {\n        if (cp.factor !== 0.0) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));', '//VTK::UniformFlow::Impl'], false).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;').result;\n        } else {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;').result;\n        }\n      }\n\n      if (model._openGLRenderWindow.getWebgl2()) {\n        if (cp.factor !== 0.0) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));', '//VTK::UniformFlow::Impl'], false).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;').result;\n        } else {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;').result;\n        }\n      }\n\n      shaders.Fragment = FSSource;\n    }\n  };\n}\n\nexport default {\n  implementReplaceShaderCoincidentOffset\n};","map":{"version":3,"names":["vtkShaderProgram","implementReplaceShaderCoincidentOffset","publicAPI","model","initialValues","replaceShaderCoincidentOffset","shaders","ren","actor","cp","getCoincidentParameters","factor","offset","FSSource","Fragment","substitute","result","context","getExtension","_openGLRenderWindow","getWebgl2"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/OpenGL/ReplacementShaderMapper/index.js"],"sourcesContent":["import vtkShaderProgram from 'vtk.js/Sources/Rendering/OpenGL/ShaderProgram';\n\nfunction implementReplaceShaderCoincidentOffset(\n  publicAPI,\n  model,\n  initialValues = {}\n) {\n  publicAPI.replaceShaderCoincidentOffset = (shaders, ren, actor) => {\n    const cp = publicAPI.getCoincidentParameters(ren, actor);\n\n    // if we need an offset handle it here\n    // The value of .000016 is suitable for depth buffers\n    // of at least 16 bit depth. We do not query the depth\n    // right now because we would need some mechanism to\n    // cache the result taking into account FBO changes etc.\n    if (cp && (cp.factor !== 0.0 || cp.offset !== 0.0)) {\n      let FSSource = shaders.Fragment;\n\n      FSSource = vtkShaderProgram.substitute(\n        FSSource,\n        '//VTK::Coincident::Dec',\n        ['uniform float cfactor;', 'uniform float coffset;']\n      ).result;\n\n      if (model.context.getExtension('EXT_frag_depth')) {\n        if (cp.factor !== 0.0) {\n          FSSource = vtkShaderProgram.substitute(\n            FSSource,\n            '//VTK::UniformFlow::Impl',\n            [\n              'float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));',\n              '//VTK::UniformFlow::Impl',\n            ],\n            false\n          ).result;\n          FSSource = vtkShaderProgram.substitute(\n            FSSource,\n            '//VTK::Depth::Impl',\n            'gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;'\n          ).result;\n        } else {\n          FSSource = vtkShaderProgram.substitute(\n            FSSource,\n            '//VTK::Depth::Impl',\n            'gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;'\n          ).result;\n        }\n      }\n      if (model._openGLRenderWindow.getWebgl2()) {\n        if (cp.factor !== 0.0) {\n          FSSource = vtkShaderProgram.substitute(\n            FSSource,\n            '//VTK::UniformFlow::Impl',\n            [\n              'float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));',\n              '//VTK::UniformFlow::Impl',\n            ],\n            false\n          ).result;\n          FSSource = vtkShaderProgram.substitute(\n            FSSource,\n            '//VTK::Depth::Impl',\n            'gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;'\n          ).result;\n        } else {\n          FSSource = vtkShaderProgram.substitute(\n            FSSource,\n            '//VTK::Depth::Impl',\n            'gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;'\n          ).result;\n        }\n      }\n      shaders.Fragment = FSSource;\n    }\n  };\n}\nexport default { implementReplaceShaderCoincidentOffset };\n"],"mappings":"AAAA,OAAOA,gBAAP,MAA6B,+CAA7B;;AAEA,SAASC,sCAAT,CACEC,SADF,EAEEC,KAFF,EAIE;EAAA,IADAC,aACA,uEADgB,EAChB;;EACAF,SAAS,CAACG,6BAAV,GAA0C,CAACC,OAAD,EAAUC,GAAV,EAAeC,KAAf,KAAyB;IACjE,MAAMC,EAAE,GAAGP,SAAS,CAACQ,uBAAV,CAAkCH,GAAlC,EAAuCC,KAAvC,CAAX,CADiE,CAGjE;IACA;IACA;IACA;IACA;;IACA,IAAIC,EAAE,KAAKA,EAAE,CAACE,MAAH,KAAc,GAAd,IAAqBF,EAAE,CAACG,MAAH,KAAc,GAAxC,CAAN,EAAoD;MAClD,IAAIC,QAAQ,GAAGP,OAAO,CAACQ,QAAvB;MAEAD,QAAQ,GAAGb,gBAAgB,CAACe,UAAjB,CACTF,QADS,EAET,wBAFS,EAGT,CAAC,wBAAD,EAA2B,wBAA3B,CAHS,EAITG,MAJF;;MAMA,IAAIb,KAAK,CAACc,OAAN,CAAcC,YAAd,CAA2B,gBAA3B,CAAJ,EAAkD;QAChD,IAAIT,EAAE,CAACE,MAAH,KAAc,GAAlB,EAAuB;UACrBE,QAAQ,GAAGb,gBAAgB,CAACe,UAAjB,CACTF,QADS,EAET,0BAFS,EAGT,CACE,yEADF,EAEE,0BAFF,CAHS,EAOT,KAPS,EAQTG,MARF;UASAH,QAAQ,GAAGb,gBAAgB,CAACe,UAAjB,CACTF,QADS,EAET,oBAFS,EAGT,uEAHS,EAITG,MAJF;QAKD,CAfD,MAeO;UACLH,QAAQ,GAAGb,gBAAgB,CAACe,UAAjB,CACTF,QADS,EAET,oBAFS,EAGT,sDAHS,EAITG,MAJF;QAKD;MACF;;MACD,IAAIb,KAAK,CAACgB,mBAAN,CAA0BC,SAA1B,EAAJ,EAA2C;QACzC,IAAIX,EAAE,CAACE,MAAH,KAAc,GAAlB,EAAuB;UACrBE,QAAQ,GAAGb,gBAAgB,CAACe,UAAjB,CACTF,QADS,EAET,0BAFS,EAGT,CACE,yEADF,EAEE,0BAFF,CAHS,EAOT,KAPS,EAQTG,MARF;UASAH,QAAQ,GAAGb,gBAAgB,CAACe,UAAjB,CACTF,QADS,EAET,oBAFS,EAGT,oEAHS,EAITG,MAJF;QAKD,CAfD,MAeO;UACLH,QAAQ,GAAGb,gBAAgB,CAACe,UAAjB,CACTF,QADS,EAET,oBAFS,EAGT,mDAHS,EAITG,MAJF;QAKD;MACF;;MACDV,OAAO,CAACQ,QAAR,GAAmBD,QAAnB;IACD;EACF,CAnED;AAoED;;AACD,eAAe;EAAEZ;AAAF,CAAf"},"metadata":{},"sourceType":"module"}