{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport vtkHardwareSelector from 'vtk.js/Sources/Rendering/Core/HardwareSelector';\nimport vtkWebGPUBuffer from 'vtk.js/Sources/Rendering/WebGPU/Buffer';\nimport vtkWebGPUHardwareSelectionPass from 'vtk.js/Sources/Rendering/WebGPU/HardwareSelectionPass';\nimport vtkSelectionNode from 'vtk.js/Sources/Common/DataModel/SelectionNode';\nimport vtkDataSet from 'vtk.js/Sources/Common/DataModel/DataSet';\nconst {\n  SelectionContent,\n  SelectionField\n} = vtkSelectionNode;\nconst {\n  FieldAssociations\n} = vtkDataSet;\nconst {\n  vtkErrorMacro\n} = macro;\n\nfunction getInfoHash(info) {\n  return `${info.propID} ${info.compositeID}`;\n}\n\nfunction convert(xx, yy, buffdata, channel) {\n  const offset = ((buffdata.height - yy - 1) * buffdata.colorBufferWidth + xx) * 4 + channel;\n  return buffdata.colorValues[offset];\n}\n\nfunction getPixelInformationWithData(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {\n  // Base case\n  const maxDist = maxDistance < 0 ? 0 : maxDistance;\n\n  if (maxDist === 0) {\n    outSelectedPosition[0] = inDisplayPosition[0];\n    outSelectedPosition[1] = inDisplayPosition[1];\n\n    if (inDisplayPosition[0] < 0 || inDisplayPosition[0] >= buffdata.width || inDisplayPosition[1] < 0 || inDisplayPosition[1] >= buffdata.height) {\n      return null;\n    }\n\n    const actorid = convert(inDisplayPosition[0], inDisplayPosition[1], buffdata, 0);\n\n    if (actorid <= 0) {\n      // the pixel did not hit any actor.\n      return null;\n    }\n\n    const info = {};\n    info.propID = actorid;\n    let compositeID = convert(inDisplayPosition[0], inDisplayPosition[1], buffdata, 1);\n\n    if (compositeID < 0 || compositeID > 0xffffff) {\n      compositeID = 0;\n    }\n\n    info.compositeID = compositeID;\n\n    if (buffdata.captureZValues) {\n      const offset = (buffdata.height - inDisplayPosition[1] - 1) * buffdata.zbufferBufferWidth + inDisplayPosition[0];\n      info.zValue = buffdata.depthValues[offset];\n      info.zValue = buffdata.webGPURenderer.convertToOpenGLDepth(info.zValue);\n      info.displayPosition = inDisplayPosition;\n    }\n\n    return info;\n  } // Iterate over successively growing boxes.\n  // They recursively call the base case to handle single pixels.\n\n\n  const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];\n  const curPos = [0, 0];\n  let info = getPixelInformationWithData(buffdata, inDisplayPosition, 0, outSelectedPosition);\n\n  if (info) {\n    return info;\n  }\n\n  for (let dist = 1; dist < maxDist; ++dist) {\n    // Vertical sides of box.\n    for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {\n      curPos[1] = y;\n\n      if (dispPos[0] >= dist) {\n        curPos[0] = dispPos[0] - dist;\n        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n\n        if (info) {\n          return info;\n        }\n      }\n\n      curPos[0] = dispPos[0] + dist;\n      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n\n      if (info) {\n        return info;\n      }\n    } // Horizontal sides of box.\n\n\n    for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {\n      curPos[0] = x;\n\n      if (dispPos[1] >= dist) {\n        curPos[1] = dispPos[1] - dist;\n        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n\n        if (info) {\n          return info;\n        }\n      }\n\n      curPos[1] = dispPos[1] + dist;\n      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n\n      if (info) {\n        return info;\n      }\n    }\n  } // nothing hit.\n\n\n  outSelectedPosition[0] = inDisplayPosition[0];\n  outSelectedPosition[1] = inDisplayPosition[1];\n  return null;\n} //-----------------------------------------------------------------------------\n\n\nfunction convertSelection(fieldassociation, dataMap, buffdata) {\n  const sel = [];\n  let count = 0;\n  dataMap.forEach((value, key) => {\n    const child = vtkSelectionNode.newInstance();\n    child.setContentType(SelectionContent.INDICES);\n\n    switch (fieldassociation) {\n      case FieldAssociations.FIELD_ASSOCIATION_CELLS:\n        child.setFieldType(SelectionField.CELL);\n        break;\n\n      case FieldAssociations.FIELD_ASSOCIATION_POINTS:\n        child.setFieldType(SelectionField.POINT);\n        break;\n\n      default:\n        vtkErrorMacro('Unknown field association');\n    }\n\n    child.getProperties().propID = value.info.propID;\n    const wprop = buffdata.webGPURenderer.getPropFromID(value.info.propID);\n    child.getProperties().prop = wprop.getRenderable();\n    child.getProperties().compositeID = value.info.compositeID;\n    child.getProperties().pixelCount = value.pixelCount;\n\n    if (buffdata.captureZValues) {\n      child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];\n      child.getProperties().worldPosition = buffdata.webGPURenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, buffdata.renderer);\n    }\n\n    child.setSelectionList(value.attributeIDs);\n    sel[count] = child;\n    count++;\n  });\n  return sel;\n} //----------------------------------------------------------------------------\n\n\nfunction generateSelectionWithData(buffdata, fx1, fy1, fx2, fy2) {\n  const x1 = Math.floor(fx1);\n  const y1 = Math.floor(fy1);\n  const x2 = Math.floor(fx2);\n  const y2 = Math.floor(fy2);\n  const dataMap = new Map();\n  const outSelectedPosition = [0, 0];\n\n  for (let yy = y1; yy <= y2; yy++) {\n    for (let xx = x1; xx <= x2; xx++) {\n      const pos = [xx, yy];\n      const info = getPixelInformationWithData(buffdata, pos, 0, outSelectedPosition);\n\n      if (info) {\n        const hash = getInfoHash(info);\n\n        if (!dataMap.has(hash)) {\n          dataMap.set(hash, {\n            info,\n            pixelCount: 1,\n            attributeIDs: [info.attributeID]\n          });\n        } else {\n          const dmv = dataMap.get(hash);\n          dmv.pixelCount++;\n\n          if (buffdata.captureZValues) {\n            if (info.zValue < dmv.info.zValue) {\n              dmv.info = info;\n            }\n          }\n\n          if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {\n            dmv.attributeIDs.push(info.attributeID);\n          }\n        }\n      }\n    }\n  }\n\n  return convertSelection(buffdata.fieldAssociation, dataMap, buffdata);\n} // ----------------------------------------------------------------------------\n// vtkWebGPUHardwareSelector methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkWebGPUHardwareSelector(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUHardwareSelector'); //----------------------------------------------------------------------------\n\n  publicAPI.endSelection = () => {\n    model.WebGPURenderer.setSelector(null);\n  }; //----------------------------------------------------------------------------\n  // note we ignore the x,y arguments as WebGPU has to do buffer copies\n  // of the entire depth bufer. We could realloc hardware selection textures\n  // based on the passed in size etc but it gets messy so for now we always\n  // render the full size window and copy it to the buffers.\n\n\n  publicAPI.getSourceDataAsync = async renderer => {\n    if (!renderer || !model.WebGPURenderWindow) {\n      vtkErrorMacro('Renderer and view must be set before calling Select.');\n      return false;\n    } // todo revisit making selection part of core\n    // then we can do this in core\n\n\n    model.WebGPURenderWindow.getRenderable().preRender();\n\n    if (!model.WebGPURenderWindow.getInitialized()) {\n      model.WebGPURenderWindow.initialize();\n      await new Promise(resolve => {\n        model.WebGPURenderWindow.onInitialized(resolve);\n      });\n    }\n\n    const webGPURenderer = model.WebGPURenderWindow.getViewNodeFor(renderer);\n\n    if (!webGPURenderer) {\n      return false;\n    } // Initialize renderer for selection.\n    // change the renderer's background to black, which will indicate a miss\n\n\n    const originalSuppress = webGPURenderer.getSuppressClear();\n    webGPURenderer.setSuppressClear(true);\n\n    model._selectionPass.traverse(model.WebGPURenderWindow, webGPURenderer); // restore original background\n\n\n    webGPURenderer.setSuppressClear(originalSuppress);\n    const device = model.WebGPURenderWindow.getDevice();\n\n    const texture = model._selectionPass.getColorTexture();\n\n    const depthTexture = model._selectionPass.getDepthTexture(); // as this is async we really don't want to store things in\n    // the class as multiple calls may start before resolving\n    // so anything specific to this request gets put into the\n    // result object (by value in most cases)\n\n\n    const result = {\n      area: [0, 0, texture.getWidth() - 1, texture.getHeight() - 1],\n      captureZValues: model.captureZValues,\n      fieldAssociation: model.fieldAssociation,\n      renderer,\n      webGPURenderer,\n      webGPURenderWindow: model.WebGPURenderWindow,\n      width: texture.getWidth(),\n      height: texture.getHeight()\n    }; // must be a multiple of 256 bytes, so 16 texels with rgba32uint\n\n    result.colorBufferWidth = 16 * Math.floor((result.width + 15) / 16);\n    result.colorBufferSizeInBytes = result.colorBufferWidth * result.height * 4 * 4;\n    const colorBuffer = vtkWebGPUBuffer.newInstance({\n      label: 'hardwareSelectColorBuffer'\n    });\n    colorBuffer.setDevice(device);\n    /* eslint-disable no-bitwise */\n\n    /* eslint-disable no-undef */\n\n    colorBuffer.create(result.colorBufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);\n    /* eslint-enable no-bitwise */\n\n    /* eslint-enable no-undef */\n\n    const cmdEnc = model.WebGPURenderWindow.getCommandEncoder();\n    cmdEnc.copyTextureToBuffer({\n      texture: texture.getHandle()\n    }, {\n      buffer: colorBuffer.getHandle(),\n      bytesPerRow: 16 * result.colorBufferWidth,\n      rowsPerImage: result.height\n    }, {\n      width: result.width,\n      height: result.height,\n      depthOrArrayLayers: 1\n    });\n    let zbuffer;\n\n    if (model.captureZValues) {\n      result.zbufferBufferWidth = 64 * Math.floor((result.width + 63) / 64);\n      zbuffer = vtkWebGPUBuffer.newInstance({\n        label: 'hardwareSelectDepthBuffer'\n      });\n      zbuffer.setDevice(device);\n      result.zbufferSizeInBytes = result.height * result.zbufferBufferWidth * 4;\n      /* eslint-disable no-bitwise */\n\n      /* eslint-disable no-undef */\n\n      zbuffer.create(result.zbufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);\n      /* eslint-enable no-bitwise */\n\n      /* eslint-enable no-undef */\n\n      cmdEnc.copyTextureToBuffer({\n        texture: depthTexture.getHandle(),\n        aspect: 'depth-only'\n      }, {\n        buffer: zbuffer.getHandle(),\n        bytesPerRow: 4 * result.zbufferBufferWidth,\n        rowsPerImage: result.height\n      }, {\n        width: result.width,\n        height: result.height,\n        depthOrArrayLayers: 1\n      });\n    }\n\n    device.submitCommandEncoder(cmdEnc);\n    /* eslint-disable no-undef */\n\n    const cLoad = colorBuffer.mapAsync(GPUMapMode.READ);\n\n    if (model.captureZValues) {\n      const zLoad = zbuffer.mapAsync(GPUMapMode.READ);\n      await Promise.all([cLoad, zLoad]);\n      result.depthValues = new Float32Array(zbuffer.getMappedRange().slice());\n      zbuffer.unmap();\n    } else {\n      await cLoad;\n    }\n    /* eslint-enable no-undef */\n\n\n    result.colorValues = new Uint32Array(colorBuffer.getMappedRange().slice());\n    colorBuffer.unmap();\n\n    result.generateSelection = (fx1, fy1, fx2, fy2) => generateSelectionWithData(result, fx1, fy1, fx2, fy2);\n\n    return result;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  WebGPURenderWindow: null\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  vtkHardwareSelector.extend(publicAPI, model, initialValues);\n  model._selectionPass = vtkWebGPUHardwareSelectionPass.newInstance();\n  macro.setGet(publicAPI, model, ['WebGPURenderWindow']); // Object methods\n\n  vtkWebGPUHardwareSelector(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkWebGPUHardwareSelector'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["macro","vtkHardwareSelector","vtkWebGPUBuffer","vtkWebGPUHardwareSelectionPass","vtkSelectionNode","vtkDataSet","SelectionContent","SelectionField","FieldAssociations","vtkErrorMacro","getInfoHash","info","propID","compositeID","convert","xx","yy","buffdata","channel","offset","height","colorBufferWidth","colorValues","getPixelInformationWithData","inDisplayPosition","maxDistance","outSelectedPosition","maxDist","width","actorid","captureZValues","zbufferBufferWidth","zValue","depthValues","webGPURenderer","convertToOpenGLDepth","displayPosition","dispPos","curPos","dist","y","x","convertSelection","fieldassociation","dataMap","sel","count","forEach","value","key","child","newInstance","setContentType","INDICES","FIELD_ASSOCIATION_CELLS","setFieldType","CELL","FIELD_ASSOCIATION_POINTS","POINT","getProperties","wprop","getPropFromID","prop","getRenderable","pixelCount","worldPosition","webGPURenderWindow","displayToWorld","renderer","setSelectionList","attributeIDs","generateSelectionWithData","fx1","fy1","fx2","fy2","x1","Math","floor","y1","x2","y2","Map","pos","hash","has","set","attributeID","dmv","get","indexOf","push","fieldAssociation","vtkWebGPUHardwareSelector","publicAPI","model","classHierarchy","endSelection","WebGPURenderer","setSelector","getSourceDataAsync","WebGPURenderWindow","preRender","getInitialized","initialize","Promise","resolve","onInitialized","getViewNodeFor","originalSuppress","getSuppressClear","setSuppressClear","_selectionPass","traverse","device","getDevice","texture","getColorTexture","depthTexture","getDepthTexture","result","area","getWidth","getHeight","colorBufferSizeInBytes","colorBuffer","label","setDevice","create","GPUBufferUsage","MAP_READ","COPY_DST","cmdEnc","getCommandEncoder","copyTextureToBuffer","getHandle","buffer","bytesPerRow","rowsPerImage","depthOrArrayLayers","zbuffer","zbufferSizeInBytes","aspect","submitCommandEncoder","cLoad","mapAsync","GPUMapMode","READ","zLoad","all","Float32Array","getMappedRange","slice","unmap","Uint32Array","generateSelection","DEFAULT_VALUES","extend","initialValues","Object","assign","setGet"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/WebGPU/HardwareSelector/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport vtkHardwareSelector from 'vtk.js/Sources/Rendering/Core/HardwareSelector';\nimport vtkWebGPUBuffer from 'vtk.js/Sources/Rendering/WebGPU/Buffer';\nimport vtkWebGPUHardwareSelectionPass from 'vtk.js/Sources/Rendering/WebGPU/HardwareSelectionPass';\nimport vtkSelectionNode from 'vtk.js/Sources/Common/DataModel/SelectionNode';\nimport vtkDataSet from 'vtk.js/Sources/Common/DataModel/DataSet';\n\nconst { SelectionContent, SelectionField } = vtkSelectionNode;\nconst { FieldAssociations } = vtkDataSet;\nconst { vtkErrorMacro } = macro;\n\nfunction getInfoHash(info) {\n  return `${info.propID} ${info.compositeID}`;\n}\n\nfunction convert(xx, yy, buffdata, channel) {\n  const offset =\n    ((buffdata.height - yy - 1) * buffdata.colorBufferWidth + xx) * 4 + channel;\n  return buffdata.colorValues[offset];\n}\n\nfunction getPixelInformationWithData(\n  buffdata,\n  inDisplayPosition,\n  maxDistance,\n  outSelectedPosition\n) {\n  // Base case\n  const maxDist = maxDistance < 0 ? 0 : maxDistance;\n  if (maxDist === 0) {\n    outSelectedPosition[0] = inDisplayPosition[0];\n    outSelectedPosition[1] = inDisplayPosition[1];\n    if (\n      inDisplayPosition[0] < 0 ||\n      inDisplayPosition[0] >= buffdata.width ||\n      inDisplayPosition[1] < 0 ||\n      inDisplayPosition[1] >= buffdata.height\n    ) {\n      return null;\n    }\n\n    const actorid = convert(\n      inDisplayPosition[0],\n      inDisplayPosition[1],\n      buffdata,\n      0\n    );\n\n    if (actorid <= 0) {\n      // the pixel did not hit any actor.\n      return null;\n    }\n\n    const info = {};\n\n    info.propID = actorid;\n\n    let compositeID = convert(\n      inDisplayPosition[0],\n      inDisplayPosition[1],\n      buffdata,\n      1\n    );\n    if (compositeID < 0 || compositeID > 0xffffff) {\n      compositeID = 0;\n    }\n    info.compositeID = compositeID;\n\n    if (buffdata.captureZValues) {\n      const offset =\n        (buffdata.height - inDisplayPosition[1] - 1) *\n          buffdata.zbufferBufferWidth +\n        inDisplayPosition[0];\n      info.zValue = buffdata.depthValues[offset];\n      info.zValue = buffdata.webGPURenderer.convertToOpenGLDepth(info.zValue);\n      info.displayPosition = inDisplayPosition;\n    }\n    return info;\n  }\n\n  // Iterate over successively growing boxes.\n  // They recursively call the base case to handle single pixels.\n  const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];\n  const curPos = [0, 0];\n  let info = getPixelInformationWithData(\n    buffdata,\n    inDisplayPosition,\n    0,\n    outSelectedPosition\n  );\n  if (info) {\n    return info;\n  }\n  for (let dist = 1; dist < maxDist; ++dist) {\n    // Vertical sides of box.\n    for (\n      let y = dispPos[1] > dist ? dispPos[1] - dist : 0;\n      y <= dispPos[1] + dist;\n      ++y\n    ) {\n      curPos[1] = y;\n      if (dispPos[0] >= dist) {\n        curPos[0] = dispPos[0] - dist;\n        info = getPixelInformationWithData(\n          buffdata,\n          curPos,\n          0,\n          outSelectedPosition\n        );\n        if (info) {\n          return info;\n        }\n      }\n      curPos[0] = dispPos[0] + dist;\n      info = getPixelInformationWithData(\n        buffdata,\n        curPos,\n        0,\n        outSelectedPosition\n      );\n      if (info) {\n        return info;\n      }\n    }\n    // Horizontal sides of box.\n    for (\n      let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0;\n      x <= dispPos[0] + (dist - 1);\n      ++x\n    ) {\n      curPos[0] = x;\n      if (dispPos[1] >= dist) {\n        curPos[1] = dispPos[1] - dist;\n        info = getPixelInformationWithData(\n          buffdata,\n          curPos,\n          0,\n          outSelectedPosition\n        );\n        if (info) {\n          return info;\n        }\n      }\n      curPos[1] = dispPos[1] + dist;\n      info = getPixelInformationWithData(\n        buffdata,\n        curPos,\n        0,\n        outSelectedPosition\n      );\n      if (info) {\n        return info;\n      }\n    }\n  }\n\n  // nothing hit.\n  outSelectedPosition[0] = inDisplayPosition[0];\n  outSelectedPosition[1] = inDisplayPosition[1];\n  return null;\n}\n\n//-----------------------------------------------------------------------------\nfunction convertSelection(fieldassociation, dataMap, buffdata) {\n  const sel = [];\n\n  let count = 0;\n  dataMap.forEach((value, key) => {\n    const child = vtkSelectionNode.newInstance();\n    child.setContentType(SelectionContent.INDICES);\n    switch (fieldassociation) {\n      case FieldAssociations.FIELD_ASSOCIATION_CELLS:\n        child.setFieldType(SelectionField.CELL);\n        break;\n      case FieldAssociations.FIELD_ASSOCIATION_POINTS:\n        child.setFieldType(SelectionField.POINT);\n        break;\n      default:\n        vtkErrorMacro('Unknown field association');\n    }\n    child.getProperties().propID = value.info.propID;\n    const wprop = buffdata.webGPURenderer.getPropFromID(value.info.propID);\n    child.getProperties().prop = wprop.getRenderable();\n    child.getProperties().compositeID = value.info.compositeID;\n    child.getProperties().pixelCount = value.pixelCount;\n    if (buffdata.captureZValues) {\n      child.getProperties().displayPosition = [\n        value.info.displayPosition[0],\n        value.info.displayPosition[1],\n        value.info.zValue,\n      ];\n      child.getProperties().worldPosition =\n        buffdata.webGPURenderWindow.displayToWorld(\n          value.info.displayPosition[0],\n          value.info.displayPosition[1],\n          value.info.zValue,\n          buffdata.renderer\n        );\n    }\n\n    child.setSelectionList(value.attributeIDs);\n    sel[count] = child;\n    count++;\n  });\n\n  return sel;\n}\n\n//----------------------------------------------------------------------------\nfunction generateSelectionWithData(buffdata, fx1, fy1, fx2, fy2) {\n  const x1 = Math.floor(fx1);\n  const y1 = Math.floor(fy1);\n  const x2 = Math.floor(fx2);\n  const y2 = Math.floor(fy2);\n\n  const dataMap = new Map();\n\n  const outSelectedPosition = [0, 0];\n\n  for (let yy = y1; yy <= y2; yy++) {\n    for (let xx = x1; xx <= x2; xx++) {\n      const pos = [xx, yy];\n      const info = getPixelInformationWithData(\n        buffdata,\n        pos,\n        0,\n        outSelectedPosition\n      );\n      if (info) {\n        const hash = getInfoHash(info);\n        if (!dataMap.has(hash)) {\n          dataMap.set(hash, {\n            info,\n            pixelCount: 1,\n            attributeIDs: [info.attributeID],\n          });\n        } else {\n          const dmv = dataMap.get(hash);\n          dmv.pixelCount++;\n          if (buffdata.captureZValues) {\n            if (info.zValue < dmv.info.zValue) {\n              dmv.info = info;\n            }\n          }\n          if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {\n            dmv.attributeIDs.push(info.attributeID);\n          }\n        }\n      }\n    }\n  }\n  return convertSelection(buffdata.fieldAssociation, dataMap, buffdata);\n}\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUHardwareSelector methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUHardwareSelector(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUHardwareSelector');\n\n  //----------------------------------------------------------------------------\n  publicAPI.endSelection = () => {\n    model.WebGPURenderer.setSelector(null);\n  };\n\n  //----------------------------------------------------------------------------\n  // note we ignore the x,y arguments as WebGPU has to do buffer copies\n  // of the entire depth bufer. We could realloc hardware selection textures\n  // based on the passed in size etc but it gets messy so for now we always\n  // render the full size window and copy it to the buffers.\n  publicAPI.getSourceDataAsync = async (renderer) => {\n    if (!renderer || !model.WebGPURenderWindow) {\n      vtkErrorMacro('Renderer and view must be set before calling Select.');\n      return false;\n    }\n\n    // todo revisit making selection part of core\n    // then we can do this in core\n    model.WebGPURenderWindow.getRenderable().preRender();\n\n    if (!model.WebGPURenderWindow.getInitialized()) {\n      model.WebGPURenderWindow.initialize();\n      await new Promise((resolve) => {\n        model.WebGPURenderWindow.onInitialized(resolve);\n      });\n    }\n\n    const webGPURenderer = model.WebGPURenderWindow.getViewNodeFor(renderer);\n\n    if (!webGPURenderer) {\n      return false;\n    }\n\n    // Initialize renderer for selection.\n    // change the renderer's background to black, which will indicate a miss\n    const originalSuppress = webGPURenderer.getSuppressClear();\n    webGPURenderer.setSuppressClear(true);\n\n    model._selectionPass.traverse(model.WebGPURenderWindow, webGPURenderer);\n\n    // restore original background\n    webGPURenderer.setSuppressClear(originalSuppress);\n\n    const device = model.WebGPURenderWindow.getDevice();\n    const texture = model._selectionPass.getColorTexture();\n    const depthTexture = model._selectionPass.getDepthTexture();\n\n    // as this is async we really don't want to store things in\n    // the class as multiple calls may start before resolving\n    // so anything specific to this request gets put into the\n    // result object (by value in most cases)\n    const result = {\n      area: [0, 0, texture.getWidth() - 1, texture.getHeight() - 1],\n      captureZValues: model.captureZValues,\n      fieldAssociation: model.fieldAssociation,\n      renderer,\n      webGPURenderer,\n      webGPURenderWindow: model.WebGPURenderWindow,\n      width: texture.getWidth(),\n      height: texture.getHeight(),\n    };\n\n    // must be a multiple of 256 bytes, so 16 texels with rgba32uint\n    result.colorBufferWidth = 16 * Math.floor((result.width + 15) / 16);\n    result.colorBufferSizeInBytes =\n      result.colorBufferWidth * result.height * 4 * 4;\n    const colorBuffer = vtkWebGPUBuffer.newInstance({\n      label: 'hardwareSelectColorBuffer',\n    });\n    colorBuffer.setDevice(device);\n    /* eslint-disable no-bitwise */\n    /* eslint-disable no-undef */\n    colorBuffer.create(\n      result.colorBufferSizeInBytes,\n      GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n    );\n    /* eslint-enable no-bitwise */\n    /* eslint-enable no-undef */\n\n    const cmdEnc = model.WebGPURenderWindow.getCommandEncoder();\n    cmdEnc.copyTextureToBuffer(\n      {\n        texture: texture.getHandle(),\n      },\n      {\n        buffer: colorBuffer.getHandle(),\n        bytesPerRow: 16 * result.colorBufferWidth,\n        rowsPerImage: result.height,\n      },\n      {\n        width: result.width,\n        height: result.height,\n        depthOrArrayLayers: 1,\n      }\n    );\n\n    let zbuffer;\n    if (model.captureZValues) {\n      result.zbufferBufferWidth = 64 * Math.floor((result.width + 63) / 64);\n      zbuffer = vtkWebGPUBuffer.newInstance({\n        label: 'hardwareSelectDepthBuffer',\n      });\n      zbuffer.setDevice(device);\n      result.zbufferSizeInBytes = result.height * result.zbufferBufferWidth * 4;\n      /* eslint-disable no-bitwise */\n      /* eslint-disable no-undef */\n      zbuffer.create(\n        result.zbufferSizeInBytes,\n        GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n      );\n      /* eslint-enable no-bitwise */\n      /* eslint-enable no-undef */\n\n      cmdEnc.copyTextureToBuffer(\n        {\n          texture: depthTexture.getHandle(),\n          aspect: 'depth-only',\n        },\n        {\n          buffer: zbuffer.getHandle(),\n          bytesPerRow: 4 * result.zbufferBufferWidth,\n          rowsPerImage: result.height,\n        },\n        {\n          width: result.width,\n          height: result.height,\n          depthOrArrayLayers: 1,\n        }\n      );\n    }\n    device.submitCommandEncoder(cmdEnc);\n\n    /* eslint-disable no-undef */\n    const cLoad = colorBuffer.mapAsync(GPUMapMode.READ);\n    if (model.captureZValues) {\n      const zLoad = zbuffer.mapAsync(GPUMapMode.READ);\n      await Promise.all([cLoad, zLoad]);\n      result.depthValues = new Float32Array(zbuffer.getMappedRange().slice());\n      zbuffer.unmap();\n    } else {\n      await cLoad;\n    }\n    /* eslint-enable no-undef */\n\n    result.colorValues = new Uint32Array(colorBuffer.getMappedRange().slice());\n    colorBuffer.unmap();\n\n    result.generateSelection = (fx1, fy1, fx2, fy2) =>\n      generateSelectionWithData(result, fx1, fy1, fx2, fy2);\n    return result;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  WebGPURenderWindow: null,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  vtkHardwareSelector.extend(publicAPI, model, initialValues);\n\n  model._selectionPass = vtkWebGPUHardwareSelectionPass.newInstance();\n\n  macro.setGet(publicAPI, model, ['WebGPURenderWindow']);\n\n  // Object methods\n  vtkWebGPUHardwareSelector(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(\n  extend,\n  'vtkWebGPUHardwareSelector'\n);\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}