{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport vtkWebGPUBufferManager from 'vtk.js/Sources/Rendering/WebGPU/BufferManager';\nimport vtkWebGPUTypes from 'vtk.js/Sources/Rendering/WebGPU/Types';\nconst {\n  BufferUsage\n} = vtkWebGPUBufferManager;\nconst {\n  vtkErrorMacro\n} = macro; // ----------------------------------------------------------------------------\n// vtkWebGPUStorageBuffer - similar to the UniformBuffer class\n// but YOU are responsible for layout issues and alignment.\n// The order you add entries is the order they will be layed out\n// in memory. But you must follow layout rules.\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// vtkWebGPUStorageBuffer methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUStorageBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUStorageBuffer');\n\n  publicAPI.addEntry = (name, type) => {\n    if (model._bufferEntryNames.has(name)) {\n      vtkErrorMacro(`entry named ${name} already exists`);\n      return;\n    }\n\n    model._bufferEntryNames.set(name, model.bufferEntries.length);\n\n    const sizeInBytes = vtkWebGPUTypes.getByteStrideFromShaderFormat(type);\n    model.bufferEntries.push({\n      name,\n      type,\n      sizeInBytes,\n      offset: model.sizeInBytes,\n      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type)\n    });\n    model.sizeInBytes += sizeInBytes;\n  };\n\n  publicAPI.send = device => {\n    if (!model._buffer) {\n      const req = {\n        nativeArray: model.Float32Array,\n        usage: BufferUsage.Storage,\n        label: model.label\n      };\n      model._buffer = device.getBufferManager().getBuffer(req);\n      model.bindGroupTime.modified();\n\n      model._sendTime.modified();\n\n      return;\n    }\n\n    device.getHandle().queue.writeBuffer(model._buffer.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes * model.numberOfInstances);\n\n    model._sendTime.modified();\n  };\n\n  publicAPI.createView = type => {\n    if (type in model === false) {\n      if (!model.arrayBuffer) {\n        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes * model.numberOfInstances);\n      }\n\n      model[type] = macro.newTypedArray(type, model.arrayBuffer);\n    }\n  };\n\n  publicAPI.setValue = (name, instance, val) => {\n    const idx = model._bufferEntryNames.get(name);\n\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    view[(entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT] = val;\n  };\n\n  publicAPI.setArray = (name, instance, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const ioffset = (entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n\n    for (let i = 0; i < arr.length; i++) {\n      view[ioffset + i] = arr[i];\n    }\n  };\n\n  publicAPI.setAllInstancesFromArray = (name, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const numComponents = arr.length / model.numberOfInstances;\n\n    for (let inst = 0; inst < model.numberOfInstances; inst++) {\n      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n\n      for (let i = 0; i < numComponents; i++) {\n        view[ioffset + i] = arr[inst * numComponents + i];\n      }\n    }\n  };\n\n  publicAPI.setAllInstancesFromArrayColorToFloat = (name, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const numComponents = arr.length / model.numberOfInstances;\n\n    for (let inst = 0; inst < model.numberOfInstances; inst++) {\n      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n\n      for (let i = 0; i < numComponents; i++) {\n        view[ioffset + i] = arr[inst * numComponents + i] / 255.0;\n      }\n    }\n  };\n\n  publicAPI.setAllInstancesFromArray3x3To4x4 = (name, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const numComponents = 9;\n\n    for (let inst = 0; inst < model.numberOfInstances; inst++) {\n      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n\n      for (let j = 0; j < 3; j++) {\n        for (let i = 0; i < 3; i++) {\n          view[ioffset + j * 4 + i] = arr[inst * numComponents + j * 3 + i];\n        }\n      }\n    }\n  };\n\n  publicAPI.getSendTime = () => model._sendTime.getMTime();\n\n  publicAPI.getShaderCode = (binding, group) => {\n    const lines = [`struct ${model.label}StructEntry\\n{`];\n\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      lines.push(`  ${entry.name}: ${entry.type},`);\n    }\n\n    lines.push(`\n};\nstruct ${model.label}Struct\n{\n  values: array<${model.label}StructEntry>,\n};\n@binding(${binding}) @group(${group}) var<storage, read> ${model.label}: ${model.label}Struct;\n`);\n    return lines.join('\\n');\n  };\n\n  publicAPI.getBindGroupEntry = () => {\n    const foo = {\n      resource: {\n        buffer: model._buffer.getHandle()\n      }\n    };\n    return foo;\n  };\n\n  publicAPI.clearData = () => {\n    model.numberOfInstances = 0;\n    model.sizeInBytes = 0;\n    model.bufferEntries = [];\n    model._bufferEntryNames = new Map();\n    model._buffer = null;\n    delete model.arrayBuffer;\n    delete model.Float32Array;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  bufferEntries: null,\n  bufferEntryNames: null,\n  sizeInBytes: 0,\n  label: null,\n  numberOfInstances: 1\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model); // Internal objects\n\n  model._bufferEntryNames = new Map();\n  model.bufferEntries = [];\n  model._sendTime = {};\n  macro.obj(model._sendTime, {\n    mtime: 0\n  });\n  model.bindGroupTime = {};\n  macro.obj(model.bindGroupTime, {\n    mtime: 0\n  }); // default SSBO desc\n\n  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {\n    buffer: {\n      type: 'read-only-storage'\n    }\n  };\n  macro.get(publicAPI, model, ['bindGroupTime']);\n  macro.setGet(publicAPI, model, ['device', 'bindGroupLayoutEntry', 'label', 'numberOfInstances', 'sizeInBytes']); // Object methods\n\n  vtkWebGPUStorageBuffer(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkWebGPUStorageBuffer'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["macro","vtkWebGPUBufferManager","vtkWebGPUTypes","BufferUsage","vtkErrorMacro","vtkWebGPUStorageBuffer","publicAPI","model","classHierarchy","push","addEntry","name","type","_bufferEntryNames","has","set","bufferEntries","length","sizeInBytes","getByteStrideFromShaderFormat","offset","nativeType","getNativeTypeFromShaderFormat","send","device","_buffer","req","nativeArray","Float32Array","usage","Storage","label","getBufferManager","getBuffer","bindGroupTime","modified","_sendTime","getHandle","queue","writeBuffer","arrayBuffer","numberOfInstances","createView","ArrayBuffer","newTypedArray","setValue","instance","val","idx","get","undefined","entry","view","BYTES_PER_ELEMENT","setArray","arr","ioffset","i","setAllInstancesFromArray","numComponents","inst","setAllInstancesFromArrayColorToFloat","setAllInstancesFromArray3x3To4x4","j","getSendTime","getMTime","getShaderCode","binding","group","lines","join","getBindGroupEntry","foo","resource","buffer","clearData","Map","DEFAULT_VALUES","bufferEntryNames","extend","initialValues","Object","assign","obj","mtime","bindGroupLayoutEntry","setGet","newInstance"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/WebGPU/StorageBuffer/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport vtkWebGPUBufferManager from 'vtk.js/Sources/Rendering/WebGPU/BufferManager';\nimport vtkWebGPUTypes from 'vtk.js/Sources/Rendering/WebGPU/Types';\n\nconst { BufferUsage } = vtkWebGPUBufferManager;\n\nconst { vtkErrorMacro } = macro;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUStorageBuffer - similar to the UniformBuffer class\n// but YOU are responsible for layout issues and alignment.\n// The order you add entries is the order they will be layed out\n// in memory. But you must follow layout rules.\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUStorageBuffer methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUStorageBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUStorageBuffer');\n\n  publicAPI.addEntry = (name, type) => {\n    if (model._bufferEntryNames.has(name)) {\n      vtkErrorMacro(`entry named ${name} already exists`);\n      return;\n    }\n    model._bufferEntryNames.set(name, model.bufferEntries.length);\n    const sizeInBytes = vtkWebGPUTypes.getByteStrideFromShaderFormat(type);\n    model.bufferEntries.push({\n      name,\n      type,\n      sizeInBytes,\n      offset: model.sizeInBytes,\n      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type),\n    });\n    model.sizeInBytes += sizeInBytes;\n  };\n\n  publicAPI.send = (device) => {\n    if (!model._buffer) {\n      const req = {\n        nativeArray: model.Float32Array,\n        usage: BufferUsage.Storage,\n        label: model.label,\n      };\n      model._buffer = device.getBufferManager().getBuffer(req);\n      model.bindGroupTime.modified();\n      model._sendTime.modified();\n      return;\n    }\n\n    device\n      .getHandle()\n      .queue.writeBuffer(\n        model._buffer.getHandle(),\n        0,\n        model.arrayBuffer,\n        0,\n        model.sizeInBytes * model.numberOfInstances\n      );\n    model._sendTime.modified();\n  };\n\n  publicAPI.createView = (type) => {\n    if (type in model === false) {\n      if (!model.arrayBuffer) {\n        model.arrayBuffer = new ArrayBuffer(\n          model.sizeInBytes * model.numberOfInstances\n        );\n      }\n      model[type] = macro.newTypedArray(type, model.arrayBuffer);\n    }\n  };\n\n  publicAPI.setValue = (name, instance, val) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    view[\n      (entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT\n    ] = val;\n  };\n\n  publicAPI.setArray = (name, instance, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const ioffset =\n      (entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n    for (let i = 0; i < arr.length; i++) {\n      view[ioffset + i] = arr[i];\n    }\n  };\n\n  publicAPI.setAllInstancesFromArray = (name, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const numComponents = arr.length / model.numberOfInstances;\n    for (let inst = 0; inst < model.numberOfInstances; inst++) {\n      const ioffset =\n        (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n      for (let i = 0; i < numComponents; i++) {\n        view[ioffset + i] = arr[inst * numComponents + i];\n      }\n    }\n  };\n\n  publicAPI.setAllInstancesFromArrayColorToFloat = (name, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const numComponents = arr.length / model.numberOfInstances;\n    for (let inst = 0; inst < model.numberOfInstances; inst++) {\n      const ioffset =\n        (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n      for (let i = 0; i < numComponents; i++) {\n        view[ioffset + i] = arr[inst * numComponents + i] / 255.0;\n      }\n    }\n  };\n\n  publicAPI.setAllInstancesFromArray3x3To4x4 = (name, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const numComponents = 9;\n    for (let inst = 0; inst < model.numberOfInstances; inst++) {\n      const ioffset =\n        (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n      for (let j = 0; j < 3; j++) {\n        for (let i = 0; i < 3; i++) {\n          view[ioffset + j * 4 + i] = arr[inst * numComponents + j * 3 + i];\n        }\n      }\n    }\n  };\n\n  publicAPI.getSendTime = () => model._sendTime.getMTime();\n  publicAPI.getShaderCode = (binding, group) => {\n    const lines = [`struct ${model.label}StructEntry\\n{`];\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      lines.push(`  ${entry.name}: ${entry.type},`);\n    }\n    lines.push(`\n};\nstruct ${model.label}Struct\n{\n  values: array<${model.label}StructEntry>,\n};\n@binding(${binding}) @group(${group}) var<storage, read> ${model.label}: ${model.label}Struct;\n`);\n\n    return lines.join('\\n');\n  };\n\n  publicAPI.getBindGroupEntry = () => {\n    const foo = {\n      resource: {\n        buffer: model._buffer.getHandle(),\n      },\n    };\n    return foo;\n  };\n\n  publicAPI.clearData = () => {\n    model.numberOfInstances = 0;\n    model.sizeInBytes = 0;\n    model.bufferEntries = [];\n    model._bufferEntryNames = new Map();\n    model._buffer = null;\n    delete model.arrayBuffer;\n    delete model.Float32Array;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  bufferEntries: null,\n  bufferEntryNames: null,\n  sizeInBytes: 0,\n  label: null,\n  numberOfInstances: 1,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n\n  // Internal objects\n  model._bufferEntryNames = new Map();\n  model.bufferEntries = [];\n\n  model._sendTime = {};\n  macro.obj(model._sendTime, { mtime: 0 });\n\n  model.bindGroupTime = {};\n  macro.obj(model.bindGroupTime, { mtime: 0 });\n\n  // default SSBO desc\n  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {\n    buffer: {\n      type: 'read-only-storage',\n    },\n  };\n\n  macro.get(publicAPI, model, ['bindGroupTime']);\n  macro.setGet(publicAPI, model, [\n    'device',\n    'bindGroupLayoutEntry',\n    'label',\n    'numberOfInstances',\n    'sizeInBytes',\n  ]);\n\n  // Object methods\n  vtkWebGPUStorageBuffer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkWebGPUStorageBuffer');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}