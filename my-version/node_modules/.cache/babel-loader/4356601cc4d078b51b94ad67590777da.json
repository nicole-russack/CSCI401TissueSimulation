{"ast":null,"code":"import { decompressSync, strFromU8, strToU8, unzipSync } from 'fflate';\nimport macro from 'vtk.js/Sources/macros';\nimport Endian from 'vtk.js/Sources/Common/Core/Endian';\nimport { DataTypeByteSize } from 'vtk.js/Sources/Common/Core/DataArray/Constants';\nimport { registerType } from 'vtk.js/Sources/IO/Core/DataAccessHelper';\nimport { fromArrayBuffer } from 'vtk.js/Sources/Common/Core/Base64';\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\n\nfunction toMimeType(url) {\n  const ext = url.split('.').pop().toLowerCase();\n\n  if (ext === 'jpg') {\n    return 'jpeg';\n  }\n\n  return ext;\n}\n\nfunction handleUint8Array(array, compression, done) {\n  return uint8array => {\n    array.buffer = new ArrayBuffer(uint8array.length); // copy uint8array to buffer\n\n    const view = new Uint8Array(array.buffer);\n    view.set(uint8array);\n\n    if (compression) {\n      if (array.dataType === 'string' || array.dataType === 'JSON') {\n        array.buffer = strFromU8(decompressSync(new Uint8Array(array.buffer)));\n      } else {\n        array.buffer = decompressSync(new Uint8Array(array.buffer)).buffer;\n      }\n    }\n\n    if (array.ref.encode === 'JSON') {\n      array.values = JSON.parse(array.buffer);\n    } else {\n      if (Endian.ENDIANNESS !== array.ref.encode && Endian.ENDIANNESS) {\n        // Need to swap bytes\n        vtkDebugMacro(`Swap bytes of ${array.name}`);\n        Endian.swapBytes(array.buffer, DataTypeByteSize[array.dataType]);\n      }\n\n      array.values = macro.newTypedArray(array.dataType, array.buffer);\n    }\n\n    if (array.values.length !== array.size) {\n      vtkErrorMacro(`Error in FetchArray: ${array.name} does not have the proper array size. Got ${array.values.length}, instead of ${array.size}`);\n    }\n\n    done();\n  };\n}\n\nfunction handleString(array, compression, done) {\n  return string => {\n    if (compression) {\n      array.values = JSON.parse(strFromU8(decompressSync(string)));\n    } else {\n      array.values = JSON.parse(string);\n    }\n\n    done();\n  };\n}\n\nfunction removeLeadingSlash(str) {\n  return str[0] === '/' ? str.substr(1) : str;\n}\n\nfunction normalizePath(str) {\n  return new URL(str, 'http://any').pathname;\n}\n\nfunction cleanUpPath(str) {\n  return removeLeadingSlash(normalizePath(str));\n}\n\nfunction unpack(zipContent) {\n  return new Promise((resolve, reject) => {\n    if (typeof zipContent === 'string') {\n      resolve(strToU8(zipContent));\n    } else if (zipContent instanceof Blob) {\n      resolve(zipContent.arrayBuffer().then(ab => new Uint8Array(ab)));\n    } else if (zipContent instanceof ArrayBuffer) {\n      resolve(new Uint8Array(zipContent));\n    } else if (zipContent?.buffer instanceof ArrayBuffer) {\n      resolve(new Uint8Array(zipContent.buffer));\n    } else {\n      reject(new Error('Invalid datatype to unpack.'));\n    }\n  });\n}\n\nfunction create(createOptions) {\n  let ready = false;\n  let requestCount = 0;\n  let decompressedFiles = null;\n  let fullRootPath = '';\n  unpack(createOptions.zipContent).then(zipFileData => {\n    decompressedFiles = unzipSync(zipFileData);\n    ready = true; // Find root index.json\n\n    const metaFiles = [];\n    Object.keys(decompressedFiles).forEach(relativePath => {\n      if (relativePath.endsWith('index.json')) {\n        metaFiles.push(relativePath);\n      }\n    });\n    metaFiles.sort((a, b) => a.length - b.length); // if not empty, then fullRootPath will have a forward slash suffix\n\n    fullRootPath = metaFiles[0].replace(/index\\.json$/, '');\n\n    if (createOptions.callback) {\n      createOptions.callback(decompressedFiles);\n    }\n  });\n  return {\n    fetchArray(instance, baseURL, array) {\n      let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      return new Promise((resolve, reject) => {\n        if (!ready) {\n          vtkErrorMacro('ERROR!!! zip not ready...');\n        }\n\n        const url = cleanUpPath([baseURL, array.ref.basepath, options.compression ? `${array.ref.id}.gz` : array.ref.id].join('/'));\n\n        if (++requestCount === 1 && instance?.invokeBusy) {\n          instance.invokeBusy(true);\n        }\n\n        function doneCleanUp() {\n          // Done with the ref and work\n          delete array.ref;\n\n          if (--requestCount === 0 && instance?.invokeBusy) {\n            instance.invokeBusy(false);\n          }\n\n          if (instance?.modified) {\n            instance.modified();\n          }\n\n          resolve(array);\n        }\n\n        const fileData = decompressedFiles[`${fullRootPath}${url}`];\n\n        if (array.dataType === 'string' && !options.compression) {\n          // string\n          const handler = handleString(array, options.compression, doneCleanUp);\n          handler(strFromU8(fileData));\n        } else {\n          // uint8array\n          const handler = handleUint8Array(array, options.compression, doneCleanUp);\n          handler(fileData);\n        }\n      });\n    },\n\n    fetchJSON(instance, url) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      const path = cleanUpPath(url);\n\n      if (!ready) {\n        vtkErrorMacro('ERROR!!! zip not ready...');\n      }\n\n      const fileData = decompressedFiles[`${fullRootPath}${path}`];\n\n      if (options.compression) {\n        if (options.compression === 'gz') {\n          const str = strFromU8(decompressSync(fileData));\n          return Promise.resolve(JSON.parse(str));\n        }\n\n        return Promise.reject(new Error('Invalid compression'));\n      }\n\n      return Promise.resolve(JSON.parse(strFromU8(fileData)));\n    },\n\n    fetchText(instance, url) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      const path = cleanUpPath(url);\n\n      if (!ready) {\n        vtkErrorMacro('ERROR!!! zip not ready...');\n      }\n\n      const fileData = decompressedFiles[`${fullRootPath}${path}`];\n\n      if (options.compression) {\n        if (options.compression === 'gz') {\n          return Promise.resolve(strFromU8(unzipSync(fileData)));\n        }\n\n        return Promise.reject(new Error('Invalid compression'));\n      }\n\n      return Promise.resolve(strFromU8(fileData));\n    },\n\n    fetchImage(instance, url) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      const path = cleanUpPath(url);\n\n      if (!ready) {\n        vtkErrorMacro('ERROR!!! zip not ready...');\n      }\n\n      const fileData = decompressedFiles[`${fullRootPath}${path}`];\n      return new Promise((resolve, reject) => {\n        const img = new Image();\n\n        img.onload = () => resolve(img);\n\n        img.onerror = reject;\n        const str = fromArrayBuffer(fileData.buffer);\n        img.src = `data:image/${toMimeType(path)};base64,${str}`;\n      });\n    },\n\n    fetchBinary(instance, url) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      const path = cleanUpPath(url);\n\n      if (!ready) {\n        vtkErrorMacro('ERROR!!! zip not ready...');\n      }\n\n      const fileData = decompressedFiles[`${fullRootPath}${path}`];\n\n      if (options.compression) {\n        if (options.compression === 'gz') {\n          return Promise.resolve(decompressSync(fileData).buffer);\n        }\n\n        return Promise.reject(new Error('Invalid compression'));\n      }\n\n      return Promise.resolve(fileData.buffer);\n    }\n\n  };\n}\n\nconst JSZipDataAccessHelper = {\n  create\n};\nregisterType('zip', options => JSZipDataAccessHelper.create(options));\nexport default JSZipDataAccessHelper;","map":{"version":3,"names":["decompressSync","strFromU8","strToU8","unzipSync","macro","Endian","DataTypeByteSize","registerType","fromArrayBuffer","vtkErrorMacro","vtkDebugMacro","toMimeType","url","ext","split","pop","toLowerCase","handleUint8Array","array","compression","done","uint8array","buffer","ArrayBuffer","length","view","Uint8Array","set","dataType","ref","encode","values","JSON","parse","ENDIANNESS","name","swapBytes","newTypedArray","size","handleString","string","removeLeadingSlash","str","substr","normalizePath","URL","pathname","cleanUpPath","unpack","zipContent","Promise","resolve","reject","Blob","arrayBuffer","then","ab","Error","create","createOptions","ready","requestCount","decompressedFiles","fullRootPath","zipFileData","metaFiles","Object","keys","forEach","relativePath","endsWith","push","sort","a","b","replace","callback","fetchArray","instance","baseURL","options","basepath","id","join","invokeBusy","doneCleanUp","modified","fileData","handler","fetchJSON","path","fetchText","fetchImage","img","Image","onload","onerror","src","fetchBinary","JSZipDataAccessHelper"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/IO/Core/DataAccessHelper/JSZipDataAccessHelper.js"],"sourcesContent":["import { decompressSync, strFromU8, strToU8, unzipSync } from 'fflate';\n\nimport macro from 'vtk.js/Sources/macros';\nimport Endian from 'vtk.js/Sources/Common/Core/Endian';\nimport { DataTypeByteSize } from 'vtk.js/Sources/Common/Core/DataArray/Constants';\nimport { registerType } from 'vtk.js/Sources/IO/Core/DataAccessHelper';\nimport { fromArrayBuffer } from 'vtk.js/Sources/Common/Core/Base64';\n\nconst { vtkErrorMacro, vtkDebugMacro } = macro;\n\nfunction toMimeType(url) {\n  const ext = url.split('.').pop().toLowerCase();\n  if (ext === 'jpg') {\n    return 'jpeg';\n  }\n  return ext;\n}\n\nfunction handleUint8Array(array, compression, done) {\n  return (uint8array) => {\n    array.buffer = new ArrayBuffer(uint8array.length);\n\n    // copy uint8array to buffer\n    const view = new Uint8Array(array.buffer);\n    view.set(uint8array);\n\n    if (compression) {\n      if (array.dataType === 'string' || array.dataType === 'JSON') {\n        array.buffer = strFromU8(decompressSync(new Uint8Array(array.buffer)));\n      } else {\n        array.buffer = decompressSync(new Uint8Array(array.buffer)).buffer;\n      }\n    }\n\n    if (array.ref.encode === 'JSON') {\n      array.values = JSON.parse(array.buffer);\n    } else {\n      if (Endian.ENDIANNESS !== array.ref.encode && Endian.ENDIANNESS) {\n        // Need to swap bytes\n        vtkDebugMacro(`Swap bytes of ${array.name}`);\n        Endian.swapBytes(array.buffer, DataTypeByteSize[array.dataType]);\n      }\n\n      array.values = macro.newTypedArray(array.dataType, array.buffer);\n    }\n\n    if (array.values.length !== array.size) {\n      vtkErrorMacro(\n        `Error in FetchArray: ${array.name} does not have the proper array size. Got ${array.values.length}, instead of ${array.size}`\n      );\n    }\n\n    done();\n  };\n}\n\nfunction handleString(array, compression, done) {\n  return (string) => {\n    if (compression) {\n      array.values = JSON.parse(strFromU8(decompressSync(string)));\n    } else {\n      array.values = JSON.parse(string);\n    }\n    done();\n  };\n}\n\nfunction removeLeadingSlash(str) {\n  return str[0] === '/' ? str.substr(1) : str;\n}\n\nfunction normalizePath(str) {\n  return new URL(str, 'http://any').pathname;\n}\n\nfunction cleanUpPath(str) {\n  return removeLeadingSlash(normalizePath(str));\n}\n\nfunction unpack(zipContent) {\n  return new Promise((resolve, reject) => {\n    if (typeof zipContent === 'string') {\n      resolve(strToU8(zipContent));\n    } else if (zipContent instanceof Blob) {\n      resolve(zipContent.arrayBuffer().then((ab) => new Uint8Array(ab)));\n    } else if (zipContent instanceof ArrayBuffer) {\n      resolve(new Uint8Array(zipContent));\n    } else if (zipContent?.buffer instanceof ArrayBuffer) {\n      resolve(new Uint8Array(zipContent.buffer));\n    } else {\n      reject(new Error('Invalid datatype to unpack.'));\n    }\n  });\n}\n\nfunction create(createOptions) {\n  let ready = false;\n  let requestCount = 0;\n  let decompressedFiles = null;\n  let fullRootPath = '';\n\n  unpack(createOptions.zipContent).then((zipFileData) => {\n    decompressedFiles = unzipSync(zipFileData);\n    ready = true;\n\n    // Find root index.json\n    const metaFiles = [];\n    Object.keys(decompressedFiles).forEach((relativePath) => {\n      if (relativePath.endsWith('index.json')) {\n        metaFiles.push(relativePath);\n      }\n    });\n    metaFiles.sort((a, b) => a.length - b.length);\n    // if not empty, then fullRootPath will have a forward slash suffix\n    fullRootPath = metaFiles[0].replace(/index\\.json$/, '');\n\n    if (createOptions.callback) {\n      createOptions.callback(decompressedFiles);\n    }\n  });\n\n  return {\n    fetchArray(instance, baseURL, array, options = {}) {\n      return new Promise((resolve, reject) => {\n        if (!ready) {\n          vtkErrorMacro('ERROR!!! zip not ready...');\n        }\n        const url = cleanUpPath(\n          [\n            baseURL,\n            array.ref.basepath,\n            options.compression ? `${array.ref.id}.gz` : array.ref.id,\n          ].join('/')\n        );\n\n        if (++requestCount === 1 && instance?.invokeBusy) {\n          instance.invokeBusy(true);\n        }\n\n        function doneCleanUp() {\n          // Done with the ref and work\n          delete array.ref;\n          if (--requestCount === 0 && instance?.invokeBusy) {\n            instance.invokeBusy(false);\n          }\n          if (instance?.modified) {\n            instance.modified();\n          }\n          resolve(array);\n        }\n\n        const fileData = decompressedFiles[`${fullRootPath}${url}`];\n\n        if (array.dataType === 'string' && !options.compression) {\n          // string\n          const handler = handleString(array, options.compression, doneCleanUp);\n          handler(strFromU8(fileData));\n        } else {\n          // uint8array\n          const handler = handleUint8Array(\n            array,\n            options.compression,\n            doneCleanUp\n          );\n          handler(fileData);\n        }\n      });\n    },\n\n    fetchJSON(instance, url, options = {}) {\n      const path = cleanUpPath(url);\n      if (!ready) {\n        vtkErrorMacro('ERROR!!! zip not ready...');\n      }\n      const fileData = decompressedFiles[`${fullRootPath}${path}`];\n      if (options.compression) {\n        if (options.compression === 'gz') {\n          const str = strFromU8(decompressSync(fileData));\n          return Promise.resolve(JSON.parse(str));\n        }\n        return Promise.reject(new Error('Invalid compression'));\n      }\n      return Promise.resolve(JSON.parse(strFromU8(fileData)));\n    },\n\n    fetchText(instance, url, options = {}) {\n      const path = cleanUpPath(url);\n      if (!ready) {\n        vtkErrorMacro('ERROR!!! zip not ready...');\n      }\n      const fileData = decompressedFiles[`${fullRootPath}${path}`];\n      if (options.compression) {\n        if (options.compression === 'gz') {\n          return Promise.resolve(strFromU8(unzipSync(fileData)));\n        }\n        return Promise.reject(new Error('Invalid compression'));\n      }\n      return Promise.resolve(strFromU8(fileData));\n    },\n\n    fetchImage(instance, url, options = {}) {\n      const path = cleanUpPath(url);\n      if (!ready) {\n        vtkErrorMacro('ERROR!!! zip not ready...');\n      }\n      const fileData = decompressedFiles[`${fullRootPath}${path}`];\n      return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.onload = () => resolve(img);\n        img.onerror = reject;\n        const str = fromArrayBuffer(fileData.buffer);\n        img.src = `data:image/${toMimeType(path)};base64,${str}`;\n      });\n    },\n\n    fetchBinary(instance, url, options = {}) {\n      const path = cleanUpPath(url);\n      if (!ready) {\n        vtkErrorMacro('ERROR!!! zip not ready...');\n      }\n      const fileData = decompressedFiles[`${fullRootPath}${path}`];\n      if (options.compression) {\n        if (options.compression === 'gz') {\n          return Promise.resolve(decompressSync(fileData).buffer);\n        }\n        return Promise.reject(new Error('Invalid compression'));\n      }\n      return Promise.resolve(fileData.buffer);\n    },\n  };\n}\n\nconst JSZipDataAccessHelper = {\n  create,\n};\n\nregisterType('zip', (options) => JSZipDataAccessHelper.create(options));\n\nexport default JSZipDataAccessHelper;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}