{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport vtkViewNode from 'vtk.js/Sources/Rendering/SceneGraph/ViewNode';\nimport vtkWebGPUBindGroup from 'vtk.js/Sources/Rendering/WebGPU/BindGroup';\nimport vtkWebGPUPipeline from 'vtk.js/Sources/Rendering/WebGPU/Pipeline';\nimport vtkWebGPUShaderCache from 'vtk.js/Sources/Rendering/WebGPU/ShaderCache';\nimport vtkWebGPUShaderDescription from 'vtk.js/Sources/Rendering/WebGPU/ShaderDescription';\nimport vtkWebGPUVertexInput from 'vtk.js/Sources/Rendering/WebGPU/VertexInput';\nconst vtkWebGPUSimpleMapperVS = `\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n`;\nconst vtkWebGPUSimpleMapperFS = `\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n`; // ----------------------------------------------------------------------------\n// vtkWebGPUSimpleMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUSimpleMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUSimpleMapper');\n\n  publicAPI.generateShaderDescriptions = (hash, pipeline, vertexInput) => {\n    // create the shader descriptions\n    const vDesc = vtkWebGPUShaderDescription.newInstance({\n      type: 'vertex',\n      hash,\n      code: model.vertexShaderTemplate\n    });\n    const fDesc = vtkWebGPUShaderDescription.newInstance({\n      type: 'fragment',\n      hash,\n      code: model.fragmentShaderTemplate\n    }); // add them to the pipeline\n\n    const sdrs = pipeline.getShaderDescriptions();\n    sdrs.push(vDesc);\n    sdrs.push(fDesc); // look for replacements to invoke\n\n    const scode = model.vertexShaderTemplate + model.fragmentShaderTemplate; // eslint-disable-next-line prefer-regex-literals\n\n    const re = new RegExp('//VTK::[^:]*::', 'g');\n    const unique = scode.match(re).filter((v, i, a) => a.indexOf(v) === i);\n    const fnames = unique.map(v => `replaceShader${v.substring(7, v.length - 2)}`); // now invoke shader replacement functions\n\n    for (let i = 0; i < fnames.length; i++) {\n      const fname = fnames[i];\n\n      if (fname !== 'replaceShaderIOStructs' && model.shaderReplacements.has(fname)) {\n        model.shaderReplacements.get(fname)(hash, pipeline, vertexInput);\n      }\n    } // always replace the IOStructs last as other replacement funcs may\n    // add inputs or outputs\n\n\n    publicAPI.replaceShaderIOStructs(hash, pipeline, vertexInput); // console.log(vDesc.getCode());\n    // console.log(fDesc.getCode());\n  };\n\n  publicAPI.replaceShaderIOStructs = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.replaceShaderCode(null, vertexInput);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.replaceShaderCode(vDesc);\n  };\n\n  publicAPI.replaceShaderRenderEncoder = (hash, pipeline, vertexInput) => {\n    model.renderEncoder.replaceShaderCode(pipeline);\n  };\n\n  model.shaderReplacements.set('replaceShaderRenderEncoder', publicAPI.replaceShaderRenderEncoder);\n\n  publicAPI.replaceShaderRenderer = (hash, pipeline, vertexInput) => {\n    if (!model.WebGPURenderer) {\n      return;\n    }\n\n    const ubocode = model.WebGPURenderer.getBindGroup().getShaderCode(pipeline);\n    const vDesc = pipeline.getShaderDescription('vertex');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Renderer::Dec', [ubocode]).result;\n    vDesc.setCode(code);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Renderer::Dec', [ubocode]).result;\n    fDesc.setCode(code);\n  };\n\n  model.shaderReplacements.set('replaceShaderRenderer', publicAPI.replaceShaderRenderer);\n\n  publicAPI.replaceShaderMapper = (hash, pipeline, vertexInput) => {\n    const ubocode = model.bindGroup.getShaderCode(pipeline);\n    const vDesc = pipeline.getShaderDescription('vertex');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Mapper::Dec', [ubocode]).result;\n    vDesc.setCode(code);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinInput('bool', '@builtin(front_facing) frontFacing');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Mapper::Dec', [ubocode]).result;\n    fDesc.setCode(code);\n  };\n\n  model.shaderReplacements.set('replaceShaderMapper', publicAPI.replaceShaderMapper);\n\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    output.Position = rendererUBO.SCPCMatrix*vertexBC;']).result;\n    vDesc.setCode(code);\n  };\n\n  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n\n  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addOutput('vec2<f32>', 'tcoordVS');\n  };\n\n  model.shaderReplacements.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);\n\n  publicAPI.addTextureView = view => {\n    // is it already there?\n    if (model.textureViews.includes(view)) {\n      return;\n    }\n\n    model.textureViews.push(view);\n  }; // do everything required for this mapper to be rerady to draw\n  // but do not bind or do the actual draw commands as the pipeline\n  // is not neccessarily bound yet\n\n\n  publicAPI.prepareToDraw = renderEncoder => {\n    model.renderEncoder = renderEncoder; // do anything needed to get our input data up to date\n\n    publicAPI.updateInput(); // make sure buffers are created and up to date\n\n    publicAPI.updateBuffers(); // update bindings and bind groups/layouts\n    // does not acutally bind them, that is done in draw(...)\n\n    publicAPI.updateBindings(); // update the pipeline, includes computing the hash, and if needed\n    // creating the pipeline, shader code etc\n\n    publicAPI.updatePipeline();\n  };\n\n  publicAPI.updateInput = () => {};\n\n  publicAPI.updateBuffers = () => {};\n\n  publicAPI.updateBindings = () => {\n    // bindings can change without a pipeline change\n    // as long as their layout remains the same.\n    // That is why this is done even when the pipeline\n    // hash doesn't change.\n    model.bindGroup.setBindables(publicAPI.getBindables());\n  };\n\n  publicAPI.computePipelineHash = () => {};\n\n  publicAPI.registerDrawCallback = encoder => {\n    encoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n  };\n\n  publicAPI.prepareAndDraw = encoder => {\n    publicAPI.prepareToDraw(encoder);\n    encoder.setPipeline(model.pipeline);\n    publicAPI.draw(encoder);\n  }; // do the rest of the calls required to draw this mapper\n  // at this point the command encouder and pipeline are\n  // created and bound\n\n\n  publicAPI.draw = renderEncoder => {\n    const pipeline = renderEncoder.getBoundPipeline(); // bind the mapper bind group\n\n    renderEncoder.activateBindGroup(model.bindGroup);\n\n    if (model.WebGPURenderer) {\n      model.WebGPURenderer.bindUBO(renderEncoder);\n    } // bind the vertex input\n\n\n    pipeline.bindVertexInput(renderEncoder, model.vertexInput);\n    const indexBuffer = model.vertexInput.getIndexBuffer();\n\n    if (indexBuffer) {\n      renderEncoder.drawIndexed(indexBuffer.getIndexCount(), model.numberOfInstances, 0, 0, 0);\n    } else {\n      renderEncoder.draw(model.numberOfVertices, model.numberOfInstances, 0, 0);\n    }\n  };\n\n  publicAPI.getBindables = () => {\n    const bindables = [...model.additionalBindables];\n\n    if (model.UBO) {\n      bindables.push(model.UBO);\n    }\n\n    if (model.SSBO) {\n      bindables.push(model.SSBO);\n    } // add texture BindGroupLayouts\n\n\n    for (let t = 0; t < model.textureViews.length; t++) {\n      bindables.push(model.textureViews[t]);\n      const samp = model.textureViews[t].getSampler();\n\n      if (samp) {\n        bindables.push(samp);\n      }\n    }\n\n    return bindables;\n  };\n\n  publicAPI.updatePipeline = () => {\n    publicAPI.computePipelineHash();\n    model.pipeline = model.device.getPipeline(model.pipelineHash); // build the pipeline if needed\n\n    if (!model.pipeline) {\n      model.pipeline = vtkWebGPUPipeline.newInstance();\n      model.pipeline.setDevice(model.device);\n\n      if (model.WebGPURenderer) {\n        model.pipeline.addBindGroupLayout(model.WebGPURenderer.getBindGroup());\n      }\n\n      model.pipeline.addBindGroupLayout(model.bindGroup);\n      publicAPI.generateShaderDescriptions(model.pipelineHash, model.pipeline, model.vertexInput);\n      model.pipeline.setTopology(model.topology);\n      model.pipeline.setRenderEncoder(model.renderEncoder);\n      model.pipeline.setVertexState(model.vertexInput.getVertexInputInformation());\n      model.device.createPipeline(model.pipelineHash, model.pipeline);\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  additionalBindables: undefined,\n  bindGroup: null,\n  device: null,\n  fragmentShaderTemplate: null,\n  numberOfInstances: 1,\n  numberOfVertices: 0,\n  pipelineHash: null,\n  shaderReplacements: null,\n  SSBO: null,\n  textureViews: null,\n  topology: 'triangle-list',\n  UBO: null,\n  vertexShaderTemplate: null,\n  WebGPURenderer: null\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.textureViews = [];\n  model.vertexInput = vtkWebGPUVertexInput.newInstance();\n  model.bindGroup = vtkWebGPUBindGroup.newInstance({\n    label: 'mapperBG'\n  });\n  model.additionalBindables = [];\n  model.fragmentShaderTemplate = model.fragmentShaderTemplate || vtkWebGPUSimpleMapperFS;\n  model.vertexShaderTemplate = model.vertexShaderTemplate || vtkWebGPUSimpleMapperVS;\n  model.shaderReplacements = new Map(); // Build VTK API\n\n  macro.get(publicAPI, model, ['pipeline', 'vertexInput']);\n  macro.setGet(publicAPI, model, ['additionalBindables', 'device', 'fragmentShaderTemplate', 'interpolate', 'numberOfInstances', 'numberOfVertices', 'pipelineHash', 'shaderReplacements', 'SSBO', 'textureViews', 'topology', 'UBO', 'vertexShaderTemplate', 'WebGPURenderer']); // Object methods\n\n  vtkWebGPUSimpleMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkWebGPUSimpleMapper'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["macro","vtkViewNode","vtkWebGPUBindGroup","vtkWebGPUPipeline","vtkWebGPUShaderCache","vtkWebGPUShaderDescription","vtkWebGPUVertexInput","vtkWebGPUSimpleMapperVS","vtkWebGPUSimpleMapperFS","vtkWebGPUSimpleMapper","publicAPI","model","classHierarchy","push","generateShaderDescriptions","hash","pipeline","vertexInput","vDesc","newInstance","type","code","vertexShaderTemplate","fDesc","fragmentShaderTemplate","sdrs","getShaderDescriptions","scode","re","RegExp","unique","match","filter","v","i","a","indexOf","fnames","map","substring","length","fname","shaderReplacements","has","get","replaceShaderIOStructs","getShaderDescription","replaceShaderCode","replaceShaderRenderEncoder","renderEncoder","set","replaceShaderRenderer","WebGPURenderer","ubocode","getBindGroup","getShaderCode","getCode","substitute","result","setCode","replaceShaderMapper","bindGroup","addBuiltinInput","replaceShaderPosition","addBuiltinOutput","replaceShaderTCoord","addOutput","addTextureView","view","textureViews","includes","prepareToDraw","updateInput","updateBuffers","updateBindings","updatePipeline","setBindables","getBindables","computePipelineHash","registerDrawCallback","encoder","draw","prepareAndDraw","setPipeline","getBoundPipeline","activateBindGroup","bindUBO","bindVertexInput","indexBuffer","getIndexBuffer","drawIndexed","getIndexCount","numberOfInstances","numberOfVertices","bindables","additionalBindables","UBO","SSBO","t","samp","getSampler","device","getPipeline","pipelineHash","setDevice","addBindGroupLayout","setTopology","topology","setRenderEncoder","setVertexState","getVertexInputInformation","createPipeline","DEFAULT_VALUES","undefined","extend","initialValues","Object","assign","label","Map","setGet"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/WebGPU/SimpleMapper/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport vtkViewNode from 'vtk.js/Sources/Rendering/SceneGraph/ViewNode';\nimport vtkWebGPUBindGroup from 'vtk.js/Sources/Rendering/WebGPU/BindGroup';\nimport vtkWebGPUPipeline from 'vtk.js/Sources/Rendering/WebGPU/Pipeline';\nimport vtkWebGPUShaderCache from 'vtk.js/Sources/Rendering/WebGPU/ShaderCache';\nimport vtkWebGPUShaderDescription from 'vtk.js/Sources/Rendering/WebGPU/ShaderDescription';\nimport vtkWebGPUVertexInput from 'vtk.js/Sources/Rendering/WebGPU/VertexInput';\n\nconst vtkWebGPUSimpleMapperVS = `\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n`;\n\nconst vtkWebGPUSimpleMapperFS = `\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n`;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUSimpleMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUSimpleMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUSimpleMapper');\n\n  publicAPI.generateShaderDescriptions = (hash, pipeline, vertexInput) => {\n    // create the shader descriptions\n    const vDesc = vtkWebGPUShaderDescription.newInstance({\n      type: 'vertex',\n      hash,\n      code: model.vertexShaderTemplate,\n    });\n    const fDesc = vtkWebGPUShaderDescription.newInstance({\n      type: 'fragment',\n      hash,\n      code: model.fragmentShaderTemplate,\n    });\n\n    // add them to the pipeline\n    const sdrs = pipeline.getShaderDescriptions();\n    sdrs.push(vDesc);\n    sdrs.push(fDesc);\n\n    // look for replacements to invoke\n    const scode = model.vertexShaderTemplate + model.fragmentShaderTemplate;\n    // eslint-disable-next-line prefer-regex-literals\n    const re = new RegExp('//VTK::[^:]*::', 'g');\n    const unique = scode.match(re).filter((v, i, a) => a.indexOf(v) === i);\n    const fnames = unique.map(\n      (v) => `replaceShader${v.substring(7, v.length - 2)}`\n    );\n\n    // now invoke shader replacement functions\n    for (let i = 0; i < fnames.length; i++) {\n      const fname = fnames[i];\n      if (\n        fname !== 'replaceShaderIOStructs' &&\n        model.shaderReplacements.has(fname)\n      ) {\n        model.shaderReplacements.get(fname)(hash, pipeline, vertexInput);\n      }\n    }\n\n    // always replace the IOStructs last as other replacement funcs may\n    // add inputs or outputs\n    publicAPI.replaceShaderIOStructs(hash, pipeline, vertexInput);\n\n    // console.log(vDesc.getCode());\n    // console.log(fDesc.getCode());\n  };\n\n  publicAPI.replaceShaderIOStructs = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.replaceShaderCode(null, vertexInput);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.replaceShaderCode(vDesc);\n  };\n\n  publicAPI.replaceShaderRenderEncoder = (hash, pipeline, vertexInput) => {\n    model.renderEncoder.replaceShaderCode(pipeline);\n  };\n  model.shaderReplacements.set(\n    'replaceShaderRenderEncoder',\n    publicAPI.replaceShaderRenderEncoder\n  );\n\n  publicAPI.replaceShaderRenderer = (hash, pipeline, vertexInput) => {\n    if (!model.WebGPURenderer) {\n      return;\n    }\n    const ubocode = model.WebGPURenderer.getBindGroup().getShaderCode(pipeline);\n\n    const vDesc = pipeline.getShaderDescription('vertex');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Renderer::Dec', [\n      ubocode,\n    ]).result;\n    vDesc.setCode(code);\n\n    const fDesc = pipeline.getShaderDescription('fragment');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Renderer::Dec', [\n      ubocode,\n    ]).result;\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set(\n    'replaceShaderRenderer',\n    publicAPI.replaceShaderRenderer\n  );\n\n  publicAPI.replaceShaderMapper = (hash, pipeline, vertexInput) => {\n    const ubocode = model.bindGroup.getShaderCode(pipeline);\n    const vDesc = pipeline.getShaderDescription('vertex');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Mapper::Dec', [\n      ubocode,\n    ]).result;\n    vDesc.setCode(code);\n\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinInput('bool', '@builtin(front_facing) frontFacing');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Mapper::Dec', [\n      ubocode,\n    ]).result;\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set(\n    'replaceShaderMapper',\n    publicAPI.replaceShaderMapper\n  );\n\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', [\n      '    output.Position = rendererUBO.SCPCMatrix*vertexBC;',\n    ]).result;\n    vDesc.setCode(code);\n  };\n  model.shaderReplacements.set(\n    'replaceShaderPosition',\n    publicAPI.replaceShaderPosition\n  );\n\n  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addOutput('vec2<f32>', 'tcoordVS');\n  };\n  model.shaderReplacements.set(\n    'replaceShaderTCoord',\n    publicAPI.replaceShaderTCoord\n  );\n\n  publicAPI.addTextureView = (view) => {\n    // is it already there?\n    if (model.textureViews.includes(view)) {\n      return;\n    }\n    model.textureViews.push(view);\n  };\n\n  // do everything required for this mapper to be rerady to draw\n  // but do not bind or do the actual draw commands as the pipeline\n  // is not neccessarily bound yet\n  publicAPI.prepareToDraw = (renderEncoder) => {\n    model.renderEncoder = renderEncoder;\n\n    // do anything needed to get our input data up to date\n    publicAPI.updateInput();\n\n    // make sure buffers are created and up to date\n    publicAPI.updateBuffers();\n\n    // update bindings and bind groups/layouts\n    // does not acutally bind them, that is done in draw(...)\n    publicAPI.updateBindings();\n\n    // update the pipeline, includes computing the hash, and if needed\n    // creating the pipeline, shader code etc\n    publicAPI.updatePipeline();\n  };\n\n  publicAPI.updateInput = () => {};\n\n  publicAPI.updateBuffers = () => {};\n\n  publicAPI.updateBindings = () => {\n    // bindings can change without a pipeline change\n    // as long as their layout remains the same.\n    // That is why this is done even when the pipeline\n    // hash doesn't change.\n    model.bindGroup.setBindables(publicAPI.getBindables());\n  };\n\n  publicAPI.computePipelineHash = () => {};\n\n  publicAPI.registerDrawCallback = (encoder) => {\n    encoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n  };\n\n  publicAPI.prepareAndDraw = (encoder) => {\n    publicAPI.prepareToDraw(encoder);\n    encoder.setPipeline(model.pipeline);\n    publicAPI.draw(encoder);\n  };\n\n  // do the rest of the calls required to draw this mapper\n  // at this point the command encouder and pipeline are\n  // created and bound\n  publicAPI.draw = (renderEncoder) => {\n    const pipeline = renderEncoder.getBoundPipeline();\n\n    // bind the mapper bind group\n    renderEncoder.activateBindGroup(model.bindGroup);\n\n    if (model.WebGPURenderer) {\n      model.WebGPURenderer.bindUBO(renderEncoder);\n    }\n\n    // bind the vertex input\n    pipeline.bindVertexInput(renderEncoder, model.vertexInput);\n    const indexBuffer = model.vertexInput.getIndexBuffer();\n    if (indexBuffer) {\n      renderEncoder.drawIndexed(\n        indexBuffer.getIndexCount(),\n        model.numberOfInstances,\n        0,\n        0,\n        0\n      );\n    } else {\n      renderEncoder.draw(model.numberOfVertices, model.numberOfInstances, 0, 0);\n    }\n  };\n\n  publicAPI.getBindables = () => {\n    const bindables = [...model.additionalBindables];\n    if (model.UBO) {\n      bindables.push(model.UBO);\n    }\n\n    if (model.SSBO) {\n      bindables.push(model.SSBO);\n    }\n\n    // add texture BindGroupLayouts\n    for (let t = 0; t < model.textureViews.length; t++) {\n      bindables.push(model.textureViews[t]);\n      const samp = model.textureViews[t].getSampler();\n      if (samp) {\n        bindables.push(samp);\n      }\n    }\n\n    return bindables;\n  };\n\n  publicAPI.updatePipeline = () => {\n    publicAPI.computePipelineHash();\n    model.pipeline = model.device.getPipeline(model.pipelineHash);\n\n    // build the pipeline if needed\n    if (!model.pipeline) {\n      model.pipeline = vtkWebGPUPipeline.newInstance();\n      model.pipeline.setDevice(model.device);\n\n      if (model.WebGPURenderer) {\n        model.pipeline.addBindGroupLayout(model.WebGPURenderer.getBindGroup());\n      }\n\n      model.pipeline.addBindGroupLayout(model.bindGroup);\n\n      publicAPI.generateShaderDescriptions(\n        model.pipelineHash,\n        model.pipeline,\n        model.vertexInput\n      );\n      model.pipeline.setTopology(model.topology);\n      model.pipeline.setRenderEncoder(model.renderEncoder);\n      model.pipeline.setVertexState(\n        model.vertexInput.getVertexInputInformation()\n      );\n      model.device.createPipeline(model.pipelineHash, model.pipeline);\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  additionalBindables: undefined,\n  bindGroup: null,\n  device: null,\n  fragmentShaderTemplate: null,\n  numberOfInstances: 1,\n  numberOfVertices: 0,\n  pipelineHash: null,\n  shaderReplacements: null,\n  SSBO: null,\n  textureViews: null,\n  topology: 'triangle-list',\n  UBO: null,\n  vertexShaderTemplate: null,\n  WebGPURenderer: null,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n\n  model.textureViews = [];\n  model.vertexInput = vtkWebGPUVertexInput.newInstance();\n\n  model.bindGroup = vtkWebGPUBindGroup.newInstance({ label: 'mapperBG' });\n\n  model.additionalBindables = [];\n\n  model.fragmentShaderTemplate =\n    model.fragmentShaderTemplate || vtkWebGPUSimpleMapperFS;\n  model.vertexShaderTemplate =\n    model.vertexShaderTemplate || vtkWebGPUSimpleMapperVS;\n\n  model.shaderReplacements = new Map();\n\n  // Build VTK API\n  macro.get(publicAPI, model, ['pipeline', 'vertexInput']);\n  macro.setGet(publicAPI, model, [\n    'additionalBindables',\n    'device',\n    'fragmentShaderTemplate',\n    'interpolate',\n    'numberOfInstances',\n    'numberOfVertices',\n    'pipelineHash',\n    'shaderReplacements',\n    'SSBO',\n    'textureViews',\n    'topology',\n    'UBO',\n    'vertexShaderTemplate',\n    'WebGPURenderer',\n  ]);\n\n  // Object methods\n  vtkWebGPUSimpleMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkWebGPUSimpleMapper');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}