{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport Constants from 'vtk.js/Sources/Rendering/OpenGL/HardwareSelector/Constants';\nimport vtkHardwareSelector from 'vtk.js/Sources/Rendering/Core/HardwareSelector';\nimport vtkOpenGLFramebuffer from 'vtk.js/Sources/Rendering/OpenGL/Framebuffer';\nimport vtkSelectionNode from 'vtk.js/Sources/Common/DataModel/SelectionNode';\nimport vtkDataSet from 'vtk.js/Sources/Common/DataModel/DataSet';\nconst {\n  PassTypes\n} = Constants;\nconst {\n  SelectionContent,\n  SelectionField\n} = vtkSelectionNode;\nconst {\n  FieldAssociations\n} = vtkDataSet;\nconst {\n  vtkErrorMacro\n} = macro;\nconst idOffset = 1;\n\nfunction getInfoHash(info) {\n  return `${info.propID} ${info.compositeID}`;\n}\n\nfunction getAlpha(xx, yy, pb, area) {\n  if (!pb) {\n    return 0;\n  }\n\n  const offset = (yy * (area[2] - area[0] + 1) + xx) * 4;\n  return pb[offset + 3];\n}\n\nfunction convert(xx, yy, pb, area) {\n  if (!pb) {\n    return 0;\n  }\n\n  const offset = (yy * (area[2] - area[0] + 1) + xx) * 4;\n  const rgb = [];\n  rgb[0] = pb[offset];\n  rgb[1] = pb[offset + 1];\n  rgb[2] = pb[offset + 2];\n  let val = rgb[2];\n  val *= 256;\n  val += rgb[1];\n  val *= 256;\n  val += rgb[0];\n  return val;\n}\n\nfunction getID(low24, high8) {\n  /* eslint-disable no-bitwise */\n  let val = high8;\n  val <<= 24;\n  val |= low24;\n  return val;\n  /* eslint-enable no-bitwise */\n}\n\nfunction getPixelInformationWithData(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {\n  // Base case\n  const maxDist = maxDistance < 0 ? 0 : maxDistance;\n\n  if (maxDist === 0) {\n    outSelectedPosition[0] = inDisplayPosition[0];\n    outSelectedPosition[1] = inDisplayPosition[1];\n\n    if (inDisplayPosition[0] < buffdata.area[0] || inDisplayPosition[0] > buffdata.area[2] || inDisplayPosition[1] < buffdata.area[1] || inDisplayPosition[1] > buffdata.area[3]) {\n      return null;\n    } // offset inDisplayPosition based on the lower-left-corner of the Area.\n\n\n    const displayPosition = [inDisplayPosition[0] - buffdata.area[0], inDisplayPosition[1] - buffdata.area[1]];\n    const actorid = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ACTOR_PASS], buffdata.area);\n\n    if (actorid <= 0 || actorid - idOffset >= buffdata.props.length) {\n      // the pixel did not hit any actor.\n      return null;\n    }\n\n    const info = {};\n    info.valid = true;\n    info.propID = actorid - idOffset;\n    info.prop = buffdata.props[info.propID];\n    let compositeID = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS], buffdata.area);\n\n    if (compositeID < 0 || compositeID > 0xffffff) {\n      compositeID = 0;\n    }\n\n    info.compositeID = compositeID - idOffset;\n\n    if (buffdata.captureZValues) {\n      const offset = (displayPosition[1] * (buffdata.area[2] - buffdata.area[0] + 1) + displayPosition[0]) * 4;\n      info.zValue = (256 * buffdata.zBuffer[offset] + buffdata.zBuffer[offset + 1]) / 65535.0;\n      info.displayPosition = inDisplayPosition;\n    }\n\n    if (buffdata.pixBuffer[PassTypes.ID_LOW24]) {\n      if (getAlpha(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_LOW24], buffdata.area) === 0.0) {\n        return info;\n      }\n    }\n\n    const low24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_LOW24], buffdata.area);\n    const high24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_HIGH24], buffdata.area);\n    info.attributeID = getID(low24, high24, 0);\n    return info;\n  } // Iterate over successively growing boxes.\n  // They recursively call the base case to handle single pixels.\n\n\n  const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];\n  const curPos = [0, 0];\n  let info = getPixelInformationWithData(buffdata, inDisplayPosition, 0, outSelectedPosition);\n\n  if (info && info.valid) {\n    return info;\n  }\n\n  for (let dist = 1; dist < maxDist; ++dist) {\n    // Vertical sides of box.\n    for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {\n      curPos[1] = y;\n\n      if (dispPos[0] >= dist) {\n        curPos[0] = dispPos[0] - dist;\n        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n\n        if (info && info.valid) {\n          return info;\n        }\n      }\n\n      curPos[0] = dispPos[0] + dist;\n      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n\n      if (info && info.valid) {\n        return info;\n      }\n    } // Horizontal sides of box.\n\n\n    for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {\n      curPos[0] = x;\n\n      if (dispPos[1] >= dist) {\n        curPos[1] = dispPos[1] - dist;\n        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n\n        if (info && info.valid) {\n          return info;\n        }\n      }\n\n      curPos[1] = dispPos[1] + dist;\n      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n\n      if (info && info.valid) {\n        return info;\n      }\n    }\n  } // nothing hit.\n\n\n  outSelectedPosition[0] = inDisplayPosition[0];\n  outSelectedPosition[1] = inDisplayPosition[1];\n  return null;\n} //-----------------------------------------------------------------------------\n\n\nfunction convertSelection(fieldassociation, dataMap, captureZValues, renderer, openGLRenderWindow) {\n  const sel = [];\n  let count = 0;\n  dataMap.forEach((value, key) => {\n    const child = vtkSelectionNode.newInstance();\n    child.setContentType(SelectionContent.INDICES);\n\n    switch (fieldassociation) {\n      case FieldAssociations.FIELD_ASSOCIATION_CELLS:\n        child.setFieldType(SelectionField.CELL);\n        break;\n\n      case FieldAssociations.FIELD_ASSOCIATION_POINTS:\n        child.setFieldType(SelectionField.POINT);\n        break;\n\n      default:\n        vtkErrorMacro('Unknown field association');\n    }\n\n    child.getProperties().propID = value.info.propID;\n    child.getProperties().prop = value.info.prop;\n    child.getProperties().compositeID = value.info.compositeID;\n    child.getProperties().attributeID = value.info.attributeID;\n    child.getProperties().pixelCount = value.pixelCount;\n\n    if (captureZValues) {\n      child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];\n      child.getProperties().worldPosition = openGLRenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, renderer);\n    }\n\n    child.setSelectionList(value.attributeIDs);\n    sel[count] = child;\n    count++;\n  });\n  return sel;\n} //----------------------------------------------------------------------------\n\n\nfunction generateSelectionWithData(buffdata, fx1, fy1, fx2, fy2) {\n  const x1 = Math.floor(fx1);\n  const y1 = Math.floor(fy1);\n  const x2 = Math.floor(fx2);\n  const y2 = Math.floor(fy2);\n  const dataMap = new Map();\n  const outSelectedPosition = [0, 0];\n\n  for (let yy = y1; yy <= y2; yy++) {\n    for (let xx = x1; xx <= x2; xx++) {\n      const pos = [xx, yy];\n      const info = getPixelInformationWithData(buffdata, pos, 0, outSelectedPosition);\n\n      if (info && info.valid) {\n        const hash = getInfoHash(info);\n\n        if (!dataMap.has(hash)) {\n          dataMap.set(hash, {\n            info,\n            pixelCount: 1,\n            attributeIDs: [info.attributeID]\n          });\n        } else {\n          const dmv = dataMap.get(hash);\n          dmv.pixelCount++;\n\n          if (buffdata.captureZValues) {\n            if (info.zValue < dmv.info.zValue) {\n              dmv.info = info;\n            }\n          }\n\n          if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {\n            dmv.attributeIDs.push(info.attributeID);\n          }\n        }\n      }\n    }\n  }\n\n  return convertSelection(buffdata.fieldAssociation, dataMap, buffdata.captureZValues, buffdata.renderer, buffdata.openGLRenderWindow);\n} // ----------------------------------------------------------------------------\n// vtkOpenGLHardwareSelector methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkOpenGLHardwareSelector(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLHardwareSelector'); //----------------------------------------------------------------------------\n\n  publicAPI.releasePixBuffers = () => {\n    model.rawPixBuffer = [];\n    model.pixBuffer = [];\n    model.zBuffer = null;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.beginSelection = () => {\n    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);\n    model.maxAttributeId = 0;\n\n    const size = model._openGLRenderWindow.getSize();\n\n    if (!model.framebuffer) {\n      model.framebuffer = vtkOpenGLFramebuffer.newInstance();\n      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.framebuffer.saveCurrentBindingsAndBuffers();\n      model.framebuffer.create(size[0], size[1]); // this calls model.framebuffer.bind()\n\n      model.framebuffer.populateFramebuffer();\n    } else {\n      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.framebuffer.saveCurrentBindingsAndBuffers();\n      const fbSize = model.framebuffer.getSize();\n\n      if (fbSize[0] !== size[0] || fbSize[1] !== size[1]) {\n        model.framebuffer.create(size[0], size[1]); // this calls model.framebuffer.bind()\n\n        model.framebuffer.populateFramebuffer();\n      } else {\n        model.framebuffer.bind();\n      }\n    }\n\n    model._openGLRenderer.clear();\n\n    model._openGLRenderer.setSelector(publicAPI);\n\n    model.hitProps = {};\n    model.propPixels = {};\n    model.props = [];\n    publicAPI.releasePixBuffers();\n\n    if (model.fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      const gl = model._openGLRenderWindow.getContext();\n\n      const originalBlending = gl.isEnabled(gl.BLEND);\n      gl.disable(gl.BLEND);\n\n      model._openGLRenderWindow.traverseAllPasses();\n\n      model._renderer.setPreserveDepthBuffer(true);\n\n      if (originalBlending) {\n        gl.enable(gl.BLEND);\n      }\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.endSelection = () => {\n    model.hitProps = {};\n\n    model._openGLRenderer.setSelector(null);\n\n    model.framebuffer.restorePreviousBindingsAndBuffers();\n\n    model._renderer.setPreserveDepthBuffer(false);\n  };\n\n  publicAPI.preCapturePass = () => {\n    const gl = model._openGLRenderWindow.getContext(); // Disable blending\n\n\n    model.originalBlending = gl.isEnabled(gl.BLEND);\n    gl.disable(gl.BLEND);\n  };\n\n  publicAPI.postCapturePass = () => {\n    const gl = model._openGLRenderWindow.getContext(); // Restore blending if it was enabled prior to the capture\n\n\n    if (model.originalBlending) {\n      gl.enable(gl.BLEND);\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.select = () => {\n    let sel = null;\n\n    if (publicAPI.captureBuffers()) {\n      sel = publicAPI.generateSelection(model.area[0], model.area[1], model.area[2], model.area[3]);\n      publicAPI.releasePixBuffers();\n    }\n\n    return sel;\n  };\n\n  publicAPI.getSourceDataAsync = async (renderer, fx1, fy1, fx2, fy2) => {\n    // assign the renderer\n    model._renderer = renderer; // set area to all if no arguments provided\n\n    if (fx1 === undefined) {\n      const size = model._openGLRenderWindow.getSize();\n\n      publicAPI.setArea(0, 0, size[0] - 1, size[1] - 1);\n    } else {\n      publicAPI.setArea(fx1, fy1, fx2, fy2);\n    } // just do capture buffers and package up the result\n\n\n    if (!publicAPI.captureBuffers()) {\n      return false;\n    }\n\n    const result = {\n      area: [...model.area],\n      pixBuffer: [...model.pixBuffer],\n      captureZValues: model.captureZValues,\n      zBuffer: model.zBuffer,\n      props: [...model.props],\n      fieldAssociation: model.fieldAssociation,\n      renderer,\n      openGLRenderWindow: model._openGLRenderWindow\n    };\n\n    result.generateSelection = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return generateSelectionWithData(result, ...args);\n    };\n\n    return result;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.captureBuffers = () => {\n    if (!model._renderer || !model._openGLRenderWindow) {\n      vtkErrorMacro('Renderer and view must be set before calling Select.');\n      return false;\n    }\n\n    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer); // todo revisit making selection part of core\n    // then we can do this in core\n\n    model._openGLRenderWindow.getRenderable().preRender(); // int rgba[4];\n    // rwin.getColorBufferSizes(rgba);\n    // if (rgba[0] < 8 || rgba[1] < 8 || rgba[2] < 8) {\n    //   vtkErrorMacro(\"Color buffer depth must be at least 8 bit. \"\n    //     \"Currently: \" << rgba[0] << \", \" << rgba[1] << \", \" <<rgba[2]);\n    //   return false;\n    // }\n\n\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    }); // Initialize renderer for selection.\n    // change the renderer's background to black, which will indicate a miss\n\n    model.originalBackground = model._renderer.getBackgroundByReference();\n\n    model._renderer.setBackground(0.0, 0.0, 0.0, 0.0);\n\n    const rpasses = model._openGLRenderWindow.getRenderPasses();\n\n    publicAPI.beginSelection();\n\n    for (model.currentPass = PassTypes.MIN_KNOWN_PASS; model.currentPass <= PassTypes.MAX_KNOWN_PASS; model.currentPass++) {\n      if (publicAPI.passRequired(model.currentPass)) {\n        publicAPI.preCapturePass(model.currentPass);\n\n        if (model.captureZValues && model.currentPass === PassTypes.ACTOR_PASS && typeof rpasses[0].requestDepth === 'function' && typeof rpasses[0].getFramebuffer === 'function') {\n          rpasses[0].requestDepth();\n\n          model._openGLRenderWindow.traverseAllPasses();\n        } else {\n          model._openGLRenderWindow.traverseAllPasses();\n        }\n\n        publicAPI.postCapturePass(model.currentPass);\n        publicAPI.savePixelBuffer(model.currentPass);\n        publicAPI.processPixelBuffers();\n      }\n    }\n\n    publicAPI.endSelection(); // restore original background\n\n    model._renderer.setBackground(model.originalBackground);\n\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    }); // restore image, not needed?\n    // model._openGLRenderWindow.traverseAllPasses();\n\n    return true;\n  };\n\n  publicAPI.processPixelBuffers = () => {\n    model.props.forEach((prop, index) => {\n      if (publicAPI.isPropHit(index)) {\n        prop.processSelectorPixelBuffers(publicAPI, model.propPixels[index]);\n      }\n    });\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.passRequired = pass => {\n    if (pass === PassTypes.ID_HIGH24) {\n      if (model.fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n        return model.maximumPointId > 0x00ffffff;\n      }\n\n      if (model.fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_CELLS) {\n        return model.maximumCellId > 0x00ffffff;\n      }\n    }\n\n    return true;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.savePixelBuffer = passNo => {\n    model.pixBuffer[passNo] = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);\n\n    if (!model.rawPixBuffer[passNo]) {\n      const size = (model.area[2] - model.area[0] + 1) * (model.area[3] - model.area[1] + 1) * 4;\n      model.rawPixBuffer[passNo] = new Uint8Array(size);\n      model.rawPixBuffer[passNo].set(model.pixBuffer[passNo]);\n    }\n\n    if (passNo === PassTypes.ACTOR_PASS) {\n      if (model.captureZValues) {\n        const rpasses = model._openGLRenderWindow.getRenderPasses();\n\n        if (typeof rpasses[0].requestDepth === 'function' && typeof rpasses[0].getFramebuffer === 'function') {\n          const fb = rpasses[0].getFramebuffer();\n          fb.saveCurrentBindingsAndBuffers();\n          fb.bind();\n          model.zBuffer = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);\n          fb.restorePreviousBindingsAndBuffers();\n        }\n      }\n\n      publicAPI.buildPropHitList(model.rawPixBuffer[passNo]);\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.buildPropHitList = pixelbuffer => {\n    let offset = 0;\n\n    for (let yy = 0; yy <= model.area[3] - model.area[1]; yy++) {\n      for (let xx = 0; xx <= model.area[2] - model.area[0]; xx++) {\n        let val = convert(xx, yy, pixelbuffer, model.area);\n\n        if (val > 0) {\n          val--;\n\n          if (!(val in model.hitProps)) {\n            model.hitProps[val] = true;\n            model.propPixels[val] = [];\n          }\n\n          model.propPixels[val].push(offset * 4);\n        }\n\n        ++offset;\n      }\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.renderProp = prop => {\n    if (model.currentPass === PassTypes.ACTOR_PASS) {\n      publicAPI.setPropColorValueFromInt(model.props.length + idOffset);\n      model.props.push(prop);\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.renderCompositeIndex = index => {\n    if (model.currentPass === PassTypes.COMPOSITE_INDEX_PASS) {\n      publicAPI.setPropColorValueFromInt(index + idOffset);\n    }\n  }; //----------------------------------------------------------------------------\n  // TODO: make inline\n\n\n  publicAPI.renderAttributeId = attribid => {\n    if (attribid < 0) {\n      // negative attribid is valid. It happens when rendering higher order\n      // elements where new points are added for rendering smooth surfaces.\n      return;\n    }\n\n    model.maxAttributeId = attribid > model.maxAttributeId ? attribid : model.maxAttributeId; // if (model.currentPass < PassTypes.ID_LOW24) {\n    //   return; // useless...\n    // }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.passTypeToString = type => macro.enumToString(PassTypes, type); //----------------------------------------------------------------------------\n\n\n  publicAPI.isPropHit = id => Boolean(model.hitProps[id]);\n\n  publicAPI.setPropColorValueFromInt = val => {\n    model.propColorValue[0] = val % 256 / 255.0;\n    model.propColorValue[1] = Math.floor(val / 256) % 256 / 255.0;\n    model.propColorValue[2] = Math.floor(val / 65536) % 256 / 255.0;\n  }; // info has\n  //   valid\n  //   propId\n  //   prop\n  //   compositeID\n  //   attributeID\n  //----------------------------------------------------------------------------\n\n\n  publicAPI.getPixelInformation = (inDisplayPosition, maxDistance, outSelectedPosition) => {\n    // Base case\n    const maxDist = maxDistance < 0 ? 0 : maxDistance;\n\n    if (maxDist === 0) {\n      outSelectedPosition[0] = inDisplayPosition[0];\n      outSelectedPosition[1] = inDisplayPosition[1];\n\n      if (inDisplayPosition[0] < model.area[0] || inDisplayPosition[0] > model.area[2] || inDisplayPosition[1] < model.area[1] || inDisplayPosition[1] > model.area[3]) {\n        return null;\n      } // offset inDisplayPosition based on the lower-left-corner of the Area.\n\n\n      const displayPosition = [inDisplayPosition[0] - model.area[0], inDisplayPosition[1] - model.area[1]];\n      const actorid = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ACTOR_PASS], model.area);\n\n      if (actorid <= 0 || actorid - idOffset >= model.props.length) {\n        // the pixel did not hit any actor.\n        return null;\n      }\n\n      const info = {};\n      info.valid = true;\n      info.propID = actorid - idOffset;\n      info.prop = model.props[info.propID];\n      let compositeID = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS], model.area);\n\n      if (compositeID < 0 || compositeID > 0xffffff) {\n        compositeID = 0;\n      }\n\n      info.compositeID = compositeID - idOffset;\n\n      if (model.captureZValues) {\n        const offset = (displayPosition[1] * (model.area[2] - model.area[0] + 1) + displayPosition[0]) * 4;\n        info.zValue = (256 * model.zBuffer[offset] + model.zBuffer[offset + 1]) / 65535.0;\n        info.displayPosition = inDisplayPosition;\n      } // Skip attribute ids if alpha is zero (missed)\n\n\n      if (model.pixBuffer[PassTypes.ID_LOW24]) {\n        if (getAlpha(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_LOW24], model.area) === 0.0) {\n          return info;\n        }\n      }\n\n      const low24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_LOW24], model.area);\n      const high24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_HIGH24], model.area);\n      info.attributeID = getID(low24, high24);\n      return info;\n    } // Iterate over successively growing boxes.\n    // They recursively call the base case to handle single pixels.\n\n\n    const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];\n    const curPos = [0, 0];\n    let info = publicAPI.getPixelInformation(inDisplayPosition, 0, outSelectedPosition);\n\n    if (info && info.valid) {\n      return info;\n    }\n\n    for (let dist = 1; dist < maxDist; ++dist) {\n      // Vertical sides of box.\n      for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {\n        curPos[1] = y;\n\n        if (dispPos[0] >= dist) {\n          curPos[0] = dispPos[0] - dist;\n          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);\n\n          if (info && info.valid) {\n            return info;\n          }\n        }\n\n        curPos[0] = dispPos[0] + dist;\n        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);\n\n        if (info && info.valid) {\n          return info;\n        }\n      } // Horizontal sides of box.\n\n\n      for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {\n        curPos[0] = x;\n\n        if (dispPos[1] >= dist) {\n          curPos[1] = dispPos[1] - dist;\n          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);\n\n          if (info && info.valid) {\n            return info;\n          }\n        }\n\n        curPos[1] = dispPos[1] + dist;\n        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);\n\n        if (info && info.valid) {\n          return info;\n        }\n      }\n    } // nothing hit.\n\n\n    outSelectedPosition[0] = inDisplayPosition[0];\n    outSelectedPosition[1] = inDisplayPosition[1];\n    return null;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.generateSelection = (fx1, fy1, fx2, fy2) => {\n    const x1 = Math.floor(fx1);\n    const y1 = Math.floor(fy1);\n    const x2 = Math.floor(fx2);\n    const y2 = Math.floor(fy2);\n    const dataMap = new Map();\n    const outSelectedPosition = [0, 0];\n\n    for (let yy = y1; yy <= y2; yy++) {\n      for (let xx = x1; xx <= x2; xx++) {\n        const pos = [xx, yy];\n        const info = publicAPI.getPixelInformation(pos, 0, outSelectedPosition);\n\n        if (info && info.valid) {\n          const hash = getInfoHash(info);\n\n          if (!dataMap.has(hash)) {\n            dataMap.set(hash, {\n              info,\n              pixelCount: 1,\n              attributeIDs: [info.attributeID]\n            });\n          } else {\n            const dmv = dataMap.get(hash);\n            dmv.pixelCount++;\n\n            if (model.captureZValues) {\n              if (info.zValue < dmv.info.zValue) {\n                dmv.info = info;\n              }\n            }\n\n            if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {\n              dmv.attributeIDs.push(info.attributeID);\n            }\n          }\n        }\n      }\n    }\n\n    return convertSelection(model.fieldAssociation, dataMap, model.captureZValues, model._renderer, model._openGLRenderWindow);\n  };\n\n  publicAPI.getRawPixelBuffer = passNo => model.rawPixBuffer[passNo];\n\n  publicAPI.getPixelBuffer = passNo => model.pixBuffer[passNo]; //----------------------------------------------------------------------------\n\n\n  publicAPI.attach = (w, r) => {\n    model._openGLRenderWindow = w;\n    model._renderer = r;\n  }; // override\n\n\n  const superSetArea = publicAPI.setArea;\n\n  publicAPI.setArea = function () {\n    if (superSetArea(...arguments)) {\n      model.area[0] = Math.floor(model.area[0]);\n      model.area[1] = Math.floor(model.area[1]);\n      model.area[2] = Math.floor(model.area[2]);\n      model.area[3] = Math.floor(model.area[3]);\n      return true;\n    }\n\n    return false;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  area: undefined,\n  // _renderer: null,\n  // _openGLRenderWindow: null,\n  // _openGLRenderer: null,\n  currentPass: -1,\n  propColorValue: null,\n  props: null,\n  maximumPointId: 0,\n  maximumCellId: 0,\n  idOffset: 1\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  vtkHardwareSelector.extend(publicAPI, model, initialValues);\n  model.propColorValue = [0, 0, 0];\n  model.props = [];\n\n  if (!model.area) {\n    model.area = [0, 0, 0, 0];\n  }\n\n  macro.setGetArray(publicAPI, model, ['area'], 4);\n  macro.setGet(publicAPI, model, ['_renderer', 'currentPass', '_openGLRenderWindow', 'maximumPointId', 'maximumCellId']);\n  macro.setGetArray(publicAPI, model, ['propColorValue'], 3);\n  macro.moveToProtected(publicAPI, model, ['renderer', 'openGLRenderWindow']);\n  macro.event(publicAPI, model, 'event'); // Object methods\n\n  vtkOpenGLHardwareSelector(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkOpenGLHardwareSelector'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend,\n  ...Constants\n};","map":{"version":3,"names":["macro","Constants","vtkHardwareSelector","vtkOpenGLFramebuffer","vtkSelectionNode","vtkDataSet","PassTypes","SelectionContent","SelectionField","FieldAssociations","vtkErrorMacro","idOffset","getInfoHash","info","propID","compositeID","getAlpha","xx","yy","pb","area","offset","convert","rgb","val","getID","low24","high8","getPixelInformationWithData","buffdata","inDisplayPosition","maxDistance","outSelectedPosition","maxDist","displayPosition","actorid","pixBuffer","ACTOR_PASS","props","length","valid","prop","COMPOSITE_INDEX_PASS","captureZValues","zValue","zBuffer","ID_LOW24","high24","ID_HIGH24","attributeID","dispPos","curPos","dist","y","x","convertSelection","fieldassociation","dataMap","renderer","openGLRenderWindow","sel","count","forEach","value","key","child","newInstance","setContentType","INDICES","FIELD_ASSOCIATION_CELLS","setFieldType","CELL","FIELD_ASSOCIATION_POINTS","POINT","getProperties","pixelCount","worldPosition","displayToWorld","setSelectionList","attributeIDs","generateSelectionWithData","fx1","fy1","fx2","fy2","x1","Math","floor","y1","x2","y2","Map","pos","hash","has","set","dmv","get","indexOf","push","fieldAssociation","vtkOpenGLHardwareSelector","publicAPI","model","classHierarchy","releasePixBuffers","rawPixBuffer","beginSelection","_openGLRenderer","_openGLRenderWindow","getViewNodeFor","_renderer","maxAttributeId","size","getSize","framebuffer","setOpenGLRenderWindow","saveCurrentBindingsAndBuffers","create","populateFramebuffer","fbSize","bind","clear","setSelector","hitProps","propPixels","gl","getContext","originalBlending","isEnabled","BLEND","disable","traverseAllPasses","setPreserveDepthBuffer","enable","endSelection","restorePreviousBindingsAndBuffers","preCapturePass","postCapturePass","select","captureBuffers","generateSelection","getSourceDataAsync","undefined","setArea","result","args","getRenderable","preRender","invokeEvent","type","originalBackground","getBackgroundByReference","setBackground","rpasses","getRenderPasses","currentPass","MIN_KNOWN_PASS","MAX_KNOWN_PASS","passRequired","requestDepth","getFramebuffer","savePixelBuffer","processPixelBuffers","index","isPropHit","processSelectorPixelBuffers","pass","maximumPointId","maximumCellId","passNo","getPixelData","Uint8Array","fb","buildPropHitList","pixelbuffer","renderProp","setPropColorValueFromInt","renderCompositeIndex","renderAttributeId","attribid","passTypeToString","enumToString","id","Boolean","propColorValue","getPixelInformation","getRawPixelBuffer","getPixelBuffer","attach","w","r","superSetArea","DEFAULT_VALUES","extend","initialValues","Object","assign","setGetArray","setGet","moveToProtected","event"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/OpenGL/HardwareSelector/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport Constants from 'vtk.js/Sources/Rendering/OpenGL/HardwareSelector/Constants';\nimport vtkHardwareSelector from 'vtk.js/Sources/Rendering/Core/HardwareSelector';\nimport vtkOpenGLFramebuffer from 'vtk.js/Sources/Rendering/OpenGL/Framebuffer';\nimport vtkSelectionNode from 'vtk.js/Sources/Common/DataModel/SelectionNode';\nimport vtkDataSet from 'vtk.js/Sources/Common/DataModel/DataSet';\n\nconst { PassTypes } = Constants;\nconst { SelectionContent, SelectionField } = vtkSelectionNode;\nconst { FieldAssociations } = vtkDataSet;\nconst { vtkErrorMacro } = macro;\n\nconst idOffset = 1;\n\nfunction getInfoHash(info) {\n  return `${info.propID} ${info.compositeID}`;\n}\n\nfunction getAlpha(xx, yy, pb, area) {\n  if (!pb) {\n    return 0;\n  }\n  const offset = (yy * (area[2] - area[0] + 1) + xx) * 4;\n  return pb[offset + 3];\n}\n\nfunction convert(xx, yy, pb, area) {\n  if (!pb) {\n    return 0;\n  }\n  const offset = (yy * (area[2] - area[0] + 1) + xx) * 4;\n  const rgb = [];\n  rgb[0] = pb[offset];\n  rgb[1] = pb[offset + 1];\n  rgb[2] = pb[offset + 2];\n  let val = rgb[2];\n  val *= 256;\n  val += rgb[1];\n  val *= 256;\n  val += rgb[0];\n  return val;\n}\n\nfunction getID(low24, high8) {\n  /* eslint-disable no-bitwise */\n  let val = high8;\n  val <<= 24;\n  val |= low24;\n  return val;\n  /* eslint-enable no-bitwise */\n}\n\nfunction getPixelInformationWithData(\n  buffdata,\n  inDisplayPosition,\n  maxDistance,\n  outSelectedPosition\n) {\n  // Base case\n  const maxDist = maxDistance < 0 ? 0 : maxDistance;\n  if (maxDist === 0) {\n    outSelectedPosition[0] = inDisplayPosition[0];\n    outSelectedPosition[1] = inDisplayPosition[1];\n    if (\n      inDisplayPosition[0] < buffdata.area[0] ||\n      inDisplayPosition[0] > buffdata.area[2] ||\n      inDisplayPosition[1] < buffdata.area[1] ||\n      inDisplayPosition[1] > buffdata.area[3]\n    ) {\n      return null;\n    }\n\n    // offset inDisplayPosition based on the lower-left-corner of the Area.\n    const displayPosition = [\n      inDisplayPosition[0] - buffdata.area[0],\n      inDisplayPosition[1] - buffdata.area[1],\n    ];\n\n    const actorid = convert(\n      displayPosition[0],\n      displayPosition[1],\n      buffdata.pixBuffer[PassTypes.ACTOR_PASS],\n      buffdata.area\n    );\n    if (actorid <= 0 || actorid - idOffset >= buffdata.props.length) {\n      // the pixel did not hit any actor.\n      return null;\n    }\n\n    const info = {};\n    info.valid = true;\n\n    info.propID = actorid - idOffset;\n    info.prop = buffdata.props[info.propID];\n\n    let compositeID = convert(\n      displayPosition[0],\n      displayPosition[1],\n      buffdata.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS],\n      buffdata.area\n    );\n    if (compositeID < 0 || compositeID > 0xffffff) {\n      compositeID = 0;\n    }\n    info.compositeID = compositeID - idOffset;\n    if (buffdata.captureZValues) {\n      const offset =\n        (displayPosition[1] * (buffdata.area[2] - buffdata.area[0] + 1) +\n          displayPosition[0]) *\n        4;\n      info.zValue =\n        (256 * buffdata.zBuffer[offset] + buffdata.zBuffer[offset + 1]) /\n        65535.0;\n      info.displayPosition = inDisplayPosition;\n    }\n\n    if (buffdata.pixBuffer[PassTypes.ID_LOW24]) {\n      if (\n        getAlpha(\n          displayPosition[0],\n          displayPosition[1],\n          buffdata.pixBuffer[PassTypes.ID_LOW24],\n          buffdata.area\n        ) === 0.0\n      ) {\n        return info;\n      }\n    }\n\n    const low24 = convert(\n      displayPosition[0],\n      displayPosition[1],\n      buffdata.pixBuffer[PassTypes.ID_LOW24],\n      buffdata.area\n    );\n    const high24 = convert(\n      displayPosition[0],\n      displayPosition[1],\n      buffdata.pixBuffer[PassTypes.ID_HIGH24],\n      buffdata.area\n    );\n    info.attributeID = getID(low24, high24, 0);\n\n    return info;\n  }\n\n  // Iterate over successively growing boxes.\n  // They recursively call the base case to handle single pixels.\n  const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];\n  const curPos = [0, 0];\n  let info = getPixelInformationWithData(\n    buffdata,\n    inDisplayPosition,\n    0,\n    outSelectedPosition\n  );\n  if (info && info.valid) {\n    return info;\n  }\n  for (let dist = 1; dist < maxDist; ++dist) {\n    // Vertical sides of box.\n    for (\n      let y = dispPos[1] > dist ? dispPos[1] - dist : 0;\n      y <= dispPos[1] + dist;\n      ++y\n    ) {\n      curPos[1] = y;\n      if (dispPos[0] >= dist) {\n        curPos[0] = dispPos[0] - dist;\n        info = getPixelInformationWithData(\n          buffdata,\n          curPos,\n          0,\n          outSelectedPosition\n        );\n        if (info && info.valid) {\n          return info;\n        }\n      }\n      curPos[0] = dispPos[0] + dist;\n      info = getPixelInformationWithData(\n        buffdata,\n        curPos,\n        0,\n        outSelectedPosition\n      );\n      if (info && info.valid) {\n        return info;\n      }\n    }\n    // Horizontal sides of box.\n    for (\n      let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0;\n      x <= dispPos[0] + (dist - 1);\n      ++x\n    ) {\n      curPos[0] = x;\n      if (dispPos[1] >= dist) {\n        curPos[1] = dispPos[1] - dist;\n        info = getPixelInformationWithData(\n          buffdata,\n          curPos,\n          0,\n          outSelectedPosition\n        );\n        if (info && info.valid) {\n          return info;\n        }\n      }\n      curPos[1] = dispPos[1] + dist;\n      info = getPixelInformationWithData(\n        buffdata,\n        curPos,\n        0,\n        outSelectedPosition\n      );\n      if (info && info.valid) {\n        return info;\n      }\n    }\n  }\n\n  // nothing hit.\n  outSelectedPosition[0] = inDisplayPosition[0];\n  outSelectedPosition[1] = inDisplayPosition[1];\n  return null;\n}\n\n//-----------------------------------------------------------------------------\nfunction convertSelection(\n  fieldassociation,\n  dataMap,\n  captureZValues,\n  renderer,\n  openGLRenderWindow\n) {\n  const sel = [];\n\n  let count = 0;\n  dataMap.forEach((value, key) => {\n    const child = vtkSelectionNode.newInstance();\n    child.setContentType(SelectionContent.INDICES);\n    switch (fieldassociation) {\n      case FieldAssociations.FIELD_ASSOCIATION_CELLS:\n        child.setFieldType(SelectionField.CELL);\n        break;\n      case FieldAssociations.FIELD_ASSOCIATION_POINTS:\n        child.setFieldType(SelectionField.POINT);\n        break;\n      default:\n        vtkErrorMacro('Unknown field association');\n    }\n    child.getProperties().propID = value.info.propID;\n    child.getProperties().prop = value.info.prop;\n    child.getProperties().compositeID = value.info.compositeID;\n    child.getProperties().attributeID = value.info.attributeID;\n    child.getProperties().pixelCount = value.pixelCount;\n    if (captureZValues) {\n      child.getProperties().displayPosition = [\n        value.info.displayPosition[0],\n        value.info.displayPosition[1],\n        value.info.zValue,\n      ];\n      child.getProperties().worldPosition = openGLRenderWindow.displayToWorld(\n        value.info.displayPosition[0],\n        value.info.displayPosition[1],\n        value.info.zValue,\n        renderer\n      );\n    }\n\n    child.setSelectionList(value.attributeIDs);\n    sel[count] = child;\n    count++;\n  });\n\n  return sel;\n}\n\n//----------------------------------------------------------------------------\nfunction generateSelectionWithData(buffdata, fx1, fy1, fx2, fy2) {\n  const x1 = Math.floor(fx1);\n  const y1 = Math.floor(fy1);\n  const x2 = Math.floor(fx2);\n  const y2 = Math.floor(fy2);\n\n  const dataMap = new Map();\n\n  const outSelectedPosition = [0, 0];\n\n  for (let yy = y1; yy <= y2; yy++) {\n    for (let xx = x1; xx <= x2; xx++) {\n      const pos = [xx, yy];\n      const info = getPixelInformationWithData(\n        buffdata,\n        pos,\n        0,\n        outSelectedPosition\n      );\n      if (info && info.valid) {\n        const hash = getInfoHash(info);\n        if (!dataMap.has(hash)) {\n          dataMap.set(hash, {\n            info,\n            pixelCount: 1,\n            attributeIDs: [info.attributeID],\n          });\n        } else {\n          const dmv = dataMap.get(hash);\n          dmv.pixelCount++;\n          if (buffdata.captureZValues) {\n            if (info.zValue < dmv.info.zValue) {\n              dmv.info = info;\n            }\n          }\n          if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {\n            dmv.attributeIDs.push(info.attributeID);\n          }\n        }\n      }\n    }\n  }\n  return convertSelection(\n    buffdata.fieldAssociation,\n    dataMap,\n    buffdata.captureZValues,\n    buffdata.renderer,\n    buffdata.openGLRenderWindow\n  );\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLHardwareSelector methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLHardwareSelector(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLHardwareSelector');\n\n  //----------------------------------------------------------------------------\n  publicAPI.releasePixBuffers = () => {\n    model.rawPixBuffer = [];\n    model.pixBuffer = [];\n    model.zBuffer = null;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.beginSelection = () => {\n    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(\n      model._renderer\n    );\n    model.maxAttributeId = 0;\n\n    const size = model._openGLRenderWindow.getSize();\n    if (!model.framebuffer) {\n      model.framebuffer = vtkOpenGLFramebuffer.newInstance();\n      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.framebuffer.saveCurrentBindingsAndBuffers();\n      model.framebuffer.create(size[0], size[1]);\n      // this calls model.framebuffer.bind()\n      model.framebuffer.populateFramebuffer();\n    } else {\n      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.framebuffer.saveCurrentBindingsAndBuffers();\n      const fbSize = model.framebuffer.getSize();\n      if (fbSize[0] !== size[0] || fbSize[1] !== size[1]) {\n        model.framebuffer.create(size[0], size[1]);\n        // this calls model.framebuffer.bind()\n        model.framebuffer.populateFramebuffer();\n      } else {\n        model.framebuffer.bind();\n      }\n    }\n\n    model._openGLRenderer.clear();\n    model._openGLRenderer.setSelector(publicAPI);\n    model.hitProps = {};\n    model.propPixels = {};\n    model.props = [];\n    publicAPI.releasePixBuffers();\n\n    if (model.fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      const gl = model._openGLRenderWindow.getContext();\n      const originalBlending = gl.isEnabled(gl.BLEND);\n      gl.disable(gl.BLEND);\n      model._openGLRenderWindow.traverseAllPasses();\n      model._renderer.setPreserveDepthBuffer(true);\n      if (originalBlending) {\n        gl.enable(gl.BLEND);\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.endSelection = () => {\n    model.hitProps = {};\n    model._openGLRenderer.setSelector(null);\n    model.framebuffer.restorePreviousBindingsAndBuffers();\n    model._renderer.setPreserveDepthBuffer(false);\n  };\n\n  publicAPI.preCapturePass = () => {\n    const gl = model._openGLRenderWindow.getContext();\n    // Disable blending\n    model.originalBlending = gl.isEnabled(gl.BLEND);\n    gl.disable(gl.BLEND);\n  };\n\n  publicAPI.postCapturePass = () => {\n    const gl = model._openGLRenderWindow.getContext();\n    // Restore blending if it was enabled prior to the capture\n    if (model.originalBlending) {\n      gl.enable(gl.BLEND);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.select = () => {\n    let sel = null;\n    if (publicAPI.captureBuffers()) {\n      sel = publicAPI.generateSelection(\n        model.area[0],\n        model.area[1],\n        model.area[2],\n        model.area[3]\n      );\n      publicAPI.releasePixBuffers();\n    }\n    return sel;\n  };\n\n  publicAPI.getSourceDataAsync = async (renderer, fx1, fy1, fx2, fy2) => {\n    // assign the renderer\n    model._renderer = renderer;\n\n    // set area to all if no arguments provided\n    if (fx1 === undefined) {\n      const size = model._openGLRenderWindow.getSize();\n      publicAPI.setArea(0, 0, size[0] - 1, size[1] - 1);\n    } else {\n      publicAPI.setArea(fx1, fy1, fx2, fy2);\n    }\n    // just do capture buffers and package up the result\n    if (!publicAPI.captureBuffers()) {\n      return false;\n    }\n    const result = {\n      area: [...model.area],\n      pixBuffer: [...model.pixBuffer],\n      captureZValues: model.captureZValues,\n      zBuffer: model.zBuffer,\n      props: [...model.props],\n      fieldAssociation: model.fieldAssociation,\n      renderer,\n      openGLRenderWindow: model._openGLRenderWindow,\n    };\n    result.generateSelection = (...args) =>\n      generateSelectionWithData(result, ...args);\n    return result;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.captureBuffers = () => {\n    if (!model._renderer || !model._openGLRenderWindow) {\n      vtkErrorMacro('Renderer and view must be set before calling Select.');\n      return false;\n    }\n\n    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(\n      model._renderer\n    );\n\n    // todo revisit making selection part of core\n    // then we can do this in core\n    model._openGLRenderWindow.getRenderable().preRender();\n\n    // int rgba[4];\n    // rwin.getColorBufferSizes(rgba);\n    // if (rgba[0] < 8 || rgba[1] < 8 || rgba[2] < 8) {\n    //   vtkErrorMacro(\"Color buffer depth must be at least 8 bit. \"\n    //     \"Currently: \" << rgba[0] << \", \" << rgba[1] << \", \" <<rgba[2]);\n    //   return false;\n    // }\n    publicAPI.invokeEvent({ type: 'StartEvent' });\n\n    // Initialize renderer for selection.\n    // change the renderer's background to black, which will indicate a miss\n    model.originalBackground = model._renderer.getBackgroundByReference();\n    model._renderer.setBackground(0.0, 0.0, 0.0, 0.0);\n    const rpasses = model._openGLRenderWindow.getRenderPasses();\n\n    publicAPI.beginSelection();\n    for (\n      model.currentPass = PassTypes.MIN_KNOWN_PASS;\n      model.currentPass <= PassTypes.MAX_KNOWN_PASS;\n      model.currentPass++\n    ) {\n      if (publicAPI.passRequired(model.currentPass)) {\n        publicAPI.preCapturePass(model.currentPass);\n        if (\n          model.captureZValues &&\n          model.currentPass === PassTypes.ACTOR_PASS &&\n          typeof rpasses[0].requestDepth === 'function' &&\n          typeof rpasses[0].getFramebuffer === 'function'\n        ) {\n          rpasses[0].requestDepth();\n          model._openGLRenderWindow.traverseAllPasses();\n        } else {\n          model._openGLRenderWindow.traverseAllPasses();\n        }\n        publicAPI.postCapturePass(model.currentPass);\n\n        publicAPI.savePixelBuffer(model.currentPass);\n        publicAPI.processPixelBuffers();\n      }\n    }\n    publicAPI.endSelection();\n\n    // restore original background\n    model._renderer.setBackground(model.originalBackground);\n    publicAPI.invokeEvent({ type: 'EndEvent' });\n\n    // restore image, not needed?\n    // model._openGLRenderWindow.traverseAllPasses();\n    return true;\n  };\n\n  publicAPI.processPixelBuffers = () => {\n    model.props.forEach((prop, index) => {\n      if (publicAPI.isPropHit(index)) {\n        prop.processSelectorPixelBuffers(publicAPI, model.propPixels[index]);\n      }\n    });\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.passRequired = (pass) => {\n    if (pass === PassTypes.ID_HIGH24) {\n      if (\n        model.fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS\n      ) {\n        return model.maximumPointId > 0x00ffffff;\n      }\n      if (\n        model.fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_CELLS\n      ) {\n        return model.maximumCellId > 0x00ffffff;\n      }\n    }\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.savePixelBuffer = (passNo) => {\n    model.pixBuffer[passNo] = model._openGLRenderWindow.getPixelData(\n      model.area[0],\n      model.area[1],\n      model.area[2],\n      model.area[3]\n    );\n\n    if (!model.rawPixBuffer[passNo]) {\n      const size =\n        (model.area[2] - model.area[0] + 1) *\n        (model.area[3] - model.area[1] + 1) *\n        4;\n\n      model.rawPixBuffer[passNo] = new Uint8Array(size);\n      model.rawPixBuffer[passNo].set(model.pixBuffer[passNo]);\n    }\n\n    if (passNo === PassTypes.ACTOR_PASS) {\n      if (model.captureZValues) {\n        const rpasses = model._openGLRenderWindow.getRenderPasses();\n        if (\n          typeof rpasses[0].requestDepth === 'function' &&\n          typeof rpasses[0].getFramebuffer === 'function'\n        ) {\n          const fb = rpasses[0].getFramebuffer();\n          fb.saveCurrentBindingsAndBuffers();\n          fb.bind();\n          model.zBuffer = model._openGLRenderWindow.getPixelData(\n            model.area[0],\n            model.area[1],\n            model.area[2],\n            model.area[3]\n          );\n          fb.restorePreviousBindingsAndBuffers();\n        }\n      }\n      publicAPI.buildPropHitList(model.rawPixBuffer[passNo]);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.buildPropHitList = (pixelbuffer) => {\n    let offset = 0;\n    for (let yy = 0; yy <= model.area[3] - model.area[1]; yy++) {\n      for (let xx = 0; xx <= model.area[2] - model.area[0]; xx++) {\n        let val = convert(xx, yy, pixelbuffer, model.area);\n        if (val > 0) {\n          val--;\n          if (!(val in model.hitProps)) {\n            model.hitProps[val] = true;\n            model.propPixels[val] = [];\n          }\n          model.propPixels[val].push(offset * 4);\n        }\n        ++offset;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.renderProp = (prop) => {\n    if (model.currentPass === PassTypes.ACTOR_PASS) {\n      publicAPI.setPropColorValueFromInt(model.props.length + idOffset);\n      model.props.push(prop);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.renderCompositeIndex = (index) => {\n    if (model.currentPass === PassTypes.COMPOSITE_INDEX_PASS) {\n      publicAPI.setPropColorValueFromInt(index + idOffset);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  // TODO: make inline\n  publicAPI.renderAttributeId = (attribid) => {\n    if (attribid < 0) {\n      // negative attribid is valid. It happens when rendering higher order\n      // elements where new points are added for rendering smooth surfaces.\n      return;\n    }\n\n    model.maxAttributeId =\n      attribid > model.maxAttributeId ? attribid : model.maxAttributeId;\n\n    // if (model.currentPass < PassTypes.ID_LOW24) {\n    //   return; // useless...\n    // }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.passTypeToString = (type) => macro.enumToString(PassTypes, type);\n\n  //----------------------------------------------------------------------------\n  publicAPI.isPropHit = (id) => Boolean(model.hitProps[id]);\n\n  publicAPI.setPropColorValueFromInt = (val) => {\n    model.propColorValue[0] = (val % 256) / 255.0;\n    model.propColorValue[1] = (Math.floor(val / 256) % 256) / 255.0;\n    model.propColorValue[2] = (Math.floor(val / 65536) % 256) / 255.0;\n  };\n\n  // info has\n  //   valid\n  //   propId\n  //   prop\n  //   compositeID\n  //   attributeID\n\n  //----------------------------------------------------------------------------\n  publicAPI.getPixelInformation = (\n    inDisplayPosition,\n    maxDistance,\n    outSelectedPosition\n  ) => {\n    // Base case\n    const maxDist = maxDistance < 0 ? 0 : maxDistance;\n    if (maxDist === 0) {\n      outSelectedPosition[0] = inDisplayPosition[0];\n      outSelectedPosition[1] = inDisplayPosition[1];\n      if (\n        inDisplayPosition[0] < model.area[0] ||\n        inDisplayPosition[0] > model.area[2] ||\n        inDisplayPosition[1] < model.area[1] ||\n        inDisplayPosition[1] > model.area[3]\n      ) {\n        return null;\n      }\n\n      // offset inDisplayPosition based on the lower-left-corner of the Area.\n      const displayPosition = [\n        inDisplayPosition[0] - model.area[0],\n        inDisplayPosition[1] - model.area[1],\n      ];\n\n      const actorid = convert(\n        displayPosition[0],\n        displayPosition[1],\n        model.pixBuffer[PassTypes.ACTOR_PASS],\n        model.area\n      );\n      if (actorid <= 0 || actorid - idOffset >= model.props.length) {\n        // the pixel did not hit any actor.\n        return null;\n      }\n\n      const info = {};\n      info.valid = true;\n\n      info.propID = actorid - idOffset;\n      info.prop = model.props[info.propID];\n      let compositeID = convert(\n        displayPosition[0],\n        displayPosition[1],\n        model.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS],\n        model.area\n      );\n      if (compositeID < 0 || compositeID > 0xffffff) {\n        compositeID = 0;\n      }\n      info.compositeID = compositeID - idOffset;\n      if (model.captureZValues) {\n        const offset =\n          (displayPosition[1] * (model.area[2] - model.area[0] + 1) +\n            displayPosition[0]) *\n          4;\n        info.zValue =\n          (256 * model.zBuffer[offset] + model.zBuffer[offset + 1]) / 65535.0;\n        info.displayPosition = inDisplayPosition;\n      }\n\n      // Skip attribute ids if alpha is zero (missed)\n      if (model.pixBuffer[PassTypes.ID_LOW24]) {\n        if (\n          getAlpha(\n            displayPosition[0],\n            displayPosition[1],\n            model.pixBuffer[PassTypes.ID_LOW24],\n            model.area\n          ) === 0.0\n        ) {\n          return info;\n        }\n      }\n\n      const low24 = convert(\n        displayPosition[0],\n        displayPosition[1],\n        model.pixBuffer[PassTypes.ID_LOW24],\n        model.area\n      );\n      const high24 = convert(\n        displayPosition[0],\n        displayPosition[1],\n        model.pixBuffer[PassTypes.ID_HIGH24],\n        model.area\n      );\n      info.attributeID = getID(low24, high24);\n\n      return info;\n    }\n\n    // Iterate over successively growing boxes.\n    // They recursively call the base case to handle single pixels.\n    const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];\n    const curPos = [0, 0];\n    let info = publicAPI.getPixelInformation(\n      inDisplayPosition,\n      0,\n      outSelectedPosition\n    );\n    if (info && info.valid) {\n      return info;\n    }\n    for (let dist = 1; dist < maxDist; ++dist) {\n      // Vertical sides of box.\n      for (\n        let y = dispPos[1] > dist ? dispPos[1] - dist : 0;\n        y <= dispPos[1] + dist;\n        ++y\n      ) {\n        curPos[1] = y;\n        if (dispPos[0] >= dist) {\n          curPos[0] = dispPos[0] - dist;\n          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);\n          if (info && info.valid) {\n            return info;\n          }\n        }\n        curPos[0] = dispPos[0] + dist;\n        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);\n        if (info && info.valid) {\n          return info;\n        }\n      }\n      // Horizontal sides of box.\n      for (\n        let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0;\n        x <= dispPos[0] + (dist - 1);\n        ++x\n      ) {\n        curPos[0] = x;\n        if (dispPos[1] >= dist) {\n          curPos[1] = dispPos[1] - dist;\n          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);\n          if (info && info.valid) {\n            return info;\n          }\n        }\n        curPos[1] = dispPos[1] + dist;\n        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);\n        if (info && info.valid) {\n          return info;\n        }\n      }\n    }\n\n    // nothing hit.\n    outSelectedPosition[0] = inDisplayPosition[0];\n    outSelectedPosition[1] = inDisplayPosition[1];\n    return null;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.generateSelection = (fx1, fy1, fx2, fy2) => {\n    const x1 = Math.floor(fx1);\n    const y1 = Math.floor(fy1);\n    const x2 = Math.floor(fx2);\n    const y2 = Math.floor(fy2);\n\n    const dataMap = new Map();\n\n    const outSelectedPosition = [0, 0];\n\n    for (let yy = y1; yy <= y2; yy++) {\n      for (let xx = x1; xx <= x2; xx++) {\n        const pos = [xx, yy];\n        const info = publicAPI.getPixelInformation(pos, 0, outSelectedPosition);\n        if (info && info.valid) {\n          const hash = getInfoHash(info);\n          if (!dataMap.has(hash)) {\n            dataMap.set(hash, {\n              info,\n              pixelCount: 1,\n              attributeIDs: [info.attributeID],\n            });\n          } else {\n            const dmv = dataMap.get(hash);\n            dmv.pixelCount++;\n            if (model.captureZValues) {\n              if (info.zValue < dmv.info.zValue) {\n                dmv.info = info;\n              }\n            }\n            if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {\n              dmv.attributeIDs.push(info.attributeID);\n            }\n          }\n        }\n      }\n    }\n    return convertSelection(\n      model.fieldAssociation,\n      dataMap,\n      model.captureZValues,\n      model._renderer,\n      model._openGLRenderWindow\n    );\n  };\n\n  publicAPI.getRawPixelBuffer = (passNo) => model.rawPixBuffer[passNo];\n  publicAPI.getPixelBuffer = (passNo) => model.pixBuffer[passNo];\n\n  //----------------------------------------------------------------------------\n\n  publicAPI.attach = (w, r) => {\n    model._openGLRenderWindow = w;\n    model._renderer = r;\n  };\n\n  // override\n  const superSetArea = publicAPI.setArea;\n  publicAPI.setArea = (...args) => {\n    if (superSetArea(...args)) {\n      model.area[0] = Math.floor(model.area[0]);\n      model.area[1] = Math.floor(model.area[1]);\n      model.area[2] = Math.floor(model.area[2]);\n      model.area[3] = Math.floor(model.area[3]);\n      return true;\n    }\n    return false;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  area: undefined,\n  // _renderer: null,\n  // _openGLRenderWindow: null,\n  // _openGLRenderer: null,\n  currentPass: -1,\n  propColorValue: null,\n  props: null,\n  maximumPointId: 0,\n  maximumCellId: 0,\n  idOffset: 1,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  vtkHardwareSelector.extend(publicAPI, model, initialValues);\n\n  model.propColorValue = [0, 0, 0];\n  model.props = [];\n\n  if (!model.area) {\n    model.area = [0, 0, 0, 0];\n  }\n\n  macro.setGetArray(publicAPI, model, ['area'], 4);\n  macro.setGet(publicAPI, model, [\n    '_renderer',\n    'currentPass',\n    '_openGLRenderWindow',\n    'maximumPointId',\n    'maximumCellId',\n  ]);\n\n  macro.setGetArray(publicAPI, model, ['propColorValue'], 3);\n  macro.moveToProtected(publicAPI, model, ['renderer', 'openGLRenderWindow']);\n  macro.event(publicAPI, model, 'event');\n\n  // Object methods\n  vtkOpenGLHardwareSelector(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(\n  extend,\n  'vtkOpenGLHardwareSelector'\n);\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend, ...Constants };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}