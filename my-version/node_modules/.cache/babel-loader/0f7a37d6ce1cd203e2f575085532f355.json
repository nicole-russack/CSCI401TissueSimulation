{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nimport { VtkDataTypes } from 'vtk.js/Sources/Common/Core/DataArray/Constants'; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction extractCellSizes(cellArray) {\n  let currentIdx = 0;\n  return cellArray.filter((value, index) => {\n    if (index === currentIdx) {\n      currentIdx += value + 1;\n      return true;\n    }\n\n    return false;\n  });\n}\n\nfunction getNumberOfCells(cellArray) {\n  let cellId = 0;\n\n  for (let cellArrayIndex = 0; cellArrayIndex < cellArray.length;) {\n    cellArrayIndex += cellArray[cellArrayIndex] + 1;\n    cellId++;\n  }\n\n  return cellId;\n} // ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\n\nexport const STATIC = {\n  extractCellSizes,\n  getNumberOfCells\n}; // ----------------------------------------------------------------------------\n// vtkCellArray methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellArray(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellArray');\n\n  publicAPI.getNumberOfCells = recompute => {\n    if (model.numberOfCells !== undefined && !recompute) {\n      return model.numberOfCells;\n    }\n\n    if (model.cellSizes) {\n      model.numberOfCells = model.cellSizes.length;\n    } else {\n      model.numberOfCells = getNumberOfCells(publicAPI.getData());\n    }\n\n    return model.numberOfCells;\n  };\n\n  publicAPI.getCellSizes = recompute => {\n    if (model.cellSizes !== undefined && !recompute) {\n      return model.cellSizes;\n    }\n\n    model.cellSizes = extractCellSizes(publicAPI.getData());\n    return model.cellSizes;\n  };\n\n  const superSetData = publicAPI.setData;\n\n  publicAPI.setData = typedArray => {\n    superSetData(typedArray, 1);\n    model.numberOfCells = undefined;\n    model.cellSizes = undefined;\n  };\n\n  publicAPI.getCell = loc => {\n    let cellLoc = loc;\n    const numberOfPoints = model.values[cellLoc++];\n    return model.values.subarray(cellLoc, cellLoc + numberOfPoints);\n  };\n\n  const superInitialize = publicAPI.initialize;\n\n  publicAPI.initialize = () => {\n    superInitialize(); // Set to undefined to ensure insertNextCell works correctly\n\n    model.numberOfCells = undefined;\n    model.cellSizes = undefined;\n  };\n\n  publicAPI.insertNextCell = cellPointIds => {\n    const cellId = publicAPI.getNumberOfCells();\n    publicAPI.insertNextTuples([cellPointIds.length, ...cellPointIds]); // By computing the number of cells earlier, we made sure that numberOfCells is defined\n\n    ++model.numberOfCells;\n\n    if (model.cellSizes != null) {\n      model.cellSizes.push(cellPointIds.length);\n    }\n\n    return cellId;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nfunction defaultValues(initialValues) {\n  return {\n    empty: true,\n    numberOfComponents: 1,\n    dataType: VtkDataTypes.UNSIGNED_INT,\n    ...initialValues\n  };\n} // ----------------------------------------------------------------------------\n\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  vtkDataArray.extend(publicAPI, model, defaultValues(initialValues));\n  vtkCellArray(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkCellArray'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend,\n  ...STATIC\n};","map":{"version":3,"names":["macro","vtkDataArray","VtkDataTypes","extractCellSizes","cellArray","currentIdx","filter","value","index","getNumberOfCells","cellId","cellArrayIndex","length","STATIC","vtkCellArray","publicAPI","model","classHierarchy","push","recompute","numberOfCells","undefined","cellSizes","getData","getCellSizes","superSetData","setData","typedArray","getCell","loc","cellLoc","numberOfPoints","values","subarray","superInitialize","initialize","insertNextCell","cellPointIds","insertNextTuples","defaultValues","initialValues","empty","numberOfComponents","dataType","UNSIGNED_INT","extend","newInstance"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Common/Core/CellArray/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nimport { VtkDataTypes } from 'vtk.js/Sources/Common/Core/DataArray/Constants';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction extractCellSizes(cellArray) {\n  let currentIdx = 0;\n  return cellArray.filter((value, index) => {\n    if (index === currentIdx) {\n      currentIdx += value + 1;\n      return true;\n    }\n    return false;\n  });\n}\n\nfunction getNumberOfCells(cellArray) {\n  let cellId = 0;\n  for (let cellArrayIndex = 0; cellArrayIndex < cellArray.length; ) {\n    cellArrayIndex += cellArray[cellArrayIndex] + 1;\n    cellId++;\n  }\n  return cellId;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nexport const STATIC = {\n  extractCellSizes,\n  getNumberOfCells,\n};\n\n// ----------------------------------------------------------------------------\n// vtkCellArray methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellArray(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellArray');\n\n  publicAPI.getNumberOfCells = (recompute) => {\n    if (model.numberOfCells !== undefined && !recompute) {\n      return model.numberOfCells;\n    }\n\n    if (model.cellSizes) {\n      model.numberOfCells = model.cellSizes.length;\n    } else {\n      model.numberOfCells = getNumberOfCells(publicAPI.getData());\n    }\n    return model.numberOfCells;\n  };\n\n  publicAPI.getCellSizes = (recompute) => {\n    if (model.cellSizes !== undefined && !recompute) {\n      return model.cellSizes;\n    }\n\n    model.cellSizes = extractCellSizes(publicAPI.getData());\n    return model.cellSizes;\n  };\n\n  const superSetData = publicAPI.setData;\n  publicAPI.setData = (typedArray) => {\n    superSetData(typedArray, 1);\n    model.numberOfCells = undefined;\n    model.cellSizes = undefined;\n  };\n\n  publicAPI.getCell = (loc) => {\n    let cellLoc = loc;\n    const numberOfPoints = model.values[cellLoc++];\n    return model.values.subarray(cellLoc, cellLoc + numberOfPoints);\n  };\n\n  const superInitialize = publicAPI.initialize;\n  publicAPI.initialize = () => {\n    superInitialize();\n    // Set to undefined to ensure insertNextCell works correctly\n    model.numberOfCells = undefined;\n    model.cellSizes = undefined;\n  };\n\n  publicAPI.insertNextCell = (cellPointIds) => {\n    const cellId = publicAPI.getNumberOfCells();\n    publicAPI.insertNextTuples([cellPointIds.length, ...cellPointIds]);\n    // By computing the number of cells earlier, we made sure that numberOfCells is defined\n    ++model.numberOfCells;\n    if (model.cellSizes != null) {\n      model.cellSizes.push(cellPointIds.length);\n    }\n    return cellId;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(initialValues) {\n  return {\n    empty: true,\n    numberOfComponents: 1,\n    dataType: VtkDataTypes.UNSIGNED_INT,\n    ...initialValues,\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  vtkDataArray.extend(publicAPI, model, defaultValues(initialValues));\n  vtkCellArray(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkCellArray');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend, ...STATIC };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}