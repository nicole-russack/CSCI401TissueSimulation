{"ast":null,"code":"import * as macro from 'vtk.js/Sources/macros';\nimport vtkWebGPUBufferManager from 'vtk.js/Sources/Rendering/WebGPU/BufferManager';\nimport vtkWebGPUShaderCache from 'vtk.js/Sources/Rendering/WebGPU/ShaderCache';\nimport vtkWebGPUTextureManager from 'vtk.js/Sources/Rendering/WebGPU/TextureManager';\n/**\n * provide a simple WeakRefMap class to share device objects based on\n * hash values so that buffers/textures etc can be shared betwen mappers.\n * This is roughly based on WeakLRUCache but without the actual caching\n * behavior. This is just a map of key -> WeakRef(value)\n */\n\n/* eslint-disable no-undef */\n\nexport class WeakRefMap extends Map {\n  constructor() {\n    super();\n    this.registry = new FinalizationRegistry(key => {\n      const entry = super.get(key);\n      if (entry && entry.deref && entry.deref() === undefined) super.delete(key);\n    });\n  }\n\n  getValue(key) {\n    const entry = super.get(key);\n\n    if (entry) {\n      const value = entry.deref();\n      if (value !== undefined) return value;\n      super.delete(key);\n    }\n\n    return undefined;\n  }\n\n  setValue(key, value) {\n    let entry;\n\n    if (value && typeof value === 'object') {\n      entry = new WeakRef(value);\n      this.registry.register(value, key);\n      super.set(key, entry);\n    } // else entry is undefined\n\n\n    return entry;\n  }\n\n}\n/* eslint-enable no-undef */\n// ----------------------------------------------------------------------------\n// vtkWebGPUDevice methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUDevice(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUDevice');\n\n  publicAPI.initialize = handle => {\n    model.handle = handle;\n  };\n\n  publicAPI.createCommandEncoder = () => model.handle.createCommandEncoder();\n\n  publicAPI.submitCommandEncoder = commandEncoder => {\n    model.handle.queue.submit([commandEncoder.finish()]);\n  };\n\n  publicAPI.getShaderModule = sd => model.shaderCache.getShaderModule(sd);\n  /* eslint-disable no-bitwise */\n\n  /* eslint-disable no-undef */\n\n\n  publicAPI.getBindGroupLayout = val => {\n    if (!val.entries) {\n      return null;\n    } // add in basic required values if missing\n\n\n    for (let i = 0; i < val.entries.length; i++) {\n      const ent = val.entries[i];\n      ent.binding = ent.binding || 0;\n      ent.visibility = ent.visibility || GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;\n    } // do we already have one?\n\n\n    const sval = JSON.stringify(val);\n\n    for (let i = 0; i < model.bindGroupLayouts.length; i++) {\n      if (model.bindGroupLayouts[i].sval === sval) {\n        return model.bindGroupLayouts[i].layout;\n      }\n    } // create one and store it\n\n\n    const layout = model.handle.createBindGroupLayout(val); // we actually only store the stringified version\n    // as that is what we always compare against\n\n    model.bindGroupLayouts.push({\n      sval,\n      layout\n    });\n    return layout;\n  };\n\n  publicAPI.getBindGroupLayoutDescription = layout => {\n    for (let i = 0; i < model.bindGroupLayouts.length; i++) {\n      if (model.bindGroupLayouts[i].layout === layout) {\n        return model.bindGroupLayouts[i].sval;\n      }\n    }\n\n    vtkErrorMacro('layout not found');\n    console.trace();\n    return null;\n  };\n\n  publicAPI.getPipeline = hash => {\n    if (hash in model.pipelines) {\n      return model.pipelines[hash];\n    }\n\n    return null;\n  };\n\n  publicAPI.createPipeline = (hash, pipeline) => {\n    pipeline.initialize(publicAPI, hash);\n    model.pipelines[hash] = pipeline;\n  };\n\n  publicAPI.onSubmittedWorkDone = () => model.handle.queue.onSubmittedWorkDone(); // The Device has an object cache that can be used to cache buffers,\n  // textures and other objects that can be shared. The basic approach is to\n  // call getCachedObject with a request and a create function. The request\n  // is based on a hash. The cache lookup just returns any entry that has a\n  // matching hash. If a match isn't found then the create function is\n  // called with any extra arguments.\n  // is the object already cached?\n\n\n  publicAPI.hasCachedObject = hash => model.objectCache.getValue(hash);\n\n  publicAPI.getCachedObject = function (hash, creator) {\n    if (!hash) {\n      vtkErrorMacro('attempt to cache an object without a hash');\n      return null;\n    }\n\n    const existingValue = model.objectCache.getValue(hash);\n\n    if (existingValue) {\n      return existingValue;\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    const createdObject = creator(...args);\n    model.objectCache.setValue(hash, createdObject);\n    return createdObject;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  handle: null,\n  pipelines: null,\n  shaderCache: null,\n  bindGroupLayouts: null,\n  bufferManager: null,\n  textureManager: null\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['handle']);\n  macro.get(publicAPI, model, ['bufferManager', 'shaderCache', 'textureManager']); // this is a weak ref cache implementation, we create it without\n  // an expirer (so it is strictly based on garbage collection and\n  // objects are not held if there are no external references)\n  // model.objectCache = new WeakLRUCache({ expirer: false });\n\n  model.objectCache = new WeakRefMap();\n  model.shaderCache = vtkWebGPUShaderCache.newInstance();\n  model.shaderCache.setDevice(publicAPI);\n  model.bindGroupLayouts = [];\n  model.bufferManager = vtkWebGPUBufferManager.newInstance();\n  model.bufferManager.setDevice(publicAPI);\n  model.textureManager = vtkWebGPUTextureManager.newInstance();\n  model.textureManager.setDevice(publicAPI);\n  model.pipelines = {}; // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkWebGPUDevice(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkWebGPUDevice'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["macro","vtkWebGPUBufferManager","vtkWebGPUShaderCache","vtkWebGPUTextureManager","WeakRefMap","Map","constructor","registry","FinalizationRegistry","key","entry","get","deref","undefined","delete","getValue","value","setValue","WeakRef","register","set","vtkWebGPUDevice","publicAPI","model","classHierarchy","push","initialize","handle","createCommandEncoder","submitCommandEncoder","commandEncoder","queue","submit","finish","getShaderModule","sd","shaderCache","getBindGroupLayout","val","entries","i","length","ent","binding","visibility","GPUShaderStage","VERTEX","FRAGMENT","sval","JSON","stringify","bindGroupLayouts","layout","createBindGroupLayout","getBindGroupLayoutDescription","vtkErrorMacro","console","trace","getPipeline","hash","pipelines","createPipeline","pipeline","onSubmittedWorkDone","hasCachedObject","objectCache","getCachedObject","creator","existingValue","args","createdObject","DEFAULT_VALUES","bufferManager","textureManager","extend","initialValues","Object","assign","obj","setGet","newInstance","setDevice"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/WebGPU/Device/index.js"],"sourcesContent":["import * as macro from 'vtk.js/Sources/macros';\nimport vtkWebGPUBufferManager from 'vtk.js/Sources/Rendering/WebGPU/BufferManager';\nimport vtkWebGPUShaderCache from 'vtk.js/Sources/Rendering/WebGPU/ShaderCache';\nimport vtkWebGPUTextureManager from 'vtk.js/Sources/Rendering/WebGPU/TextureManager';\n\n/**\n * provide a simple WeakRefMap class to share device objects based on\n * hash values so that buffers/textures etc can be shared betwen mappers.\n * This is roughly based on WeakLRUCache but without the actual caching\n * behavior. This is just a map of key -> WeakRef(value)\n */\n\n/* eslint-disable no-undef */\nexport class WeakRefMap extends Map {\n  constructor() {\n    super();\n    this.registry = new FinalizationRegistry((key) => {\n      const entry = super.get(key);\n      if (entry && entry.deref && entry.deref() === undefined)\n        super.delete(key);\n    });\n  }\n\n  getValue(key) {\n    const entry = super.get(key);\n    if (entry) {\n      const value = entry.deref();\n      if (value !== undefined) return value;\n      super.delete(key);\n    }\n    return undefined;\n  }\n\n  setValue(key, value) {\n    let entry;\n    if (value && typeof value === 'object') {\n      entry = new WeakRef(value);\n      this.registry.register(value, key);\n      super.set(key, entry);\n    }\n    // else entry is undefined\n    return entry;\n  }\n}\n/* eslint-enable no-undef */\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUDevice methods\n// ----------------------------------------------------------------------------\nfunction vtkWebGPUDevice(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUDevice');\n  publicAPI.initialize = (handle) => {\n    model.handle = handle;\n  };\n\n  publicAPI.createCommandEncoder = () => model.handle.createCommandEncoder();\n\n  publicAPI.submitCommandEncoder = (commandEncoder) => {\n    model.handle.queue.submit([commandEncoder.finish()]);\n  };\n\n  publicAPI.getShaderModule = (sd) => model.shaderCache.getShaderModule(sd);\n\n  /* eslint-disable no-bitwise */\n  /* eslint-disable no-undef */\n  publicAPI.getBindGroupLayout = (val) => {\n    if (!val.entries) {\n      return null;\n    }\n\n    // add in basic required values if missing\n    for (let i = 0; i < val.entries.length; i++) {\n      const ent = val.entries[i];\n      ent.binding = ent.binding || 0;\n      ent.visibility =\n        ent.visibility || GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;\n    }\n\n    // do we already have one?\n    const sval = JSON.stringify(val);\n    for (let i = 0; i < model.bindGroupLayouts.length; i++) {\n      if (model.bindGroupLayouts[i].sval === sval) {\n        return model.bindGroupLayouts[i].layout;\n      }\n    }\n\n    // create one and store it\n    const layout = model.handle.createBindGroupLayout(val);\n\n    // we actually only store the stringified version\n    // as that is what we always compare against\n    model.bindGroupLayouts.push({ sval, layout });\n    return layout;\n  };\n\n  publicAPI.getBindGroupLayoutDescription = (layout) => {\n    for (let i = 0; i < model.bindGroupLayouts.length; i++) {\n      if (model.bindGroupLayouts[i].layout === layout) {\n        return model.bindGroupLayouts[i].sval;\n      }\n    }\n    vtkErrorMacro('layout not found');\n    console.trace();\n    return null;\n  };\n\n  publicAPI.getPipeline = (hash) => {\n    if (hash in model.pipelines) {\n      return model.pipelines[hash];\n    }\n    return null;\n  };\n\n  publicAPI.createPipeline = (hash, pipeline) => {\n    pipeline.initialize(publicAPI, hash);\n    model.pipelines[hash] = pipeline;\n  };\n\n  publicAPI.onSubmittedWorkDone = () =>\n    model.handle.queue.onSubmittedWorkDone();\n\n  // The Device has an object cache that can be used to cache buffers,\n  // textures and other objects that can be shared. The basic approach is to\n  // call getCachedObject with a request and a create function. The request\n  // is based on a hash. The cache lookup just returns any entry that has a\n  // matching hash. If a match isn't found then the create function is\n  // called with any extra arguments.\n\n  // is the object already cached?\n  publicAPI.hasCachedObject = (hash) => model.objectCache.getValue(hash);\n\n  publicAPI.getCachedObject = (hash, creator, ...args) => {\n    if (!hash) {\n      vtkErrorMacro('attempt to cache an object without a hash');\n      return null;\n    }\n\n    const existingValue = model.objectCache.getValue(hash);\n    if (existingValue) {\n      return existingValue;\n    }\n\n    const createdObject = creator(...args);\n    model.objectCache.setValue(hash, createdObject);\n    return createdObject;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\nconst DEFAULT_VALUES = {\n  handle: null,\n  pipelines: null,\n  shaderCache: null,\n  bindGroupLayouts: null,\n  bufferManager: null,\n  textureManager: null,\n};\n\n// ----------------------------------------------------------------------------\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n\n  macro.setGet(publicAPI, model, ['handle']);\n  macro.get(publicAPI, model, [\n    'bufferManager',\n    'shaderCache',\n    'textureManager',\n  ]);\n\n  // this is a weak ref cache implementation, we create it without\n  // an expirer (so it is strictly based on garbage collection and\n  // objects are not held if there are no external references)\n  // model.objectCache = new WeakLRUCache({ expirer: false });\n  model.objectCache = new WeakRefMap();\n\n  model.shaderCache = vtkWebGPUShaderCache.newInstance();\n  model.shaderCache.setDevice(publicAPI);\n\n  model.bindGroupLayouts = [];\n\n  model.bufferManager = vtkWebGPUBufferManager.newInstance();\n  model.bufferManager.setDevice(publicAPI);\n\n  model.textureManager = vtkWebGPUTextureManager.newInstance();\n  model.textureManager.setDevice(publicAPI);\n\n  model.pipelines = {};\n\n  // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n  vtkWebGPUDevice(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\nexport const newInstance = macro.newInstance(extend, 'vtkWebGPUDevice');\n\n// ----------------------------------------------------------------------------\nexport default {\n  newInstance,\n  extend,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}