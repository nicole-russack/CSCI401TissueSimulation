{"ast":null,"code":"import * as macro from 'vtk.js/Sources/macros';\nimport vtkWebGPUShaderCache from 'vtk.js/Sources/Rendering/WebGPU/ShaderCache'; // methods we forward to the handle\n\nconst forwarded = ['setBindGroup', 'setIndexBuffer', 'setVertexBuffer', 'draw', 'drawIndexed']; // ----------------------------------------------------------------------------\n// vtkWebGPURenderEncoder methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPURenderEncoder(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPURenderEncoder');\n\n  publicAPI.begin = encoder => {\n    model.drawCallbacks = [];\n    model.handle = encoder.beginRenderPass(model.description);\n\n    if (model.label) {\n      model.handle.pushDebugGroup(model.label);\n    }\n  };\n\n  publicAPI.end = () => {\n    // loop over registered pipelines and their callbacks\n    for (let i = 0; i < model.drawCallbacks.length; i++) {\n      const pStruct = model.drawCallbacks[i];\n      const pl = pStruct.pipeline;\n      publicAPI.setPipeline(pl);\n\n      for (let cb = 0; cb < pStruct.callbacks.length; cb++) {\n        pStruct.callbacks[cb](publicAPI);\n      }\n    }\n\n    if (model.label) {\n      model.handle.popDebugGroup();\n    }\n\n    model.handle.end();\n    model.boundPipeline = null;\n  };\n\n  publicAPI.setPipeline = pl => {\n    if (model.boundPipeline === pl) {\n      return;\n    }\n\n    model.handle.setPipeline(pl.getHandle());\n    const pd = pl.getPipelineDescription(); // check attachment state\n\n    if (model.colorTextureViews.length !== pd.fragment.targets.length) {\n      console.log(`mismatched attachment counts on pipeline ${pd.fragment.targets.length} while encoder has ${model.colorTextureViews.length}`);\n      console.trace();\n    } else {\n      for (let i = 0; i < model.colorTextureViews.length; i++) {\n        const fmt = model.colorTextureViews[i].getTexture()?.getFormat();\n\n        if (fmt && fmt !== pd.fragment.targets[i].format) {\n          console.log(`mismatched attachments for attachment ${i} on pipeline ${pd.fragment.targets[i].format} while encoder has ${fmt}`);\n          console.trace();\n        }\n      }\n    } // check depth buffer\n\n\n    if (!model.depthTextureView !== !('depthStencil' in pd)) {\n      console.log('mismatched depth attachments');\n      console.trace();\n    } else if (model.depthTextureView) {\n      const dfmt = model.depthTextureView.getTexture()?.getFormat();\n\n      if (dfmt && dfmt !== pd.depthStencil.format) {\n        console.log(`mismatched depth attachments on pipeline ${pd.depthStencil.format} while encoder has ${dfmt}`);\n        console.trace();\n      }\n    }\n\n    model.boundPipeline = pl;\n  };\n\n  publicAPI.replaceShaderCode = pipeline => {\n    model.replaceShaderCodeFunction(pipeline);\n  };\n\n  publicAPI.setColorTextureView = (idx, view) => {\n    if (model.colorTextureViews[idx] === view) {\n      return;\n    }\n\n    model.colorTextureViews[idx] = view;\n  };\n\n  publicAPI.activateBindGroup = bg => {\n    const device = model.boundPipeline.getDevice();\n    const midx = model.boundPipeline.getBindGroupLayoutCount(bg.getLabel());\n    model.handle.setBindGroup(midx, bg.getBindGroup(device)); // verify bind group layout matches\n\n    const bgl1 = device.getBindGroupLayoutDescription(bg.getBindGroupLayout(device));\n    const bgl2 = device.getBindGroupLayoutDescription(model.boundPipeline.getBindGroupLayout(midx));\n\n    if (bgl1 !== bgl2) {\n      console.log(`renderEncoder ${model.pipelineHash} mismatched bind group layouts bind group has\\n${bgl1}\\n versus pipeline\\n${bgl2}\\n`);\n      console.trace();\n    }\n  };\n\n  publicAPI.attachTextureViews = () => {\n    // for each texture create a view if we do not already have one\n    for (let i = 0; i < model.colorTextureViews.length; i++) {\n      if (!model.description.colorAttachments[i]) {\n        model.description.colorAttachments[i] = {\n          view: model.colorTextureViews[i].getHandle()\n        };\n      } else {\n        model.description.colorAttachments[i].view = model.colorTextureViews[i].getHandle();\n      }\n    }\n\n    if (model.depthTextureView) {\n      model.description.depthStencilAttachment.view = model.depthTextureView.getHandle();\n    }\n  }; // register pipeline callbacks from a mapper\n\n\n  publicAPI.registerDrawCallback = (pipeline, cb) => {\n    // if there is a matching pipeline just add the cb\n    for (let i = 0; i < model.drawCallbacks.length; i++) {\n      if (model.drawCallbacks[i].pipeline === pipeline) {\n        model.drawCallbacks[i].callbacks.push(cb);\n        return;\n      }\n    }\n\n    model.drawCallbacks.push({\n      pipeline,\n      callbacks: [cb]\n    });\n  }; // simple forwarders\n\n\n  for (let i = 0; i < forwarded.length; i++) {\n    publicAPI[forwarded[i]] = function () {\n      return model.handle[forwarded[i]](...arguments);\n    };\n  }\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  description: null,\n  handle: null,\n  boundPipeline: null,\n  pipelineHash: null,\n  pipelineSettings: null,\n  replaceShaderCodeFunction: null,\n  depthTextureView: null,\n  label: null\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  model.description = {\n    colorAttachments: [{\n      view: undefined,\n      loadOp: 'load',\n      storeOp: 'store'\n    }],\n    depthStencilAttachment: {\n      view: undefined,\n      depthLoadOp: 'clear',\n      depthClearValue: 0.0,\n      depthStoreOp: 'store'\n    }\n  }; // default shader code just writes out the computedColor\n\n  model.replaceShaderCodeFunction = pipeline => {\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addOutput('vec4<f32>', 'outColor');\n    let code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::RenderEncoder::Impl', ['output.outColor = computedColor;']).result;\n    fDesc.setCode(code);\n  }; // default pipeline settings\n\n\n  model.pipelineSettings = {\n    primitive: {\n      cullMode: 'none'\n    },\n    depthStencil: {\n      depthWriteEnabled: true,\n      depthCompare: 'greater-equal',\n      format: 'depth32float'\n    },\n    fragment: {\n      targets: [{\n        format: 'rgba16float',\n        blend: {\n          color: {\n            srcFactor: 'src-alpha',\n            dstFactor: 'one-minus-src-alpha'\n          },\n          alpha: {\n            srcfactor: 'one',\n            dstFactor: 'one-minus-src-alpha'\n          }\n        }\n      }]\n    }\n  };\n  model.colorTextureViews = [];\n  macro.get(publicAPI, model, ['boundPipeline', 'colorTextureViews']);\n  macro.setGet(publicAPI, model, ['depthTextureView', 'description', 'handle', 'label', 'pipelineHash', 'pipelineSettings', 'replaceShaderCodeFunction']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkWebGPURenderEncoder(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkWebGPURenderEncoder'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["macro","vtkWebGPUShaderCache","forwarded","vtkWebGPURenderEncoder","publicAPI","model","classHierarchy","push","begin","encoder","drawCallbacks","handle","beginRenderPass","description","label","pushDebugGroup","end","i","length","pStruct","pl","pipeline","setPipeline","cb","callbacks","popDebugGroup","boundPipeline","getHandle","pd","getPipelineDescription","colorTextureViews","fragment","targets","console","log","trace","fmt","getTexture","getFormat","format","depthTextureView","dfmt","depthStencil","replaceShaderCode","replaceShaderCodeFunction","setColorTextureView","idx","view","activateBindGroup","bg","device","getDevice","midx","getBindGroupLayoutCount","getLabel","setBindGroup","getBindGroup","bgl1","getBindGroupLayoutDescription","getBindGroupLayout","bgl2","pipelineHash","attachTextureViews","colorAttachments","depthStencilAttachment","registerDrawCallback","DEFAULT_VALUES","pipelineSettings","extend","initialValues","Object","assign","obj","undefined","loadOp","storeOp","depthLoadOp","depthClearValue","depthStoreOp","fDesc","getShaderDescription","addOutput","code","getCode","substitute","result","setCode","primitive","cullMode","depthWriteEnabled","depthCompare","blend","color","srcFactor","dstFactor","alpha","srcfactor","get","setGet","newInstance"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/WebGPU/RenderEncoder/index.js"],"sourcesContent":["import * as macro from 'vtk.js/Sources/macros';\nimport vtkWebGPUShaderCache from 'vtk.js/Sources/Rendering/WebGPU/ShaderCache';\n\n// methods we forward to the handle\nconst forwarded = [\n  'setBindGroup',\n  'setIndexBuffer',\n  'setVertexBuffer',\n  'draw',\n  'drawIndexed',\n];\n\n// ----------------------------------------------------------------------------\n// vtkWebGPURenderEncoder methods\n// ----------------------------------------------------------------------------\nfunction vtkWebGPURenderEncoder(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPURenderEncoder');\n\n  publicAPI.begin = (encoder) => {\n    model.drawCallbacks = [];\n    model.handle = encoder.beginRenderPass(model.description);\n    if (model.label) {\n      model.handle.pushDebugGroup(model.label);\n    }\n  };\n\n  publicAPI.end = () => {\n    // loop over registered pipelines and their callbacks\n    for (let i = 0; i < model.drawCallbacks.length; i++) {\n      const pStruct = model.drawCallbacks[i];\n      const pl = pStruct.pipeline;\n\n      publicAPI.setPipeline(pl);\n\n      for (let cb = 0; cb < pStruct.callbacks.length; cb++) {\n        pStruct.callbacks[cb](publicAPI);\n      }\n    }\n    if (model.label) {\n      model.handle.popDebugGroup();\n    }\n    model.handle.end();\n    model.boundPipeline = null;\n  };\n\n  publicAPI.setPipeline = (pl) => {\n    if (model.boundPipeline === pl) {\n      return;\n    }\n    model.handle.setPipeline(pl.getHandle());\n    const pd = pl.getPipelineDescription();\n\n    // check attachment state\n    if (model.colorTextureViews.length !== pd.fragment.targets.length) {\n      console.log(\n        `mismatched attachment counts on pipeline ${pd.fragment.targets.length} while encoder has ${model.colorTextureViews.length}`\n      );\n      console.trace();\n    } else {\n      for (let i = 0; i < model.colorTextureViews.length; i++) {\n        const fmt = model.colorTextureViews[i].getTexture()?.getFormat();\n        if (fmt && fmt !== pd.fragment.targets[i].format) {\n          console.log(\n            `mismatched attachments for attachment ${i} on pipeline ${pd.fragment.targets[i].format} while encoder has ${fmt}`\n          );\n          console.trace();\n        }\n      }\n    }\n\n    // check depth buffer\n    if (!model.depthTextureView !== !('depthStencil' in pd)) {\n      console.log('mismatched depth attachments');\n      console.trace();\n    } else if (model.depthTextureView) {\n      const dfmt = model.depthTextureView.getTexture()?.getFormat();\n      if (dfmt && dfmt !== pd.depthStencil.format) {\n        console.log(\n          `mismatched depth attachments on pipeline ${pd.depthStencil.format} while encoder has ${dfmt}`\n        );\n        console.trace();\n      }\n    }\n    model.boundPipeline = pl;\n  };\n\n  publicAPI.replaceShaderCode = (pipeline) => {\n    model.replaceShaderCodeFunction(pipeline);\n  };\n\n  publicAPI.setColorTextureView = (idx, view) => {\n    if (model.colorTextureViews[idx] === view) {\n      return;\n    }\n    model.colorTextureViews[idx] = view;\n  };\n\n  publicAPI.activateBindGroup = (bg) => {\n    const device = model.boundPipeline.getDevice();\n    const midx = model.boundPipeline.getBindGroupLayoutCount(bg.getLabel());\n    model.handle.setBindGroup(midx, bg.getBindGroup(device));\n    // verify bind group layout matches\n    const bgl1 = device.getBindGroupLayoutDescription(\n      bg.getBindGroupLayout(device)\n    );\n    const bgl2 = device.getBindGroupLayoutDescription(\n      model.boundPipeline.getBindGroupLayout(midx)\n    );\n    if (bgl1 !== bgl2) {\n      console.log(\n        `renderEncoder ${model.pipelineHash} mismatched bind group layouts bind group has\\n${bgl1}\\n versus pipeline\\n${bgl2}\\n`\n      );\n      console.trace();\n    }\n  };\n\n  publicAPI.attachTextureViews = () => {\n    // for each texture create a view if we do not already have one\n    for (let i = 0; i < model.colorTextureViews.length; i++) {\n      if (!model.description.colorAttachments[i]) {\n        model.description.colorAttachments[i] = {\n          view: model.colorTextureViews[i].getHandle(),\n        };\n      } else {\n        model.description.colorAttachments[i].view =\n          model.colorTextureViews[i].getHandle();\n      }\n    }\n    if (model.depthTextureView) {\n      model.description.depthStencilAttachment.view =\n        model.depthTextureView.getHandle();\n    }\n  };\n\n  // register pipeline callbacks from a mapper\n  publicAPI.registerDrawCallback = (pipeline, cb) => {\n    // if there is a matching pipeline just add the cb\n    for (let i = 0; i < model.drawCallbacks.length; i++) {\n      if (model.drawCallbacks[i].pipeline === pipeline) {\n        model.drawCallbacks[i].callbacks.push(cb);\n        return;\n      }\n    }\n\n    model.drawCallbacks.push({ pipeline, callbacks: [cb] });\n  };\n\n  // simple forwarders\n  for (let i = 0; i < forwarded.length; i++) {\n    publicAPI[forwarded[i]] = (...args) => model.handle[forwarded[i]](...args);\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\nconst DEFAULT_VALUES = {\n  description: null,\n  handle: null,\n  boundPipeline: null,\n  pipelineHash: null,\n  pipelineSettings: null,\n  replaceShaderCodeFunction: null,\n  depthTextureView: null,\n  label: null,\n};\n\n// ----------------------------------------------------------------------------\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n\n  model.description = {\n    colorAttachments: [\n      {\n        view: undefined,\n        loadOp: 'load',\n        storeOp: 'store',\n      },\n    ],\n    depthStencilAttachment: {\n      view: undefined,\n      depthLoadOp: 'clear',\n      depthClearValue: 0.0,\n      depthStoreOp: 'store',\n    },\n  };\n\n  // default shader code just writes out the computedColor\n  model.replaceShaderCodeFunction = (pipeline) => {\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addOutput('vec4<f32>', 'outColor');\n    let code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::RenderEncoder::Impl', [\n      'output.outColor = computedColor;',\n    ]).result;\n    fDesc.setCode(code);\n  };\n\n  // default pipeline settings\n  model.pipelineSettings = {\n    primitive: { cullMode: 'none' },\n    depthStencil: {\n      depthWriteEnabled: true,\n      depthCompare: 'greater-equal',\n      format: 'depth32float',\n    },\n    fragment: {\n      targets: [\n        {\n          format: 'rgba16float',\n          blend: {\n            color: {\n              srcFactor: 'src-alpha',\n              dstFactor: 'one-minus-src-alpha',\n            },\n            alpha: { srcfactor: 'one', dstFactor: 'one-minus-src-alpha' },\n          },\n        },\n      ],\n    },\n  };\n\n  model.colorTextureViews = [];\n\n  macro.get(publicAPI, model, ['boundPipeline', 'colorTextureViews']);\n\n  macro.setGet(publicAPI, model, [\n    'depthTextureView',\n    'description',\n    'handle',\n    'label',\n    'pipelineHash',\n    'pipelineSettings',\n    'replaceShaderCodeFunction',\n  ]);\n\n  // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n  vtkWebGPURenderEncoder(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\nexport const newInstance = macro.newInstance(extend, 'vtkWebGPURenderEncoder');\n\n// ----------------------------------------------------------------------------\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}