{"ast":null,"code":"/* eslint-disable no-bitwise */\n// ----------------------------------------------------------------------------\n// Decoding infrastructure\n// ----------------------------------------------------------------------------\nconst REVERSE_LOOKUP = [];\nREVERSE_LOOKUP['-'.charCodeAt(0)] = 62;\nREVERSE_LOOKUP['_'.charCodeAt(0)] = 63;\nconst BASE64_CODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfor (let i = 0; i < BASE64_CODE.length; i++) {\n  REVERSE_LOOKUP[BASE64_CODE.charCodeAt(i)] = i;\n} // ----------------------------------------------------------------------------\n// Base64 analysis\n// ----------------------------------------------------------------------------\n\n\nfunction isValidChar(c) {\n  return REVERSE_LOOKUP[c.charCodeAt(0)] !== undefined;\n}\n\nfunction extractChunks(b64Str) {\n  const strSize = b64Str.length;\n  const chunks = [];\n  let currentChunk = null;\n\n  for (let i = 0; i < strSize; i++) {\n    if (isValidChar(b64Str[i])) {\n      if (!currentChunk) {\n        currentChunk = {\n          start: i,\n          count: 0\n        };\n      }\n\n      currentChunk.count++;\n      currentChunk.end = i;\n    } else if (b64Str[i] === '=' && currentChunk) {\n      // End of chunk (found padding char)\n      chunks.push(currentChunk);\n      currentChunk = null;\n    }\n  }\n\n  if (currentChunk) {\n    chunks.push(currentChunk);\n  }\n\n  return chunks;\n}\n\nfunction writeChunk(b64Str, chunk, dstOffset, uint8) {\n  const {\n    start,\n    count\n  } = chunk;\n  const remain = count % 4;\n  const fourCharProcessCount = Math.floor(count / 4);\n  let charIdx = start;\n  let tmp = null;\n  let offset = dstOffset; // Handle 4=>3\n\n  for (let i = 0; i < fourCharProcessCount; i++) {\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n\n    tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 18;\n\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n\n    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 12;\n\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n\n    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 6;\n\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n\n    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)];\n    uint8[offset++] = tmp >> 16 & 0xff;\n    uint8[offset++] = tmp >> 8 & 0xff;\n    uint8[offset++] = tmp & 0xff;\n  } // Handle remain\n\n\n  switch (remain) {\n    case 3:\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n\n      tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 10;\n\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n\n      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 4;\n\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n\n      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] >> 2;\n      uint8[offset++] = tmp >> 8 & 0xff;\n      uint8[offset++] = tmp & 0xff;\n      break;\n\n    case 2:\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n\n      tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 2;\n\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n\n      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] >> 4;\n      uint8[offset++] = tmp & 0xff;\n      break;\n\n    case 1:\n      throw new Error('BASE64: remain 1 should not happen');\n\n    case 0:\n      break;\n\n    default:\n      break;\n  }\n\n  return offset;\n}\n\nexport function toArrayBuffer(b64Str) {\n  const chunks = extractChunks(b64Str);\n  const totalEncodedLength = chunks[chunks.length - 1].end + 1;\n  const padding = (4 - totalEncodedLength % 4) % 4; // -length mod 4\n  // Any padding chars in the middle of b64Str is to be interpreted as \\x00,\n  // whereas the terminating padding chars are to be interpreted as literal padding.\n\n  const totalSize = (totalEncodedLength + padding) * 3 / 4 - padding;\n  const arrayBuffer = new ArrayBuffer(totalSize);\n  const view = new Uint8Array(arrayBuffer);\n  let dstOffset = 0;\n\n  for (let i = 0; i < chunks.length; i++) {\n    dstOffset += writeChunk(b64Str, chunks[i], dstOffset, view);\n    dstOffset += (4 - chunks[i].count % 4) % 4;\n  }\n\n  return arrayBuffer;\n}\n\nfunction encodeTriplet(v1, v2, v3) {\n  const triplet = (v1 << 16) + (v2 << 8) + v3;\n  return BASE64_CODE[triplet >> 18] + BASE64_CODE[triplet >> 12 & 0x3f] + BASE64_CODE[triplet >> 6 & 0x3f] + BASE64_CODE[triplet & 0x3f];\n}\n\nexport function fromArrayBuffer(ab) {\n  const uint8 = new Uint8Array(ab);\n  const leftoverLength = ab.byteLength % 3;\n  const maxTripletIndex = ab.byteLength - leftoverLength;\n  const segments = Array(maxTripletIndex / 3);\n\n  for (let i = 0; i < segments.length; i++) {\n    const bufOffset = i * 3;\n    segments[i] = encodeTriplet(uint8[bufOffset], uint8[bufOffset + 1], uint8[bufOffset + 2]);\n  }\n\n  if (leftoverLength > 0) {\n    const segment = encodeTriplet(uint8[maxTripletIndex], uint8[maxTripletIndex + 1] || 0, uint8[maxTripletIndex + 2] || 0);\n\n    if (leftoverLength === 1) {\n      segments.push(`${segment.substr(0, 2)}==`);\n    } else if (leftoverLength === 2) {\n      segments.push(`${segment.substr(0, 3)}=`);\n    }\n  }\n\n  return segments.join('');\n}\nexport default {\n  toArrayBuffer,\n  fromArrayBuffer\n};","map":{"version":3,"names":["REVERSE_LOOKUP","charCodeAt","BASE64_CODE","i","length","isValidChar","c","undefined","extractChunks","b64Str","strSize","chunks","currentChunk","start","count","end","push","writeChunk","chunk","dstOffset","uint8","remain","fourCharProcessCount","Math","floor","charIdx","tmp","offset","Error","toArrayBuffer","totalEncodedLength","padding","totalSize","arrayBuffer","ArrayBuffer","view","Uint8Array","encodeTriplet","v1","v2","v3","triplet","fromArrayBuffer","ab","leftoverLength","byteLength","maxTripletIndex","segments","Array","bufOffset","segment","substr","join"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Common/Core/Base64/index.js"],"sourcesContent":["/* eslint-disable no-bitwise */\n\n// ----------------------------------------------------------------------------\n// Decoding infrastructure\n// ----------------------------------------------------------------------------\n\nconst REVERSE_LOOKUP = [];\nREVERSE_LOOKUP['-'.charCodeAt(0)] = 62;\nREVERSE_LOOKUP['_'.charCodeAt(0)] = 63;\n\nconst BASE64_CODE =\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor (let i = 0; i < BASE64_CODE.length; i++) {\n  REVERSE_LOOKUP[BASE64_CODE.charCodeAt(i)] = i;\n}\n\n// ----------------------------------------------------------------------------\n// Base64 analysis\n// ----------------------------------------------------------------------------\n\nfunction isValidChar(c) {\n  return REVERSE_LOOKUP[c.charCodeAt(0)] !== undefined;\n}\n\nfunction extractChunks(b64Str) {\n  const strSize = b64Str.length;\n  const chunks = [];\n\n  let currentChunk = null;\n  for (let i = 0; i < strSize; i++) {\n    if (isValidChar(b64Str[i])) {\n      if (!currentChunk) {\n        currentChunk = { start: i, count: 0 };\n      }\n      currentChunk.count++;\n      currentChunk.end = i;\n    } else if (b64Str[i] === '=' && currentChunk) {\n      // End of chunk (found padding char)\n      chunks.push(currentChunk);\n      currentChunk = null;\n    }\n  }\n\n  if (currentChunk) {\n    chunks.push(currentChunk);\n  }\n  return chunks;\n}\n\nfunction writeChunk(b64Str, chunk, dstOffset, uint8) {\n  const { start, count } = chunk;\n  const remain = count % 4;\n  const fourCharProcessCount = Math.floor(count / 4);\n  let charIdx = start;\n  let tmp = null;\n  let offset = dstOffset;\n\n  // Handle 4=>3\n  for (let i = 0; i < fourCharProcessCount; i++) {\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n    tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 18;\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 12;\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 6;\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)];\n\n    uint8[offset++] = (tmp >> 16) & 0xff;\n    uint8[offset++] = (tmp >> 8) & 0xff;\n    uint8[offset++] = tmp & 0xff;\n  }\n\n  // Handle remain\n  switch (remain) {\n    case 3:\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 10;\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 4;\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] >> 2;\n      uint8[offset++] = (tmp >> 8) & 0xff;\n      uint8[offset++] = tmp & 0xff;\n      break;\n    case 2:\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 2;\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] >> 4;\n      uint8[offset++] = tmp & 0xff;\n      break;\n    case 1:\n      throw new Error('BASE64: remain 1 should not happen');\n    case 0:\n      break;\n    default:\n      break;\n  }\n\n  return offset;\n}\n\nexport function toArrayBuffer(b64Str) {\n  const chunks = extractChunks(b64Str);\n  const totalEncodedLength = chunks[chunks.length - 1].end + 1;\n  const padding = (4 - (totalEncodedLength % 4)) % 4; // -length mod 4\n  // Any padding chars in the middle of b64Str is to be interpreted as \\x00,\n  // whereas the terminating padding chars are to be interpreted as literal padding.\n  const totalSize = ((totalEncodedLength + padding) * 3) / 4 - padding;\n\n  const arrayBuffer = new ArrayBuffer(totalSize);\n  const view = new Uint8Array(arrayBuffer);\n  let dstOffset = 0;\n  for (let i = 0; i < chunks.length; i++) {\n    dstOffset += writeChunk(b64Str, chunks[i], dstOffset, view);\n    dstOffset += (4 - (chunks[i].count % 4)) % 4;\n  }\n\n  return arrayBuffer;\n}\n\nfunction encodeTriplet(v1, v2, v3) {\n  const triplet = (v1 << 16) + (v2 << 8) + v3;\n  return (\n    BASE64_CODE[triplet >> 18] +\n    BASE64_CODE[(triplet >> 12) & 0x3f] +\n    BASE64_CODE[(triplet >> 6) & 0x3f] +\n    BASE64_CODE[triplet & 0x3f]\n  );\n}\n\nexport function fromArrayBuffer(ab) {\n  const uint8 = new Uint8Array(ab);\n  const leftoverLength = ab.byteLength % 3;\n  const maxTripletIndex = ab.byteLength - leftoverLength;\n  const segments = Array(maxTripletIndex / 3);\n  for (let i = 0; i < segments.length; i++) {\n    const bufOffset = i * 3;\n    segments[i] = encodeTriplet(\n      uint8[bufOffset],\n      uint8[bufOffset + 1],\n      uint8[bufOffset + 2]\n    );\n  }\n  if (leftoverLength > 0) {\n    const segment = encodeTriplet(\n      uint8[maxTripletIndex],\n      uint8[maxTripletIndex + 1] || 0,\n      uint8[maxTripletIndex + 2] || 0\n    );\n    if (leftoverLength === 1) {\n      segments.push(`${segment.substr(0, 2)}==`);\n    } else if (leftoverLength === 2) {\n      segments.push(`${segment.substr(0, 3)}=`);\n    }\n  }\n  return segments.join('');\n}\n\nexport default {\n  toArrayBuffer,\n  fromArrayBuffer,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}