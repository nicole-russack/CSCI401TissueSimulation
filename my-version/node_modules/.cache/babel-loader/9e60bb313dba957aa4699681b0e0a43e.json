{"ast":null,"code":"/* eslint-disable no-bitwise */\nconst floatView = new Float32Array(1);\nconst int32View = new Int32Array(floatView.buffer);\n/* eslint-disable no-bitwise */\n\n/* This method is faster than the OpenEXR implementation (very often\n * used, eg. in Ogre), with the additional benefit of rounding, inspired\n * by James Tursa?s half-precision code. */\n\nfunction toHalf(val) {\n  floatView[0] = val;\n  const x = int32View[0];\n  let bits = x >> 16 & 0x8000;\n  /* Get the sign */\n\n  let m = x >> 12 & 0x07ff;\n  /* Keep one extra bit for rounding */\n\n  const e = x >> 23 & 0xff;\n  /* Using int is faster here */\n\n  /* If zero, or denormal, or exponent underflows too much for a denormal\n   * half, return signed zero. */\n\n  if (e < 103) {\n    return bits;\n  }\n  /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n\n\n  if (e > 142) {\n    bits |= 0x7c00;\n    /* If exponent was 0xff and one mantissa bit was set, it means NaN,\n     * not Inf, so make sure we set one mantissa bit too. */\n\n    bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;\n    return bits;\n  }\n  /* If exponent underflows but not too much, return a denormal */\n\n\n  if (e < 113) {\n    m |= 0x0800;\n    /* Extra rounding may overflow and set mantissa to 0 and exponent\n     * to 1, which is OK. */\n\n    bits |= (m >> 114 - e) + (m >> 113 - e & 1);\n    return bits;\n  }\n\n  bits |= e - 112 << 10 | m >> 1;\n  /* Extra rounding. An overflow will set mantissa to 0 and increment\n   * the exponent, which is OK. */\n\n  bits += m & 1;\n  return bits;\n}\n\nfunction fromHalf(h) {\n  const s = (h & 0x8000) >> 15;\n  const e = (h & 0x7c00) >> 10;\n  const f = h & 0x03ff;\n\n  if (e === 0) {\n    return (s ? -1 : 1) * 2 ** -14 * (f / 2 ** 10);\n  }\n\n  if (e === 0x1f) {\n    return f ? NaN : (s ? -1 : 1) * Infinity;\n  }\n\n  return (s ? -1 : 1) * 2 ** (e - 15) * (1 + f / 2 ** 10);\n}\n\nexport default {\n  fromHalf,\n  toHalf\n};","map":{"version":3,"names":["floatView","Float32Array","int32View","Int32Array","buffer","toHalf","val","x","bits","m","e","fromHalf","h","s","f","NaN","Infinity"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Common/Core/HalfFloat/index.js"],"sourcesContent":["/* eslint-disable no-bitwise */\n\nconst floatView = new Float32Array(1);\nconst int32View = new Int32Array(floatView.buffer);\n\n/* eslint-disable no-bitwise */\n/* This method is faster than the OpenEXR implementation (very often\n * used, eg. in Ogre), with the additional benefit of rounding, inspired\n * by James Tursa?s half-precision code. */\nfunction toHalf(val) {\n  floatView[0] = val;\n  const x = int32View[0];\n\n  let bits = (x >> 16) & 0x8000; /* Get the sign */\n  let m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */\n  const e = (x >> 23) & 0xff; /* Using int is faster here */\n\n  /* If zero, or denormal, or exponent underflows too much for a denormal\n   * half, return signed zero. */\n  if (e < 103) {\n    return bits;\n  }\n\n  /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n  if (e > 142) {\n    bits |= 0x7c00;\n    /* If exponent was 0xff and one mantissa bit was set, it means NaN,\n     * not Inf, so make sure we set one mantissa bit too. */\n    bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;\n    return bits;\n  }\n\n  /* If exponent underflows but not too much, return a denormal */\n  if (e < 113) {\n    m |= 0x0800;\n    /* Extra rounding may overflow and set mantissa to 0 and exponent\n     * to 1, which is OK. */\n    bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\n    return bits;\n  }\n\n  bits |= ((e - 112) << 10) | (m >> 1);\n  /* Extra rounding. An overflow will set mantissa to 0 and increment\n   * the exponent, which is OK. */\n  bits += m & 1;\n  return bits;\n}\n\nfunction fromHalf(h) {\n  const s = (h & 0x8000) >> 15;\n  const e = (h & 0x7c00) >> 10;\n  const f = h & 0x03ff;\n\n  if (e === 0) {\n    return (s ? -1 : 1) * 2 ** -14 * (f / 2 ** 10);\n  }\n\n  if (e === 0x1f) {\n    return f ? NaN : (s ? -1 : 1) * Infinity;\n  }\n\n  return (s ? -1 : 1) * 2 ** (e - 15) * (1 + f / 2 ** 10);\n}\n\nexport default {\n  fromHalf,\n  toHalf,\n};\n"],"mappings":"AAAA;AAEA,MAAMA,SAAS,GAAG,IAAIC,YAAJ,CAAiB,CAAjB,CAAlB;AACA,MAAMC,SAAS,GAAG,IAAIC,UAAJ,CAAeH,SAAS,CAACI,MAAzB,CAAlB;AAEA;;AACA;AACA;AACA;;AACA,SAASC,MAAT,CAAgBC,GAAhB,EAAqB;EACnBN,SAAS,CAAC,CAAD,CAAT,GAAeM,GAAf;EACA,MAAMC,CAAC,GAAGL,SAAS,CAAC,CAAD,CAAnB;EAEA,IAAIM,IAAI,GAAID,CAAC,IAAI,EAAN,GAAY,MAAvB;EAA+B;;EAC/B,IAAIE,CAAC,GAAIF,CAAC,IAAI,EAAN,GAAY,MAApB;EAA4B;;EAC5B,MAAMG,CAAC,GAAIH,CAAC,IAAI,EAAN,GAAY,IAAtB;EAA4B;;EAE5B;AACF;;EACE,IAAIG,CAAC,GAAG,GAAR,EAAa;IACX,OAAOF,IAAP;EACD;EAED;;;EACA,IAAIE,CAAC,GAAG,GAAR,EAAa;IACXF,IAAI,IAAI,MAAR;IACA;AACJ;;IACIA,IAAI,IAAI,CAACE,CAAC,KAAK,GAAN,GAAY,CAAZ,GAAgB,CAAjB,KAAuBH,CAAC,GAAG,UAAnC;IACA,OAAOC,IAAP;EACD;EAED;;;EACA,IAAIE,CAAC,GAAG,GAAR,EAAa;IACXD,CAAC,IAAI,MAAL;IACA;AACJ;;IACID,IAAI,IAAI,CAACC,CAAC,IAAK,MAAMC,CAAb,KAAqBD,CAAC,IAAK,MAAMC,CAAb,GAAmB,CAAvC,CAAR;IACA,OAAOF,IAAP;EACD;;EAEDA,IAAI,IAAME,CAAC,GAAG,GAAL,IAAa,EAAd,GAAqBD,CAAC,IAAI,CAAlC;EACA;AACF;;EACED,IAAI,IAAIC,CAAC,GAAG,CAAZ;EACA,OAAOD,IAAP;AACD;;AAED,SAASG,QAAT,CAAkBC,CAAlB,EAAqB;EACnB,MAAMC,CAAC,GAAG,CAACD,CAAC,GAAG,MAAL,KAAgB,EAA1B;EACA,MAAMF,CAAC,GAAG,CAACE,CAAC,GAAG,MAAL,KAAgB,EAA1B;EACA,MAAME,CAAC,GAAGF,CAAC,GAAG,MAAd;;EAEA,IAAIF,CAAC,KAAK,CAAV,EAAa;IACX,OAAO,CAACG,CAAC,GAAG,CAAC,CAAJ,GAAQ,CAAV,IAAe,KAAK,CAAC,EAArB,IAA2BC,CAAC,GAAG,KAAK,EAApC,CAAP;EACD;;EAED,IAAIJ,CAAC,KAAK,IAAV,EAAgB;IACd,OAAOI,CAAC,GAAGC,GAAH,GAAS,CAACF,CAAC,GAAG,CAAC,CAAJ,GAAQ,CAAV,IAAeG,QAAhC;EACD;;EAED,OAAO,CAACH,CAAC,GAAG,CAAC,CAAJ,GAAQ,CAAV,IAAe,MAAMH,CAAC,GAAG,EAAV,CAAf,IAAgC,IAAII,CAAC,GAAG,KAAK,EAA7C,CAAP;AACD;;AAED,eAAe;EACbH,QADa;EAEbN;AAFa,CAAf"},"metadata":{},"sourceType":"module"}