{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport WebworkerPromise from 'webworker-promise';\nimport ComputeHistogramWorker from './ComputeHistogram.worker';\n/* eslint-disable no-continue */\n// ----------------------------------------------------------------------------\n// Global structures\n// ----------------------------------------------------------------------------\n\nconst MIN_GAUSSIAN_WIDTH = 0.001;\nconst ACTION_TO_CURSOR = {\n  adjustPosition: '-webkit-grab',\n  adjustHeight: 'row-resize',\n  adjustBias: 'crosshair',\n  adjustWidth: 'col-resize',\n  adjustZoom: 'col-resize'\n};\nconst TOUCH_CLICK = []; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nconst ACTIONS = {\n  adjustPosition(x, y, _ref) {\n    let {\n      originalXY,\n      gaussian,\n      originalGaussian\n    } = _ref;\n    const xOffset = originalGaussian.position - originalXY[0];\n    gaussian.position = x + xOffset;\n    return true;\n  },\n\n  adjustHeight(x, y, _ref2) {\n    let {\n      model,\n      gaussian\n    } = _ref2;\n    gaussian.height = 1 - y;\n    gaussian.height = Math.min(1, Math.max(model.gaussianMinimumHeight, gaussian.height));\n    return true;\n  },\n\n  adjustBias(x, y, _ref3) {\n    let {\n      originalXY,\n      gaussian,\n      originalGaussian\n    } = _ref3;\n    gaussian.xBias = originalGaussian.xBias - (originalXY[0] - x) / gaussian.height;\n    gaussian.yBias = originalGaussian.yBias + 4 * (originalXY[1] - y) / gaussian.height; // Clamps\n\n    gaussian.xBias = Math.max(-1, Math.min(1, gaussian.xBias));\n    gaussian.yBias = Math.max(0, Math.min(2, gaussian.yBias));\n    return true;\n  },\n\n  adjustWidth(x, y, _ref4) {\n    let {\n      originalXY,\n      gaussian,\n      originalGaussian,\n      gaussianSide\n    } = _ref4;\n    gaussian.width = gaussianSide < 0 ? originalGaussian.width - (originalXY[0] - x) : originalGaussian.width + (originalXY[0] - x);\n\n    if (gaussian.width < MIN_GAUSSIAN_WIDTH) {\n      gaussian.width = MIN_GAUSSIAN_WIDTH;\n    }\n\n    return true;\n  },\n\n  adjustZoom(x, y, _ref5) {\n    let {\n      rangeZoom,\n      publicAPI\n    } = _ref5;\n    const delta = rangeZoom[1] - rangeZoom[0];\n    const absNormX = (x - rangeZoom[0]) / delta;\n    const minDelta = Math.abs(absNormX - rangeZoom[0]);\n    const maxDelta = Math.abs(absNormX - rangeZoom[1]);\n    const meanDelta = Math.abs(absNormX - 0.5 * (rangeZoom[0] + rangeZoom[1]));\n\n    if (meanDelta < Math.min(minDelta, maxDelta)) {\n      const halfDelta = delta * 0.5;\n      rangeZoom[0] = Math.min(Math.max(absNormX - halfDelta, 0), rangeZoom[1] - 0.1);\n      rangeZoom[1] = Math.max(Math.min(absNormX + halfDelta, 1), rangeZoom[0] + 0.1);\n    } else if (minDelta < maxDelta) {\n      rangeZoom[0] = Math.min(Math.max(absNormX, 0), rangeZoom[1] - 0.1);\n    } else {\n      rangeZoom[1] = Math.max(Math.min(absNormX, 1), rangeZoom[0] + 0.1);\n    }\n\n    publicAPI.invokeZoomChange(rangeZoom); // The opacity did not changed\n\n    return false;\n  }\n\n}; // ----------------------------------------------------------------------------\n\nfunction computeOpacities(gaussians) {\n  let sampling = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 256;\n  const opacities = [];\n\n  while (opacities.length < sampling) {\n    opacities.push(0);\n  }\n\n  let count = gaussians.length;\n\n  while (count--) {\n    const {\n      position,\n      height,\n      width,\n      xBias,\n      yBias\n    } = gaussians[count];\n\n    for (let i = 0; i < sampling; i++) {\n      const x = i / (sampling - 1); // clamp non-zero values to pos +/- width\n\n      if (x > position + width || x < position - width) {\n        if (opacities[i] < 0.0) {\n          opacities[i] = 0.0;\n        }\n\n        continue;\n      } // non-zero width\n\n\n      const correctedWidth = width < MIN_GAUSSIAN_WIDTH ? MIN_GAUSSIAN_WIDTH : width; // translate the original x to a new x based on the xbias\n\n      let x0 = 0;\n\n      if (xBias === 0 || x === position + xBias) {\n        x0 = x;\n      } else if (x > position + xBias) {\n        if (correctedWidth === xBias) {\n          x0 = position;\n        } else {\n          x0 = position + (x - position - xBias) * (correctedWidth / (correctedWidth - xBias));\n        }\n      } else if (-correctedWidth === xBias) {\n        // (x < pos+xBias)\n        x0 = position;\n      } else {\n        x0 = position - (x - position - xBias) * (correctedWidth / (correctedWidth + xBias));\n      } // center around 0 and normalize to -1,1\n\n\n      const x1 = (x0 - position) / correctedWidth; // do a linear interpolation between:\n      //    a gaussian and a parabola        if 0 < yBias <1\n      //    a parabola and a step function   if 1 < yBias <2\n\n      const h0a = Math.exp(-(4 * x1 * x1));\n      const h0b = 1.0 - x1 * x1;\n      const h0c = 1.0;\n      let h1;\n\n      if (yBias < 1) {\n        h1 = yBias * h0b + (1 - yBias) * h0a;\n      } else {\n        h1 = (2 - yBias) * h0b + (yBias - 1) * h0c;\n      }\n\n      const h2 = height * h1; // perform the MAX over different gaussians, not the sum\n\n      if (h2 > opacities[i]) {\n        opacities[i] = h2;\n      }\n    }\n  }\n\n  return opacities;\n} // ----------------------------------------------------------------------------\n\n\nfunction applyGaussianToPiecewiseFunction(gaussians, sampling, rangeToUse, piecewiseFunction) {\n  const opacities = computeOpacities(gaussians, sampling);\n  const nodes = [];\n  const delta = (rangeToUse[1] - rangeToUse[0]) / (opacities.length - 1);\n  const midpoint = 0.5;\n  const sharpness = 0;\n\n  for (let index = 0; index < opacities.length; index++) {\n    const x = rangeToUse[0] + delta * index;\n    const y = opacities[index];\n    nodes.push({\n      x,\n      y,\n      midpoint,\n      sharpness\n    });\n  }\n\n  piecewiseFunction.setNodes(nodes);\n} // ----------------------------------------------------------------------------\n\n\nfunction drawChart(ctx, area, values) {\n  let style = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n    lineWidth: 1,\n    strokeStyle: '#000'\n  };\n  const verticalScale = area[3];\n  const horizontalScale = area[2] / (values.length - 1);\n  const fill = !!style.fillStyle;\n  const offset = verticalScale + area[1];\n  ctx.lineWidth = style.lineWidth;\n  ctx.strokeStyle = style.strokeStyle;\n  ctx.beginPath();\n  ctx.moveTo(area[0], area[1] + area[3]);\n\n  for (let index = 0; index < values.length; index++) {\n    ctx.lineTo(area[0] + index * horizontalScale, Math.max(area[1], offset - values[index] * verticalScale));\n  }\n\n  if (fill) {\n    ctx.fillStyle = style.fillStyle;\n    ctx.lineTo(area[0] + area[2], area[1] + area[3]);\n\n    if (style.clip) {\n      ctx.clip();\n      return;\n    }\n\n    ctx.fill();\n  }\n\n  ctx.stroke();\n} // ----------------------------------------------------------------------------\n\n\nfunction updateColorCanvas(colorTransferFunction, width, rangeToUse, canvas) {\n  const workCanvas = canvas || document.createElement('canvas');\n  workCanvas.setAttribute('width', width);\n  workCanvas.setAttribute('height', 256);\n  const ctx = workCanvas.getContext('2d');\n  const rgba = colorTransferFunction.getUint8Table(rangeToUse[0], rangeToUse[1], width, 4);\n  const pixelsArea = ctx.getImageData(0, 0, width, 256);\n\n  for (let lineIdx = 0; lineIdx < 256; lineIdx++) {\n    pixelsArea.data.set(rgba, lineIdx * 4 * width);\n  }\n\n  const nbValues = 256 * width * 4;\n  const lineSize = width * 4;\n\n  for (let i = 3; i < nbValues; i += 4) {\n    pixelsArea.data[i] = 255 - Math.floor(i / lineSize);\n  }\n\n  ctx.putImageData(pixelsArea, 0, 0);\n  return workCanvas;\n} // ----------------------------------------------------------------------------\n\n\nfunction updateColorCanvasFromImage(img, width, canvas) {\n  const workCanvas = canvas || document.createElement('canvas');\n  workCanvas.setAttribute('width', width);\n  workCanvas.setAttribute('height', 256);\n  const ctx = workCanvas.getContext('2d');\n  ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, 256);\n  return workCanvas;\n} // ----------------------------------------------------------------------------\n\n\nfunction normalizeCoordinates(x, y, subRectangeArea) {\n  let zoomRange = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, 1];\n  return [zoomRange[0] + (x - subRectangeArea[0]) / subRectangeArea[2] * (zoomRange[1] - zoomRange[0]), (y - subRectangeArea[1]) / subRectangeArea[3]];\n} // ----------------------------------------------------------------------------\n\n\nfunction findGaussian(x, gaussians) {\n  const distances = gaussians.map(g => Math.abs(g.position - x));\n  const min = Math.min(...distances);\n  return distances.indexOf(min);\n} // ----------------------------------------------------------------------------\n\n\nfunction createListener(callback) {\n  let preventDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return e => {\n    const {\n      offsetX,\n      offsetY\n    } = e;\n\n    if (preventDefault) {\n      e.preventDefault();\n    }\n\n    callback(offsetX, offsetY);\n  };\n} // ----------------------------------------------------------------------------\n\n\nfunction createTouchClickListener() {\n  const id = TOUCH_CLICK.length;\n\n  for (var _len = arguments.length, callbacks = new Array(_len), _key = 0; _key < _len; _key++) {\n    callbacks[_key] = arguments[_key];\n  }\n\n  TOUCH_CLICK.push({\n    callbacks,\n    timeout: 0,\n    deltaT: 200,\n    count: 0,\n    ready: false\n  });\n  return id;\n} // ----------------------------------------------------------------------------\n\n\nfunction processTouchClicks() {\n  TOUCH_CLICK.filter(t => t.ready).forEach(touchHandle => {\n    touchHandle.callbacks.forEach(callback => {\n      if (callback.touches === touchHandle.touches && callback.clicks === touchHandle.count) {\n        callback.action(...touchHandle.singleTouche);\n      }\n    }); // Clear state\n\n    touchHandle.ts = 0;\n    touchHandle.count = 0;\n    touchHandle.touches = 0;\n    touchHandle.ready = false;\n  });\n} // ----------------------------------------------------------------------------\n\n\nfunction createTouchListener(id, callback) {\n  let nbTouches = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let preventDefault = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  return e => {\n    const targetBounds = e.target.getBoundingClientRect();\n    const relativeTouches = Array.prototype.map.call(e.touches, t => [t.pageX - targetBounds.left, t.pageY - targetBounds.top]);\n    const singleTouche = relativeTouches.reduce((a, b) => [a[0] + b[0], a[1] + b[1]], [0, 0]).map(v => v / e.touches.length);\n\n    if (e.type === 'touchstart') {\n      clearTimeout(TOUCH_CLICK[id].timeout);\n      TOUCH_CLICK[id].ts = e.timeStamp;\n      TOUCH_CLICK[id].singleTouche = singleTouche;\n      TOUCH_CLICK[id].touches = e.touches.length;\n    } else if (e.type === 'touchmove') {\n      TOUCH_CLICK[id].ts = 0;\n      TOUCH_CLICK[id].count = 0;\n      TOUCH_CLICK[id].ready = false;\n    } else if (e.type === 'touchend') {\n      if (e.timeStamp - TOUCH_CLICK[id].ts < TOUCH_CLICK[id].deltaT) {\n        TOUCH_CLICK[id].count += 1;\n        TOUCH_CLICK[id].ready = true;\n\n        if (preventDefault) {\n          e.preventDefault();\n        }\n\n        TOUCH_CLICK[id].timeout = setTimeout(processTouchClicks, TOUCH_CLICK[id].deltaT);\n      } else {\n        TOUCH_CLICK[id].ready = false;\n      }\n    }\n\n    if (e.touches.length === nbTouches) {\n      callback(...singleTouche);\n\n      if (preventDefault) {\n        e.preventDefault();\n      }\n    }\n  };\n} // ----------------------------------------------------------------------------\n\n\nfunction listenerSelector(condition, ok, ko) {\n  return e => condition() ? ok(e) : ko(e);\n} // ----------------------------------------------------------------------------\n\n\nfunction rescaleArray(array, focusArea) {\n  if (!focusArea) {\n    return array;\n  }\n\n  const maxIdx = array.length - 1;\n  const idxRange = focusArea.map(v => Math.round(v * maxIdx));\n  return array.slice(idxRange[0], idxRange[1] + 1);\n} // ----------------------------------------------------------------------------\n\n\nfunction rescaleValue(value, focusArea) {\n  if (!focusArea) {\n    return value;\n  }\n\n  return (value - focusArea[0]) / (focusArea[1] - focusArea[0]);\n} // ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\n\nexport const STATIC = {\n  applyGaussianToPiecewiseFunction,\n  computeOpacities,\n  createListener,\n  drawChart,\n  findGaussian,\n  listenerSelector,\n  normalizeCoordinates\n}; // ----------------------------------------------------------------------------\n// vtkPiecewiseGaussianWidget methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPiecewiseGaussianWidget(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPiecewiseGaussianWidget');\n\n  if (!model.canvas) {\n    model.canvas = document.createElement('canvas');\n  }\n\n  publicAPI.setContainer = el => {\n    if (model.container && model.container !== el) {\n      model.container.removeChild(model.canvas);\n    }\n\n    if (model.container !== el) {\n      model.container = el;\n\n      if (model.container) {\n        model.container.appendChild(model.canvas);\n      }\n\n      publicAPI.modified();\n    }\n  };\n\n  publicAPI.setGaussians = gaussians => {\n    if (model.gaussians === gaussians) {\n      return;\n    }\n\n    model.gaussians = gaussians;\n    model.opacities = computeOpacities(model.gaussians, model.piecewiseSize);\n    publicAPI.invokeOpacityChange(publicAPI);\n    publicAPI.modified();\n  };\n\n  publicAPI.addGaussian = (position, height, width, xBias, yBias) => {\n    const nextIndex = model.gaussians.length;\n    model.gaussians.push({\n      position,\n      height,\n      width,\n      xBias,\n      yBias\n    });\n    model.opacities = computeOpacities(model.gaussians, model.piecewiseSize);\n    publicAPI.invokeOpacityChange(publicAPI);\n    publicAPI.modified();\n    return nextIndex;\n  };\n\n  publicAPI.removeGaussian = index => {\n    model.gaussians.splice(index, 1);\n    model.opacities = computeOpacities(model.gaussians, model.piecewiseSize);\n    publicAPI.invokeOpacityChange(publicAPI);\n    publicAPI.modified();\n  };\n\n  publicAPI.setSize = (width, height) => {\n    model.canvas.setAttribute('width', width);\n    model.canvas.setAttribute('height', height);\n\n    if (model.size[0] !== width || model.size[1] !== height) {\n      model.size = [width, height];\n      model.colorCanvasMTime = 0;\n      publicAPI.modified();\n    }\n  };\n\n  publicAPI.updateStyle = style => {\n    model.style = { ...model.style,\n      ...style\n    };\n    publicAPI.modified();\n  }; // Method used to compute and show data distribution in the background.\n  // When an array with many components is used, you can provide additional\n  // information to choose which component you want to extract the histogram\n  // from.\n\n\n  publicAPI.setDataArray = function (array) {\n    let {\n      numberOfBinToConsiders = 1,\n      numberOfBinsToSkip = 1,\n      numberOfComponents = 1,\n      component = 0\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    model.histogram = null;\n    model.histogramArray = array;\n    model.dataRange = vtkMath.arrayRange(array, component, numberOfComponents);\n    const [min, max] = model.dataRange;\n    const maxNumberOfWorkers = 4;\n    let arrayStride = Math.floor(array.length / maxNumberOfWorkers) || 1;\n    arrayStride += arrayStride % numberOfComponents;\n    let arrayIndex = 0;\n    const workerChunks = [];\n    const workers = [];\n\n    while (arrayIndex < array.length) {\n      const worker = new ComputeHistogramWorker();\n      workers.push(worker);\n      const workerPromise = new WebworkerPromise(worker);\n      const arrayStart = arrayIndex;\n      const arrayEnd = Math.min(arrayIndex + arrayStride, array.length - 1);\n      const subArray = new array.constructor(array.slice(arrayStart, arrayEnd + 1));\n      workerChunks.push(workerPromise.postMessage({\n        array: subArray,\n        component,\n        numberOfComponents,\n        min,\n        max,\n        numberOfBins: model.numberOfBins\n      }, [subArray.buffer]));\n      arrayIndex += arrayStride;\n    }\n\n    Promise.all(workerChunks).then(subHistograms => {\n      workers.forEach(worker => worker.terminate());\n      model.histogram = new Float32Array(model.numberOfBins);\n      model.histogram.fill(0);\n      subHistograms.forEach(subHistogram => {\n        for (let i = 0, len = subHistogram.length; i < len; ++i) {\n          model.histogram[i] += subHistogram[i];\n        }\n      }); // Smart Rescale Histogram\n\n      const sampleSize = Math.min(numberOfBinToConsiders, model.histogram.length - numberOfBinsToSkip);\n      const sortedArray = Array.from(model.histogram);\n      sortedArray.sort((a, b) => Number(a) - Number(b));\n\n      for (let i = 0; i < numberOfBinsToSkip; i++) {\n        sortedArray.pop();\n      }\n\n      while (sortedArray.length > sampleSize) {\n        sortedArray.shift();\n      }\n\n      const mean = sortedArray.reduce((a, b) => a + b, 0) / sampleSize;\n\n      for (let i = 0, len = model.histogram.length; i < len; ++i) {\n        model.histogram[i] /= mean;\n      }\n\n      publicAPI.modified();\n      setTimeout(publicAPI.render, 0);\n    });\n    publicAPI.modified();\n  };\n\n  publicAPI.onClick = (x, y) => {\n    const [xNormalized, yNormalized] = normalizeCoordinates(x, y, model.graphArea, model.enableRangeZoom ? model.rangeZoom : null);\n\n    if (xNormalized < 0 && model.style.iconSize > 1) {\n      // Control buttons\n      const delta = model.style.iconSize + model.style.padding;\n      let offset = delta;\n      let buttonIdx = 0;\n\n      while (y > offset) {\n        buttonIdx += 1;\n        offset += delta;\n      }\n\n      switch (buttonIdx) {\n        case 0:\n          {\n            const gaussianIdx = publicAPI.addGaussian(0, 1, 0.1, 0, 0);\n            const gaussian = model.gaussians[gaussianIdx];\n            const originalGaussian = { ...gaussian\n            };\n            const action = ACTIONS.adjustPosition;\n            model.activeGaussian = gaussianIdx;\n            model.selectedGaussian = gaussianIdx; // Fake active action\n\n            macro.setImmediate(() => {\n              publicAPI.onDown(x, y);\n              model.dragAction = {\n                originalXY: [0, 0],\n                action,\n                gaussian,\n                originalGaussian\n              };\n            });\n            break;\n          }\n\n        case 1:\n          {\n            if (model.selectedGaussian !== -1) {\n              publicAPI.removeGaussian(model.selectedGaussian);\n            }\n\n            break;\n          }\n\n        default:\n          {\n            model.selectedGaussian = -1;\n            model.dragAction = null;\n          }\n      }\n    } else if (xNormalized < 0 || xNormalized > 1 || yNormalized < 0 || yNormalized > 1) {\n      model.selectedGaussian = -1;\n      model.dragAction = null;\n    } else {\n      const newSelected = findGaussian(xNormalized, model.gaussians);\n\n      if (newSelected !== model.selectedGaussian) {\n        model.selectedGaussian = newSelected;\n        publicAPI.modified();\n      }\n    }\n\n    return true;\n  };\n\n  publicAPI.onHover = (x, y) => {\n    // Determines the interaction region size for adjusting the Gaussian's\n    // height.\n    const tolerance = 20 / model.canvas.height;\n    const [xNormalized, yNormalized] = normalizeCoordinates(x, y, model.graphArea, model.enableRangeZoom ? model.rangeZoom : null);\n    const [xNormalizedAbs] = normalizeCoordinates(x, y, model.graphArea);\n    const newActive = xNormalized < 0 ? model.selectedGaussian : findGaussian(xNormalized, model.gaussians);\n    model.canvas.style.cursor = 'default';\n    const gaussian = model.gaussians[newActive];\n\n    if (model.enableRangeZoom && xNormalizedAbs >= 0 && y < model.graphArea[1] - 6 // circle radius\n    ) {\n      const thirdDelta = (model.rangeZoom[1] - model.rangeZoom[0]) / 3;\n\n      if (xNormalizedAbs < model.rangeZoom[0] + thirdDelta || xNormalizedAbs > model.rangeZoom[1] - thirdDelta) {\n        model.canvas.style.cursor = ACTION_TO_CURSOR.adjustZoom;\n      } else {\n        model.canvas.style.cursor = ACTION_TO_CURSOR.adjustPosition;\n      }\n\n      model.dragAction = {\n        rangeZoom: model.rangeZoom,\n        action: ACTIONS.adjustZoom\n      };\n    } else if (gaussian && xNormalizedAbs >= 0) {\n      const invY = 1 - yNormalized;\n      let actionName = null;\n\n      if (invY > gaussian.height + tolerance) {\n        actionName = 'adjustPosition';\n      } else if (invY > gaussian.height - tolerance) {\n        if (Math.abs(xNormalized - gaussian.position) < tolerance) {\n          actionName = 'adjustHeight';\n        } else {\n          actionName = 'adjustPosition';\n        }\n      } else if (invY > gaussian.height * 0.5 + tolerance) {\n        actionName = 'adjustPosition';\n      } else if (invY > gaussian.height * 0.5 - tolerance) {\n        if (Math.abs(xNormalized - gaussian.position) < tolerance) {\n          actionName = 'adjustBias';\n        } else {\n          actionName = 'adjustPosition';\n        }\n      } else if (invY > tolerance) {\n        actionName = 'adjustPosition';\n      } else {\n        actionName = 'adjustWidth';\n      }\n\n      model.canvas.style.cursor = ACTION_TO_CURSOR[actionName];\n      const action = ACTIONS[actionName];\n      const originalGaussian = { ...gaussian\n      };\n      model.dragAction = {\n        originalXY: [xNormalized, yNormalized],\n        action,\n        gaussian,\n        originalGaussian\n      };\n    }\n\n    if (newActive !== model.activeGaussian) {\n      model.activeGaussian = newActive;\n      publicAPI.modified();\n    }\n\n    return true;\n  };\n\n  publicAPI.onDown = (x, y) => {\n    if (!model.mouseIsDown) {\n      publicAPI.invokeAnimation(true);\n    }\n\n    model.mouseIsDown = true;\n    const xNormalized = normalizeCoordinates(x, y, model.graphArea, model.enableRangeZoom ? model.rangeZoom : null)[0];\n    const newSelected = findGaussian(xNormalized, model.gaussians);\n    model.gaussianSide = 0;\n    const gaussian = model.gaussians[newSelected];\n\n    if (gaussian) {\n      model.gaussianSide = gaussian.position - xNormalized;\n    }\n\n    if (newSelected !== model.selectedGaussian && xNormalized > 0) {\n      model.selectedGaussian = newSelected;\n      publicAPI.modified();\n    }\n\n    return true;\n  };\n\n  publicAPI.onDrag = (x, y) => {\n    if (model.dragAction) {\n      const [xNormalized, yNormalized] = normalizeCoordinates(x, y, model.graphArea, model.enableRangeZoom ? model.rangeZoom : null);\n      const {\n        action\n      } = model.dragAction;\n\n      if (action(xNormalized, yNormalized, {\n        gaussianSide: model.gaussianSide,\n        model,\n        publicAPI,\n        ...model.dragAction\n      })) {\n        model.opacities = computeOpacities(model.gaussians, model.piecewiseSize);\n        publicAPI.invokeOpacityChange(publicAPI, true);\n      }\n\n      publicAPI.modified();\n    }\n\n    return true;\n  };\n\n  publicAPI.onUp = (x, y) => {\n    if (model.mouseIsDown) {\n      publicAPI.invokeAnimation(false);\n    }\n\n    model.mouseIsDown = false;\n    return true;\n  };\n\n  publicAPI.onLeave = (x, y) => {\n    publicAPI.onUp(x, y);\n    model.canvas.style.cursor = 'default';\n    model.activeGaussian = -1;\n    publicAPI.modified();\n    return true;\n  };\n\n  publicAPI.onAddGaussian = (x, y) => {\n    const [xNormalized, yNormalized] = normalizeCoordinates(x, y, model.graphArea, model.enableRangeZoom ? model.rangeZoom : null);\n\n    if (xNormalized >= 0) {\n      publicAPI.addGaussian(xNormalized, 1 - yNormalized, 0.1, 0, 0);\n    }\n\n    return true;\n  };\n\n  publicAPI.onRemoveGaussian = (x, y) => {\n    const xNormalized = normalizeCoordinates(x, y, model.graphArea, model.enableRangeZoom ? model.rangeZoom : null)[0];\n    const newSelected = findGaussian(xNormalized, model.gaussians);\n\n    if (xNormalized >= 0 && newSelected !== -1) {\n      publicAPI.removeGaussian(newSelected);\n    }\n\n    return true;\n  };\n\n  publicAPI.bindMouseListeners = () => {\n    if (!model.listeners) {\n      const isDown = () => !!model.mouseIsDown;\n\n      const touchId = createTouchClickListener({\n        clicks: 1,\n        touches: 1,\n        action: publicAPI.onClick\n      }, {\n        clicks: 2,\n        touches: 1,\n        action: publicAPI.onAddGaussian\n      }, {\n        clicks: 2,\n        touches: 2,\n        action: publicAPI.onRemoveGaussian\n      });\n      model.listeners = {\n        mousemove: listenerSelector(isDown, createListener(publicAPI.onDrag), createListener(publicAPI.onHover)),\n        dblclick: createListener(publicAPI.onAddGaussian),\n        contextmenu: createListener(publicAPI.onRemoveGaussian),\n        click: createListener(publicAPI.onClick),\n        mouseup: createListener(publicAPI.onUp),\n        mousedown: createListener(publicAPI.onDown),\n        mouseout: createListener(publicAPI.onLeave),\n        touchstart: createTouchListener(touchId, macro.chain(publicAPI.onHover, publicAPI.onDown)),\n        touchmove: listenerSelector(isDown, createTouchListener(touchId, publicAPI.onDrag), createTouchListener(touchId, publicAPI.onHover)),\n        touchend: createTouchListener(touchId, publicAPI.onUp, 0) // touchend have 0 touch event...\n\n      };\n      Object.keys(model.listeners).forEach(eventType => {\n        model.canvas.addEventListener(eventType, model.listeners[eventType], false);\n      });\n    }\n  };\n\n  publicAPI.unbindMouseListeners = () => {\n    if (model.listeners) {\n      Object.keys(model.listeners).forEach(eventType => {\n        model.canvas.removeEventListener(eventType, model.listeners[eventType]);\n      });\n      delete model.listeners;\n    }\n  };\n\n  publicAPI.render = () => {\n    const ctx = model.canvas.getContext('2d');\n    ctx.imageSmoothingEnabled = true;\n    const [width, height] = model.size;\n    const offset = model.style.padding;\n    const graphArea = [Math.floor(model.style.iconSize + offset), Math.floor(offset), Math.ceil(width - 2 * offset - model.style.iconSize), Math.ceil(height - 2 * offset)];\n    const zoomControlHeight = model.style.zoomControlHeight;\n\n    if (model.enableRangeZoom) {\n      graphArea[1] += Math.floor(zoomControlHeight);\n      graphArea[3] -= Math.floor(zoomControlHeight);\n    }\n\n    model.graphArea = graphArea; // Clear canvas\n\n    ctx.clearRect(0, 0, width, height);\n    ctx.lineJoin = 'round';\n    ctx.fillStyle = model.style.backgroundColor;\n    ctx.fillRect(...graphArea);\n\n    if (model.style.iconSize > 1) {\n      // Draw icons\n      // +\n      const halfSize = Math.round(model.style.iconSize / 2 - model.style.strokeWidth);\n      const center = Math.round(halfSize + offset + model.style.strokeWidth);\n      ctx.beginPath();\n      ctx.lineWidth = model.style.buttonStrokeWidth;\n      ctx.strokeStyle = model.style.buttonStrokeColor;\n      ctx.arc(center - offset / 2, center, halfSize, 0, 2 * Math.PI, false);\n      ctx.fillStyle = model.style.buttonFillColor;\n      ctx.fill();\n      ctx.stroke();\n      ctx.moveTo(center - halfSize + model.style.strokeWidth + 2 - offset / 2, center);\n      ctx.lineTo(center + halfSize - model.style.strokeWidth - 2 - offset / 2, center);\n      ctx.stroke();\n      ctx.moveTo(center - offset / 2, center - halfSize + model.style.strokeWidth + 2);\n      ctx.lineTo(center - offset / 2, center + halfSize - model.style.strokeWidth - 2);\n      ctx.stroke(); // -\n\n      if (model.selectedGaussian === -1) {\n        ctx.fillStyle = model.style.buttonDisableFillColor;\n        ctx.lineWidth = model.style.buttonDisableStrokeWidth;\n        ctx.strokeStyle = model.style.buttonDisableStrokeColor;\n      } else {\n        ctx.fillStyle = model.style.buttonFillColor;\n        ctx.lineWidth = model.style.buttonStrokeWidth;\n        ctx.strokeStyle = model.style.buttonStrokeColor;\n      }\n\n      ctx.beginPath();\n      ctx.arc(center - offset / 2, center + offset / 2 + model.style.iconSize, halfSize, 0, 2 * Math.PI, false);\n      ctx.fill();\n      ctx.stroke();\n      ctx.moveTo(center - halfSize + model.style.strokeWidth + 2 - offset / 2, center + offset / 2 + model.style.iconSize);\n      ctx.lineTo(center + halfSize - model.style.strokeWidth - 2 - offset / 2, center + offset / 2 + model.style.iconSize);\n      ctx.stroke();\n    } // Draw histogram\n\n\n    if (model.histogram) {\n      drawChart(ctx, graphArea, rescaleArray(model.histogram, model.rangeZoom), {\n        lineWidth: 1,\n        strokeStyle: model.style.histogramColor,\n        fillStyle: model.style.histogramColor\n      });\n    } // Draw gaussians\n\n\n    drawChart(ctx, graphArea, rescaleArray(model.opacities, model.enableRangeZoom && model.rangeZoom), {\n      lineWidth: model.style.strokeWidth,\n      strokeStyle: model.style.strokeColor\n    }); // Draw color function if any\n\n    if (model.colorTransferFunction && model.colorTransferFunction.getSize()) {\n      const rangeToUse = model.dataRange || model.colorTransferFunction.getMappingRange();\n\n      if (!model.colorCanvas || model.colorCanvasMTime !== model.colorTransferFunction.getMTime()) {\n        model.colorCanvasMTime = model.colorTransferFunction.getMTime();\n        model.colorCanvas = updateColorCanvas(model.colorTransferFunction, graphArea[2], rangeToUse, model.colorCanvas);\n      }\n\n      ctx.save();\n      drawChart(ctx, graphArea, rescaleArray(model.opacities, model.enableRangeZoom && model.rangeZoom), {\n        lineWidth: 1,\n        strokeStyle: 'rgba(0,0,0,0)',\n        fillStyle: 'rgba(0,0,0,1)',\n        clip: true\n      }); // Draw the correct portion of the color BG image\n\n      if (model.enableRangeZoom) {\n        ctx.drawImage(model.colorCanvas, model.rangeZoom[0] * graphArea[2], 0, graphArea[2], graphArea[3], graphArea[0], graphArea[1], graphArea[2] / (model.rangeZoom[1] - model.rangeZoom[0]), graphArea[3]);\n      } else {\n        ctx.drawImage(model.colorCanvas, graphArea[0], graphArea[1]);\n      }\n\n      ctx.restore();\n    } else if (model.backgroundImage) {\n      model.colorCanvas = updateColorCanvasFromImage(model.backgroundImage, graphArea[2], model.colorCanvas);\n      ctx.save();\n      drawChart(ctx, graphArea, rescaleArray(model.opacities, model.enableRangeZoom && model.rangeZoom), {\n        lineWidth: 1,\n        strokeStyle: 'rgba(0,0,0,0)',\n        fillStyle: 'rgba(0,0,0,1)',\n        clip: true\n      });\n      ctx.drawImage(model.colorCanvas, graphArea[0], graphArea[1]);\n      ctx.restore();\n    } // Draw zoomed area\n\n\n    if (model.enableRangeZoom) {\n      ctx.fillStyle = model.style.zoomControlColor;\n      ctx.beginPath();\n      ctx.rect(graphArea[0] + model.rangeZoom[0] * graphArea[2], 0, (model.rangeZoom[1] - model.rangeZoom[0]) * graphArea[2], zoomControlHeight);\n      ctx.fill();\n    } // Draw active gaussian\n\n\n    const activeGaussian = model.gaussians[model.activeGaussian] || model.gaussians[model.selectedGaussian];\n\n    if (activeGaussian) {\n      const activeOpacities = computeOpacities([activeGaussian], graphArea[2]);\n      drawChart(ctx, graphArea, rescaleArray(activeOpacities, model.enableRangeZoom && model.rangeZoom), {\n        lineWidth: model.style.activeStrokeWidth,\n        strokeStyle: model.style.activeColor\n      }); // Draw controls\n\n      const xCenter = graphArea[0] + rescaleValue(activeGaussian.position, model.enableRangeZoom && model.rangeZoom) * graphArea[2];\n      const yTop = graphArea[1] + (1 - activeGaussian.height) * graphArea[3];\n      const yMiddle = graphArea[1] + (1 - 0.5 * activeGaussian.height) * graphArea[3];\n      const yBottom = graphArea[1] + graphArea[3];\n      let widthInPixel = activeGaussian.width * graphArea[2];\n\n      if (model.enableRangeZoom) {\n        widthInPixel /= model.rangeZoom[1] - model.rangeZoom[0];\n      }\n\n      ctx.lineWidth = model.style.handleWidth;\n      ctx.strokeStyle = model.style.handleColor;\n      ctx.fillStyle = model.style.backgroundColor;\n      ctx.beginPath();\n      ctx.moveTo(xCenter, graphArea[1] + (1 - activeGaussian.height) * graphArea[3]);\n      ctx.lineTo(xCenter, graphArea[1] + graphArea[3]);\n      ctx.stroke(); // Height\n\n      ctx.beginPath();\n      ctx.arc(xCenter, yTop, 6, 0, 2 * Math.PI);\n      ctx.fill();\n      ctx.stroke(); // Bias\n\n      const radius = Math.min(widthInPixel * 0.1, activeGaussian.height * graphArea[3] * 0.2);\n      ctx.beginPath();\n      ctx.rect(xCenter - radius, yMiddle - radius, radius * 2, radius * 2);\n      ctx.fill();\n      ctx.stroke();\n      ctx.beginPath(); // Width\n\n      const sliderWidth = widthInPixel * 0.8;\n      ctx.rect(xCenter - sliderWidth, yBottom - 5, 2 * sliderWidth, 10);\n      ctx.fill();\n      ctx.stroke();\n    }\n  };\n\n  publicAPI.getOpacityNodes = dataRange => {\n    const rangeToUse = dataRange || model.dataRange;\n    const delta = (rangeToUse[1] - rangeToUse[0]) / (model.opacities.length - 1);\n    const nodes = [];\n    const midpoint = 0.5;\n    const sharpness = 0;\n\n    for (let index = 0; index < model.opacities.length; index++) {\n      const x = rangeToUse[0] + delta * index;\n      const y = model.opacities[index];\n      nodes.push({\n        x,\n        y,\n        midpoint,\n        sharpness\n      });\n    }\n\n    return nodes;\n  };\n\n  publicAPI.applyOpacity = (piecewiseFunction, dataRange) => {\n    const nodes = publicAPI.getOpacityNodes(dataRange);\n    piecewiseFunction.setNodes(nodes);\n  };\n\n  publicAPI.getOpacityRange = dataRange => {\n    const rangeToUse = dataRange || model.dataRange;\n    const delta = (rangeToUse[1] - rangeToUse[0]) / (model.opacities.length - 1);\n    let minIndex = model.opacities.length - 1;\n    let maxIndex = 0;\n\n    for (let index = 0; index < model.opacities.length; index++) {\n      if (model.opacities[index] > 0) {\n        minIndex = Math.min(minIndex, index);\n      }\n\n      if (model.opacities[index] > 0) {\n        maxIndex = Math.max(maxIndex, index);\n      }\n    }\n\n    return [rangeToUse[0] + minIndex * delta, rangeToUse[0] + maxIndex * delta];\n  };\n\n  const enableZoom = publicAPI.setEnableRangeZoom;\n\n  publicAPI.setEnableRangeZoom = v => {\n    const change = enableZoom(v);\n\n    if (change) {\n      model.colorCanvasMTime = 0;\n      model.rangeZoom = [0, 1];\n    }\n\n    return change;\n  };\n\n  const rangeZoom = publicAPI.setRangeZoom;\n\n  publicAPI.setRangeZoom = function () {\n    const change = rangeZoom(...arguments);\n\n    if (change) {\n      model.colorCanvasMTime = 0;\n    }\n\n    return change;\n  }; // Trigger rendering for any modified event\n\n\n  publicAPI.onModified(() => publicAPI.render());\n  publicAPI.setSize(...model.size);\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  histogram: [],\n  numberOfBins: 256,\n  histogramArray: null,\n  dataRange: [0, 1],\n  gaussians: [],\n  opacities: [],\n  size: [600, 300],\n  piecewiseSize: 256,\n  colorCanvasMTime: 0,\n  gaussianMinimumHeight: 0.05,\n  style: {\n    backgroundColor: 'rgba(255, 255, 255, 1)',\n    histogramColor: 'rgba(200, 200, 200, 0.5)',\n    strokeColor: 'rgb(0, 0, 0)',\n    activeColor: 'rgb(0, 0, 150)',\n    buttonDisableFillColor: 'rgba(255, 255, 255, 0.5)',\n    buttonDisableStrokeColor: 'rgba(0, 0, 0, 0.5)',\n    buttonStrokeColor: 'rgba(0, 0, 0, 1)',\n    buttonFillColor: 'rgba(255, 255, 255, 1)',\n    handleColor: 'rgb(0, 150, 0)',\n    strokeWidth: 2,\n    activeStrokeWidth: 3,\n    buttonStrokeWidth: 1.5,\n    handleWidth: 3,\n    iconSize: 20,\n    padding: 10,\n    zoomControlHeight: 10,\n    zoomControlColor: '#999'\n  },\n  activeGaussian: -1,\n  selectedGaussian: -1,\n  enableRangeZoom: true,\n  rangeZoom: [0, 1] // normalized value\n\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Object methods\n\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['piecewiseSize', 'numberOfBins', 'colorTransferFunction', 'backgroundImage', 'enableRangeZoom', 'gaussianMinimumHeight']);\n  macro.setGetArray(publicAPI, model, ['rangeZoom'], 2);\n  macro.get(publicAPI, model, ['size', 'canvas', 'gaussians']);\n  macro.event(publicAPI, model, 'opacityChange');\n  macro.event(publicAPI, model, 'animation');\n  macro.event(publicAPI, model, 'zoomChange'); // Object specific methods\n\n  vtkPiecewiseGaussianWidget(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkPiecewiseGaussianWidget'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend,\n  ...STATIC\n};","map":{"version":3,"names":["macro","vtkMath","WebworkerPromise","ComputeHistogramWorker","MIN_GAUSSIAN_WIDTH","ACTION_TO_CURSOR","adjustPosition","adjustHeight","adjustBias","adjustWidth","adjustZoom","TOUCH_CLICK","ACTIONS","x","y","originalXY","gaussian","originalGaussian","xOffset","position","model","height","Math","min","max","gaussianMinimumHeight","xBias","yBias","gaussianSide","width","rangeZoom","publicAPI","delta","absNormX","minDelta","abs","maxDelta","meanDelta","halfDelta","invokeZoomChange","computeOpacities","gaussians","sampling","opacities","length","push","count","i","correctedWidth","x0","x1","h0a","exp","h0b","h0c","h1","h2","applyGaussianToPiecewiseFunction","rangeToUse","piecewiseFunction","nodes","midpoint","sharpness","index","setNodes","drawChart","ctx","area","values","style","lineWidth","strokeStyle","verticalScale","horizontalScale","fill","fillStyle","offset","beginPath","moveTo","lineTo","clip","stroke","updateColorCanvas","colorTransferFunction","canvas","workCanvas","document","createElement","setAttribute","getContext","rgba","getUint8Table","pixelsArea","getImageData","lineIdx","data","set","nbValues","lineSize","floor","putImageData","updateColorCanvasFromImage","img","drawImage","normalizeCoordinates","subRectangeArea","zoomRange","findGaussian","distances","map","g","indexOf","createListener","callback","preventDefault","e","offsetX","offsetY","createTouchClickListener","id","callbacks","timeout","deltaT","ready","processTouchClicks","filter","t","forEach","touchHandle","touches","clicks","action","singleTouche","ts","createTouchListener","nbTouches","targetBounds","target","getBoundingClientRect","relativeTouches","Array","prototype","call","pageX","left","pageY","top","reduce","a","b","v","type","clearTimeout","timeStamp","setTimeout","listenerSelector","condition","ok","ko","rescaleArray","array","focusArea","maxIdx","idxRange","round","slice","rescaleValue","value","STATIC","vtkPiecewiseGaussianWidget","classHierarchy","setContainer","el","container","removeChild","appendChild","modified","setGaussians","piecewiseSize","invokeOpacityChange","addGaussian","nextIndex","removeGaussian","splice","setSize","size","colorCanvasMTime","updateStyle","setDataArray","numberOfBinToConsiders","numberOfBinsToSkip","numberOfComponents","component","histogram","histogramArray","dataRange","arrayRange","maxNumberOfWorkers","arrayStride","arrayIndex","workerChunks","workers","worker","workerPromise","arrayStart","arrayEnd","subArray","constructor","postMessage","numberOfBins","buffer","Promise","all","then","subHistograms","terminate","Float32Array","subHistogram","len","sampleSize","sortedArray","from","sort","Number","pop","shift","mean","render","onClick","xNormalized","yNormalized","graphArea","enableRangeZoom","iconSize","padding","buttonIdx","gaussianIdx","activeGaussian","selectedGaussian","setImmediate","onDown","dragAction","newSelected","onHover","tolerance","xNormalizedAbs","newActive","cursor","thirdDelta","invY","actionName","mouseIsDown","invokeAnimation","onDrag","onUp","onLeave","onAddGaussian","onRemoveGaussian","bindMouseListeners","listeners","isDown","touchId","mousemove","dblclick","contextmenu","click","mouseup","mousedown","mouseout","touchstart","chain","touchmove","touchend","Object","keys","eventType","addEventListener","unbindMouseListeners","removeEventListener","imageSmoothingEnabled","ceil","zoomControlHeight","clearRect","lineJoin","backgroundColor","fillRect","halfSize","strokeWidth","center","buttonStrokeWidth","buttonStrokeColor","arc","PI","buttonFillColor","buttonDisableFillColor","buttonDisableStrokeWidth","buttonDisableStrokeColor","histogramColor","strokeColor","getSize","getMappingRange","colorCanvas","getMTime","save","restore","backgroundImage","zoomControlColor","rect","activeOpacities","activeStrokeWidth","activeColor","xCenter","yTop","yMiddle","yBottom","widthInPixel","handleWidth","handleColor","radius","sliderWidth","getOpacityNodes","applyOpacity","getOpacityRange","minIndex","maxIndex","enableZoom","setEnableRangeZoom","change","setRangeZoom","onModified","DEFAULT_VALUES","extend","initialValues","assign","obj","setGet","setGetArray","get","event","newInstance"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Interaction/Widgets/PiecewiseGaussianWidget/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\n\nimport WebworkerPromise from 'webworker-promise';\n\nimport ComputeHistogramWorker from './ComputeHistogram.worker';\n\n/* eslint-disable no-continue */\n\n// ----------------------------------------------------------------------------\n// Global structures\n// ----------------------------------------------------------------------------\n\nconst MIN_GAUSSIAN_WIDTH = 0.001;\n\nconst ACTION_TO_CURSOR = {\n  adjustPosition: '-webkit-grab',\n  adjustHeight: 'row-resize',\n  adjustBias: 'crosshair',\n  adjustWidth: 'col-resize',\n  adjustZoom: 'col-resize',\n};\n\nconst TOUCH_CLICK = [];\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nconst ACTIONS = {\n  adjustPosition(x, y, { originalXY, gaussian, originalGaussian }) {\n    const xOffset = originalGaussian.position - originalXY[0];\n    gaussian.position = x + xOffset;\n    return true;\n  },\n  adjustHeight(x, y, { model, gaussian }) {\n    gaussian.height = 1 - y;\n    gaussian.height = Math.min(\n      1,\n      Math.max(model.gaussianMinimumHeight, gaussian.height)\n    );\n    return true;\n  },\n  adjustBias(x, y, { originalXY, gaussian, originalGaussian }) {\n    gaussian.xBias =\n      originalGaussian.xBias - (originalXY[0] - x) / gaussian.height;\n    gaussian.yBias =\n      originalGaussian.yBias + (4 * (originalXY[1] - y)) / gaussian.height;\n    // Clamps\n    gaussian.xBias = Math.max(-1, Math.min(1, gaussian.xBias));\n    gaussian.yBias = Math.max(0, Math.min(2, gaussian.yBias));\n    return true;\n  },\n  adjustWidth(x, y, { originalXY, gaussian, originalGaussian, gaussianSide }) {\n    gaussian.width =\n      gaussianSide < 0\n        ? originalGaussian.width - (originalXY[0] - x)\n        : originalGaussian.width + (originalXY[0] - x);\n    if (gaussian.width < MIN_GAUSSIAN_WIDTH) {\n      gaussian.width = MIN_GAUSSIAN_WIDTH;\n    }\n    return true;\n  },\n  adjustZoom(x, y, { rangeZoom, publicAPI }) {\n    const delta = rangeZoom[1] - rangeZoom[0];\n    const absNormX = (x - rangeZoom[0]) / delta;\n    const minDelta = Math.abs(absNormX - rangeZoom[0]);\n    const maxDelta = Math.abs(absNormX - rangeZoom[1]);\n    const meanDelta = Math.abs(absNormX - 0.5 * (rangeZoom[0] + rangeZoom[1]));\n    if (meanDelta < Math.min(minDelta, maxDelta)) {\n      const halfDelta = delta * 0.5;\n      rangeZoom[0] = Math.min(\n        Math.max(absNormX - halfDelta, 0),\n        rangeZoom[1] - 0.1\n      );\n      rangeZoom[1] = Math.max(\n        Math.min(absNormX + halfDelta, 1),\n        rangeZoom[0] + 0.1\n      );\n    } else if (minDelta < maxDelta) {\n      rangeZoom[0] = Math.min(Math.max(absNormX, 0), rangeZoom[1] - 0.1);\n    } else {\n      rangeZoom[1] = Math.max(Math.min(absNormX, 1), rangeZoom[0] + 0.1);\n    }\n    publicAPI.invokeZoomChange(rangeZoom);\n\n    // The opacity did not changed\n    return false;\n  },\n};\n\n// ----------------------------------------------------------------------------\n\nfunction computeOpacities(gaussians, sampling = 256) {\n  const opacities = [];\n  while (opacities.length < sampling) {\n    opacities.push(0);\n  }\n\n  let count = gaussians.length;\n  while (count--) {\n    const { position, height, width, xBias, yBias } = gaussians[count];\n    for (let i = 0; i < sampling; i++) {\n      const x = i / (sampling - 1);\n\n      // clamp non-zero values to pos +/- width\n      if (x > position + width || x < position - width) {\n        if (opacities[i] < 0.0) {\n          opacities[i] = 0.0;\n        }\n        continue;\n      }\n\n      // non-zero width\n      const correctedWidth =\n        width < MIN_GAUSSIAN_WIDTH ? MIN_GAUSSIAN_WIDTH : width;\n\n      // translate the original x to a new x based on the xbias\n      let x0 = 0;\n      if (xBias === 0 || x === position + xBias) {\n        x0 = x;\n      } else if (x > position + xBias) {\n        if (correctedWidth === xBias) {\n          x0 = position;\n        } else {\n          x0 =\n            position +\n            (x - position - xBias) *\n              (correctedWidth / (correctedWidth - xBias));\n        }\n      } else if (-correctedWidth === xBias) {\n        // (x < pos+xBias)\n        x0 = position;\n      } else {\n        x0 =\n          position -\n          (x - position - xBias) * (correctedWidth / (correctedWidth + xBias));\n      }\n\n      // center around 0 and normalize to -1,1\n      const x1 = (x0 - position) / correctedWidth;\n\n      // do a linear interpolation between:\n      //    a gaussian and a parabola        if 0 < yBias <1\n      //    a parabola and a step function   if 1 < yBias <2\n      const h0a = Math.exp(-(4 * x1 * x1));\n      const h0b = 1.0 - x1 * x1;\n      const h0c = 1.0;\n      let h1;\n      if (yBias < 1) {\n        h1 = yBias * h0b + (1 - yBias) * h0a;\n      } else {\n        h1 = (2 - yBias) * h0b + (yBias - 1) * h0c;\n      }\n      const h2 = height * h1;\n\n      // perform the MAX over different gaussians, not the sum\n      if (h2 > opacities[i]) {\n        opacities[i] = h2;\n      }\n    }\n  }\n\n  return opacities;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction applyGaussianToPiecewiseFunction(\n  gaussians,\n  sampling,\n  rangeToUse,\n  piecewiseFunction\n) {\n  const opacities = computeOpacities(gaussians, sampling);\n  const nodes = [];\n  const delta = (rangeToUse[1] - rangeToUse[0]) / (opacities.length - 1);\n  const midpoint = 0.5;\n  const sharpness = 0;\n  for (let index = 0; index < opacities.length; index++) {\n    const x = rangeToUse[0] + delta * index;\n    const y = opacities[index];\n    nodes.push({ x, y, midpoint, sharpness });\n  }\n\n  piecewiseFunction.setNodes(nodes);\n}\n\n// ----------------------------------------------------------------------------\n\nfunction drawChart(\n  ctx,\n  area,\n  values,\n  style = { lineWidth: 1, strokeStyle: '#000' }\n) {\n  const verticalScale = area[3];\n  const horizontalScale = area[2] / (values.length - 1);\n  const fill = !!style.fillStyle;\n  const offset = verticalScale + area[1];\n\n  ctx.lineWidth = style.lineWidth;\n  ctx.strokeStyle = style.strokeStyle;\n\n  ctx.beginPath();\n  ctx.moveTo(area[0], area[1] + area[3]);\n\n  for (let index = 0; index < values.length; index++) {\n    ctx.lineTo(\n      area[0] + index * horizontalScale,\n      Math.max(area[1], offset - values[index] * verticalScale)\n    );\n  }\n\n  if (fill) {\n    ctx.fillStyle = style.fillStyle;\n    ctx.lineTo(area[0] + area[2], area[1] + area[3]);\n\n    if (style.clip) {\n      ctx.clip();\n      return;\n    }\n\n    ctx.fill();\n  }\n  ctx.stroke();\n}\n\n// ----------------------------------------------------------------------------\n\nfunction updateColorCanvas(colorTransferFunction, width, rangeToUse, canvas) {\n  const workCanvas = canvas || document.createElement('canvas');\n  workCanvas.setAttribute('width', width);\n  workCanvas.setAttribute('height', 256);\n  const ctx = workCanvas.getContext('2d');\n\n  const rgba = colorTransferFunction.getUint8Table(\n    rangeToUse[0],\n    rangeToUse[1],\n    width,\n    4\n  );\n  const pixelsArea = ctx.getImageData(0, 0, width, 256);\n  for (let lineIdx = 0; lineIdx < 256; lineIdx++) {\n    pixelsArea.data.set(rgba, lineIdx * 4 * width);\n  }\n\n  const nbValues = 256 * width * 4;\n  const lineSize = width * 4;\n  for (let i = 3; i < nbValues; i += 4) {\n    pixelsArea.data[i] = 255 - Math.floor(i / lineSize);\n  }\n\n  ctx.putImageData(pixelsArea, 0, 0);\n  return workCanvas;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction updateColorCanvasFromImage(img, width, canvas) {\n  const workCanvas = canvas || document.createElement('canvas');\n  workCanvas.setAttribute('width', width);\n  workCanvas.setAttribute('height', 256);\n  const ctx = workCanvas.getContext('2d');\n  ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, 256);\n  return workCanvas;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction normalizeCoordinates(x, y, subRectangeArea, zoomRange = [0, 1]) {\n  return [\n    zoomRange[0] +\n      ((x - subRectangeArea[0]) / subRectangeArea[2]) *\n        (zoomRange[1] - zoomRange[0]),\n    (y - subRectangeArea[1]) / subRectangeArea[3],\n  ];\n}\n\n// ----------------------------------------------------------------------------\n\nfunction findGaussian(x, gaussians) {\n  const distances = gaussians.map((g) => Math.abs(g.position - x));\n  const min = Math.min(...distances);\n  return distances.indexOf(min);\n}\n\n// ----------------------------------------------------------------------------\n\nfunction createListener(callback, preventDefault = true) {\n  return (e) => {\n    const { offsetX, offsetY } = e;\n    if (preventDefault) {\n      e.preventDefault();\n    }\n    callback(offsetX, offsetY);\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction createTouchClickListener(...callbacks) {\n  const id = TOUCH_CLICK.length;\n  TOUCH_CLICK.push({\n    callbacks,\n    timeout: 0,\n    deltaT: 200,\n    count: 0,\n    ready: false,\n  });\n  return id;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction processTouchClicks() {\n  TOUCH_CLICK.filter((t) => t.ready).forEach((touchHandle) => {\n    touchHandle.callbacks.forEach((callback) => {\n      if (\n        callback.touches === touchHandle.touches &&\n        callback.clicks === touchHandle.count\n      ) {\n        callback.action(...touchHandle.singleTouche);\n      }\n    });\n\n    // Clear state\n    touchHandle.ts = 0;\n    touchHandle.count = 0;\n    touchHandle.touches = 0;\n    touchHandle.ready = false;\n  });\n}\n\n// ----------------------------------------------------------------------------\n\nfunction createTouchListener(\n  id,\n  callback,\n  nbTouches = 1,\n  preventDefault = true\n) {\n  return (e) => {\n    const targetBounds = e.target.getBoundingClientRect();\n    const relativeTouches = Array.prototype.map.call(e.touches, (t) => [\n      t.pageX - targetBounds.left,\n      t.pageY - targetBounds.top,\n    ]);\n    const singleTouche = relativeTouches\n      .reduce((a, b) => [a[0] + b[0], a[1] + b[1]], [0, 0])\n      .map((v) => v / e.touches.length);\n\n    if (e.type === 'touchstart') {\n      clearTimeout(TOUCH_CLICK[id].timeout);\n      TOUCH_CLICK[id].ts = e.timeStamp;\n      TOUCH_CLICK[id].singleTouche = singleTouche;\n      TOUCH_CLICK[id].touches = e.touches.length;\n    } else if (e.type === 'touchmove') {\n      TOUCH_CLICK[id].ts = 0;\n      TOUCH_CLICK[id].count = 0;\n      TOUCH_CLICK[id].ready = false;\n    } else if (e.type === 'touchend') {\n      if (e.timeStamp - TOUCH_CLICK[id].ts < TOUCH_CLICK[id].deltaT) {\n        TOUCH_CLICK[id].count += 1;\n        TOUCH_CLICK[id].ready = true;\n        if (preventDefault) {\n          e.preventDefault();\n        }\n        TOUCH_CLICK[id].timeout = setTimeout(\n          processTouchClicks,\n          TOUCH_CLICK[id].deltaT\n        );\n      } else {\n        TOUCH_CLICK[id].ready = false;\n      }\n    }\n\n    if (e.touches.length === nbTouches) {\n      callback(...singleTouche);\n      if (preventDefault) {\n        e.preventDefault();\n      }\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction listenerSelector(condition, ok, ko) {\n  return (e) => (condition() ? ok(e) : ko(e));\n}\n\n// ----------------------------------------------------------------------------\n\nfunction rescaleArray(array, focusArea) {\n  if (!focusArea) {\n    return array;\n  }\n  const maxIdx = array.length - 1;\n  const idxRange = focusArea.map((v) => Math.round(v * maxIdx));\n  return array.slice(idxRange[0], idxRange[1] + 1);\n}\n\n// ----------------------------------------------------------------------------\n\nfunction rescaleValue(value, focusArea) {\n  if (!focusArea) {\n    return value;\n  }\n  return (value - focusArea[0]) / (focusArea[1] - focusArea[0]);\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nexport const STATIC = {\n  applyGaussianToPiecewiseFunction,\n  computeOpacities,\n  createListener,\n  drawChart,\n  findGaussian,\n  listenerSelector,\n  normalizeCoordinates,\n};\n\n// ----------------------------------------------------------------------------\n// vtkPiecewiseGaussianWidget methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPiecewiseGaussianWidget(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPiecewiseGaussianWidget');\n\n  if (!model.canvas) {\n    model.canvas = document.createElement('canvas');\n  }\n\n  publicAPI.setContainer = (el) => {\n    if (model.container && model.container !== el) {\n      model.container.removeChild(model.canvas);\n    }\n    if (model.container !== el) {\n      model.container = el;\n      if (model.container) {\n        model.container.appendChild(model.canvas);\n      }\n      publicAPI.modified();\n    }\n  };\n\n  publicAPI.setGaussians = (gaussians) => {\n    if (model.gaussians === gaussians) {\n      return;\n    }\n    model.gaussians = gaussians;\n    model.opacities = computeOpacities(model.gaussians, model.piecewiseSize);\n    publicAPI.invokeOpacityChange(publicAPI);\n    publicAPI.modified();\n  };\n\n  publicAPI.addGaussian = (position, height, width, xBias, yBias) => {\n    const nextIndex = model.gaussians.length;\n    model.gaussians.push({ position, height, width, xBias, yBias });\n    model.opacities = computeOpacities(model.gaussians, model.piecewiseSize);\n    publicAPI.invokeOpacityChange(publicAPI);\n    publicAPI.modified();\n    return nextIndex;\n  };\n\n  publicAPI.removeGaussian = (index) => {\n    model.gaussians.splice(index, 1);\n    model.opacities = computeOpacities(model.gaussians, model.piecewiseSize);\n    publicAPI.invokeOpacityChange(publicAPI);\n    publicAPI.modified();\n  };\n\n  publicAPI.setSize = (width, height) => {\n    model.canvas.setAttribute('width', width);\n    model.canvas.setAttribute('height', height);\n\n    if (model.size[0] !== width || model.size[1] !== height) {\n      model.size = [width, height];\n      model.colorCanvasMTime = 0;\n      publicAPI.modified();\n    }\n  };\n\n  publicAPI.updateStyle = (style) => {\n    model.style = { ...model.style, ...style };\n    publicAPI.modified();\n  };\n\n  // Method used to compute and show data distribution in the background.\n  // When an array with many components is used, you can provide additional\n  // information to choose which component you want to extract the histogram\n  // from.\n\n  publicAPI.setDataArray = (\n    array,\n    {\n      numberOfBinToConsiders = 1,\n      numberOfBinsToSkip = 1,\n      numberOfComponents = 1,\n      component = 0,\n    } = {}\n  ) => {\n    model.histogram = null;\n    model.histogramArray = array;\n    model.dataRange = vtkMath.arrayRange(array, component, numberOfComponents);\n    const [min, max] = model.dataRange;\n\n    const maxNumberOfWorkers = 4;\n    let arrayStride = Math.floor(array.length / maxNumberOfWorkers) || 1;\n    arrayStride += arrayStride % numberOfComponents;\n    let arrayIndex = 0;\n    const workerChunks = [];\n    const workers = [];\n    while (arrayIndex < array.length) {\n      const worker = new ComputeHistogramWorker();\n      workers.push(worker);\n      const workerPromise = new WebworkerPromise(worker);\n      const arrayStart = arrayIndex;\n      const arrayEnd = Math.min(arrayIndex + arrayStride, array.length - 1);\n      const subArray = new array.constructor(\n        array.slice(arrayStart, arrayEnd + 1)\n      );\n      workerChunks.push(\n        workerPromise.postMessage(\n          {\n            array: subArray,\n            component,\n            numberOfComponents,\n            min,\n            max,\n            numberOfBins: model.numberOfBins,\n          },\n          [subArray.buffer]\n        )\n      );\n      arrayIndex += arrayStride;\n    }\n    Promise.all(workerChunks).then((subHistograms) => {\n      workers.forEach((worker) => worker.terminate());\n      model.histogram = new Float32Array(model.numberOfBins);\n      model.histogram.fill(0);\n      subHistograms.forEach((subHistogram) => {\n        for (let i = 0, len = subHistogram.length; i < len; ++i) {\n          model.histogram[i] += subHistogram[i];\n        }\n      });\n\n      // Smart Rescale Histogram\n      const sampleSize = Math.min(\n        numberOfBinToConsiders,\n        model.histogram.length - numberOfBinsToSkip\n      );\n      const sortedArray = Array.from(model.histogram);\n      sortedArray.sort((a, b) => Number(a) - Number(b));\n      for (let i = 0; i < numberOfBinsToSkip; i++) {\n        sortedArray.pop();\n      }\n      while (sortedArray.length > sampleSize) {\n        sortedArray.shift();\n      }\n      const mean = sortedArray.reduce((a, b) => a + b, 0) / sampleSize;\n\n      for (let i = 0, len = model.histogram.length; i < len; ++i) {\n        model.histogram[i] /= mean;\n      }\n      publicAPI.modified();\n      setTimeout(publicAPI.render, 0);\n    });\n\n    publicAPI.modified();\n  };\n\n  publicAPI.onClick = (x, y) => {\n    const [xNormalized, yNormalized] = normalizeCoordinates(\n      x,\n      y,\n      model.graphArea,\n      model.enableRangeZoom ? model.rangeZoom : null\n    );\n    if (xNormalized < 0 && model.style.iconSize > 1) {\n      // Control buttons\n      const delta = model.style.iconSize + model.style.padding;\n      let offset = delta;\n      let buttonIdx = 0;\n      while (y > offset) {\n        buttonIdx += 1;\n        offset += delta;\n      }\n      switch (buttonIdx) {\n        case 0: {\n          const gaussianIdx = publicAPI.addGaussian(0, 1, 0.1, 0, 0);\n          const gaussian = model.gaussians[gaussianIdx];\n          const originalGaussian = { ...gaussian };\n          const action = ACTIONS.adjustPosition;\n          model.activeGaussian = gaussianIdx;\n          model.selectedGaussian = gaussianIdx;\n\n          // Fake active action\n          macro.setImmediate(() => {\n            publicAPI.onDown(x, y);\n            model.dragAction = {\n              originalXY: [0, 0],\n              action,\n              gaussian,\n              originalGaussian,\n            };\n          });\n          break;\n        }\n        case 1: {\n          if (model.selectedGaussian !== -1) {\n            publicAPI.removeGaussian(model.selectedGaussian);\n          }\n          break;\n        }\n        default: {\n          model.selectedGaussian = -1;\n          model.dragAction = null;\n        }\n      }\n    } else if (\n      xNormalized < 0 ||\n      xNormalized > 1 ||\n      yNormalized < 0 ||\n      yNormalized > 1\n    ) {\n      model.selectedGaussian = -1;\n      model.dragAction = null;\n    } else {\n      const newSelected = findGaussian(xNormalized, model.gaussians);\n      if (newSelected !== model.selectedGaussian) {\n        model.selectedGaussian = newSelected;\n        publicAPI.modified();\n      }\n    }\n    return true;\n  };\n\n  publicAPI.onHover = (x, y) => {\n    // Determines the interaction region size for adjusting the Gaussian's\n    // height.\n    const tolerance = 20 / model.canvas.height;\n    const [xNormalized, yNormalized] = normalizeCoordinates(\n      x,\n      y,\n      model.graphArea,\n      model.enableRangeZoom ? model.rangeZoom : null\n    );\n    const [xNormalizedAbs] = normalizeCoordinates(x, y, model.graphArea);\n    const newActive =\n      xNormalized < 0\n        ? model.selectedGaussian\n        : findGaussian(xNormalized, model.gaussians);\n    model.canvas.style.cursor = 'default';\n    const gaussian = model.gaussians[newActive];\n\n    if (\n      model.enableRangeZoom &&\n      xNormalizedAbs >= 0 &&\n      y < model.graphArea[1] - 6 // circle radius\n    ) {\n      const thirdDelta = (model.rangeZoom[1] - model.rangeZoom[0]) / 3;\n      if (\n        xNormalizedAbs < model.rangeZoom[0] + thirdDelta ||\n        xNormalizedAbs > model.rangeZoom[1] - thirdDelta\n      ) {\n        model.canvas.style.cursor = ACTION_TO_CURSOR.adjustZoom;\n      } else {\n        model.canvas.style.cursor = ACTION_TO_CURSOR.adjustPosition;\n      }\n\n      model.dragAction = {\n        rangeZoom: model.rangeZoom,\n        action: ACTIONS.adjustZoom,\n      };\n    } else if (gaussian && xNormalizedAbs >= 0) {\n      const invY = 1 - yNormalized;\n      let actionName = null;\n      if (invY > gaussian.height + tolerance) {\n        actionName = 'adjustPosition';\n      } else if (invY > gaussian.height - tolerance) {\n        if (Math.abs(xNormalized - gaussian.position) < tolerance) {\n          actionName = 'adjustHeight';\n        } else {\n          actionName = 'adjustPosition';\n        }\n      } else if (invY > gaussian.height * 0.5 + tolerance) {\n        actionName = 'adjustPosition';\n      } else if (invY > gaussian.height * 0.5 - tolerance) {\n        if (Math.abs(xNormalized - gaussian.position) < tolerance) {\n          actionName = 'adjustBias';\n        } else {\n          actionName = 'adjustPosition';\n        }\n      } else if (invY > tolerance) {\n        actionName = 'adjustPosition';\n      } else {\n        actionName = 'adjustWidth';\n      }\n      model.canvas.style.cursor = ACTION_TO_CURSOR[actionName];\n      const action = ACTIONS[actionName];\n      const originalGaussian = { ...gaussian };\n      model.dragAction = {\n        originalXY: [xNormalized, yNormalized],\n        action,\n        gaussian,\n        originalGaussian,\n      };\n    }\n\n    if (newActive !== model.activeGaussian) {\n      model.activeGaussian = newActive;\n      publicAPI.modified();\n    }\n    return true;\n  };\n\n  publicAPI.onDown = (x, y) => {\n    if (!model.mouseIsDown) {\n      publicAPI.invokeAnimation(true);\n    }\n    model.mouseIsDown = true;\n    const xNormalized = normalizeCoordinates(\n      x,\n      y,\n      model.graphArea,\n      model.enableRangeZoom ? model.rangeZoom : null\n    )[0];\n    const newSelected = findGaussian(xNormalized, model.gaussians);\n    model.gaussianSide = 0;\n    const gaussian = model.gaussians[newSelected];\n    if (gaussian) {\n      model.gaussianSide = gaussian.position - xNormalized;\n    }\n\n    if (newSelected !== model.selectedGaussian && xNormalized > 0) {\n      model.selectedGaussian = newSelected;\n      publicAPI.modified();\n    }\n    return true;\n  };\n\n  publicAPI.onDrag = (x, y) => {\n    if (model.dragAction) {\n      const [xNormalized, yNormalized] = normalizeCoordinates(\n        x,\n        y,\n        model.graphArea,\n        model.enableRangeZoom ? model.rangeZoom : null\n      );\n      const { action } = model.dragAction;\n      if (\n        action(xNormalized, yNormalized, {\n          gaussianSide: model.gaussianSide,\n          model,\n          publicAPI,\n          ...model.dragAction,\n        })\n      ) {\n        model.opacities = computeOpacities(\n          model.gaussians,\n          model.piecewiseSize\n        );\n        publicAPI.invokeOpacityChange(publicAPI, true);\n      }\n\n      publicAPI.modified();\n    }\n    return true;\n  };\n\n  publicAPI.onUp = (x, y) => {\n    if (model.mouseIsDown) {\n      publicAPI.invokeAnimation(false);\n    }\n    model.mouseIsDown = false;\n    return true;\n  };\n\n  publicAPI.onLeave = (x, y) => {\n    publicAPI.onUp(x, y);\n    model.canvas.style.cursor = 'default';\n    model.activeGaussian = -1;\n    publicAPI.modified();\n    return true;\n  };\n\n  publicAPI.onAddGaussian = (x, y) => {\n    const [xNormalized, yNormalized] = normalizeCoordinates(\n      x,\n      y,\n      model.graphArea,\n      model.enableRangeZoom ? model.rangeZoom : null\n    );\n    if (xNormalized >= 0) {\n      publicAPI.addGaussian(xNormalized, 1 - yNormalized, 0.1, 0, 0);\n    }\n    return true;\n  };\n\n  publicAPI.onRemoveGaussian = (x, y) => {\n    const xNormalized = normalizeCoordinates(\n      x,\n      y,\n      model.graphArea,\n      model.enableRangeZoom ? model.rangeZoom : null\n    )[0];\n    const newSelected = findGaussian(xNormalized, model.gaussians);\n    if (xNormalized >= 0 && newSelected !== -1) {\n      publicAPI.removeGaussian(newSelected);\n    }\n    return true;\n  };\n\n  publicAPI.bindMouseListeners = () => {\n    if (!model.listeners) {\n      const isDown = () => !!model.mouseIsDown;\n      const touchId = createTouchClickListener(\n        {\n          clicks: 1,\n          touches: 1,\n          action: publicAPI.onClick,\n        },\n        {\n          clicks: 2,\n          touches: 1,\n          action: publicAPI.onAddGaussian,\n        },\n        {\n          clicks: 2,\n          touches: 2,\n          action: publicAPI.onRemoveGaussian,\n        }\n      );\n\n      model.listeners = {\n        mousemove: listenerSelector(\n          isDown,\n          createListener(publicAPI.onDrag),\n          createListener(publicAPI.onHover)\n        ),\n        dblclick: createListener(publicAPI.onAddGaussian),\n        contextmenu: createListener(publicAPI.onRemoveGaussian),\n        click: createListener(publicAPI.onClick),\n        mouseup: createListener(publicAPI.onUp),\n        mousedown: createListener(publicAPI.onDown),\n        mouseout: createListener(publicAPI.onLeave),\n\n        touchstart: createTouchListener(\n          touchId,\n          macro.chain(publicAPI.onHover, publicAPI.onDown)\n        ),\n        touchmove: listenerSelector(\n          isDown,\n          createTouchListener(touchId, publicAPI.onDrag),\n          createTouchListener(touchId, publicAPI.onHover)\n        ),\n        touchend: createTouchListener(touchId, publicAPI.onUp, 0), // touchend have 0 touch event...\n      };\n      Object.keys(model.listeners).forEach((eventType) => {\n        model.canvas.addEventListener(\n          eventType,\n          model.listeners[eventType],\n          false\n        );\n      });\n    }\n  };\n\n  publicAPI.unbindMouseListeners = () => {\n    if (model.listeners) {\n      Object.keys(model.listeners).forEach((eventType) => {\n        model.canvas.removeEventListener(eventType, model.listeners[eventType]);\n      });\n      delete model.listeners;\n    }\n  };\n\n  publicAPI.render = () => {\n    const ctx = model.canvas.getContext('2d');\n    ctx.imageSmoothingEnabled = true;\n\n    const [width, height] = model.size;\n    const offset = model.style.padding;\n    const graphArea = [\n      Math.floor(model.style.iconSize + offset),\n      Math.floor(offset),\n      Math.ceil(width - 2 * offset - model.style.iconSize),\n      Math.ceil(height - 2 * offset),\n    ];\n\n    const zoomControlHeight = model.style.zoomControlHeight;\n    if (model.enableRangeZoom) {\n      graphArea[1] += Math.floor(zoomControlHeight);\n      graphArea[3] -= Math.floor(zoomControlHeight);\n    }\n\n    model.graphArea = graphArea;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    ctx.lineJoin = 'round';\n    ctx.fillStyle = model.style.backgroundColor;\n    ctx.fillRect(...graphArea);\n\n    if (model.style.iconSize > 1) {\n      // Draw icons\n      // +\n      const halfSize = Math.round(\n        model.style.iconSize / 2 - model.style.strokeWidth\n      );\n      const center = Math.round(halfSize + offset + model.style.strokeWidth);\n      ctx.beginPath();\n      ctx.lineWidth = model.style.buttonStrokeWidth;\n      ctx.strokeStyle = model.style.buttonStrokeColor;\n      ctx.arc(center - offset / 2, center, halfSize, 0, 2 * Math.PI, false);\n      ctx.fillStyle = model.style.buttonFillColor;\n      ctx.fill();\n      ctx.stroke();\n      ctx.moveTo(\n        center - halfSize + model.style.strokeWidth + 2 - offset / 2,\n        center\n      );\n      ctx.lineTo(\n        center + halfSize - model.style.strokeWidth - 2 - offset / 2,\n        center\n      );\n      ctx.stroke();\n      ctx.moveTo(\n        center - offset / 2,\n        center - halfSize + model.style.strokeWidth + 2\n      );\n      ctx.lineTo(\n        center - offset / 2,\n        center + halfSize - model.style.strokeWidth - 2\n      );\n      ctx.stroke();\n\n      // -\n      if (model.selectedGaussian === -1) {\n        ctx.fillStyle = model.style.buttonDisableFillColor;\n        ctx.lineWidth = model.style.buttonDisableStrokeWidth;\n        ctx.strokeStyle = model.style.buttonDisableStrokeColor;\n      } else {\n        ctx.fillStyle = model.style.buttonFillColor;\n        ctx.lineWidth = model.style.buttonStrokeWidth;\n        ctx.strokeStyle = model.style.buttonStrokeColor;\n      }\n      ctx.beginPath();\n      ctx.arc(\n        center - offset / 2,\n        center + offset / 2 + model.style.iconSize,\n        halfSize,\n        0,\n        2 * Math.PI,\n        false\n      );\n      ctx.fill();\n      ctx.stroke();\n      ctx.moveTo(\n        center - halfSize + model.style.strokeWidth + 2 - offset / 2,\n        center + offset / 2 + model.style.iconSize\n      );\n      ctx.lineTo(\n        center + halfSize - model.style.strokeWidth - 2 - offset / 2,\n        center + offset / 2 + model.style.iconSize\n      );\n      ctx.stroke();\n    }\n\n    // Draw histogram\n    if (model.histogram) {\n      drawChart(\n        ctx,\n        graphArea,\n        rescaleArray(model.histogram, model.rangeZoom),\n        {\n          lineWidth: 1,\n          strokeStyle: model.style.histogramColor,\n          fillStyle: model.style.histogramColor,\n        }\n      );\n    }\n\n    // Draw gaussians\n    drawChart(\n      ctx,\n      graphArea,\n      rescaleArray(model.opacities, model.enableRangeZoom && model.rangeZoom),\n      {\n        lineWidth: model.style.strokeWidth,\n        strokeStyle: model.style.strokeColor,\n      }\n    );\n\n    // Draw color function if any\n    if (model.colorTransferFunction && model.colorTransferFunction.getSize()) {\n      const rangeToUse =\n        model.dataRange || model.colorTransferFunction.getMappingRange();\n      if (\n        !model.colorCanvas ||\n        model.colorCanvasMTime !== model.colorTransferFunction.getMTime()\n      ) {\n        model.colorCanvasMTime = model.colorTransferFunction.getMTime();\n        model.colorCanvas = updateColorCanvas(\n          model.colorTransferFunction,\n          graphArea[2],\n          rangeToUse,\n          model.colorCanvas\n        );\n      }\n      ctx.save();\n      drawChart(\n        ctx,\n        graphArea,\n        rescaleArray(model.opacities, model.enableRangeZoom && model.rangeZoom),\n        {\n          lineWidth: 1,\n          strokeStyle: 'rgba(0,0,0,0)',\n          fillStyle: 'rgba(0,0,0,1)',\n          clip: true,\n        }\n      );\n\n      // Draw the correct portion of the color BG image\n      if (model.enableRangeZoom) {\n        ctx.drawImage(\n          model.colorCanvas,\n          model.rangeZoom[0] * graphArea[2],\n          0,\n          graphArea[2],\n          graphArea[3],\n          graphArea[0],\n          graphArea[1],\n          graphArea[2] / (model.rangeZoom[1] - model.rangeZoom[0]),\n          graphArea[3]\n        );\n      } else {\n        ctx.drawImage(model.colorCanvas, graphArea[0], graphArea[1]);\n      }\n\n      ctx.restore();\n    } else if (model.backgroundImage) {\n      model.colorCanvas = updateColorCanvasFromImage(\n        model.backgroundImage,\n        graphArea[2],\n        model.colorCanvas\n      );\n      ctx.save();\n      drawChart(\n        ctx,\n        graphArea,\n        rescaleArray(model.opacities, model.enableRangeZoom && model.rangeZoom),\n        {\n          lineWidth: 1,\n          strokeStyle: 'rgba(0,0,0,0)',\n          fillStyle: 'rgba(0,0,0,1)',\n          clip: true,\n        }\n      );\n      ctx.drawImage(model.colorCanvas, graphArea[0], graphArea[1]);\n      ctx.restore();\n    }\n\n    // Draw zoomed area\n    if (model.enableRangeZoom) {\n      ctx.fillStyle = model.style.zoomControlColor;\n\n      ctx.beginPath();\n      ctx.rect(\n        graphArea[0] + model.rangeZoom[0] * graphArea[2],\n        0,\n        (model.rangeZoom[1] - model.rangeZoom[0]) * graphArea[2],\n        zoomControlHeight\n      );\n      ctx.fill();\n    }\n\n    // Draw active gaussian\n    const activeGaussian =\n      model.gaussians[model.activeGaussian] ||\n      model.gaussians[model.selectedGaussian];\n    if (activeGaussian) {\n      const activeOpacities = computeOpacities([activeGaussian], graphArea[2]);\n      drawChart(\n        ctx,\n        graphArea,\n        rescaleArray(activeOpacities, model.enableRangeZoom && model.rangeZoom),\n        {\n          lineWidth: model.style.activeStrokeWidth,\n          strokeStyle: model.style.activeColor,\n        }\n      );\n      // Draw controls\n      const xCenter =\n        graphArea[0] +\n        rescaleValue(\n          activeGaussian.position,\n          model.enableRangeZoom && model.rangeZoom\n        ) *\n          graphArea[2];\n      const yTop = graphArea[1] + (1 - activeGaussian.height) * graphArea[3];\n      const yMiddle =\n        graphArea[1] + (1 - 0.5 * activeGaussian.height) * graphArea[3];\n      const yBottom = graphArea[1] + graphArea[3];\n      let widthInPixel = activeGaussian.width * graphArea[2];\n      if (model.enableRangeZoom) {\n        widthInPixel /= model.rangeZoom[1] - model.rangeZoom[0];\n      }\n\n      ctx.lineWidth = model.style.handleWidth;\n      ctx.strokeStyle = model.style.handleColor;\n      ctx.fillStyle = model.style.backgroundColor;\n      ctx.beginPath();\n      ctx.moveTo(\n        xCenter,\n        graphArea[1] + (1 - activeGaussian.height) * graphArea[3]\n      );\n      ctx.lineTo(xCenter, graphArea[1] + graphArea[3]);\n      ctx.stroke();\n      // Height\n      ctx.beginPath();\n      ctx.arc(xCenter, yTop, 6, 0, 2 * Math.PI);\n      ctx.fill();\n      ctx.stroke();\n      // Bias\n      const radius = Math.min(\n        widthInPixel * 0.1,\n        activeGaussian.height * graphArea[3] * 0.2\n      );\n      ctx.beginPath();\n      ctx.rect(xCenter - radius, yMiddle - radius, radius * 2, radius * 2);\n      ctx.fill();\n      ctx.stroke();\n      ctx.beginPath();\n      // Width\n      const sliderWidth = widthInPixel * 0.8;\n      ctx.rect(xCenter - sliderWidth, yBottom - 5, 2 * sliderWidth, 10);\n      ctx.fill();\n      ctx.stroke();\n    }\n  };\n\n  publicAPI.getOpacityNodes = (dataRange) => {\n    const rangeToUse = dataRange || model.dataRange;\n    const delta =\n      (rangeToUse[1] - rangeToUse[0]) / (model.opacities.length - 1);\n    const nodes = [];\n    const midpoint = 0.5;\n    const sharpness = 0;\n    for (let index = 0; index < model.opacities.length; index++) {\n      const x = rangeToUse[0] + delta * index;\n      const y = model.opacities[index];\n      nodes.push({ x, y, midpoint, sharpness });\n    }\n    return nodes;\n  };\n\n  publicAPI.applyOpacity = (piecewiseFunction, dataRange) => {\n    const nodes = publicAPI.getOpacityNodes(dataRange);\n    piecewiseFunction.setNodes(nodes);\n  };\n\n  publicAPI.getOpacityRange = (dataRange) => {\n    const rangeToUse = dataRange || model.dataRange;\n    const delta =\n      (rangeToUse[1] - rangeToUse[0]) / (model.opacities.length - 1);\n    let minIndex = model.opacities.length - 1;\n    let maxIndex = 0;\n    for (let index = 0; index < model.opacities.length; index++) {\n      if (model.opacities[index] > 0) {\n        minIndex = Math.min(minIndex, index);\n      }\n      if (model.opacities[index] > 0) {\n        maxIndex = Math.max(maxIndex, index);\n      }\n    }\n    return [rangeToUse[0] + minIndex * delta, rangeToUse[0] + maxIndex * delta];\n  };\n\n  const enableZoom = publicAPI.setEnableRangeZoom;\n  publicAPI.setEnableRangeZoom = (v) => {\n    const change = enableZoom(v);\n    if (change) {\n      model.colorCanvasMTime = 0;\n      model.rangeZoom = [0, 1];\n    }\n    return change;\n  };\n\n  const rangeZoom = publicAPI.setRangeZoom;\n  publicAPI.setRangeZoom = (...v) => {\n    const change = rangeZoom(...v);\n    if (change) {\n      model.colorCanvasMTime = 0;\n    }\n    return change;\n  };\n\n  // Trigger rendering for any modified event\n  publicAPI.onModified(() => publicAPI.render());\n  publicAPI.setSize(...model.size);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  histogram: [],\n  numberOfBins: 256,\n  histogramArray: null,\n  dataRange: [0, 1],\n  gaussians: [],\n  opacities: [],\n  size: [600, 300],\n  piecewiseSize: 256,\n  colorCanvasMTime: 0,\n  gaussianMinimumHeight: 0.05,\n  style: {\n    backgroundColor: 'rgba(255, 255, 255, 1)',\n    histogramColor: 'rgba(200, 200, 200, 0.5)',\n    strokeColor: 'rgb(0, 0, 0)',\n    activeColor: 'rgb(0, 0, 150)',\n    buttonDisableFillColor: 'rgba(255, 255, 255, 0.5)',\n    buttonDisableStrokeColor: 'rgba(0, 0, 0, 0.5)',\n    buttonStrokeColor: 'rgba(0, 0, 0, 1)',\n    buttonFillColor: 'rgba(255, 255, 255, 1)',\n    handleColor: 'rgb(0, 150, 0)',\n    strokeWidth: 2,\n    activeStrokeWidth: 3,\n    buttonStrokeWidth: 1.5,\n    handleWidth: 3,\n    iconSize: 20,\n    padding: 10,\n    zoomControlHeight: 10,\n    zoomControlColor: '#999',\n  },\n  activeGaussian: -1,\n  selectedGaussian: -1,\n  enableRangeZoom: true,\n  rangeZoom: [0, 1], // normalized value\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, [\n    'piecewiseSize',\n    'numberOfBins',\n    'colorTransferFunction',\n    'backgroundImage',\n    'enableRangeZoom',\n    'gaussianMinimumHeight',\n  ]);\n  macro.setGetArray(publicAPI, model, ['rangeZoom'], 2);\n  macro.get(publicAPI, model, ['size', 'canvas', 'gaussians']);\n  macro.event(publicAPI, model, 'opacityChange');\n  macro.event(publicAPI, model, 'animation');\n  macro.event(publicAPI, model, 'zoomChange');\n\n  // Object specific methods\n  vtkPiecewiseGaussianWidget(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(\n  extend,\n  'vtkPiecewiseGaussianWidget'\n);\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend, ...STATIC };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}