{"ast":null,"code":"import Md5 from 'spark-md5';\nimport macro from 'vtk.js/Sources/macros';\nimport vtkShaderProgram from 'vtk.js/Sources/Rendering/OpenGL/ShaderProgram'; // ----------------------------------------------------------------------------\n\nconst SET_GET_FIELDS = ['lastShaderBound', 'context', '_openGLRenderWindow']; // ----------------------------------------------------------------------------\n// vtkShaderCache methods\n// ----------------------------------------------------------------------------\n\nfunction vtkShaderCache(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkShaderCache');\n\n  publicAPI.replaceShaderValues = (VSSource, FSSource, GSSource) => {\n    // first handle renaming any Fragment shader inputs\n    // if we have a geometry shader. By default fragment shaders\n    // assume their inputs come from a Vertex Shader. When we\n    // have a Geometry shader we rename the frament shader inputs\n    // to come from the geometry shader\n    let nFSSource = FSSource;\n\n    if (GSSource.length > 0) {\n      nFSSource = vtkShaderProgram.substitute(nFSSource, 'VSOut', 'GSOut').result;\n    }\n\n    const gl2 = model._openGLRenderWindow.getWebgl2();\n\n    let fragDepthString = '\\n';\n    let version = '#version 100\\n';\n\n    if (gl2) {\n      version = '#version 300 es\\n' + '#define attribute in\\n' + '#define textureCube texture\\n' + '#define texture2D texture\\n' + '#define textureCubeLod textureLod\\n' + '#define texture2DLod textureLod\\n';\n    } else {\n      model.context.getExtension('OES_standard_derivatives');\n\n      if (model.context.getExtension('EXT_frag_depth')) {\n        fragDepthString = '#extension GL_EXT_frag_depth : enable\\n';\n      }\n\n      if (model.context.getExtension('EXT_shader_texture_lod')) {\n        fragDepthString += '#extension GL_EXT_shader_texture_lod : enable\\n' + '#define textureCubeLod textureCubeLodEXT\\n' + '#define texture2DLod texture2DLodEXT';\n      }\n    }\n\n    nFSSource = vtkShaderProgram.substitute(nFSSource, '//VTK::System::Dec', [`${version}\\n`, gl2 ? '' : '#extension GL_OES_standard_derivatives : enable\\n', fragDepthString, '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', 'precision highp int;', '#else', 'precision mediump float;', 'precision mediump int;', '#endif']).result;\n    let nVSSource = vtkShaderProgram.substitute(VSSource, '//VTK::System::Dec', [`${version}\\n`, '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', 'precision highp int;', '#else', 'precision mediump float;', 'precision mediump int;', '#endif']).result;\n\n    if (gl2) {\n      nVSSource = vtkShaderProgram.substitute(nVSSource, 'varying', 'out').result;\n      nFSSource = vtkShaderProgram.substitute(nFSSource, 'varying', 'in').result;\n      let shaderOutputs = '';\n      let outputCount = 0;\n\n      while (nFSSource.includes(`gl_FragData[${outputCount}]`)) {\n        nFSSource = vtkShaderProgram.substitute(nFSSource, `gl_FragData\\\\[${outputCount}\\\\]`, `fragOutput${outputCount}`).result;\n        shaderOutputs += `layout(location = ${outputCount}) out vec4 fragOutput${outputCount};\\n`;\n        outputCount++;\n      }\n\n      nFSSource = vtkShaderProgram.substitute(nFSSource, '//VTK::Output::Dec', shaderOutputs).result;\n    } // nFSSource = ShaderProgram.substitute(nFSSource, 'gl_FragData\\\\[0\\\\]',\n    //   'gl_FragColor').result;\n\n\n    const nGSSource = vtkShaderProgram.substitute(GSSource, '//VTK::System::Dec', version).result;\n    return {\n      VSSource: nVSSource,\n      FSSource: nFSSource,\n      GSSource: nGSSource\n    };\n  }; // return NULL if there is an issue\n\n\n  publicAPI.readyShaderProgramArray = (vertexCode, fragmentCode, geometryCode) => {\n    const data = publicAPI.replaceShaderValues(vertexCode, fragmentCode, geometryCode);\n    const shader = publicAPI.getShaderProgram(data.VSSource, data.FSSource, data.GSSource);\n    return publicAPI.readyShaderProgram(shader);\n  };\n\n  publicAPI.readyShaderProgram = shader => {\n    if (!shader) {\n      return null;\n    } // compile if needed\n\n\n    if (!shader.getCompiled() && !shader.compileShader()) {\n      return null;\n    } // bind if needed\n\n\n    if (!publicAPI.bindShader(shader)) {\n      return null;\n    }\n\n    return shader;\n  };\n\n  publicAPI.getShaderProgram = (vertexCode, fragmentCode, geometryCode) => {\n    // compute the MD5 and the check the map\n    const hashInput = `${vertexCode}${fragmentCode}${geometryCode}`;\n    const result = Md5.hash(hashInput); // does it already exist?\n\n    if (!(result in model.shaderPrograms)) {\n      // create one\n      const sps = vtkShaderProgram.newInstance();\n      sps.setContext(model.context);\n      sps.getVertexShader().setSource(vertexCode);\n      sps.getFragmentShader().setSource(fragmentCode);\n\n      if (geometryCode) {\n        sps.getGeometryShader().setSource(geometryCode);\n      }\n\n      sps.setMd5Hash(result);\n      model.shaderPrograms[result] = sps;\n      return sps;\n    }\n\n    return model.shaderPrograms[result];\n  };\n\n  publicAPI.releaseGraphicsResources = win => {\n    // NOTE:\n    // In the current implementation as of October 26th, if a shader\n    // program is created by ShaderCache then it should make sure\n    // that it releases the graphics resources used by these programs.\n    // It is not wisely for callers to do that since then they would\n    // have to loop over all the programs were in use and invoke\n    // release graphics resources individually.\n    publicAPI.releaseCurrentShader();\n    Object.keys(model.shaderPrograms).map(key => model.shaderPrograms[key]).forEach(sp => sp.releaseGraphicsResources(win));\n  };\n\n  publicAPI.releaseGraphicsResources = () => {\n    // release prior shader\n    if (model.astShaderBound) {\n      model.lastShaderBound.release();\n      model.lastShaderBound = null;\n    }\n  };\n\n  publicAPI.bindShader = shader => {\n    if (model.lastShaderBound === shader) {\n      return 1;\n    } // release prior shader\n\n\n    if (model.lastShaderBound) {\n      model.lastShaderBound.release();\n    }\n\n    shader.bind();\n    model.lastShaderBound = shader;\n    return 1;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  lastShaderBound: null,\n  shaderPrograms: null,\n  context: null // _openGLRenderWindow: null,\n\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Internal objects\n\n  model.shaderPrograms = {}; // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, SET_GET_FIELDS);\n  macro.moveToProtected(publicAPI, model, ['openGLRenderWindow']); // Object methods\n\n  vtkShaderCache(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkShaderCache'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["Md5","macro","vtkShaderProgram","SET_GET_FIELDS","vtkShaderCache","publicAPI","model","classHierarchy","push","replaceShaderValues","VSSource","FSSource","GSSource","nFSSource","length","substitute","result","gl2","_openGLRenderWindow","getWebgl2","fragDepthString","version","context","getExtension","nVSSource","shaderOutputs","outputCount","includes","nGSSource","readyShaderProgramArray","vertexCode","fragmentCode","geometryCode","data","shader","getShaderProgram","readyShaderProgram","getCompiled","compileShader","bindShader","hashInput","hash","shaderPrograms","sps","newInstance","setContext","getVertexShader","setSource","getFragmentShader","getGeometryShader","setMd5Hash","releaseGraphicsResources","win","releaseCurrentShader","Object","keys","map","key","forEach","sp","astShaderBound","lastShaderBound","release","bind","DEFAULT_VALUES","extend","initialValues","assign","obj","setGet","moveToProtected"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/OpenGL/ShaderCache/index.js"],"sourcesContent":["import Md5 from 'spark-md5';\n\nimport macro from 'vtk.js/Sources/macros';\nimport vtkShaderProgram from 'vtk.js/Sources/Rendering/OpenGL/ShaderProgram';\n\n// ----------------------------------------------------------------------------\n\nconst SET_GET_FIELDS = ['lastShaderBound', 'context', '_openGLRenderWindow'];\n\n// ----------------------------------------------------------------------------\n// vtkShaderCache methods\n// ----------------------------------------------------------------------------\n\nfunction vtkShaderCache(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkShaderCache');\n\n  publicAPI.replaceShaderValues = (VSSource, FSSource, GSSource) => {\n    // first handle renaming any Fragment shader inputs\n    // if we have a geometry shader. By default fragment shaders\n    // assume their inputs come from a Vertex Shader. When we\n    // have a Geometry shader we rename the frament shader inputs\n    // to come from the geometry shader\n\n    let nFSSource = FSSource;\n    if (GSSource.length > 0) {\n      nFSSource = vtkShaderProgram.substitute(\n        nFSSource,\n        'VSOut',\n        'GSOut'\n      ).result;\n    }\n\n    const gl2 = model._openGLRenderWindow.getWebgl2();\n\n    let fragDepthString = '\\n';\n\n    let version = '#version 100\\n';\n    if (gl2) {\n      version =\n        '#version 300 es\\n' +\n        '#define attribute in\\n' +\n        '#define textureCube texture\\n' +\n        '#define texture2D texture\\n' +\n        '#define textureCubeLod textureLod\\n' +\n        '#define texture2DLod textureLod\\n';\n    } else {\n      model.context.getExtension('OES_standard_derivatives');\n      if (model.context.getExtension('EXT_frag_depth')) {\n        fragDepthString = '#extension GL_EXT_frag_depth : enable\\n';\n      }\n      if (model.context.getExtension('EXT_shader_texture_lod')) {\n        fragDepthString +=\n          '#extension GL_EXT_shader_texture_lod : enable\\n' +\n          '#define textureCubeLod textureCubeLodEXT\\n' +\n          '#define texture2DLod texture2DLodEXT';\n      }\n    }\n\n    nFSSource = vtkShaderProgram.substitute(nFSSource, '//VTK::System::Dec', [\n      `${version}\\n`,\n      gl2 ? '' : '#extension GL_OES_standard_derivatives : enable\\n',\n      fragDepthString,\n      '#ifdef GL_FRAGMENT_PRECISION_HIGH',\n      'precision highp float;',\n      'precision highp int;',\n      '#else',\n      'precision mediump float;',\n      'precision mediump int;',\n      '#endif',\n    ]).result;\n\n    let nVSSource = vtkShaderProgram.substitute(\n      VSSource,\n      '//VTK::System::Dec',\n      [\n        `${version}\\n`,\n        '#ifdef GL_FRAGMENT_PRECISION_HIGH',\n        'precision highp float;',\n        'precision highp int;',\n        '#else',\n        'precision mediump float;',\n        'precision mediump int;',\n        '#endif',\n      ]\n    ).result;\n\n    if (gl2) {\n      nVSSource = vtkShaderProgram.substitute(\n        nVSSource,\n        'varying',\n        'out'\n      ).result;\n      nFSSource = vtkShaderProgram.substitute(\n        nFSSource,\n        'varying',\n        'in'\n      ).result;\n\n      let shaderOutputs = '';\n      let outputCount = 0;\n      while (nFSSource.includes(`gl_FragData[${outputCount}]`)) {\n        nFSSource = vtkShaderProgram.substitute(\n          nFSSource,\n          `gl_FragData\\\\[${outputCount}\\\\]`,\n          `fragOutput${outputCount}`\n        ).result;\n        shaderOutputs += `layout(location = ${outputCount}) out vec4 fragOutput${outputCount};\\n`;\n        outputCount++;\n      }\n      nFSSource = vtkShaderProgram.substitute(\n        nFSSource,\n        '//VTK::Output::Dec',\n        shaderOutputs\n      ).result;\n    }\n\n    // nFSSource = ShaderProgram.substitute(nFSSource, 'gl_FragData\\\\[0\\\\]',\n    //   'gl_FragColor').result;\n\n    const nGSSource = vtkShaderProgram.substitute(\n      GSSource,\n      '//VTK::System::Dec',\n      version\n    ).result;\n\n    return { VSSource: nVSSource, FSSource: nFSSource, GSSource: nGSSource };\n  };\n\n  // return NULL if there is an issue\n  publicAPI.readyShaderProgramArray = (\n    vertexCode,\n    fragmentCode,\n    geometryCode\n  ) => {\n    const data = publicAPI.replaceShaderValues(\n      vertexCode,\n      fragmentCode,\n      geometryCode\n    );\n\n    const shader = publicAPI.getShaderProgram(\n      data.VSSource,\n      data.FSSource,\n      data.GSSource\n    );\n\n    return publicAPI.readyShaderProgram(shader);\n  };\n\n  publicAPI.readyShaderProgram = (shader) => {\n    if (!shader) {\n      return null;\n    }\n\n    // compile if needed\n    if (!shader.getCompiled() && !shader.compileShader()) {\n      return null;\n    }\n\n    // bind if needed\n    if (!publicAPI.bindShader(shader)) {\n      return null;\n    }\n\n    return shader;\n  };\n\n  publicAPI.getShaderProgram = (vertexCode, fragmentCode, geometryCode) => {\n    // compute the MD5 and the check the map\n    const hashInput = `${vertexCode}${fragmentCode}${geometryCode}`;\n    const result = Md5.hash(hashInput);\n\n    // does it already exist?\n    if (!(result in model.shaderPrograms)) {\n      // create one\n      const sps = vtkShaderProgram.newInstance();\n      sps.setContext(model.context);\n      sps.getVertexShader().setSource(vertexCode);\n      sps.getFragmentShader().setSource(fragmentCode);\n      if (geometryCode) {\n        sps.getGeometryShader().setSource(geometryCode);\n      }\n      sps.setMd5Hash(result);\n      model.shaderPrograms[result] = sps;\n      return sps;\n    }\n\n    return model.shaderPrograms[result];\n  };\n\n  publicAPI.releaseGraphicsResources = (win) => {\n    // NOTE:\n    // In the current implementation as of October 26th, if a shader\n    // program is created by ShaderCache then it should make sure\n    // that it releases the graphics resources used by these programs.\n    // It is not wisely for callers to do that since then they would\n    // have to loop over all the programs were in use and invoke\n    // release graphics resources individually.\n\n    publicAPI.releaseCurrentShader();\n\n    Object.keys(model.shaderPrograms)\n      .map((key) => model.shaderPrograms[key])\n      .forEach((sp) => sp.releaseGraphicsResources(win));\n  };\n\n  publicAPI.releaseGraphicsResources = () => {\n    // release prior shader\n    if (model.astShaderBound) {\n      model.lastShaderBound.release();\n      model.lastShaderBound = null;\n    }\n  };\n\n  publicAPI.bindShader = (shader) => {\n    if (model.lastShaderBound === shader) {\n      return 1;\n    }\n\n    // release prior shader\n    if (model.lastShaderBound) {\n      model.lastShaderBound.release();\n    }\n    shader.bind();\n    model.lastShaderBound = shader;\n    return 1;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  lastShaderBound: null,\n  shaderPrograms: null,\n  context: null,\n  // _openGLRenderWindow: null,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Internal objects\n  model.shaderPrograms = {};\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, SET_GET_FIELDS);\n  macro.moveToProtected(publicAPI, model, ['openGLRenderWindow']);\n\n  // Object methods\n  vtkShaderCache(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkShaderCache');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}