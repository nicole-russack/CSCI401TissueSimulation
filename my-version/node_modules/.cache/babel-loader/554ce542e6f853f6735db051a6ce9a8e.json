{"ast":null,"code":"import * as macro from 'vtk.js/Sources/macros';\nimport vtkWebGPUTypes from 'vtk.js/Sources/Rendering/WebGPU/Types';\n\nfunction arraysEqual(a, b) {\n  if (a === b) return true;\n  if (a == null || b == null) return false;\n  if (a.length !== b.length) return false;\n\n  for (let i = 0; i < a.length; ++i) {\n    if (!b.includes(a[i])) return false;\n  }\n\n  return true;\n} // ----------------------------------------------------------------------------\n// vtkWebGPUVertexInput methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkWebGPUVertexInput(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUVertexInput');\n\n  publicAPI.addBuffer = function (buffer, inames) {\n    let stepMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'vertex';\n    let names = inames;\n\n    if (!Array.isArray(names)) {\n      names = [names];\n    } // only add if it is a new setting\n\n\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (arraysEqual(model.inputs[i].names, names)) {\n        if (model.inputs[i].buffer === buffer) {\n          return;\n        }\n\n        model.inputs[i].buffer = buffer;\n        return;\n      }\n    } // when adding a new entry, make sure we sort the array\n    // as the order is important to the shader and must always\n    // be the same, so alphabetical is an easy option\n\n\n    model.inputs.push({\n      buffer,\n      stepMode,\n      names\n    });\n    model.inputs = model.inputs.sort((v1, v2) => {\n      if (v1.names[0] < v2.names[0]) {\n        return -1;\n      }\n\n      if (v1.names[0] > v2.names[0]) {\n        return 1;\n      }\n\n      return 0;\n    });\n  };\n\n  publicAPI.removeBufferIfPresent = name => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        model.inputs.splice(i, 1);\n      }\n    }\n  };\n\n  publicAPI.getBuffer = name => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return model.inputs[i].buffer;\n      }\n    }\n\n    return null;\n  };\n\n  publicAPI.hasAttribute = name => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  publicAPI.getAttributeTime = name => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return model.inputs[i].buffer.getSourceTime();\n      }\n    }\n\n    return 0;\n  };\n\n  publicAPI.getShaderCode = () => {\n    let result = '';\n    let nameCount = 0;\n\n    for (let i = 0; i < model.inputs.length; i++) {\n      for (let nm = 0; nm < model.inputs[i].names.length; nm++) {\n        const arrayInfo = model.inputs[i].buffer.getArrayInformation()[nm];\n        const type = vtkWebGPUTypes.getShaderTypeFromBufferFormat(arrayInfo.format);\n\n        if (nameCount > 0) {\n          result += ',\\n';\n        }\n\n        result = `${result}  @location(${nameCount}) ${model.inputs[i].names[nm]} : ${type}`;\n        nameCount++;\n      }\n    }\n\n    return result;\n  };\n\n  publicAPI.getVertexInputInformation = () => {\n    const info = {};\n\n    if (model.inputs.length) {\n      const vertexBuffers = [];\n      let nameCount = 0;\n\n      for (let i = 0; i < model.inputs.length; i++) {\n        const buf = model.inputs[i].buffer;\n        const buffer = {\n          arrayStride: buf.getStrideInBytes(),\n          stepMode: model.inputs[i].stepMode,\n          attributes: []\n        };\n        const arrayInfo = buf.getArrayInformation();\n\n        for (let nm = 0; nm < model.inputs[i].names.length; nm++) {\n          buffer.attributes.push({\n            shaderLocation: nameCount,\n            offset: arrayInfo[nm].offset,\n            format: arrayInfo[nm].format\n          });\n          nameCount++;\n        }\n\n        vertexBuffers.push(buffer);\n      }\n\n      info.buffers = vertexBuffers;\n    }\n\n    return info;\n  };\n\n  publicAPI.bindBuffers = renderEncoder => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      renderEncoder.setVertexBuffer(i, model.inputs[i].buffer.getHandle());\n    }\n\n    if (model.indexBuffer) {\n      renderEncoder.setIndexBuffer(model.indexBuffer.getHandle(), model.indexBuffer.getArrayInformation()[0].format);\n    }\n  };\n\n  publicAPI.getReady = () => {};\n\n  publicAPI.releaseGraphicsResources = () => {\n    if (model.created) {\n      model.inputs = [];\n      model.bindingDescriptions = [];\n      model.attributeDescriptions = [];\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  inputs: null,\n  bindingDescriptions: false,\n  attributeDescriptions: null,\n  indexBuffer: null\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  model.bindingDescriptions = [];\n  model.attributeDescriptions = [];\n  model.inputs = [];\n  macro.setGet(publicAPI, model, ['created', 'device', 'handle', 'indexBuffer']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkWebGPUVertexInput(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkWebGPUVertexInput'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["macro","vtkWebGPUTypes","arraysEqual","a","b","length","i","includes","vtkWebGPUVertexInput","publicAPI","model","classHierarchy","push","addBuffer","buffer","inames","stepMode","names","Array","isArray","inputs","sort","v1","v2","removeBufferIfPresent","name","splice","getBuffer","hasAttribute","getAttributeTime","getSourceTime","getShaderCode","result","nameCount","nm","arrayInfo","getArrayInformation","type","getShaderTypeFromBufferFormat","format","getVertexInputInformation","info","vertexBuffers","buf","arrayStride","getStrideInBytes","attributes","shaderLocation","offset","buffers","bindBuffers","renderEncoder","setVertexBuffer","getHandle","indexBuffer","setIndexBuffer","getReady","releaseGraphicsResources","created","bindingDescriptions","attributeDescriptions","DEFAULT_VALUES","extend","initialValues","Object","assign","obj","setGet","newInstance"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/WebGPU/VertexInput/index.js"],"sourcesContent":["import * as macro from 'vtk.js/Sources/macros';\nimport vtkWebGPUTypes from 'vtk.js/Sources/Rendering/WebGPU/Types';\n\nfunction arraysEqual(a, b) {\n  if (a === b) return true;\n  if (a == null || b == null) return false;\n  if (a.length !== b.length) return false;\n\n  for (let i = 0; i < a.length; ++i) {\n    if (!b.includes(a[i])) return false;\n  }\n  return true;\n}\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUVertexInput methods\n// ----------------------------------------------------------------------------\nfunction vtkWebGPUVertexInput(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUVertexInput');\n\n  publicAPI.addBuffer = (buffer, inames, stepMode = 'vertex') => {\n    let names = inames;\n    if (!Array.isArray(names)) {\n      names = [names];\n    }\n    // only add if it is a new setting\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (arraysEqual(model.inputs[i].names, names)) {\n        if (model.inputs[i].buffer === buffer) {\n          return;\n        }\n        model.inputs[i].buffer = buffer;\n        return;\n      }\n    }\n\n    // when adding a new entry, make sure we sort the array\n    // as the order is important to the shader and must always\n    // be the same, so alphabetical is an easy option\n    model.inputs.push({ buffer, stepMode, names });\n    model.inputs = model.inputs.sort((v1, v2) => {\n      if (v1.names[0] < v2.names[0]) {\n        return -1;\n      }\n      if (v1.names[0] > v2.names[0]) {\n        return 1;\n      }\n      return 0;\n    });\n  };\n\n  publicAPI.removeBufferIfPresent = (name) => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        model.inputs.splice(i, 1);\n      }\n    }\n  };\n\n  publicAPI.getBuffer = (name) => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return model.inputs[i].buffer;\n      }\n    }\n    return null;\n  };\n\n  publicAPI.hasAttribute = (name) => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  publicAPI.getAttributeTime = (name) => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return model.inputs[i].buffer.getSourceTime();\n      }\n    }\n    return 0;\n  };\n\n  publicAPI.getShaderCode = () => {\n    let result = '';\n    let nameCount = 0;\n    for (let i = 0; i < model.inputs.length; i++) {\n      for (let nm = 0; nm < model.inputs[i].names.length; nm++) {\n        const arrayInfo = model.inputs[i].buffer.getArrayInformation()[nm];\n        const type = vtkWebGPUTypes.getShaderTypeFromBufferFormat(\n          arrayInfo.format\n        );\n        if (nameCount > 0) {\n          result += ',\\n';\n        }\n        result = `${result}  @location(${nameCount}) ${model.inputs[i].names[nm]} : ${type}`;\n        nameCount++;\n      }\n    }\n    return result;\n  };\n\n  publicAPI.getVertexInputInformation = () => {\n    const info = {};\n    if (model.inputs.length) {\n      const vertexBuffers = [];\n      let nameCount = 0;\n      for (let i = 0; i < model.inputs.length; i++) {\n        const buf = model.inputs[i].buffer;\n\n        const buffer = {\n          arrayStride: buf.getStrideInBytes(),\n          stepMode: model.inputs[i].stepMode,\n          attributes: [],\n        };\n        const arrayInfo = buf.getArrayInformation();\n        for (let nm = 0; nm < model.inputs[i].names.length; nm++) {\n          buffer.attributes.push({\n            shaderLocation: nameCount,\n            offset: arrayInfo[nm].offset,\n            format: arrayInfo[nm].format,\n          });\n          nameCount++;\n        }\n        vertexBuffers.push(buffer);\n      }\n      info.buffers = vertexBuffers;\n    }\n    return info;\n  };\n\n  publicAPI.bindBuffers = (renderEncoder) => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      renderEncoder.setVertexBuffer(i, model.inputs[i].buffer.getHandle());\n    }\n    if (model.indexBuffer) {\n      renderEncoder.setIndexBuffer(\n        model.indexBuffer.getHandle(),\n        model.indexBuffer.getArrayInformation()[0].format\n      );\n    }\n  };\n\n  publicAPI.getReady = () => {};\n\n  publicAPI.releaseGraphicsResources = () => {\n    if (model.created) {\n      model.inputs = [];\n      model.bindingDescriptions = [];\n      model.attributeDescriptions = [];\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\nconst DEFAULT_VALUES = {\n  inputs: null,\n  bindingDescriptions: false,\n  attributeDescriptions: null,\n  indexBuffer: null,\n};\n\n// ----------------------------------------------------------------------------\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n\n  model.bindingDescriptions = [];\n  model.attributeDescriptions = [];\n  model.inputs = [];\n\n  macro.setGet(publicAPI, model, [\n    'created',\n    'device',\n    'handle',\n    'indexBuffer',\n  ]);\n\n  // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n  vtkWebGPUVertexInput(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\nexport const newInstance = macro.newInstance(extend, 'vtkWebGPUVertexInput');\n\n// ----------------------------------------------------------------------------\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}