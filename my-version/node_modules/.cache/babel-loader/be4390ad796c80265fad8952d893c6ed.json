{"ast":null,"code":"import * as macro from 'vtk.js/Sources/macros';\nimport { vec3, mat3, mat4 } from 'gl-matrix'; // import vtkBoundingBox       from 'vtk.js/Sources/Common/DataModel/BoundingBox';\n\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nimport { VtkDataTypes } from 'vtk.js/Sources/Common/Core/DataArray/Constants';\nimport vtkHelper from 'vtk.js/Sources/Rendering/OpenGL/Helper';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkOpenGLFramebuffer from 'vtk.js/Sources/Rendering/OpenGL/Framebuffer';\nimport vtkOpenGLTexture from 'vtk.js/Sources/Rendering/OpenGL/Texture';\nimport vtkShaderProgram from 'vtk.js/Sources/Rendering/OpenGL/ShaderProgram';\nimport vtkVertexArrayObject from 'vtk.js/Sources/Rendering/OpenGL/VertexArrayObject';\nimport vtkViewNode from 'vtk.js/Sources/Rendering/SceneGraph/ViewNode';\nimport { Representation } from 'vtk.js/Sources/Rendering/Core/Property/Constants';\nimport { Wrap, Filter } from 'vtk.js/Sources/Rendering/OpenGL/Texture/Constants';\nimport { InterpolationType, OpacityMode } from 'vtk.js/Sources/Rendering/Core/VolumeProperty/Constants';\nimport { BlendMode } from 'vtk.js/Sources/Rendering/Core/VolumeMapper/Constants';\nimport vtkVolumeVS from 'vtk.js/Sources/Rendering/OpenGL/glsl/vtkVolumeVS.glsl';\nimport vtkVolumeFS from 'vtk.js/Sources/Rendering/OpenGL/glsl/vtkVolumeFS.glsl';\nimport { registerOverride } from 'vtk.js/Sources/Rendering/OpenGL/ViewNodeFactory';\nconst {\n  vtkWarningMacro,\n  vtkErrorMacro\n} = macro; // TODO: Do we want this in some shared utility? Shouldwe just use lodash.isEqual\n\nfunction arrayEquals(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n} // ----------------------------------------------------------------------------\n// vtkOpenGLVolumeMapper methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkOpenGLVolumeMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLVolumeMapper');\n\n  publicAPI.buildPass = () => {\n    model.zBufferTexture = null;\n  }; // ohh someone is doing a zbuffer pass, use that for\n  // intermixed volume rendering\n\n\n  publicAPI.opaqueZBufferPass = (prepass, renderPass) => {\n    if (prepass) {\n      const zbt = renderPass.getZBufferTexture();\n\n      if (zbt !== model.zBufferTexture) {\n        model.zBufferTexture = zbt;\n      }\n    }\n  }; // Renders myself\n\n\n  publicAPI.volumePass = (prepass, renderPass) => {\n    if (prepass) {\n      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderWindow');\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.jitterTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow); // Per Component?\n\n      model.scalarTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.opacityTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.openGLVolume = publicAPI.getFirstAncestorOfType('vtkOpenGLVolume');\n      const actor = model.openGLVolume.getRenderable();\n      model.openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      const ren = model.openGLRenderer.getRenderable();\n      model.openGLCamera = model.openGLRenderer.getViewNodeFor(ren.getActiveCamera());\n      publicAPI.renderPiece(ren, actor);\n    }\n  };\n\n  publicAPI.buildShaders = (shaders, ren, actor) => {\n    publicAPI.getShaderTemplate(shaders, ren, actor);\n    publicAPI.replaceShaderValues(shaders, ren, actor);\n  };\n\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkVolumeVS;\n    shaders.Fragment = vtkVolumeFS;\n    shaders.Geometry = '';\n  };\n\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment; // define some values in the shader\n\n    const iType = actor.getProperty().getInterpolationType();\n\n    if (iType === InterpolationType.LINEAR) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TrilinearOn', '#define vtkTrilinearOn').result;\n    }\n\n    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();\n\n    if (vtkImageLabelOutline === true) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ImageLabelOutlineOn', '#define vtkImageLabelOutlineOn').result;\n    }\n\n    const numComp = model.scalarTexture.getComponents();\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::NumComponents', `#define vtkNumComponents ${numComp}`).result;\n    const iComps = actor.getProperty().getIndependentComponents();\n\n    if (iComps) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::IndependentComponentsOn', '#define vtkIndependentComponentsOn').result; // Define any proportional components\n\n      const proportionalComponents = [];\n\n      for (let nc = 0; nc < numComp; nc++) {\n        if (actor.getProperty().getOpacityMode(nc) === OpacityMode.PROPORTIONAL) {\n          proportionalComponents.push(`#define vtkComponent${nc}Proportional`);\n        }\n      }\n\n      if (proportionalComponents.length > 0) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::vtkProportionalComponents', proportionalComponents.join('\\n')).result;\n      }\n    } // WebGL only supports loops over constants\n    // and does not support while loops so we\n    // have to hard code how many steps/samples to take\n    // We do a break so most systems will gracefully\n    // early terminate, but it is always possible\n    // a system will execute every step regardless\n\n\n    const ext = model.currentInput.getSpatialExtent();\n    const spc = model.currentInput.getSpacing();\n    const vsize = new Float64Array(3);\n    vec3.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);\n    const maxSamples = vec3.length(vsize) / model.renderable.getSampleDistance();\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::MaximumSamplesValue', `${Math.ceil(maxSamples)}`).result; // set light complexity\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::LightComplexity', `#define vtkLightComplexity ${model.lastLightComplexity}`).result; // set shadow blending flag\n\n    if (model.lastLightComplexity > 0) {\n      if (model.renderable.getVolumetricScatteringBlending() > 0.0) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::VolumeShadowOn', `#define VolumeShadowOn`).result;\n      }\n\n      if (model.renderable.getVolumetricScatteringBlending() < 1.0) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::SurfaceShadowOn', `#define SurfaceShadowOn`).result;\n      }\n\n      if (model.renderable.getVolumetricScatteringBlending() === 0.0 && model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0.0) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::localAmbientOcclusionOn', `#define localAmbientOcclusionOn`).result;\n      }\n    } // if using gradient opacity define that\n\n\n    model.gopacity = actor.getProperty().getUseGradientOpacity(0);\n\n    for (let nc = 1; iComps && !model.gopacity && nc < numComp; ++nc) {\n      if (actor.getProperty().getUseGradientOpacity(nc)) {\n        model.gopacity = true;\n      }\n    }\n\n    if (model.gopacity) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::GradientOpacityOn', '#define vtkGradientOpacityOn').result;\n    } // set normal from density\n\n\n    if (model.renderable.getComputeNormalFromOpacity()) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::vtkComputeNormalFromOpacity', `#define vtkComputeNormalFromOpacity`).result;\n    } // if we have a ztexture then declare it and use it\n\n\n    if (model.zBufferTexture !== null) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', ['uniform sampler2D zBufferTexture;', 'uniform float vpWidth;', 'uniform float vpHeight;']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpWidth, gl_FragCoord.y/vpHeight));', 'float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;', 'zdepth = zdepth * 2.0 - 1.0;', 'zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;', 'zdepth = -zdepth/rayDir.z;', 'dists.y = min(zdepth,dists.y);']).result;\n    } // Set the BlendMode approach\n\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::BlendMode', `${model.renderable.getBlendMode()}`).result;\n    shaders.Fragment = FSSource;\n    publicAPI.replaceShaderLight(shaders, ren, actor);\n    publicAPI.replaceShaderClippingPlane(shaders, ren, actor);\n  };\n\n  publicAPI.replaceShaderLight = (shaders, ren, actor) => {\n    if (model.lastLightComplexity === 0) {\n      return;\n    }\n\n    let FSSource = shaders.Fragment; // check for shadow maps - not implemented yet, skip\n    // const shadowFactor = '';\n    // to-do: single out the case when complexity = 1\n    // only account for lights that are switched on\n\n    let lightNum = 0;\n    ren.getLights().forEach(light => {\n      if (light.getSwitch()) {\n        lightNum += 1;\n      }\n    });\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', [`uniform int lightNum;`, `uniform bool twoSidedLighting;`, `uniform vec3 lightColor[${lightNum}];`, `uniform vec3 lightDirectionVC[${lightNum}]; // normalized`, `uniform vec3 lightHalfAngleVC[${lightNum}];`, '//VTK::Light::Dec'], false).result; // support any number of lights\n\n    if (model.lastLightComplexity === 3) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', [`uniform vec3 lightPositionVC[${lightNum}];`, `uniform vec3 lightAttenuation[${lightNum}];`, `uniform float lightConeAngle[${lightNum}];`, `uniform float lightExponent[${lightNum}];`, `uniform int lightPositional[${lightNum}];`], false).result;\n    }\n\n    if (model.renderable.getVolumetricScatteringBlending() > 0.0) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::VolumeShadow::Dec', [`uniform float volumetricScatteringBlending;`, `uniform float giReach;`, `uniform float volumeShadowSamplingDistFactor;`, `uniform float anisotropy;`, `uniform float anisotropy2;`], false).result;\n    }\n\n    if (model.renderable.getVolumetricScatteringBlending() === 0.0 && model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0.0) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::LAO::Dec', [`uniform int kernelRadius;`, `uniform vec2 kernelSample[${model.renderable.getLAOKernelRadius()}];`, `uniform int kernelSize;`], false).result;\n    }\n\n    shaders.Fragment = FSSource;\n  };\n\n  publicAPI.replaceShaderClippingPlane = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment;\n\n    if (model.renderable.getClippingPlanes().length > 0) {\n      const clipPlaneSize = model.renderable.getClippingPlanes().length;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ClipPlane::Dec', [`uniform vec3 vClipPlaneNormals[6];`, `uniform float vClipPlaneDistances[6];`, '//VTK::ClipPlane::Dec'], false).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ClipPlane::Impl', [`for(int i = 0; i < ${clipPlaneSize}; i++) {`, '  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);', '  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];', '  if (rayDirRatio == 0.0)', '  {', '    if (equationResult < 0.0) dists.x = dists.y;', '    continue;', '  }', '  float result = -1.0 * equationResult / rayDirRatio;', '  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);', '  else dists.x = max(dists.x, result);', '}', '//VTK::ClipPlane::Impl'], false).result;\n    }\n\n    shaders.Fragment = FSSource;\n  };\n\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    // do we need lighting?\n    let lightComplexity = 0;\n\n    if (actor.getProperty().getShade() && model.renderable.getBlendMode() === BlendMode.COMPOSITE_BLEND) {\n      // consider the lighting complexity to determine which case applies\n      // simple headlight, Light Kit, the whole feature set of VTK\n      lightComplexity = 0;\n      model.numberOfLights = 0;\n      ren.getLights().forEach(light => {\n        const status = light.getSwitch();\n\n        if (status > 0) {\n          model.numberOfLights++;\n\n          if (lightComplexity === 0) {\n            lightComplexity = 1;\n          }\n        }\n\n        if (lightComplexity === 1 && (model.numberOfLights > 1 || light.getIntensity() !== 1.0 || !light.lightTypeIsHeadLight())) {\n          lightComplexity = 2;\n        }\n\n        if (lightComplexity < 3 && light.getPositional()) {\n          lightComplexity = 3;\n        }\n      });\n    }\n\n    let needRebuild = false;\n\n    if (model.lastLightComplexity !== lightComplexity) {\n      model.lastLightComplexity = lightComplexity;\n      needRebuild = true;\n    }\n\n    const numComp = model.scalarTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n    let usesProportionalComponents = false;\n    const proportionalComponents = [];\n\n    if (iComps) {\n      // Define any proportional components\n      for (let nc = 0; nc < numComp; nc++) {\n        proportionalComponents.push(actor.getProperty().getOpacityMode(nc));\n      }\n\n      if (proportionalComponents.length > 0) {\n        usesProportionalComponents = true;\n      }\n    }\n\n    const ext = model.currentInput.getSpatialExtent();\n    const spc = model.currentInput.getSpacing();\n    const vsize = new Float64Array(3);\n    vec3.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);\n    const maxSamples = vec3.length(vsize) / model.renderable.getSampleDistance();\n    const state = {\n      interpolationType: actor.getProperty().getInterpolationType(),\n      useLabelOutline: actor.getProperty().getUseLabelOutline(),\n      numComp,\n      usesProportionalComponents,\n      iComps,\n      maxSamples,\n      useGradientOpacity: actor.getProperty().getUseGradientOpacity(0),\n      blendMode: model.renderable.getBlendMode(),\n      proportionalComponents\n    }; // We only need to rebuild the shader if one of these variables has changed,\n    // since they are used in the shader template replacement step.\n\n    if (!model.previousState || model.previousState.interpolationType !== state.interpolationType || model.previousState.useLabelOutline !== state.useLabelOutline || model.previousState.numComp !== state.numComp || model.previousState.usesProportionalComponents !== state.usesProportionalComponents || model.previousState.iComps !== state.iComps || model.previousState.maxSamples !== state.maxSamples || model.previousState.useGradientOpacity !== state.useGradientOpacity || model.previousState.blendMode !== state.blendMode || !arrayEquals(model.previousState.proportionalComponents, state.proportionalComponents)) {\n      model.previousState = { ...state\n      };\n      return true;\n    } // has something changed that would require us to recreate the shader?\n\n\n    if (cellBO.getProgram() === 0 || needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || !!model.lastZBufferTexture !== !!model.zBufferTexture || cellBO.getShaderSourceTime().getMTime() < publicAPI.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime()) {\n      model.lastZBufferTexture = model.zBufferTexture;\n      return true;\n    }\n\n    return false;\n  };\n\n  publicAPI.updateShaders = (cellBO, ren, actor) => {\n    model.lastBoundBO = cellBO; // has something changed that would require us to recreate the shader?\n\n    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {\n      const shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      publicAPI.buildShaders(shaders, ren, actor); // compile and bind the program if needed\n\n      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry); // if the shader changed reinitialize the VAO\n\n\n      if (newShader !== cellBO.getProgram()) {\n        cellBO.setProgram(newShader); // reset the VAO as the shader has changed\n\n        cellBO.getVAO().releaseGraphicsResources();\n      }\n\n      cellBO.getShaderSourceTime().modified();\n    } else {\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());\n    }\n\n    cellBO.getVAO().bind();\n    publicAPI.setMapperShaderParameters(cellBO, ren, actor);\n    publicAPI.setCameraShaderParameters(cellBO, ren, actor);\n    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);\n    publicAPI.getClippingPlaneShaderParameters(cellBO, ren, actor);\n  };\n\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    // Now to update the VAO too, if necessary.\n    const program = cellBO.getProgram();\n\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      if (program.isAttributeUsed('vertexDC')) {\n        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), 'vertexDC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexDC in shader VAO.');\n        }\n      }\n\n      cellBO.getAttributeUpdateTime().modified();\n    }\n\n    program.setUniformi('texture1', model.scalarTexture.getTextureUnit());\n    program.setUniformf('sampleDistance', model.renderable.getSampleDistance());\n    const volInfo = model.scalarTexture.getVolumeInfo();\n    const ipScalarRange = model.renderable.getIpScalarRange();\n    const minVals = [];\n    const maxVals = [];\n\n    for (let i = 0; i < 4; i++) {\n      // convert iprange from 0-1 into data range values\n      minVals[i] = ipScalarRange[0] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i];\n      maxVals[i] = ipScalarRange[1] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i]; // convert data ranges into texture values\n\n      minVals[i] = (minVals[i] - volInfo.offset[i]) / volInfo.scale[i];\n      maxVals[i] = (maxVals[i] - volInfo.offset[i]) / volInfo.scale[i];\n    }\n\n    program.setUniform4f('ipScalarRangeMin', minVals[0], minVals[1], minVals[2], minVals[3]);\n    program.setUniform4f('ipScalarRangeMax', maxVals[0], maxVals[1], maxVals[2], maxVals[3]); // if we have a zbuffer texture then set it\n\n    if (model.zBufferTexture !== null) {\n      program.setUniformi('zBufferTexture', model.zBufferTexture.getTextureUnit());\n      const size = model._useSmallViewport ? [model._smallViewportWidth, model._smallViewportHeight] : model._openGLRenderWindow.getFramebufferSize();\n      program.setUniformf('vpWidth', size[0]);\n      program.setUniformf('vpHeight', size[1]);\n    }\n  };\n\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    // // [WMVP]C == {world, model, view, projection} coordinates\n    // // E.g., WCPC == world to projection coordinate transformation\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    const actMats = model.openGLVolume.getKeyMatrices();\n    mat4.multiply(model.modelToView, keyMats.wcvc, actMats.mcwc);\n    const program = cellBO.getProgram();\n    const cam = model.openGLCamera.getRenderable();\n    const crange = cam.getClippingRange();\n    program.setUniformf('camThick', crange[1] - crange[0]);\n    program.setUniformf('camNear', crange[0]);\n    program.setUniformf('camFar', crange[1]);\n    const bounds = model.currentInput.getBounds();\n    const dims = model.currentInput.getDimensions(); // compute the viewport bounds of the volume\n    // we will only render those fragments.\n\n    const pos = new Float64Array(3);\n    const dir = new Float64Array(3);\n    let dcxmin = 1.0;\n    let dcxmax = -1.0;\n    let dcymin = 1.0;\n    let dcymax = -1.0;\n\n    for (let i = 0; i < 8; ++i) {\n      vec3.set(pos, bounds[i % 2], bounds[2 + Math.floor(i / 2) % 2], bounds[4 + Math.floor(i / 4)]);\n      vec3.transformMat4(pos, pos, model.modelToView);\n\n      if (!cam.getParallelProjection()) {\n        vec3.normalize(dir, pos); // now find the projection of this point onto a\n        // nearZ distance plane. Since the camera is at 0,0,0\n        // in VC the ray is just t*pos and\n        // t is -nearZ/dir.z\n        // intersection becomes pos.x/pos.z\n\n        const t = -crange[0] / pos[2];\n        vec3.scale(pos, dir, t);\n      } // now convert to DC\n\n\n      vec3.transformMat4(pos, pos, keyMats.vcpc);\n      dcxmin = Math.min(pos[0], dcxmin);\n      dcxmax = Math.max(pos[0], dcxmax);\n      dcymin = Math.min(pos[1], dcymin);\n      dcymax = Math.max(pos[1], dcymax);\n    }\n\n    program.setUniformf('dcxmin', dcxmin);\n    program.setUniformf('dcxmax', dcxmax);\n    program.setUniformf('dcymin', dcymin);\n    program.setUniformf('dcymax', dcymax);\n\n    if (program.isUniformUsed('cameraParallel')) {\n      program.setUniformi('cameraParallel', cam.getParallelProjection());\n    }\n\n    const ext = model.currentInput.getSpatialExtent();\n    const spc = model.currentInput.getSpacing();\n    const vsize = new Float64Array(3);\n    vec3.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);\n    program.setUniform3f('vSpacing', spc[0], spc[1], spc[2]);\n    vec3.set(pos, ext[0], ext[2], ext[4]);\n    model.currentInput.indexToWorldVec3(pos, pos);\n    vec3.transformMat4(pos, pos, model.modelToView);\n    program.setUniform3f('vOriginVC', pos[0], pos[1], pos[2]); // apply the image directions\n\n    const i2wmat4 = model.currentInput.getIndexToWorld();\n    mat4.multiply(model.idxToView, model.modelToView, i2wmat4);\n    mat3.multiply(model.idxNormalMatrix, keyMats.normalMatrix, actMats.normalMatrix);\n    mat3.multiply(model.idxNormalMatrix, model.idxNormalMatrix, model.currentInput.getDirection());\n    const maxSamples = vec3.length(vsize) / model.renderable.getSampleDistance();\n\n    if (maxSamples > model.renderable.getMaximumSamplesPerRay()) {\n      vtkWarningMacro(`The number of steps required ${Math.ceil(maxSamples)} is larger than the\n        specified maximum number of steps ${model.renderable.getMaximumSamplesPerRay()}.\n        Please either change the\n        volumeMapper sampleDistance or its maximum number of samples.`);\n    }\n\n    const vctoijk = new Float64Array(3);\n    vec3.set(vctoijk, 1.0, 1.0, 1.0);\n    vec3.divide(vctoijk, vctoijk, vsize);\n    program.setUniform3f('vVCToIJK', vctoijk[0], vctoijk[1], vctoijk[2]);\n    program.setUniform3i('volumeDimensions', dims[0], dims[1], dims[2]);\n\n    if (!model._openGLRenderWindow.getWebgl2()) {\n      const volInfo = model.scalarTexture.getVolumeInfo();\n      program.setUniformf('texWidth', model.scalarTexture.getWidth());\n      program.setUniformf('texHeight', model.scalarTexture.getHeight());\n      program.setUniformi('xreps', volInfo.xreps);\n      program.setUniformi('xstride', volInfo.xstride);\n      program.setUniformi('ystride', volInfo.ystride);\n    } // map normals through normal matrix\n    // then use a point on the plane to compute the distance\n\n\n    const normal = new Float64Array(3);\n    const pos2 = new Float64Array(3);\n\n    for (let i = 0; i < 6; ++i) {\n      switch (i) {\n        case 1:\n          vec3.set(normal, -1.0, 0.0, 0.0);\n          vec3.set(pos2, ext[0], ext[2], ext[4]);\n          break;\n\n        case 2:\n          vec3.set(normal, 0.0, 1.0, 0.0);\n          vec3.set(pos2, ext[1], ext[3], ext[5]);\n          break;\n\n        case 3:\n          vec3.set(normal, 0.0, -1.0, 0.0);\n          vec3.set(pos2, ext[0], ext[2], ext[4]);\n          break;\n\n        case 4:\n          vec3.set(normal, 0.0, 0.0, 1.0);\n          vec3.set(pos2, ext[1], ext[3], ext[5]);\n          break;\n\n        case 5:\n          vec3.set(normal, 0.0, 0.0, -1.0);\n          vec3.set(pos2, ext[0], ext[2], ext[4]);\n          break;\n\n        case 0:\n        default:\n          vec3.set(normal, 1.0, 0.0, 0.0);\n          vec3.set(pos2, ext[1], ext[3], ext[5]);\n          break;\n      }\n\n      vec3.transformMat3(normal, normal, model.idxNormalMatrix);\n      vec3.transformMat4(pos2, pos2, model.idxToView);\n      const dist = -1.0 * vec3.dot(pos2, normal); // we have the plane in view coordinates\n      // specify the planes in view coordinates\n\n      program.setUniform3f(`vPlaneNormal${i}`, normal[0], normal[1], normal[2]);\n      program.setUniformf(`vPlaneDistance${i}`, dist);\n    }\n\n    if (actor.getProperty().getUseLabelOutline()) {\n      const image = model.currentInput;\n      const worldToIndex = image.getWorldToIndex();\n      program.setUniformMatrix('vWCtoIDX', worldToIndex); // Get the projection coordinate to world coordinate transformation matrix.\n\n      mat4.invert(model.projectionToWorld, keyMats.wcpc);\n      program.setUniformMatrix('PCWCMatrix', model.projectionToWorld);\n      const size = publicAPI.getRenderTargetSize();\n      program.setUniformf('vpWidth', size[0]);\n      program.setUniformf('vpHeight', size[1]);\n      const offset = publicAPI.getRenderTargetOffset();\n      program.setUniformf('vpOffsetX', offset[0] / size[0]);\n      program.setUniformf('vpOffsetY', offset[1] / size[1]);\n    }\n\n    mat4.invert(model.projectionToView, keyMats.vcpc);\n    program.setUniformMatrix('PCVCMatrix', model.projectionToView); // handle lighting values\n\n    if (model.lastLightComplexity === 0) {\n      return;\n    }\n\n    let lightNum = 0;\n    const lightColor = [];\n    const lightDir = [];\n    const halfAngle = [];\n    ren.getLights().forEach(light => {\n      const status = light.getSwitch();\n\n      if (status > 0) {\n        const dColor = light.getColor();\n        const intensity = light.getIntensity();\n        lightColor[0 + lightNum * 3] = dColor[0] * intensity;\n        lightColor[1 + lightNum * 3] = dColor[1] * intensity;\n        lightColor[2 + lightNum * 3] = dColor[2] * intensity;\n        const ldir = light.getDirection();\n        vec3.set(normal, ldir[0], ldir[1], ldir[2]);\n        vec3.transformMat3(normal, normal, keyMats.normalMatrix); // in view coordinat\n\n        vec3.normalize(normal, normal);\n        lightDir[0 + lightNum * 3] = normal[0];\n        lightDir[1 + lightNum * 3] = normal[1];\n        lightDir[2 + lightNum * 3] = normal[2]; // camera DOP is 0,0,-1.0 in VC\n\n        halfAngle[0 + lightNum * 3] = -0.5 * normal[0];\n        halfAngle[1 + lightNum * 3] = -0.5 * normal[1];\n        halfAngle[2 + lightNum * 3] = -0.5 * (normal[2] - 1.0);\n        lightNum++;\n      }\n    });\n    program.setUniformi('twoSidedLighting', ren.getTwoSidedLighting());\n    program.setUniformi('lightNum', lightNum);\n    program.setUniform3fv('lightColor', lightColor);\n    program.setUniform3fv('lightDirectionVC', lightDir);\n    program.setUniform3fv('lightHalfAngleVC', halfAngle);\n\n    if (model.lastLightComplexity === 3) {\n      lightNum = 0;\n      const lightPositionVC = [];\n      const lightAttenuation = [];\n      const lightConeAngle = [];\n      const lightExponent = [];\n      const lightPositional = [];\n      ren.getLights().forEach(light => {\n        const status = light.getSwitch();\n\n        if (status > 0) {\n          const attenuation = light.getAttenuationValues();\n          lightAttenuation[0 + lightNum * 3] = attenuation[0];\n          lightAttenuation[1 + lightNum * 3] = attenuation[1];\n          lightAttenuation[2 + lightNum * 3] = attenuation[2];\n          lightExponent[lightNum] = light.getExponent();\n          lightConeAngle[lightNum] = light.getConeAngle();\n          lightPositional[lightNum] = light.getPositional();\n          const lp = light.getTransformedPosition();\n          vec3.transformMat4(lp, lp, model.modelToView);\n          lightPositionVC[0 + lightNum * 3] = lp[0];\n          lightPositionVC[1 + lightNum * 3] = lp[1];\n          lightPositionVC[2 + lightNum * 3] = lp[2];\n          lightNum += 1;\n        }\n      });\n      program.setUniform3fv('lightPositionVC', lightPositionVC);\n      program.setUniform3fv('lightAttenuation', lightAttenuation);\n      program.setUniformfv('lightConeAngle', lightConeAngle);\n      program.setUniformfv('lightExponent', lightExponent);\n      program.setUniformiv('lightPositional', lightPositional);\n    }\n\n    if (model.renderable.getVolumetricScatteringBlending() > 0.0) {\n      program.setUniformf('giReach', model.renderable.getGlobalIlluminationReach());\n      program.setUniformf('volumetricScatteringBlending', model.renderable.getVolumetricScatteringBlending());\n      program.setUniformf('volumeShadowSamplingDistFactor', model.renderable.getVolumeShadowSamplingDistFactor());\n      program.setUniformf('anisotropy', model.renderable.getAnisotropy());\n      program.setUniformf('anisotropy2', model.renderable.getAnisotropy() ** 2.0);\n    }\n\n    if (model.renderable.getVolumetricScatteringBlending() === 0.0 && model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0.0) {\n      const ks = model.renderable.getLAOKernelSize();\n      program.setUniformi('kernelSize', ks);\n      const kernelSample = [];\n\n      for (let i = 0; i < ks; i++) {\n        kernelSample[i * 2] = Math.random() * 0.5;\n        kernelSample[i * 2 + 1] = Math.random() * 0.5;\n      }\n\n      program.setUniform2fv('kernelSample', kernelSample);\n      program.setUniformi('kernelRadius', model.renderable.getLAOKernelRadius());\n    }\n  };\n\n  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    program.setUniformi('ctexture', model.colorTexture.getTextureUnit());\n    program.setUniformi('otexture', model.opacityTexture.getTextureUnit());\n    program.setUniformi('jtexture', model.jitterTexture.getTextureUnit());\n    const volInfo = model.scalarTexture.getVolumeInfo();\n    const vprop = actor.getProperty(); // set the component mix when independent\n\n    const numComp = model.scalarTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n\n    if (iComps && numComp >= 2) {\n      for (let i = 0; i < numComp; i++) {\n        program.setUniformf(`mix${i}`, actor.getProperty().getComponentWeight(i));\n      }\n    } // three levels of shift scale combined into one\n    // for performance in the fragment shader\n\n\n    for (let i = 0; i < numComp; i++) {\n      const target = iComps ? i : 0;\n      const sscale = volInfo.scale[i];\n      const ofun = vprop.getScalarOpacity(target);\n      const oRange = ofun.getRange();\n      const oscale = sscale / (oRange[1] - oRange[0]);\n      const oshift = (volInfo.offset[i] - oRange[0]) / (oRange[1] - oRange[0]);\n      program.setUniformf(`oshift${i}`, oshift);\n      program.setUniformf(`oscale${i}`, oscale);\n      const cfun = vprop.getRGBTransferFunction(target);\n      const cRange = cfun.getRange();\n      program.setUniformf(`cshift${i}`, (volInfo.offset[i] - cRange[0]) / (cRange[1] - cRange[0]));\n      program.setUniformf(`cscale${i}`, sscale / (cRange[1] - cRange[0]));\n    }\n\n    if (model.gopacity) {\n      if (iComps) {\n        for (let nc = 0; nc < numComp; ++nc) {\n          const sscale = volInfo.scale[nc];\n          const useGO = vprop.getUseGradientOpacity(nc);\n\n          if (useGO) {\n            const gomin = vprop.getGradientOpacityMinimumOpacity(nc);\n            const gomax = vprop.getGradientOpacityMaximumOpacity(nc);\n            program.setUniformf(`gomin${nc}`, gomin);\n            program.setUniformf(`gomax${nc}`, gomax);\n            const goRange = [vprop.getGradientOpacityMinimumValue(nc), vprop.getGradientOpacityMaximumValue(nc)];\n            program.setUniformf(`goscale${nc}`, sscale * (gomax - gomin) / (goRange[1] - goRange[0]));\n            program.setUniformf(`goshift${nc}`, -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin);\n          } else {\n            program.setUniformf(`gomin${nc}`, 1.0);\n            program.setUniformf(`gomax${nc}`, 1.0);\n            program.setUniformf(`goscale${nc}`, 0.0);\n            program.setUniformf(`goshift${nc}`, 1.0);\n          }\n        }\n      } else {\n        const sscale = volInfo.scale[numComp - 1];\n        const gomin = vprop.getGradientOpacityMinimumOpacity(0);\n        const gomax = vprop.getGradientOpacityMaximumOpacity(0);\n        program.setUniformf('gomin0', gomin);\n        program.setUniformf('gomax0', gomax);\n        const goRange = [vprop.getGradientOpacityMinimumValue(0), vprop.getGradientOpacityMaximumValue(0)];\n        program.setUniformf('goscale0', sscale * (gomax - gomin) / (goRange[1] - goRange[0]));\n        program.setUniformf('goshift0', -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin);\n      }\n    }\n\n    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();\n\n    if (vtkImageLabelOutline === true) {\n      const labelOutlineThickness = actor.getProperty().getLabelOutlineThickness();\n      program.setUniformi('outlineThickness', labelOutlineThickness);\n    }\n\n    if (model.lastLightComplexity > 0) {\n      program.setUniformf('vAmbient', vprop.getAmbient());\n      program.setUniformf('vDiffuse', vprop.getDiffuse());\n      program.setUniformf('vSpecular', vprop.getSpecular());\n      program.setUniformf('vSpecularPower', vprop.getSpecularPower());\n    }\n  };\n\n  publicAPI.getClippingPlaneShaderParameters = (cellBO, ren, actor) => {\n    if (model.renderable.getClippingPlanes().length > 0) {\n      const keyMats = model.openGLCamera.getKeyMatrices(ren);\n      const clipPlaneNormals = [];\n      const clipPlaneDistances = [];\n      const clipPlanes = model.renderable.getClippingPlanes();\n      const clipPlaneSize = clipPlanes.length;\n\n      for (let i = 0; i < clipPlaneSize; ++i) {\n        const clipPlaneNormal = clipPlanes[i].getNormal();\n        const clipPlanePos = clipPlanes[i].getOrigin();\n        vec3.transformMat3(clipPlaneNormal, clipPlaneNormal, keyMats.normalMatrix);\n        vec3.transformMat4(clipPlanePos, clipPlanePos, keyMats.wcvc);\n        const clipPlaneDist = -1.0 * vec3.dot(clipPlanePos, clipPlaneNormal);\n        clipPlaneNormals.push(clipPlaneNormal[0]);\n        clipPlaneNormals.push(clipPlaneNormal[1]);\n        clipPlaneNormals.push(clipPlaneNormal[2]);\n        clipPlaneDistances.push(clipPlaneDist);\n      }\n\n      const program = cellBO.getProgram();\n      program.setUniform3fv(`vClipPlaneNormals`, clipPlaneNormals);\n      program.setUniformfv(`vClipPlaneDistances`, clipPlaneDistances);\n    }\n  }; // unsubscribe from our listeners\n\n\n  publicAPI.delete = macro.chain(() => {\n    if (model._animationRateSubscription) {\n      model._animationRateSubscription.unsubscribe();\n\n      model._animationRateSubscription = null;\n    }\n  }, publicAPI.delete);\n\n  publicAPI.getRenderTargetSize = () => {\n    if (model._useSmallViewport) {\n      return [model._smallViewportWidth, model._smallViewportHeight];\n    }\n\n    const {\n      usize,\n      vsize\n    } = model.openGLRenderer.getTiledSizeAndOrigin();\n    return [usize, vsize];\n  };\n\n  publicAPI.getRenderTargetOffset = () => {\n    const {\n      lowerLeftU,\n      lowerLeftV\n    } = model.openGLRenderer.getTiledSizeAndOrigin();\n    return [lowerLeftU, lowerLeftV];\n  };\n\n  publicAPI.renderPieceStart = (ren, actor) => {\n    const rwi = ren.getVTKWindow().getInteractor();\n    model._useSmallViewport = false;\n\n    if (rwi.isAnimating() && model._lastScale > 1.5) {\n      model._useSmallViewport = true;\n    }\n\n    if (!model._animationRateSubscription) {\n      // when the animation frame rate changes recompute the scale factor\n      model._animationRateSubscription = rwi.onAnimationFrameRateUpdate(() => {\n        if (model.renderable.getAutoAdjustSampleDistances()) {\n          const frate = rwi.getRecentAnimationFrameRate();\n          const adjustment = rwi.getDesiredUpdateRate() / frate; // only change if we are off by 15%\n\n          if (adjustment > 1.15 || adjustment < 0.85) {\n            model._lastScale *= adjustment;\n          } // clamp scale to some reasonable values.\n          // Below 1.5 we will just be using full resolution as that is close enough\n          // Above 400 seems like a lot so we limit to that 1/20th per axis\n\n\n          if (model._lastScale > 400) {\n            model._lastScale = 400;\n          }\n\n          if (model._lastScale < 1.5) {\n            model._lastScale = 1.5;\n          }\n        } else {\n          model._lastScale = model.renderable.getImageSampleDistance() * model.renderable.getImageSampleDistance();\n        }\n\n        const size = model._openGLRenderWindow.getFramebufferSize();\n\n        model._smallViewportWidth = Math.ceil(size[0] / Math.sqrt(model._lastScale));\n        model._smallViewportHeight = Math.ceil(size[1] / Math.sqrt(model._lastScale));\n      });\n    } // use/create/resize framebuffer if needed\n\n\n    if (model._useSmallViewport) {\n      const size = model._openGLRenderWindow.getFramebufferSize(); // adjust viewportSize to always be at most the dest fo size\n\n\n      if (model._smallViewportHeight > size[1]) {\n        model._smallViewportHeight = size[1];\n      }\n\n      if (model._smallViewportWidth > size[0]) {\n        model._smallViewportWidth = size[0];\n      }\n\n      model.framebuffer.saveCurrentBindingsAndBuffers();\n\n      if (model.framebuffer.getGLFramebuffer() === null) {\n        model.framebuffer.create(size[0], size[1]);\n        model.framebuffer.populateFramebuffer();\n      } else {\n        const fbSize = model.framebuffer.getSize();\n\n        if (fbSize[0] !== size[0] || fbSize[1] !== size[1]) {\n          model.framebuffer.create(size[0], size[1]);\n          model.framebuffer.populateFramebuffer();\n        }\n      }\n\n      model.framebuffer.bind();\n      const gl = model.context;\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n      gl.colorMask(true, true, true, true);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      gl.viewport(0, 0, model._smallViewportWidth, model._smallViewportHeight);\n      model.fvp = [model._smallViewportWidth / size[0], model._smallViewportHeight / size[1]];\n    }\n\n    model.context.disable(model.context.DEPTH_TEST); // make sure the BOs are up to date\n\n    publicAPI.updateBufferObjects(ren, actor); // set interpolation on the texture based on property setting\n\n    const iType = actor.getProperty().getInterpolationType();\n\n    if (iType === InterpolationType.NEAREST) {\n      model.scalarTexture.setMinificationFilter(Filter.NEAREST);\n      model.scalarTexture.setMagnificationFilter(Filter.NEAREST);\n    } else {\n      model.scalarTexture.setMinificationFilter(Filter.LINEAR);\n      model.scalarTexture.setMagnificationFilter(Filter.LINEAR);\n    } // Bind the OpenGL, this is shared between the different primitive/cell types.\n\n\n    model.lastBoundBO = null; // if we have a zbuffer texture then activate it\n\n    if (model.zBufferTexture !== null) {\n      model.zBufferTexture.activate();\n    }\n  };\n\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const gl = model.context; // render the texture\n\n    model.scalarTexture.activate();\n    model.opacityTexture.activate();\n    model.colorTexture.activate();\n    model.jitterTexture.activate();\n    publicAPI.updateShaders(model.tris, ren, actor); // First we do the triangles, update the shader, set uniforms, etc.\n    // for (let i = 0; i < 11; ++i) {\n    //   gl.drawArrays(gl.TRIANGLES, 66 * i, 66);\n    // }\n\n    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n    model.tris.getVAO().release();\n    model.scalarTexture.deactivate();\n    model.colorTexture.deactivate();\n    model.opacityTexture.deactivate();\n    model.jitterTexture.deactivate();\n  };\n\n  publicAPI.renderPieceFinish = (ren, actor) => {\n    // if we have a zbuffer texture then deactivate it\n    if (model.zBufferTexture !== null) {\n      model.zBufferTexture.deactivate();\n    }\n\n    if (model._useSmallViewport) {\n      // now copy the framebuffer with the volume into the\n      // regular buffer\n      model.framebuffer.restorePreviousBindingsAndBuffers();\n\n      if (model.copyShader === null) {\n        model.copyShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(['//VTK::System::Dec', 'attribute vec4 vertexDC;', 'uniform vec2 tfactor;', 'varying vec2 tcoord;', 'void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }'].join('\\n'), ['//VTK::System::Dec', '//VTK::Output::Dec', 'uniform sampler2D texture1;', 'varying vec2 tcoord;', 'void main() { gl_FragData[0] = texture2D(texture1,tcoord); }'].join('\\n'), '');\n        const program = model.copyShader;\n        model.copyVAO = vtkVertexArrayObject.newInstance();\n        model.copyVAO.setOpenGLRenderWindow(model._openGLRenderWindow);\n        model.tris.getCABO().bind();\n\n        if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), 'vertexDC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexDC in copy shader VAO.');\n        }\n      } else {\n        model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.copyShader);\n      }\n\n      const size = model._openGLRenderWindow.getFramebufferSize();\n\n      model.context.viewport(0, 0, size[0], size[1]); // activate texture\n\n      const tex = model.framebuffer.getColorTexture();\n      tex.activate();\n      model.copyShader.setUniformi('texture', tex.getTextureUnit());\n      model.copyShader.setUniform2f('tfactor', model.fvp[0], model.fvp[1]);\n      const gl = model.context;\n      gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA); // render quad\n\n      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n      tex.deactivate();\n      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    }\n  };\n\n  publicAPI.renderPiece = (ren, actor) => {\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    });\n    model.renderable.update();\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    });\n\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n\n  publicAPI.computeBounds = (ren, actor) => {\n    if (!publicAPI.getInput()) {\n      vtkMath.uninitializeBounds(model.Bounds);\n      return;\n    }\n\n    model.bounds = publicAPI.getInput().getBounds();\n  };\n\n  publicAPI.updateBufferObjects = (ren, actor) => {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {\n    // first do a coarse check\n    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime()) {\n      return true;\n    }\n\n    return false;\n  };\n\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const image = model.currentInput;\n\n    if (!image) {\n      return;\n    }\n\n    const scalars = image.getPointData() && image.getPointData().getScalars();\n\n    if (!scalars) {\n      return;\n    }\n\n    const vprop = actor.getProperty();\n\n    if (!model.jitterTexture.getHandle()) {\n      const oTable = new Uint8Array(32 * 32);\n\n      for (let i = 0; i < 32 * 32; ++i) {\n        oTable[i] = 255.0 * Math.random();\n      }\n\n      model.jitterTexture.setMinificationFilter(Filter.LINEAR);\n      model.jitterTexture.setMagnificationFilter(Filter.LINEAR);\n      model.jitterTexture.create2DFromRaw(32, 32, 1, VtkDataTypes.UNSIGNED_CHAR, oTable);\n    }\n\n    const numComp = scalars.getNumberOfComponents();\n    const iComps = vprop.getIndependentComponents();\n    const numIComps = iComps ? numComp : 1; // rebuild opacity tfun?\n\n    let toString = `${vprop.getMTime()}`;\n\n    if (model.opacityTextureString !== toString) {\n      const oWidth = 1024;\n      const oSize = oWidth * 2 * numIComps;\n      const ofTable = new Float32Array(oSize);\n      const tmpTable = new Float32Array(oWidth);\n\n      for (let c = 0; c < numIComps; ++c) {\n        const ofun = vprop.getScalarOpacity(c);\n        const opacityFactor = model.renderable.getSampleDistance() / vprop.getScalarOpacityUnitDistance(c);\n        const oRange = ofun.getRange();\n        ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1); // adjust for sample distance etc\n\n        for (let i = 0; i < oWidth; ++i) {\n          ofTable[c * oWidth * 2 + i] = 1.0 - (1.0 - tmpTable[i]) ** opacityFactor;\n          ofTable[c * oWidth * 2 + i + oWidth] = ofTable[c * oWidth * 2 + i];\n        }\n      }\n\n      model.opacityTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.opacityTexture.setMinificationFilter(Filter.LINEAR);\n      model.opacityTexture.setMagnificationFilter(Filter.LINEAR); // use float texture where possible because we really need the resolution\n      // for this table. Errors in low values of opacity accumulate to\n      // visible artifacts. High values of opacity quickly terminate without\n      // artifacts.\n\n      if (model._openGLRenderWindow.getWebgl2() || model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes.FLOAT, ofTable);\n      } else {\n        const oTable = new Uint8Array(oSize);\n\n        for (let i = 0; i < oSize; ++i) {\n          oTable[i] = 255.0 * ofTable[i];\n        }\n\n        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes.UNSIGNED_CHAR, oTable);\n      }\n\n      model.opacityTextureString = toString;\n    } // rebuild color tfun?\n\n\n    toString = `${vprop.getMTime()}`;\n\n    if (model.colorTextureString !== toString) {\n      const cWidth = 1024;\n      const cSize = cWidth * 2 * numIComps * 3;\n      const cTable = new Uint8Array(cSize);\n      const tmpTable = new Float32Array(cWidth * 3);\n\n      for (let c = 0; c < numIComps; ++c) {\n        const cfun = vprop.getRGBTransferFunction(c);\n        const cRange = cfun.getRange();\n        cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);\n\n        for (let i = 0; i < cWidth * 3; ++i) {\n          cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n          cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];\n        }\n      }\n\n      model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.colorTexture.setMinificationFilter(Filter.LINEAR);\n      model.colorTexture.setMagnificationFilter(Filter.LINEAR);\n      model.colorTexture.create2DFromRaw(cWidth, 2 * numIComps, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      model.colorTextureString = toString;\n    } // rebuild the scalarTexture if the data has changed\n\n\n    toString = `${image.getMTime()}`;\n\n    if (model.scalarTextureString !== toString) {\n      // Build the textures\n      const dims = image.getDimensions();\n      model.scalarTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.scalarTexture.resetFormatAndType();\n      model.scalarTexture.create3DFilterableFromRaw(dims[0], dims[1], dims[2], numComp, scalars.getDataType(), scalars.getData(), model.renderable.getPreferSizeOverAccuracy());\n      model.scalarTextureString = toString;\n    }\n\n    if (!model.tris.getCABO().getElementCount()) {\n      // build the CABO\n      const ptsArray = new Float32Array(12);\n\n      for (let i = 0; i < 4; i++) {\n        ptsArray[i * 3] = i % 2 * 2 - 1.0;\n        ptsArray[i * 3 + 1] = i > 1 ? 1.0 : -1.0;\n        ptsArray[i * 3 + 2] = -1.0;\n      }\n\n      const cellArray = new Uint16Array(8);\n      cellArray[0] = 3;\n      cellArray[1] = 0;\n      cellArray[2] = 1;\n      cellArray[3] = 3;\n      cellArray[4] = 3;\n      cellArray[5] = 0;\n      cellArray[6] = 3;\n      cellArray[7] = 2; // const dim = 12.0;\n      // const ptsArray = new Float32Array(3 * dim * dim);\n      // for (let i = 0; i < dim; i++) {\n      //   for (let j = 0; j < dim; j++) {\n      //     const offset = ((i * dim) + j) * 3;\n      //     ptsArray[offset] = (2.0 * (i / (dim - 1.0))) - 1.0;\n      //     ptsArray[offset + 1] = (2.0 * (j / (dim - 1.0))) - 1.0;\n      //     ptsArray[offset + 2] = -1.0;\n      //   }\n      // }\n      // const cellArray = new Uint16Array(8 * (dim - 1) * (dim - 1));\n      // for (let i = 0; i < dim - 1; i++) {\n      //   for (let j = 0; j < dim - 1; j++) {\n      //     const offset = 8 * ((i * (dim - 1)) + j);\n      //     cellArray[offset] = 3;\n      //     cellArray[offset + 1] = (i * dim) + j;\n      //     cellArray[offset + 2] = (i * dim) + 1 + j;\n      //     cellArray[offset + 3] = ((i + 1) * dim) + 1 + j;\n      //     cellArray[offset + 4] = 3;\n      //     cellArray[offset + 5] = (i * dim) + j;\n      //     cellArray[offset + 6] = ((i + 1) * dim) + 1 + j;\n      //     cellArray[offset + 7] = ((i + 1) * dim) + j;\n      //   }\n      // }\n\n      const points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray\n      });\n      points.setName('points');\n      const cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray\n      });\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points,\n        cellOffset: 0\n      });\n    }\n\n    model.VBOBuildTime.modified();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  context: null,\n  VBOBuildTime: null,\n  scalarTexture: null,\n  scalarTextureString: null,\n  opacityTexture: null,\n  opacityTextureString: null,\n  colorTexture: null,\n  colorTextureString: null,\n  jitterTexture: null,\n  tris: null,\n  framebuffer: null,\n  copyShader: null,\n  copyVAO: null,\n  lastXYF: 1.0,\n  targetXYF: 1.0,\n  zBufferTexture: null,\n  lastZBufferTexture: null,\n  lastLightComplexity: 0,\n  fullViewportTime: 1.0,\n  idxToView: null,\n  idxNormalMatrix: null,\n  modelToView: null,\n  projectionToView: null,\n  avgWindowArea: 0.0,\n  avgFrameTime: 0.0\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.VBOBuildTime = {};\n  macro.obj(model.VBOBuildTime, {\n    mtime: 0\n  });\n  model.tris = vtkHelper.newInstance();\n  model.scalarTexture = vtkOpenGLTexture.newInstance();\n  model.opacityTexture = vtkOpenGLTexture.newInstance();\n  model.colorTexture = vtkOpenGLTexture.newInstance();\n  model.jitterTexture = vtkOpenGLTexture.newInstance();\n  model.jitterTexture.setWrapS(Wrap.REPEAT);\n  model.jitterTexture.setWrapT(Wrap.REPEAT);\n  model.framebuffer = vtkOpenGLFramebuffer.newInstance();\n  model.idxToView = mat4.identity(new Float64Array(16));\n  model.idxNormalMatrix = mat3.identity(new Float64Array(9));\n  model.modelToView = mat4.identity(new Float64Array(16));\n  model.projectionToView = mat4.identity(new Float64Array(16));\n  model.projectionToWorld = mat4.identity(new Float64Array(16));\n  model._lastScale = 1.0; // Build VTK API\n\n  macro.setGet(publicAPI, model, ['context']); // Object methods\n\n  vtkOpenGLVolumeMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkOpenGLVolumeMapper'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkVolumeMapper', newInstance);","map":{"version":3,"names":["macro","vec3","mat3","mat4","vtkDataArray","VtkDataTypes","vtkHelper","vtkMath","vtkOpenGLFramebuffer","vtkOpenGLTexture","vtkShaderProgram","vtkVertexArrayObject","vtkViewNode","Representation","Wrap","Filter","InterpolationType","OpacityMode","BlendMode","vtkVolumeVS","vtkVolumeFS","registerOverride","vtkWarningMacro","vtkErrorMacro","arrayEquals","a","b","length","i","vtkOpenGLVolumeMapper","publicAPI","model","classHierarchy","push","buildPass","zBufferTexture","opaqueZBufferPass","prepass","renderPass","zbt","getZBufferTexture","volumePass","_openGLRenderWindow","getFirstAncestorOfType","context","getContext","tris","setOpenGLRenderWindow","jitterTexture","framebuffer","scalarTexture","colorTexture","opacityTexture","openGLVolume","actor","getRenderable","openGLRenderer","ren","openGLCamera","getViewNodeFor","getActiveCamera","renderPiece","buildShaders","shaders","getShaderTemplate","replaceShaderValues","Vertex","Fragment","Geometry","FSSource","iType","getProperty","getInterpolationType","LINEAR","substitute","result","vtkImageLabelOutline","getUseLabelOutline","numComp","getComponents","iComps","getIndependentComponents","proportionalComponents","nc","getOpacityMode","PROPORTIONAL","join","ext","currentInput","getSpatialExtent","spc","getSpacing","vsize","Float64Array","set","maxSamples","renderable","getSampleDistance","Math","ceil","lastLightComplexity","getVolumetricScatteringBlending","getLocalAmbientOcclusion","getAmbient","gopacity","getUseGradientOpacity","getComputeNormalFromOpacity","getBlendMode","replaceShaderLight","replaceShaderClippingPlane","lightNum","getLights","forEach","light","getSwitch","getLAOKernelRadius","getClippingPlanes","clipPlaneSize","getNeedToRebuildShaders","cellBO","lightComplexity","getShade","COMPOSITE_BLEND","numberOfLights","status","getIntensity","lightTypeIsHeadLight","getPositional","needRebuild","usesProportionalComponents","state","interpolationType","useLabelOutline","useGradientOpacity","blendMode","previousState","getProgram","lastHaveSeenDepthRequest","haveSeenDepthRequest","lastZBufferTexture","getShaderSourceTime","getMTime","updateShaders","lastBoundBO","newShader","getShaderCache","readyShaderProgramArray","setProgram","getVAO","releaseGraphicsResources","modified","readyShaderProgram","bind","setMapperShaderParameters","setCameraShaderParameters","setPropertyShaderParameters","getClippingPlaneShaderParameters","program","getCABO","getElementCount","VBOBuildTime","getAttributeUpdateTime","isAttributeUsed","addAttributeArray","getVertexOffset","getStride","FLOAT","FALSE","setUniformi","getTextureUnit","setUniformf","volInfo","getVolumeInfo","ipScalarRange","getIpScalarRange","minVals","maxVals","dataComputedScale","dataComputedOffset","offset","scale","setUniform4f","size","_useSmallViewport","_smallViewportWidth","_smallViewportHeight","getFramebufferSize","keyMats","getKeyMatrices","actMats","multiply","modelToView","wcvc","mcwc","cam","crange","getClippingRange","bounds","getBounds","dims","getDimensions","pos","dir","dcxmin","dcxmax","dcymin","dcymax","floor","transformMat4","getParallelProjection","normalize","t","vcpc","min","max","isUniformUsed","setUniform3f","indexToWorldVec3","i2wmat4","getIndexToWorld","idxToView","idxNormalMatrix","normalMatrix","getDirection","getMaximumSamplesPerRay","vctoijk","divide","setUniform3i","getWebgl2","getWidth","getHeight","xreps","xstride","ystride","normal","pos2","transformMat3","dist","dot","image","worldToIndex","getWorldToIndex","setUniformMatrix","invert","projectionToWorld","wcpc","getRenderTargetSize","getRenderTargetOffset","projectionToView","lightColor","lightDir","halfAngle","dColor","getColor","intensity","ldir","getTwoSidedLighting","setUniform3fv","lightPositionVC","lightAttenuation","lightConeAngle","lightExponent","lightPositional","attenuation","getAttenuationValues","getExponent","getConeAngle","lp","getTransformedPosition","setUniformfv","setUniformiv","getGlobalIlluminationReach","getVolumeShadowSamplingDistFactor","getAnisotropy","ks","getLAOKernelSize","kernelSample","random","setUniform2fv","vprop","getComponentWeight","target","sscale","ofun","getScalarOpacity","oRange","getRange","oscale","oshift","cfun","getRGBTransferFunction","cRange","useGO","gomin","getGradientOpacityMinimumOpacity","gomax","getGradientOpacityMaximumOpacity","goRange","getGradientOpacityMinimumValue","getGradientOpacityMaximumValue","labelOutlineThickness","getLabelOutlineThickness","getDiffuse","getSpecular","getSpecularPower","clipPlaneNormals","clipPlaneDistances","clipPlanes","clipPlaneNormal","getNormal","clipPlanePos","getOrigin","clipPlaneDist","delete","chain","_animationRateSubscription","unsubscribe","usize","getTiledSizeAndOrigin","lowerLeftU","lowerLeftV","renderPieceStart","rwi","getVTKWindow","getInteractor","isAnimating","_lastScale","onAnimationFrameRateUpdate","getAutoAdjustSampleDistances","frate","getRecentAnimationFrameRate","adjustment","getDesiredUpdateRate","getImageSampleDistance","sqrt","saveCurrentBindingsAndBuffers","getGLFramebuffer","create","populateFramebuffer","fbSize","getSize","gl","clearColor","colorMask","clear","COLOR_BUFFER_BIT","viewport","fvp","disable","DEPTH_TEST","updateBufferObjects","NEAREST","setMinificationFilter","setMagnificationFilter","activate","renderPieceDraw","drawArrays","TRIANGLES","release","deactivate","renderPieceFinish","restorePreviousBindingsAndBuffers","copyShader","copyVAO","newInstance","tex","getColorTexture","setUniform2f","blendFuncSeparate","ONE","ONE_MINUS_SRC_ALPHA","SRC_ALPHA","invokeEvent","type","update","getInputData","computeBounds","getInput","uninitializeBounds","Bounds","getNeedToRebuildBufferObjects","buildBufferObjects","scalars","getPointData","getScalars","getHandle","oTable","Uint8Array","create2DFromRaw","UNSIGNED_CHAR","getNumberOfComponents","numIComps","toString","opacityTextureString","oWidth","oSize","ofTable","Float32Array","tmpTable","c","opacityFactor","getScalarOpacityUnitDistance","getTable","getExtension","colorTextureString","cWidth","cSize","cTable","scalarTextureString","resetFormatAndType","create3DFilterableFromRaw","getDataType","getData","getPreferSizeOverAccuracy","ptsArray","cellArray","Uint16Array","points","numberOfComponents","values","setName","cells","createVBO","SURFACE","cellOffset","DEFAULT_VALUES","lastXYF","targetXYF","fullViewportTime","avgWindowArea","avgFrameTime","extend","initialValues","Object","assign","obj","mtime","setWrapS","REPEAT","setWrapT","identity","setGet"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/OpenGL/VolumeMapper/index.js"],"sourcesContent":["import * as macro from 'vtk.js/Sources/macros';\nimport { vec3, mat3, mat4 } from 'gl-matrix';\n// import vtkBoundingBox       from 'vtk.js/Sources/Common/DataModel/BoundingBox';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nimport { VtkDataTypes } from 'vtk.js/Sources/Common/Core/DataArray/Constants';\nimport vtkHelper from 'vtk.js/Sources/Rendering/OpenGL/Helper';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkOpenGLFramebuffer from 'vtk.js/Sources/Rendering/OpenGL/Framebuffer';\nimport vtkOpenGLTexture from 'vtk.js/Sources/Rendering/OpenGL/Texture';\nimport vtkShaderProgram from 'vtk.js/Sources/Rendering/OpenGL/ShaderProgram';\nimport vtkVertexArrayObject from 'vtk.js/Sources/Rendering/OpenGL/VertexArrayObject';\nimport vtkViewNode from 'vtk.js/Sources/Rendering/SceneGraph/ViewNode';\nimport { Representation } from 'vtk.js/Sources/Rendering/Core/Property/Constants';\nimport {\n  Wrap,\n  Filter,\n} from 'vtk.js/Sources/Rendering/OpenGL/Texture/Constants';\nimport {\n  InterpolationType,\n  OpacityMode,\n} from 'vtk.js/Sources/Rendering/Core/VolumeProperty/Constants';\nimport { BlendMode } from 'vtk.js/Sources/Rendering/Core/VolumeMapper/Constants';\n\nimport vtkVolumeVS from 'vtk.js/Sources/Rendering/OpenGL/glsl/vtkVolumeVS.glsl';\nimport vtkVolumeFS from 'vtk.js/Sources/Rendering/OpenGL/glsl/vtkVolumeFS.glsl';\n\nimport { registerOverride } from 'vtk.js/Sources/Rendering/OpenGL/ViewNodeFactory';\n\nconst { vtkWarningMacro, vtkErrorMacro } = macro;\n\n// TODO: Do we want this in some shared utility? Shouldwe just use lodash.isEqual\nfunction arrayEquals(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLVolumeMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLVolumeMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLVolumeMapper');\n\n  publicAPI.buildPass = () => {\n    model.zBufferTexture = null;\n  };\n\n  // ohh someone is doing a zbuffer pass, use that for\n  // intermixed volume rendering\n  publicAPI.opaqueZBufferPass = (prepass, renderPass) => {\n    if (prepass) {\n      const zbt = renderPass.getZBufferTexture();\n      if (zbt !== model.zBufferTexture) {\n        model.zBufferTexture = zbt;\n      }\n    }\n  };\n\n  // Renders myself\n  publicAPI.volumePass = (prepass, renderPass) => {\n    if (prepass) {\n      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType(\n        'vtkOpenGLRenderWindow'\n      );\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.jitterTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);\n\n      // Per Component?\n      model.scalarTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.opacityTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n\n      model.openGLVolume = publicAPI.getFirstAncestorOfType('vtkOpenGLVolume');\n      const actor = model.openGLVolume.getRenderable();\n      model.openGLRenderer =\n        publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      const ren = model.openGLRenderer.getRenderable();\n      model.openGLCamera = model.openGLRenderer.getViewNodeFor(\n        ren.getActiveCamera()\n      );\n      publicAPI.renderPiece(ren, actor);\n    }\n  };\n\n  publicAPI.buildShaders = (shaders, ren, actor) => {\n    publicAPI.getShaderTemplate(shaders, ren, actor);\n    publicAPI.replaceShaderValues(shaders, ren, actor);\n  };\n\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkVolumeVS;\n    shaders.Fragment = vtkVolumeFS;\n    shaders.Geometry = '';\n  };\n\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment;\n\n    // define some values in the shader\n    const iType = actor.getProperty().getInterpolationType();\n    if (iType === InterpolationType.LINEAR) {\n      FSSource = vtkShaderProgram.substitute(\n        FSSource,\n        '//VTK::TrilinearOn',\n        '#define vtkTrilinearOn'\n      ).result;\n    }\n\n    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();\n    if (vtkImageLabelOutline === true) {\n      FSSource = vtkShaderProgram.substitute(\n        FSSource,\n        '//VTK::ImageLabelOutlineOn',\n        '#define vtkImageLabelOutlineOn'\n      ).result;\n    }\n\n    const numComp = model.scalarTexture.getComponents();\n    FSSource = vtkShaderProgram.substitute(\n      FSSource,\n      '//VTK::NumComponents',\n      `#define vtkNumComponents ${numComp}`\n    ).result;\n\n    const iComps = actor.getProperty().getIndependentComponents();\n    if (iComps) {\n      FSSource = vtkShaderProgram.substitute(\n        FSSource,\n        '//VTK::IndependentComponentsOn',\n        '#define vtkIndependentComponentsOn'\n      ).result;\n\n      // Define any proportional components\n      const proportionalComponents = [];\n      for (let nc = 0; nc < numComp; nc++) {\n        if (\n          actor.getProperty().getOpacityMode(nc) === OpacityMode.PROPORTIONAL\n        ) {\n          proportionalComponents.push(`#define vtkComponent${nc}Proportional`);\n        }\n      }\n\n      if (proportionalComponents.length > 0) {\n        FSSource = vtkShaderProgram.substitute(\n          FSSource,\n          '//VTK::vtkProportionalComponents',\n          proportionalComponents.join('\\n')\n        ).result;\n      }\n    }\n\n    // WebGL only supports loops over constants\n    // and does not support while loops so we\n    // have to hard code how many steps/samples to take\n    // We do a break so most systems will gracefully\n    // early terminate, but it is always possible\n    // a system will execute every step regardless\n    const ext = model.currentInput.getSpatialExtent();\n    const spc = model.currentInput.getSpacing();\n    const vsize = new Float64Array(3);\n    vec3.set(\n      vsize,\n      (ext[1] - ext[0]) * spc[0],\n      (ext[3] - ext[2]) * spc[1],\n      (ext[5] - ext[4]) * spc[2]\n    );\n\n    const maxSamples =\n      vec3.length(vsize) / model.renderable.getSampleDistance();\n\n    FSSource = vtkShaderProgram.substitute(\n      FSSource,\n      '//VTK::MaximumSamplesValue',\n      `${Math.ceil(maxSamples)}`\n    ).result;\n\n    // set light complexity\n    FSSource = vtkShaderProgram.substitute(\n      FSSource,\n      '//VTK::LightComplexity',\n      `#define vtkLightComplexity ${model.lastLightComplexity}`\n    ).result;\n\n    // set shadow blending flag\n    if (model.lastLightComplexity > 0) {\n      if (model.renderable.getVolumetricScatteringBlending() > 0.0) {\n        FSSource = vtkShaderProgram.substitute(\n          FSSource,\n          '//VTK::VolumeShadowOn',\n          `#define VolumeShadowOn`\n        ).result;\n      }\n      if (model.renderable.getVolumetricScatteringBlending() < 1.0) {\n        FSSource = vtkShaderProgram.substitute(\n          FSSource,\n          '//VTK::SurfaceShadowOn',\n          `#define SurfaceShadowOn`\n        ).result;\n      }\n      if (\n        model.renderable.getVolumetricScatteringBlending() === 0.0 &&\n        model.renderable.getLocalAmbientOcclusion() &&\n        actor.getProperty().getAmbient() > 0.0\n      ) {\n        FSSource = vtkShaderProgram.substitute(\n          FSSource,\n          '//VTK::localAmbientOcclusionOn',\n          `#define localAmbientOcclusionOn`\n        ).result;\n      }\n    }\n\n    // if using gradient opacity define that\n    model.gopacity = actor.getProperty().getUseGradientOpacity(0);\n    for (let nc = 1; iComps && !model.gopacity && nc < numComp; ++nc) {\n      if (actor.getProperty().getUseGradientOpacity(nc)) {\n        model.gopacity = true;\n      }\n    }\n    if (model.gopacity) {\n      FSSource = vtkShaderProgram.substitute(\n        FSSource,\n        '//VTK::GradientOpacityOn',\n        '#define vtkGradientOpacityOn'\n      ).result;\n    }\n\n    // set normal from density\n    if (model.renderable.getComputeNormalFromOpacity()) {\n      FSSource = vtkShaderProgram.substitute(\n        FSSource,\n        '//VTK::vtkComputeNormalFromOpacity',\n        `#define vtkComputeNormalFromOpacity`\n      ).result;\n    }\n\n    // if we have a ztexture then declare it and use it\n    if (model.zBufferTexture !== null) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', [\n        'uniform sampler2D zBufferTexture;',\n        'uniform float vpWidth;',\n        'uniform float vpHeight;',\n      ]).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', [\n        'vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpWidth, gl_FragCoord.y/vpHeight));',\n        'float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;',\n        'zdepth = zdepth * 2.0 - 1.0;',\n        'zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;',\n        'zdepth = -zdepth/rayDir.z;',\n        'dists.y = min(zdepth,dists.y);',\n      ]).result;\n    }\n\n    // Set the BlendMode approach\n    FSSource = vtkShaderProgram.substitute(\n      FSSource,\n      '//VTK::BlendMode',\n      `${model.renderable.getBlendMode()}`\n    ).result;\n\n    shaders.Fragment = FSSource;\n\n    publicAPI.replaceShaderLight(shaders, ren, actor);\n    publicAPI.replaceShaderClippingPlane(shaders, ren, actor);\n  };\n\n  publicAPI.replaceShaderLight = (shaders, ren, actor) => {\n    if (model.lastLightComplexity === 0) {\n      return;\n    }\n    let FSSource = shaders.Fragment;\n    // check for shadow maps - not implemented yet, skip\n    // const shadowFactor = '';\n\n    // to-do: single out the case when complexity = 1\n\n    // only account for lights that are switched on\n    let lightNum = 0;\n    ren.getLights().forEach((light) => {\n      if (light.getSwitch()) {\n        lightNum += 1;\n      }\n    });\n    FSSource = vtkShaderProgram.substitute(\n      FSSource,\n      '//VTK::Light::Dec',\n      [\n        `uniform int lightNum;`,\n        `uniform bool twoSidedLighting;`,\n        `uniform vec3 lightColor[${lightNum}];`,\n        `uniform vec3 lightDirectionVC[${lightNum}]; // normalized`,\n        `uniform vec3 lightHalfAngleVC[${lightNum}];`,\n        '//VTK::Light::Dec',\n      ],\n      false\n    ).result;\n    // support any number of lights\n    if (model.lastLightComplexity === 3) {\n      FSSource = vtkShaderProgram.substitute(\n        FSSource,\n        '//VTK::Light::Dec',\n        [\n          `uniform vec3 lightPositionVC[${lightNum}];`,\n          `uniform vec3 lightAttenuation[${lightNum}];`,\n          `uniform float lightConeAngle[${lightNum}];`,\n          `uniform float lightExponent[${lightNum}];`,\n          `uniform int lightPositional[${lightNum}];`,\n        ],\n        false\n      ).result;\n    }\n\n    if (model.renderable.getVolumetricScatteringBlending() > 0.0) {\n      FSSource = vtkShaderProgram.substitute(\n        FSSource,\n        '//VTK::VolumeShadow::Dec',\n        [\n          `uniform float volumetricScatteringBlending;`,\n          `uniform float giReach;`,\n          `uniform float volumeShadowSamplingDistFactor;`,\n          `uniform float anisotropy;`,\n          `uniform float anisotropy2;`,\n        ],\n        false\n      ).result;\n    }\n    if (\n      model.renderable.getVolumetricScatteringBlending() === 0.0 &&\n      model.renderable.getLocalAmbientOcclusion() &&\n      actor.getProperty().getAmbient() > 0.0\n    ) {\n      FSSource = vtkShaderProgram.substitute(\n        FSSource,\n        '//VTK::LAO::Dec',\n        [\n          `uniform int kernelRadius;`,\n          `uniform vec2 kernelSample[${model.renderable.getLAOKernelRadius()}];`,\n          `uniform int kernelSize;`,\n        ],\n        false\n      ).result;\n    }\n    shaders.Fragment = FSSource;\n  };\n\n  publicAPI.replaceShaderClippingPlane = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment;\n\n    if (model.renderable.getClippingPlanes().length > 0) {\n      const clipPlaneSize = model.renderable.getClippingPlanes().length;\n      FSSource = vtkShaderProgram.substitute(\n        FSSource,\n        '//VTK::ClipPlane::Dec',\n        [\n          `uniform vec3 vClipPlaneNormals[6];`,\n          `uniform float vClipPlaneDistances[6];`,\n          '//VTK::ClipPlane::Dec',\n        ],\n        false\n      ).result;\n\n      FSSource = vtkShaderProgram.substitute(\n        FSSource,\n        '//VTK::ClipPlane::Impl',\n        [\n          `for(int i = 0; i < ${clipPlaneSize}; i++) {`,\n          '  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);',\n          '  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];',\n          '  if (rayDirRatio == 0.0)',\n          '  {',\n          '    if (equationResult < 0.0) dists.x = dists.y;',\n          '    continue;',\n          '  }',\n          '  float result = -1.0 * equationResult / rayDirRatio;',\n          '  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);',\n          '  else dists.x = max(dists.x, result);',\n          '}',\n          '//VTK::ClipPlane::Impl',\n        ],\n        false\n      ).result;\n    }\n\n    shaders.Fragment = FSSource;\n  };\n\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    // do we need lighting?\n    let lightComplexity = 0;\n    if (\n      actor.getProperty().getShade() &&\n      model.renderable.getBlendMode() === BlendMode.COMPOSITE_BLEND\n    ) {\n      // consider the lighting complexity to determine which case applies\n      // simple headlight, Light Kit, the whole feature set of VTK\n      lightComplexity = 0;\n      model.numberOfLights = 0;\n\n      ren.getLights().forEach((light) => {\n        const status = light.getSwitch();\n        if (status > 0) {\n          model.numberOfLights++;\n          if (lightComplexity === 0) {\n            lightComplexity = 1;\n          }\n        }\n\n        if (\n          lightComplexity === 1 &&\n          (model.numberOfLights > 1 ||\n            light.getIntensity() !== 1.0 ||\n            !light.lightTypeIsHeadLight())\n        ) {\n          lightComplexity = 2;\n        }\n        if (lightComplexity < 3 && light.getPositional()) {\n          lightComplexity = 3;\n        }\n      });\n    }\n\n    let needRebuild = false;\n    if (model.lastLightComplexity !== lightComplexity) {\n      model.lastLightComplexity = lightComplexity;\n      needRebuild = true;\n    }\n\n    const numComp = model.scalarTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n    let usesProportionalComponents = false;\n    const proportionalComponents = [];\n    if (iComps) {\n      // Define any proportional components\n      for (let nc = 0; nc < numComp; nc++) {\n        proportionalComponents.push(actor.getProperty().getOpacityMode(nc));\n      }\n\n      if (proportionalComponents.length > 0) {\n        usesProportionalComponents = true;\n      }\n    }\n\n    const ext = model.currentInput.getSpatialExtent();\n    const spc = model.currentInput.getSpacing();\n    const vsize = new Float64Array(3);\n    vec3.set(\n      vsize,\n      (ext[1] - ext[0]) * spc[0],\n      (ext[3] - ext[2]) * spc[1],\n      (ext[5] - ext[4]) * spc[2]\n    );\n\n    const maxSamples =\n      vec3.length(vsize) / model.renderable.getSampleDistance();\n\n    const state = {\n      interpolationType: actor.getProperty().getInterpolationType(),\n      useLabelOutline: actor.getProperty().getUseLabelOutline(),\n      numComp,\n      usesProportionalComponents,\n      iComps,\n      maxSamples,\n      useGradientOpacity: actor.getProperty().getUseGradientOpacity(0),\n      blendMode: model.renderable.getBlendMode(),\n      proportionalComponents,\n    };\n\n    // We only need to rebuild the shader if one of these variables has changed,\n    // since they are used in the shader template replacement step.\n    if (\n      !model.previousState ||\n      model.previousState.interpolationType !== state.interpolationType ||\n      model.previousState.useLabelOutline !== state.useLabelOutline ||\n      model.previousState.numComp !== state.numComp ||\n      model.previousState.usesProportionalComponents !==\n        state.usesProportionalComponents ||\n      model.previousState.iComps !== state.iComps ||\n      model.previousState.maxSamples !== state.maxSamples ||\n      model.previousState.useGradientOpacity !== state.useGradientOpacity ||\n      model.previousState.blendMode !== state.blendMode ||\n      !arrayEquals(\n        model.previousState.proportionalComponents,\n        state.proportionalComponents\n      )\n    ) {\n      model.previousState = { ...state };\n\n      return true;\n    }\n\n    // has something changed that would require us to recreate the shader?\n    if (\n      cellBO.getProgram() === 0 ||\n      needRebuild ||\n      model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest ||\n      !!model.lastZBufferTexture !== !!model.zBufferTexture ||\n      cellBO.getShaderSourceTime().getMTime() < publicAPI.getMTime() ||\n      cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime()\n    ) {\n      model.lastZBufferTexture = model.zBufferTexture;\n      return true;\n    }\n\n    return false;\n  };\n\n  publicAPI.updateShaders = (cellBO, ren, actor) => {\n    model.lastBoundBO = cellBO;\n\n    // has something changed that would require us to recreate the shader?\n    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {\n      const shaders = { Vertex: null, Fragment: null, Geometry: null };\n\n      publicAPI.buildShaders(shaders, ren, actor);\n\n      // compile and bind the program if needed\n      const newShader = model._openGLRenderWindow\n        .getShaderCache()\n        .readyShaderProgramArray(\n          shaders.Vertex,\n          shaders.Fragment,\n          shaders.Geometry\n        );\n\n      // if the shader changed reinitialize the VAO\n      if (newShader !== cellBO.getProgram()) {\n        cellBO.setProgram(newShader);\n        // reset the VAO as the shader has changed\n        cellBO.getVAO().releaseGraphicsResources();\n      }\n\n      cellBO.getShaderSourceTime().modified();\n    } else {\n      model._openGLRenderWindow\n        .getShaderCache()\n        .readyShaderProgram(cellBO.getProgram());\n    }\n\n    cellBO.getVAO().bind();\n    publicAPI.setMapperShaderParameters(cellBO, ren, actor);\n    publicAPI.setCameraShaderParameters(cellBO, ren, actor);\n    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);\n    publicAPI.getClippingPlaneShaderParameters(cellBO, ren, actor);\n  };\n\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    // Now to update the VAO too, if necessary.\n    const program = cellBO.getProgram();\n\n    if (\n      cellBO.getCABO().getElementCount() &&\n      (model.VBOBuildTime.getMTime() >\n        cellBO.getAttributeUpdateTime().getMTime() ||\n        cellBO.getShaderSourceTime().getMTime() >\n          cellBO.getAttributeUpdateTime().getMTime())\n    ) {\n      if (program.isAttributeUsed('vertexDC')) {\n        if (\n          !cellBO\n            .getVAO()\n            .addAttributeArray(\n              program,\n              cellBO.getCABO(),\n              'vertexDC',\n              cellBO.getCABO().getVertexOffset(),\n              cellBO.getCABO().getStride(),\n              model.context.FLOAT,\n              3,\n              model.context.FALSE\n            )\n        ) {\n          vtkErrorMacro('Error setting vertexDC in shader VAO.');\n        }\n      }\n      cellBO.getAttributeUpdateTime().modified();\n    }\n\n    program.setUniformi('texture1', model.scalarTexture.getTextureUnit());\n    program.setUniformf('sampleDistance', model.renderable.getSampleDistance());\n\n    const volInfo = model.scalarTexture.getVolumeInfo();\n    const ipScalarRange = model.renderable.getIpScalarRange();\n\n    const minVals = [];\n    const maxVals = [];\n    for (let i = 0; i < 4; i++) {\n      // convert iprange from 0-1 into data range values\n      minVals[i] =\n        ipScalarRange[0] * volInfo.dataComputedScale[i] +\n        volInfo.dataComputedOffset[i];\n      maxVals[i] =\n        ipScalarRange[1] * volInfo.dataComputedScale[i] +\n        volInfo.dataComputedOffset[i];\n      // convert data ranges into texture values\n      minVals[i] = (minVals[i] - volInfo.offset[i]) / volInfo.scale[i];\n      maxVals[i] = (maxVals[i] - volInfo.offset[i]) / volInfo.scale[i];\n    }\n    program.setUniform4f(\n      'ipScalarRangeMin',\n      minVals[0],\n      minVals[1],\n      minVals[2],\n      minVals[3]\n    );\n    program.setUniform4f(\n      'ipScalarRangeMax',\n      maxVals[0],\n      maxVals[1],\n      maxVals[2],\n      maxVals[3]\n    );\n\n    // if we have a zbuffer texture then set it\n    if (model.zBufferTexture !== null) {\n      program.setUniformi(\n        'zBufferTexture',\n        model.zBufferTexture.getTextureUnit()\n      );\n      const size = model._useSmallViewport\n        ? [model._smallViewportWidth, model._smallViewportHeight]\n        : model._openGLRenderWindow.getFramebufferSize();\n      program.setUniformf('vpWidth', size[0]);\n      program.setUniformf('vpHeight', size[1]);\n    }\n  };\n\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    // // [WMVP]C == {world, model, view, projection} coordinates\n    // // E.g., WCPC == world to projection coordinate transformation\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    const actMats = model.openGLVolume.getKeyMatrices();\n\n    mat4.multiply(model.modelToView, keyMats.wcvc, actMats.mcwc);\n\n    const program = cellBO.getProgram();\n\n    const cam = model.openGLCamera.getRenderable();\n    const crange = cam.getClippingRange();\n    program.setUniformf('camThick', crange[1] - crange[0]);\n    program.setUniformf('camNear', crange[0]);\n    program.setUniformf('camFar', crange[1]);\n\n    const bounds = model.currentInput.getBounds();\n    const dims = model.currentInput.getDimensions();\n\n    // compute the viewport bounds of the volume\n    // we will only render those fragments.\n    const pos = new Float64Array(3);\n    const dir = new Float64Array(3);\n    let dcxmin = 1.0;\n    let dcxmax = -1.0;\n    let dcymin = 1.0;\n    let dcymax = -1.0;\n\n    for (let i = 0; i < 8; ++i) {\n      vec3.set(\n        pos,\n        bounds[i % 2],\n        bounds[2 + (Math.floor(i / 2) % 2)],\n        bounds[4 + Math.floor(i / 4)]\n      );\n      vec3.transformMat4(pos, pos, model.modelToView);\n      if (!cam.getParallelProjection()) {\n        vec3.normalize(dir, pos);\n\n        // now find the projection of this point onto a\n        // nearZ distance plane. Since the camera is at 0,0,0\n        // in VC the ray is just t*pos and\n        // t is -nearZ/dir.z\n        // intersection becomes pos.x/pos.z\n        const t = -crange[0] / pos[2];\n        vec3.scale(pos, dir, t);\n      }\n      // now convert to DC\n      vec3.transformMat4(pos, pos, keyMats.vcpc);\n\n      dcxmin = Math.min(pos[0], dcxmin);\n      dcxmax = Math.max(pos[0], dcxmax);\n      dcymin = Math.min(pos[1], dcymin);\n      dcymax = Math.max(pos[1], dcymax);\n    }\n\n    program.setUniformf('dcxmin', dcxmin);\n    program.setUniformf('dcxmax', dcxmax);\n    program.setUniformf('dcymin', dcymin);\n    program.setUniformf('dcymax', dcymax);\n\n    if (program.isUniformUsed('cameraParallel')) {\n      program.setUniformi('cameraParallel', cam.getParallelProjection());\n    }\n\n    const ext = model.currentInput.getSpatialExtent();\n    const spc = model.currentInput.getSpacing();\n    const vsize = new Float64Array(3);\n    vec3.set(\n      vsize,\n      (ext[1] - ext[0]) * spc[0],\n      (ext[3] - ext[2]) * spc[1],\n      (ext[5] - ext[4]) * spc[2]\n    );\n    program.setUniform3f('vSpacing', spc[0], spc[1], spc[2]);\n\n    vec3.set(pos, ext[0], ext[2], ext[4]);\n    model.currentInput.indexToWorldVec3(pos, pos);\n\n    vec3.transformMat4(pos, pos, model.modelToView);\n    program.setUniform3f('vOriginVC', pos[0], pos[1], pos[2]);\n\n    // apply the image directions\n    const i2wmat4 = model.currentInput.getIndexToWorld();\n    mat4.multiply(model.idxToView, model.modelToView, i2wmat4);\n\n    mat3.multiply(\n      model.idxNormalMatrix,\n      keyMats.normalMatrix,\n      actMats.normalMatrix\n    );\n    mat3.multiply(\n      model.idxNormalMatrix,\n      model.idxNormalMatrix,\n      model.currentInput.getDirection()\n    );\n\n    const maxSamples =\n      vec3.length(vsize) / model.renderable.getSampleDistance();\n    if (maxSamples > model.renderable.getMaximumSamplesPerRay()) {\n      vtkWarningMacro(`The number of steps required ${Math.ceil(\n        maxSamples\n      )} is larger than the\n        specified maximum number of steps ${model.renderable.getMaximumSamplesPerRay()}.\n        Please either change the\n        volumeMapper sampleDistance or its maximum number of samples.`);\n    }\n\n    const vctoijk = new Float64Array(3);\n\n    vec3.set(vctoijk, 1.0, 1.0, 1.0);\n    vec3.divide(vctoijk, vctoijk, vsize);\n    program.setUniform3f('vVCToIJK', vctoijk[0], vctoijk[1], vctoijk[2]);\n    program.setUniform3i('volumeDimensions', dims[0], dims[1], dims[2]);\n\n    if (!model._openGLRenderWindow.getWebgl2()) {\n      const volInfo = model.scalarTexture.getVolumeInfo();\n      program.setUniformf('texWidth', model.scalarTexture.getWidth());\n      program.setUniformf('texHeight', model.scalarTexture.getHeight());\n      program.setUniformi('xreps', volInfo.xreps);\n      program.setUniformi('xstride', volInfo.xstride);\n      program.setUniformi('ystride', volInfo.ystride);\n    }\n\n    // map normals through normal matrix\n    // then use a point on the plane to compute the distance\n    const normal = new Float64Array(3);\n    const pos2 = new Float64Array(3);\n    for (let i = 0; i < 6; ++i) {\n      switch (i) {\n        case 1:\n          vec3.set(normal, -1.0, 0.0, 0.0);\n          vec3.set(pos2, ext[0], ext[2], ext[4]);\n          break;\n        case 2:\n          vec3.set(normal, 0.0, 1.0, 0.0);\n          vec3.set(pos2, ext[1], ext[3], ext[5]);\n          break;\n        case 3:\n          vec3.set(normal, 0.0, -1.0, 0.0);\n          vec3.set(pos2, ext[0], ext[2], ext[4]);\n          break;\n        case 4:\n          vec3.set(normal, 0.0, 0.0, 1.0);\n          vec3.set(pos2, ext[1], ext[3], ext[5]);\n          break;\n        case 5:\n          vec3.set(normal, 0.0, 0.0, -1.0);\n          vec3.set(pos2, ext[0], ext[2], ext[4]);\n          break;\n        case 0:\n        default:\n          vec3.set(normal, 1.0, 0.0, 0.0);\n          vec3.set(pos2, ext[1], ext[3], ext[5]);\n          break;\n      }\n      vec3.transformMat3(normal, normal, model.idxNormalMatrix);\n      vec3.transformMat4(pos2, pos2, model.idxToView);\n      const dist = -1.0 * vec3.dot(pos2, normal);\n\n      // we have the plane in view coordinates\n      // specify the planes in view coordinates\n      program.setUniform3f(`vPlaneNormal${i}`, normal[0], normal[1], normal[2]);\n      program.setUniformf(`vPlaneDistance${i}`, dist);\n    }\n\n    if (actor.getProperty().getUseLabelOutline()) {\n      const image = model.currentInput;\n      const worldToIndex = image.getWorldToIndex();\n\n      program.setUniformMatrix('vWCtoIDX', worldToIndex);\n\n      // Get the projection coordinate to world coordinate transformation matrix.\n      mat4.invert(model.projectionToWorld, keyMats.wcpc);\n      program.setUniformMatrix('PCWCMatrix', model.projectionToWorld);\n\n      const size = publicAPI.getRenderTargetSize();\n\n      program.setUniformf('vpWidth', size[0]);\n      program.setUniformf('vpHeight', size[1]);\n\n      const offset = publicAPI.getRenderTargetOffset();\n      program.setUniformf('vpOffsetX', offset[0] / size[0]);\n      program.setUniformf('vpOffsetY', offset[1] / size[1]);\n    }\n\n    mat4.invert(model.projectionToView, keyMats.vcpc);\n    program.setUniformMatrix('PCVCMatrix', model.projectionToView);\n\n    // handle lighting values\n    if (model.lastLightComplexity === 0) {\n      return;\n    }\n    let lightNum = 0;\n    const lightColor = [];\n    const lightDir = [];\n    const halfAngle = [];\n    ren.getLights().forEach((light) => {\n      const status = light.getSwitch();\n      if (status > 0) {\n        const dColor = light.getColor();\n        const intensity = light.getIntensity();\n        lightColor[0 + lightNum * 3] = dColor[0] * intensity;\n        lightColor[1 + lightNum * 3] = dColor[1] * intensity;\n        lightColor[2 + lightNum * 3] = dColor[2] * intensity;\n        const ldir = light.getDirection();\n        vec3.set(normal, ldir[0], ldir[1], ldir[2]);\n        vec3.transformMat3(normal, normal, keyMats.normalMatrix); // in view coordinat\n        vec3.normalize(normal, normal);\n        lightDir[0 + lightNum * 3] = normal[0];\n        lightDir[1 + lightNum * 3] = normal[1];\n        lightDir[2 + lightNum * 3] = normal[2];\n        // camera DOP is 0,0,-1.0 in VC\n        halfAngle[0 + lightNum * 3] = -0.5 * normal[0];\n        halfAngle[1 + lightNum * 3] = -0.5 * normal[1];\n        halfAngle[2 + lightNum * 3] = -0.5 * (normal[2] - 1.0);\n        lightNum++;\n      }\n    });\n    program.setUniformi('twoSidedLighting', ren.getTwoSidedLighting());\n    program.setUniformi('lightNum', lightNum);\n    program.setUniform3fv('lightColor', lightColor);\n    program.setUniform3fv('lightDirectionVC', lightDir);\n    program.setUniform3fv('lightHalfAngleVC', halfAngle);\n\n    if (model.lastLightComplexity === 3) {\n      lightNum = 0;\n      const lightPositionVC = [];\n      const lightAttenuation = [];\n      const lightConeAngle = [];\n      const lightExponent = [];\n      const lightPositional = [];\n      ren.getLights().forEach((light) => {\n        const status = light.getSwitch();\n        if (status > 0) {\n          const attenuation = light.getAttenuationValues();\n          lightAttenuation[0 + lightNum * 3] = attenuation[0];\n          lightAttenuation[1 + lightNum * 3] = attenuation[1];\n          lightAttenuation[2 + lightNum * 3] = attenuation[2];\n          lightExponent[lightNum] = light.getExponent();\n          lightConeAngle[lightNum] = light.getConeAngle();\n          lightPositional[lightNum] = light.getPositional();\n          const lp = light.getTransformedPosition();\n          vec3.transformMat4(lp, lp, model.modelToView);\n          lightPositionVC[0 + lightNum * 3] = lp[0];\n          lightPositionVC[1 + lightNum * 3] = lp[1];\n          lightPositionVC[2 + lightNum * 3] = lp[2];\n          lightNum += 1;\n        }\n      });\n      program.setUniform3fv('lightPositionVC', lightPositionVC);\n      program.setUniform3fv('lightAttenuation', lightAttenuation);\n      program.setUniformfv('lightConeAngle', lightConeAngle);\n      program.setUniformfv('lightExponent', lightExponent);\n      program.setUniformiv('lightPositional', lightPositional);\n    }\n    if (model.renderable.getVolumetricScatteringBlending() > 0.0) {\n      program.setUniformf(\n        'giReach',\n        model.renderable.getGlobalIlluminationReach()\n      );\n      program.setUniformf(\n        'volumetricScatteringBlending',\n        model.renderable.getVolumetricScatteringBlending()\n      );\n      program.setUniformf(\n        'volumeShadowSamplingDistFactor',\n        model.renderable.getVolumeShadowSamplingDistFactor()\n      );\n      program.setUniformf('anisotropy', model.renderable.getAnisotropy());\n      program.setUniformf(\n        'anisotropy2',\n        model.renderable.getAnisotropy() ** 2.0\n      );\n    }\n    if (\n      model.renderable.getVolumetricScatteringBlending() === 0.0 &&\n      model.renderable.getLocalAmbientOcclusion() &&\n      actor.getProperty().getAmbient() > 0.0\n    ) {\n      const ks = model.renderable.getLAOKernelSize();\n      program.setUniformi('kernelSize', ks);\n      const kernelSample = [];\n      for (let i = 0; i < ks; i++) {\n        kernelSample[i * 2] = Math.random() * 0.5;\n        kernelSample[i * 2 + 1] = Math.random() * 0.5;\n      }\n      program.setUniform2fv('kernelSample', kernelSample);\n      program.setUniformi(\n        'kernelRadius',\n        model.renderable.getLAOKernelRadius()\n      );\n    }\n  };\n\n  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n\n    program.setUniformi('ctexture', model.colorTexture.getTextureUnit());\n    program.setUniformi('otexture', model.opacityTexture.getTextureUnit());\n    program.setUniformi('jtexture', model.jitterTexture.getTextureUnit());\n\n    const volInfo = model.scalarTexture.getVolumeInfo();\n    const vprop = actor.getProperty();\n\n    // set the component mix when independent\n    const numComp = model.scalarTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n    if (iComps && numComp >= 2) {\n      for (let i = 0; i < numComp; i++) {\n        program.setUniformf(\n          `mix${i}`,\n          actor.getProperty().getComponentWeight(i)\n        );\n      }\n    }\n\n    // three levels of shift scale combined into one\n    // for performance in the fragment shader\n    for (let i = 0; i < numComp; i++) {\n      const target = iComps ? i : 0;\n      const sscale = volInfo.scale[i];\n      const ofun = vprop.getScalarOpacity(target);\n      const oRange = ofun.getRange();\n      const oscale = sscale / (oRange[1] - oRange[0]);\n      const oshift = (volInfo.offset[i] - oRange[0]) / (oRange[1] - oRange[0]);\n      program.setUniformf(`oshift${i}`, oshift);\n      program.setUniformf(`oscale${i}`, oscale);\n\n      const cfun = vprop.getRGBTransferFunction(target);\n      const cRange = cfun.getRange();\n      program.setUniformf(\n        `cshift${i}`,\n        (volInfo.offset[i] - cRange[0]) / (cRange[1] - cRange[0])\n      );\n      program.setUniformf(`cscale${i}`, sscale / (cRange[1] - cRange[0]));\n    }\n\n    if (model.gopacity) {\n      if (iComps) {\n        for (let nc = 0; nc < numComp; ++nc) {\n          const sscale = volInfo.scale[nc];\n          const useGO = vprop.getUseGradientOpacity(nc);\n          if (useGO) {\n            const gomin = vprop.getGradientOpacityMinimumOpacity(nc);\n            const gomax = vprop.getGradientOpacityMaximumOpacity(nc);\n            program.setUniformf(`gomin${nc}`, gomin);\n            program.setUniformf(`gomax${nc}`, gomax);\n            const goRange = [\n              vprop.getGradientOpacityMinimumValue(nc),\n              vprop.getGradientOpacityMaximumValue(nc),\n            ];\n            program.setUniformf(\n              `goscale${nc}`,\n              (sscale * (gomax - gomin)) / (goRange[1] - goRange[0])\n            );\n            program.setUniformf(\n              `goshift${nc}`,\n              (-goRange[0] * (gomax - gomin)) / (goRange[1] - goRange[0]) +\n                gomin\n            );\n          } else {\n            program.setUniformf(`gomin${nc}`, 1.0);\n            program.setUniformf(`gomax${nc}`, 1.0);\n            program.setUniformf(`goscale${nc}`, 0.0);\n            program.setUniformf(`goshift${nc}`, 1.0);\n          }\n        }\n      } else {\n        const sscale = volInfo.scale[numComp - 1];\n        const gomin = vprop.getGradientOpacityMinimumOpacity(0);\n        const gomax = vprop.getGradientOpacityMaximumOpacity(0);\n        program.setUniformf('gomin0', gomin);\n        program.setUniformf('gomax0', gomax);\n        const goRange = [\n          vprop.getGradientOpacityMinimumValue(0),\n          vprop.getGradientOpacityMaximumValue(0),\n        ];\n        program.setUniformf(\n          'goscale0',\n          (sscale * (gomax - gomin)) / (goRange[1] - goRange[0])\n        );\n        program.setUniformf(\n          'goshift0',\n          (-goRange[0] * (gomax - gomin)) / (goRange[1] - goRange[0]) + gomin\n        );\n      }\n    }\n\n    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();\n    if (vtkImageLabelOutline === true) {\n      const labelOutlineThickness = actor\n        .getProperty()\n        .getLabelOutlineThickness();\n\n      program.setUniformi('outlineThickness', labelOutlineThickness);\n    }\n\n    if (model.lastLightComplexity > 0) {\n      program.setUniformf('vAmbient', vprop.getAmbient());\n      program.setUniformf('vDiffuse', vprop.getDiffuse());\n      program.setUniformf('vSpecular', vprop.getSpecular());\n      program.setUniformf('vSpecularPower', vprop.getSpecularPower());\n    }\n  };\n\n  publicAPI.getClippingPlaneShaderParameters = (cellBO, ren, actor) => {\n    if (model.renderable.getClippingPlanes().length > 0) {\n      const keyMats = model.openGLCamera.getKeyMatrices(ren);\n\n      const clipPlaneNormals = [];\n      const clipPlaneDistances = [];\n\n      const clipPlanes = model.renderable.getClippingPlanes();\n      const clipPlaneSize = clipPlanes.length;\n      for (let i = 0; i < clipPlaneSize; ++i) {\n        const clipPlaneNormal = clipPlanes[i].getNormal();\n        const clipPlanePos = clipPlanes[i].getOrigin();\n\n        vec3.transformMat3(\n          clipPlaneNormal,\n          clipPlaneNormal,\n          keyMats.normalMatrix\n        );\n\n        vec3.transformMat4(clipPlanePos, clipPlanePos, keyMats.wcvc);\n\n        const clipPlaneDist = -1.0 * vec3.dot(clipPlanePos, clipPlaneNormal);\n\n        clipPlaneNormals.push(clipPlaneNormal[0]);\n        clipPlaneNormals.push(clipPlaneNormal[1]);\n        clipPlaneNormals.push(clipPlaneNormal[2]);\n        clipPlaneDistances.push(clipPlaneDist);\n      }\n      const program = cellBO.getProgram();\n      program.setUniform3fv(`vClipPlaneNormals`, clipPlaneNormals);\n      program.setUniformfv(`vClipPlaneDistances`, clipPlaneDistances);\n    }\n  };\n\n  // unsubscribe from our listeners\n  publicAPI.delete = macro.chain(() => {\n    if (model._animationRateSubscription) {\n      model._animationRateSubscription.unsubscribe();\n      model._animationRateSubscription = null;\n    }\n  }, publicAPI.delete);\n\n  publicAPI.getRenderTargetSize = () => {\n    if (model._useSmallViewport) {\n      return [model._smallViewportWidth, model._smallViewportHeight];\n    }\n\n    const { usize, vsize } = model.openGLRenderer.getTiledSizeAndOrigin();\n\n    return [usize, vsize];\n  };\n\n  publicAPI.getRenderTargetOffset = () => {\n    const { lowerLeftU, lowerLeftV } =\n      model.openGLRenderer.getTiledSizeAndOrigin();\n\n    return [lowerLeftU, lowerLeftV];\n  };\n\n  publicAPI.renderPieceStart = (ren, actor) => {\n    const rwi = ren.getVTKWindow().getInteractor();\n\n    model._useSmallViewport = false;\n    if (rwi.isAnimating() && model._lastScale > 1.5) {\n      model._useSmallViewport = true;\n    }\n\n    if (!model._animationRateSubscription) {\n      // when the animation frame rate changes recompute the scale factor\n      model._animationRateSubscription = rwi.onAnimationFrameRateUpdate(() => {\n        if (model.renderable.getAutoAdjustSampleDistances()) {\n          const frate = rwi.getRecentAnimationFrameRate();\n          const adjustment = rwi.getDesiredUpdateRate() / frate;\n\n          // only change if we are off by 15%\n          if (adjustment > 1.15 || adjustment < 0.85) {\n            model._lastScale *= adjustment;\n          }\n          // clamp scale to some reasonable values.\n          // Below 1.5 we will just be using full resolution as that is close enough\n          // Above 400 seems like a lot so we limit to that 1/20th per axis\n          if (model._lastScale > 400) {\n            model._lastScale = 400;\n          }\n          if (model._lastScale < 1.5) {\n            model._lastScale = 1.5;\n          }\n        } else {\n          model._lastScale =\n            model.renderable.getImageSampleDistance() *\n            model.renderable.getImageSampleDistance();\n        }\n        const size = model._openGLRenderWindow.getFramebufferSize();\n        model._smallViewportWidth = Math.ceil(\n          size[0] / Math.sqrt(model._lastScale)\n        );\n        model._smallViewportHeight = Math.ceil(\n          size[1] / Math.sqrt(model._lastScale)\n        );\n      });\n    }\n\n    // use/create/resize framebuffer if needed\n    if (model._useSmallViewport) {\n      const size = model._openGLRenderWindow.getFramebufferSize();\n\n      // adjust viewportSize to always be at most the dest fo size\n      if (model._smallViewportHeight > size[1]) {\n        model._smallViewportHeight = size[1];\n      }\n      if (model._smallViewportWidth > size[0]) {\n        model._smallViewportWidth = size[0];\n      }\n      model.framebuffer.saveCurrentBindingsAndBuffers();\n\n      if (model.framebuffer.getGLFramebuffer() === null) {\n        model.framebuffer.create(size[0], size[1]);\n        model.framebuffer.populateFramebuffer();\n      } else {\n        const fbSize = model.framebuffer.getSize();\n        if (fbSize[0] !== size[0] || fbSize[1] !== size[1]) {\n          model.framebuffer.create(size[0], size[1]);\n          model.framebuffer.populateFramebuffer();\n        }\n      }\n      model.framebuffer.bind();\n      const gl = model.context;\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n      gl.colorMask(true, true, true, true);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      gl.viewport(0, 0, model._smallViewportWidth, model._smallViewportHeight);\n      model.fvp = [\n        model._smallViewportWidth / size[0],\n        model._smallViewportHeight / size[1],\n      ];\n    }\n    model.context.disable(model.context.DEPTH_TEST);\n\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor);\n\n    // set interpolation on the texture based on property setting\n    const iType = actor.getProperty().getInterpolationType();\n    if (iType === InterpolationType.NEAREST) {\n      model.scalarTexture.setMinificationFilter(Filter.NEAREST);\n      model.scalarTexture.setMagnificationFilter(Filter.NEAREST);\n    } else {\n      model.scalarTexture.setMinificationFilter(Filter.LINEAR);\n      model.scalarTexture.setMagnificationFilter(Filter.LINEAR);\n    }\n\n    // Bind the OpenGL, this is shared between the different primitive/cell types.\n    model.lastBoundBO = null;\n\n    // if we have a zbuffer texture then activate it\n    if (model.zBufferTexture !== null) {\n      model.zBufferTexture.activate();\n    }\n  };\n\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const gl = model.context;\n\n    // render the texture\n    model.scalarTexture.activate();\n    model.opacityTexture.activate();\n    model.colorTexture.activate();\n    model.jitterTexture.activate();\n\n    publicAPI.updateShaders(model.tris, ren, actor);\n\n    // First we do the triangles, update the shader, set uniforms, etc.\n    // for (let i = 0; i < 11; ++i) {\n    //   gl.drawArrays(gl.TRIANGLES, 66 * i, 66);\n    // }\n    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n    model.tris.getVAO().release();\n\n    model.scalarTexture.deactivate();\n    model.colorTexture.deactivate();\n    model.opacityTexture.deactivate();\n    model.jitterTexture.deactivate();\n  };\n\n  publicAPI.renderPieceFinish = (ren, actor) => {\n    // if we have a zbuffer texture then deactivate it\n    if (model.zBufferTexture !== null) {\n      model.zBufferTexture.deactivate();\n    }\n\n    if (model._useSmallViewport) {\n      // now copy the framebuffer with the volume into the\n      // regular buffer\n      model.framebuffer.restorePreviousBindingsAndBuffers();\n\n      if (model.copyShader === null) {\n        model.copyShader = model._openGLRenderWindow\n          .getShaderCache()\n          .readyShaderProgramArray(\n            [\n              '//VTK::System::Dec',\n              'attribute vec4 vertexDC;',\n              'uniform vec2 tfactor;',\n              'varying vec2 tcoord;',\n              'void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }',\n            ].join('\\n'),\n            [\n              '//VTK::System::Dec',\n              '//VTK::Output::Dec',\n              'uniform sampler2D texture1;',\n              'varying vec2 tcoord;',\n              'void main() { gl_FragData[0] = texture2D(texture1,tcoord); }',\n            ].join('\\n'),\n            ''\n          );\n        const program = model.copyShader;\n\n        model.copyVAO = vtkVertexArrayObject.newInstance();\n        model.copyVAO.setOpenGLRenderWindow(model._openGLRenderWindow);\n\n        model.tris.getCABO().bind();\n        if (\n          !model.copyVAO.addAttributeArray(\n            program,\n            model.tris.getCABO(),\n            'vertexDC',\n            model.tris.getCABO().getVertexOffset(),\n            model.tris.getCABO().getStride(),\n            model.context.FLOAT,\n            3,\n            model.context.FALSE\n          )\n        ) {\n          vtkErrorMacro('Error setting vertexDC in copy shader VAO.');\n        }\n      } else {\n        model._openGLRenderWindow\n          .getShaderCache()\n          .readyShaderProgram(model.copyShader);\n      }\n\n      const size = model._openGLRenderWindow.getFramebufferSize();\n      model.context.viewport(0, 0, size[0], size[1]);\n\n      // activate texture\n      const tex = model.framebuffer.getColorTexture();\n      tex.activate();\n      model.copyShader.setUniformi('texture', tex.getTextureUnit());\n      model.copyShader.setUniform2f('tfactor', model.fvp[0], model.fvp[1]);\n\n      const gl = model.context;\n      gl.blendFuncSeparate(\n        gl.ONE,\n        gl.ONE_MINUS_SRC_ALPHA,\n        gl.ONE,\n        gl.ONE_MINUS_SRC_ALPHA\n      );\n\n      // render quad\n      model.context.drawArrays(\n        model.context.TRIANGLES,\n        0,\n        model.tris.getCABO().getElementCount()\n      );\n      tex.deactivate();\n\n      gl.blendFuncSeparate(\n        gl.SRC_ALPHA,\n        gl.ONE_MINUS_SRC_ALPHA,\n        gl.ONE,\n        gl.ONE_MINUS_SRC_ALPHA\n      );\n    }\n  };\n\n  publicAPI.renderPiece = (ren, actor) => {\n    publicAPI.invokeEvent({ type: 'StartEvent' });\n    model.renderable.update();\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.invokeEvent({ type: 'EndEvent' });\n\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n\n  publicAPI.computeBounds = (ren, actor) => {\n    if (!publicAPI.getInput()) {\n      vtkMath.uninitializeBounds(model.Bounds);\n      return;\n    }\n    model.bounds = publicAPI.getInput().getBounds();\n  };\n\n  publicAPI.updateBufferObjects = (ren, actor) => {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {\n    // first do a coarse check\n    if (\n      model.VBOBuildTime.getMTime() < publicAPI.getMTime() ||\n      model.VBOBuildTime.getMTime() < actor.getMTime() ||\n      model.VBOBuildTime.getMTime() < model.renderable.getMTime() ||\n      model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() ||\n      model.VBOBuildTime.getMTime() < model.currentInput.getMTime()\n    ) {\n      return true;\n    }\n    return false;\n  };\n\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const image = model.currentInput;\n    if (!image) {\n      return;\n    }\n\n    const scalars = image.getPointData() && image.getPointData().getScalars();\n    if (!scalars) {\n      return;\n    }\n\n    const vprop = actor.getProperty();\n\n    if (!model.jitterTexture.getHandle()) {\n      const oTable = new Uint8Array(32 * 32);\n      for (let i = 0; i < 32 * 32; ++i) {\n        oTable[i] = 255.0 * Math.random();\n      }\n      model.jitterTexture.setMinificationFilter(Filter.LINEAR);\n      model.jitterTexture.setMagnificationFilter(Filter.LINEAR);\n      model.jitterTexture.create2DFromRaw(\n        32,\n        32,\n        1,\n        VtkDataTypes.UNSIGNED_CHAR,\n        oTable\n      );\n    }\n\n    const numComp = scalars.getNumberOfComponents();\n    const iComps = vprop.getIndependentComponents();\n    const numIComps = iComps ? numComp : 1;\n\n    // rebuild opacity tfun?\n    let toString = `${vprop.getMTime()}`;\n    if (model.opacityTextureString !== toString) {\n      const oWidth = 1024;\n      const oSize = oWidth * 2 * numIComps;\n      const ofTable = new Float32Array(oSize);\n      const tmpTable = new Float32Array(oWidth);\n\n      for (let c = 0; c < numIComps; ++c) {\n        const ofun = vprop.getScalarOpacity(c);\n        const opacityFactor =\n          model.renderable.getSampleDistance() /\n          vprop.getScalarOpacityUnitDistance(c);\n\n        const oRange = ofun.getRange();\n        ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);\n        // adjust for sample distance etc\n        for (let i = 0; i < oWidth; ++i) {\n          ofTable[c * oWidth * 2 + i] =\n            1.0 - (1.0 - tmpTable[i]) ** opacityFactor;\n          ofTable[c * oWidth * 2 + i + oWidth] = ofTable[c * oWidth * 2 + i];\n        }\n      }\n\n      model.opacityTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.opacityTexture.setMinificationFilter(Filter.LINEAR);\n      model.opacityTexture.setMagnificationFilter(Filter.LINEAR);\n\n      // use float texture where possible because we really need the resolution\n      // for this table. Errors in low values of opacity accumulate to\n      // visible artifacts. High values of opacity quickly terminate without\n      // artifacts.\n      if (\n        model._openGLRenderWindow.getWebgl2() ||\n        (model.context.getExtension('OES_texture_float') &&\n          model.context.getExtension('OES_texture_float_linear'))\n      ) {\n        model.opacityTexture.create2DFromRaw(\n          oWidth,\n          2 * numIComps,\n          1,\n          VtkDataTypes.FLOAT,\n          ofTable\n        );\n      } else {\n        const oTable = new Uint8Array(oSize);\n        for (let i = 0; i < oSize; ++i) {\n          oTable[i] = 255.0 * ofTable[i];\n        }\n        model.opacityTexture.create2DFromRaw(\n          oWidth,\n          2 * numIComps,\n          1,\n          VtkDataTypes.UNSIGNED_CHAR,\n          oTable\n        );\n      }\n      model.opacityTextureString = toString;\n    }\n\n    // rebuild color tfun?\n    toString = `${vprop.getMTime()}`;\n    if (model.colorTextureString !== toString) {\n      const cWidth = 1024;\n      const cSize = cWidth * 2 * numIComps * 3;\n      const cTable = new Uint8Array(cSize);\n      const tmpTable = new Float32Array(cWidth * 3);\n\n      for (let c = 0; c < numIComps; ++c) {\n        const cfun = vprop.getRGBTransferFunction(c);\n        const cRange = cfun.getRange();\n        cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);\n        for (let i = 0; i < cWidth * 3; ++i) {\n          cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n          cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];\n        }\n      }\n\n      model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.colorTexture.setMinificationFilter(Filter.LINEAR);\n      model.colorTexture.setMagnificationFilter(Filter.LINEAR);\n\n      model.colorTexture.create2DFromRaw(\n        cWidth,\n        2 * numIComps,\n        3,\n        VtkDataTypes.UNSIGNED_CHAR,\n        cTable\n      );\n      model.colorTextureString = toString;\n    }\n\n    // rebuild the scalarTexture if the data has changed\n    toString = `${image.getMTime()}`;\n    if (model.scalarTextureString !== toString) {\n      // Build the textures\n      const dims = image.getDimensions();\n      model.scalarTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.scalarTexture.resetFormatAndType();\n      model.scalarTexture.create3DFilterableFromRaw(\n        dims[0],\n        dims[1],\n        dims[2],\n        numComp,\n        scalars.getDataType(),\n        scalars.getData(),\n        model.renderable.getPreferSizeOverAccuracy()\n      );\n      model.scalarTextureString = toString;\n    }\n\n    if (!model.tris.getCABO().getElementCount()) {\n      // build the CABO\n      const ptsArray = new Float32Array(12);\n      for (let i = 0; i < 4; i++) {\n        ptsArray[i * 3] = (i % 2) * 2 - 1.0;\n        ptsArray[i * 3 + 1] = i > 1 ? 1.0 : -1.0;\n        ptsArray[i * 3 + 2] = -1.0;\n      }\n\n      const cellArray = new Uint16Array(8);\n      cellArray[0] = 3;\n      cellArray[1] = 0;\n      cellArray[2] = 1;\n      cellArray[3] = 3;\n      cellArray[4] = 3;\n      cellArray[5] = 0;\n      cellArray[6] = 3;\n      cellArray[7] = 2;\n\n      // const dim = 12.0;\n      // const ptsArray = new Float32Array(3 * dim * dim);\n      // for (let i = 0; i < dim; i++) {\n      //   for (let j = 0; j < dim; j++) {\n      //     const offset = ((i * dim) + j) * 3;\n      //     ptsArray[offset] = (2.0 * (i / (dim - 1.0))) - 1.0;\n      //     ptsArray[offset + 1] = (2.0 * (j / (dim - 1.0))) - 1.0;\n      //     ptsArray[offset + 2] = -1.0;\n      //   }\n      // }\n\n      // const cellArray = new Uint16Array(8 * (dim - 1) * (dim - 1));\n      // for (let i = 0; i < dim - 1; i++) {\n      //   for (let j = 0; j < dim - 1; j++) {\n      //     const offset = 8 * ((i * (dim - 1)) + j);\n      //     cellArray[offset] = 3;\n      //     cellArray[offset + 1] = (i * dim) + j;\n      //     cellArray[offset + 2] = (i * dim) + 1 + j;\n      //     cellArray[offset + 3] = ((i + 1) * dim) + 1 + j;\n      //     cellArray[offset + 4] = 3;\n      //     cellArray[offset + 5] = (i * dim) + j;\n      //     cellArray[offset + 6] = ((i + 1) * dim) + 1 + j;\n      //     cellArray[offset + 7] = ((i + 1) * dim) + j;\n      //   }\n      // }\n\n      const points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray,\n      });\n      points.setName('points');\n      const cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray,\n      });\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points,\n        cellOffset: 0,\n      });\n    }\n\n    model.VBOBuildTime.modified();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  VBOBuildTime: null,\n  scalarTexture: null,\n  scalarTextureString: null,\n  opacityTexture: null,\n  opacityTextureString: null,\n  colorTexture: null,\n  colorTextureString: null,\n  jitterTexture: null,\n  tris: null,\n  framebuffer: null,\n  copyShader: null,\n  copyVAO: null,\n  lastXYF: 1.0,\n  targetXYF: 1.0,\n  zBufferTexture: null,\n  lastZBufferTexture: null,\n  lastLightComplexity: 0,\n  fullViewportTime: 1.0,\n  idxToView: null,\n  idxNormalMatrix: null,\n  modelToView: null,\n  projectionToView: null,\n  avgWindowArea: 0.0,\n  avgFrameTime: 0.0,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n\n  model.VBOBuildTime = {};\n  macro.obj(model.VBOBuildTime, { mtime: 0 });\n\n  model.tris = vtkHelper.newInstance();\n  model.scalarTexture = vtkOpenGLTexture.newInstance();\n  model.opacityTexture = vtkOpenGLTexture.newInstance();\n  model.colorTexture = vtkOpenGLTexture.newInstance();\n  model.jitterTexture = vtkOpenGLTexture.newInstance();\n  model.jitterTexture.setWrapS(Wrap.REPEAT);\n  model.jitterTexture.setWrapT(Wrap.REPEAT);\n  model.framebuffer = vtkOpenGLFramebuffer.newInstance();\n\n  model.idxToView = mat4.identity(new Float64Array(16));\n  model.idxNormalMatrix = mat3.identity(new Float64Array(9));\n  model.modelToView = mat4.identity(new Float64Array(16));\n  model.projectionToView = mat4.identity(new Float64Array(16));\n  model.projectionToWorld = mat4.identity(new Float64Array(16));\n\n  model._lastScale = 1.0;\n\n  // Build VTK API\n  macro.setGet(publicAPI, model, ['context']);\n\n  // Object methods\n  vtkOpenGLVolumeMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkOpenGLVolumeMapper');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkVolumeMapper', newInstance);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}