{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport vtkCell from 'vtk.js/Sources/Common/DataModel/Cell'; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nexport const InitLink = {\n  ncells: 0,\n  cells: null\n};\n\nfunction resize(model, sz) {\n  let newSize = sz;\n\n  if (sz >= model.array.length) {\n    newSize += model.array.length;\n  }\n\n  while (newSize > model.array.length) model.array.push({\n    ncells: 0,\n    cells: null\n  });\n\n  model.array.length = newSize;\n} // ----------------------------------------------------------------------------\n// vtkCellLinks methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkCellLinks(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellLinks');\n  /**\n   * Build the link list array. All subclasses of vtkAbstractCellLinks\n   * must support this method.\n   */\n\n  publicAPI.buildLinks = data => {\n    const numPts = data.getPoints().getNumberOfPoints();\n    const numCells = data.getNumberOfCells(); // fill out lists with number of references to cells\n\n    const linkLoc = new Uint32Array(numPts); // Use fast path if polydata\n\n    if (data.isA('vtkPolyData')) {\n      // traverse data to determine number of uses of each point\n      for (let cellId = 0; cellId < numCells; ++cellId) {\n        const {\n          cellPointIds\n        } = data.getCellPoints(cellId);\n        cellPointIds.forEach(cellPointId => {\n          publicAPI.incrementLinkCount(cellPointId);\n        });\n      } // now allocate storage for the links\n\n\n      publicAPI.allocateLinks(numPts);\n      model.maxId = numPts - 1;\n\n      for (let cellId = 0; cellId < numCells; ++cellId) {\n        const {\n          cellPointIds\n        } = data.getCellPoints(cellId);\n        cellPointIds.forEach(cellPointId => {\n          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);\n        });\n      }\n    } // any other type of dataset\n    else {\n      // traverse data to determine number of uses of each point\n      for (let cellId = 0; cellId < numCells; cellId++) {\n        // TODO: Currently not supported: const cell = data.getCell(cellId);\n        const cell = vtkCell.newInstance();\n        cell.getPointsIds().forEach(cellPointId => {\n          publicAPI.incrementLinkCount(cellPointId);\n        });\n      } // now allocate storage for the links\n\n\n      publicAPI.allocateLinks(numPts);\n      model.maxId = numPts - 1;\n\n      for (let cellId = 0; cellId < numCells; ++cellId) {\n        // TODO: Currently not supported: const cell = data.getCell(cellId);\n        const cell = vtkCell.newInstance();\n        cell.getPointsIds().forEach(cellPointId => {\n          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);\n        });\n      }\n    } // end else\n\n  };\n  /**\n   * Build the link list array with a provided connectivity array.\n   */\n  // publicAPI.buildLinks = (data, connectivity) => {};\n\n  /**\n   * Allocate the specified number of links (i.e., number of points) that\n   * will be built.\n   */\n\n\n  publicAPI.allocate = function (numLinks) {\n    let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    model.array = Array(numLinks).fill().map(() => ({\n      ncells: 0,\n      cells: null\n    }));\n    model.extend = ext;\n    model.maxId = -1;\n  };\n\n  publicAPI.initialize = () => {\n    model.array = null;\n  };\n  /**\n   * Get a link structure given a point id.\n   */\n\n\n  publicAPI.getLink = ptId => model.array[ptId];\n  /**\n   * Get the number of cells using the point specified by ptId.\n   */\n\n\n  publicAPI.getNcells = ptId => model.array[ptId].ncells;\n  /**\n   * Return a list of cell ids using the point.\n   */\n\n\n  publicAPI.getCells = ptId => model.array[ptId].cells;\n  /**\n   * Insert a new point into the cell-links data structure. The size parameter\n   * is the initial size of the list.\n   */\n\n\n  publicAPI.insertNextPoint = numLinks => {\n    model.array.push({\n      ncells: numLinks,\n      cells: Array(numLinks)\n    });\n    ++model.maxId;\n  };\n  /**\n   * Insert a cell id into the list of cells (at the end) using the cell id\n   * provided. (Make sure to extend the link list (if necessary) using the\n   * method resizeCellList().)\n   */\n\n\n  publicAPI.insertNextCellReference = (ptId, cellId) => {\n    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;\n  };\n  /**\n   * Delete point (and storage) by destroying links to using cells.\n   */\n\n\n  publicAPI.deletePoint = ptId => {\n    model.array[ptId].ncells = 0;\n    model.array[ptId].cells = null;\n  };\n  /**\n   * Delete the reference to the cell (cellId) from the point (ptId). This\n   * removes the reference to the cellId from the cell list, but does not\n   * resize the list (recover memory with resizeCellList(), if necessary).\n   */\n\n\n  publicAPI.removeCellReference = (cellId, ptId) => {\n    model.array[ptId].cells = model.array[ptId].cells.filter(cell => cell !== cellId);\n    model.array[ptId].ncells = model.array[ptId].cells.length;\n  };\n  /**\n   * Add the reference to the cell (cellId) from the point (ptId). This\n   * adds a reference to the cellId from the cell list, but does not resize\n   * the list (extend memory with resizeCellList(), if necessary).\n   */\n\n\n  publicAPI.addCellReference = (cellId, ptId) => {\n    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;\n  };\n  /**\n   * Change the length of a point's link list (i.e., list of cells using a\n   * point) by the size specified.\n   */\n\n\n  publicAPI.resizeCellList = (ptId, size) => {\n    model.array[ptId].cells.length = size;\n  };\n  /**\n   * Reclaim any unused memory.\n   */\n\n\n  publicAPI.squeeze = () => {\n    resize(model, model.maxId + 1);\n  };\n  /**\n   * Reset to a state of no entries without freeing the memory.\n   */\n\n\n  publicAPI.reset = () => {\n    model.maxId = -1;\n  };\n  /**\n   * Standard DeepCopy method.  Since this object contains no reference\n   * to other objects, there is no ShallowCopy.\n   */\n\n\n  publicAPI.deepCopy = src => {\n    model.array = [...src.array];\n    model.extend = src.extend;\n    model.maxId = src.maxId;\n  };\n  /**\n   * Increment the count of the number of cells using the point.\n   */\n\n\n  publicAPI.incrementLinkCount = ptId => {\n    ++model.array[ptId].ncells;\n  };\n\n  publicAPI.allocateLinks = n => {\n    for (let i = 0; i < n; ++i) {\n      model.array[i].cells = new Array(model.array[i].ncells);\n    }\n  };\n  /**\n   * Insert a cell id into the list of cells using the point.\n   */\n\n\n  publicAPI.insertCellReference = (ptId, pos, cellId) => {\n    model.array[ptId].cells[pos] = cellId;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  array: null,\n  // pointer to data\n  maxId: 0,\n  // maximum index inserted thus far\n  extend: 0 // grow array by this point\n\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  vtkCellLinks(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkCellLinks'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["macro","vtkCell","InitLink","ncells","cells","resize","model","sz","newSize","array","length","push","vtkCellLinks","publicAPI","classHierarchy","buildLinks","data","numPts","getPoints","getNumberOfPoints","numCells","getNumberOfCells","linkLoc","Uint32Array","isA","cellId","cellPointIds","getCellPoints","forEach","cellPointId","incrementLinkCount","allocateLinks","maxId","insertCellReference","cell","newInstance","getPointsIds","allocate","numLinks","ext","Array","fill","map","extend","initialize","getLink","ptId","getNcells","getCells","insertNextPoint","insertNextCellReference","deletePoint","removeCellReference","filter","addCellReference","resizeCellList","size","squeeze","reset","deepCopy","src","n","i","pos","DEFAULT_VALUES","initialValues","Object","assign","obj"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Common/DataModel/CellLinks/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport vtkCell from 'vtk.js/Sources/Common/DataModel/Cell';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\nexport const InitLink = {\n  ncells: 0,\n  cells: null,\n};\n\nfunction resize(model, sz) {\n  let newSize = sz;\n  if (sz >= model.array.length) {\n    newSize += model.array.length;\n  }\n\n  while (newSize > model.array.length)\n    model.array.push({\n      ncells: 0,\n      cells: null,\n    });\n  model.array.length = newSize;\n}\n\n// ----------------------------------------------------------------------------\n// vtkCellLinks methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellLinks(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellLinks');\n\n  /**\n   * Build the link list array. All subclasses of vtkAbstractCellLinks\n   * must support this method.\n   */\n  publicAPI.buildLinks = (data) => {\n    const numPts = data.getPoints().getNumberOfPoints();\n    const numCells = data.getNumberOfCells();\n\n    // fill out lists with number of references to cells\n    const linkLoc = new Uint32Array(numPts);\n\n    // Use fast path if polydata\n    if (data.isA('vtkPolyData')) {\n      // traverse data to determine number of uses of each point\n      for (let cellId = 0; cellId < numCells; ++cellId) {\n        const { cellPointIds } = data.getCellPoints(cellId);\n        cellPointIds.forEach((cellPointId) => {\n          publicAPI.incrementLinkCount(cellPointId);\n        });\n      }\n\n      // now allocate storage for the links\n      publicAPI.allocateLinks(numPts);\n      model.maxId = numPts - 1;\n\n      for (let cellId = 0; cellId < numCells; ++cellId) {\n        const { cellPointIds } = data.getCellPoints(cellId);\n        cellPointIds.forEach((cellPointId) => {\n          publicAPI.insertCellReference(\n            cellPointId,\n            linkLoc[cellPointId]++,\n            cellId\n          );\n        });\n      }\n    } // any other type of dataset\n    else {\n      // traverse data to determine number of uses of each point\n      for (let cellId = 0; cellId < numCells; cellId++) {\n        // TODO: Currently not supported: const cell = data.getCell(cellId);\n        const cell = vtkCell.newInstance();\n        cell.getPointsIds().forEach((cellPointId) => {\n          publicAPI.incrementLinkCount(cellPointId);\n        });\n      }\n\n      // now allocate storage for the links\n      publicAPI.allocateLinks(numPts);\n      model.maxId = numPts - 1;\n\n      for (let cellId = 0; cellId < numCells; ++cellId) {\n        // TODO: Currently not supported: const cell = data.getCell(cellId);\n        const cell = vtkCell.newInstance();\n        cell.getPointsIds().forEach((cellPointId) => {\n          publicAPI.insertCellReference(\n            cellPointId,\n            linkLoc[cellPointId]++,\n            cellId\n          );\n        });\n      }\n    } // end else\n  };\n\n  /**\n   * Build the link list array with a provided connectivity array.\n   */\n  // publicAPI.buildLinks = (data, connectivity) => {};\n\n  /**\n   * Allocate the specified number of links (i.e., number of points) that\n   * will be built.\n   */\n  publicAPI.allocate = (numLinks, ext = 1000) => {\n    model.array = Array(numLinks)\n      .fill()\n      .map(() => ({\n        ncells: 0,\n        cells: null,\n      }));\n    model.extend = ext;\n    model.maxId = -1;\n  };\n\n  publicAPI.initialize = () => {\n    model.array = null;\n  };\n\n  /**\n   * Get a link structure given a point id.\n   */\n  publicAPI.getLink = (ptId) => model.array[ptId];\n\n  /**\n   * Get the number of cells using the point specified by ptId.\n   */\n  publicAPI.getNcells = (ptId) => model.array[ptId].ncells;\n\n  /**\n   * Return a list of cell ids using the point.\n   */\n  publicAPI.getCells = (ptId) => model.array[ptId].cells;\n\n  /**\n   * Insert a new point into the cell-links data structure. The size parameter\n   * is the initial size of the list.\n   */\n  publicAPI.insertNextPoint = (numLinks) => {\n    model.array.push({ ncells: numLinks, cells: Array(numLinks) });\n    ++model.maxId;\n  };\n\n  /**\n   * Insert a cell id into the list of cells (at the end) using the cell id\n   * provided. (Make sure to extend the link list (if necessary) using the\n   * method resizeCellList().)\n   */\n  publicAPI.insertNextCellReference = (ptId, cellId) => {\n    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;\n  };\n\n  /**\n   * Delete point (and storage) by destroying links to using cells.\n   */\n  publicAPI.deletePoint = (ptId) => {\n    model.array[ptId].ncells = 0;\n    model.array[ptId].cells = null;\n  };\n\n  /**\n   * Delete the reference to the cell (cellId) from the point (ptId). This\n   * removes the reference to the cellId from the cell list, but does not\n   * resize the list (recover memory with resizeCellList(), if necessary).\n   */\n  publicAPI.removeCellReference = (cellId, ptId) => {\n    model.array[ptId].cells = model.array[ptId].cells.filter(\n      (cell) => cell !== cellId\n    );\n    model.array[ptId].ncells = model.array[ptId].cells.length;\n  };\n\n  /**\n   * Add the reference to the cell (cellId) from the point (ptId). This\n   * adds a reference to the cellId from the cell list, but does not resize\n   * the list (extend memory with resizeCellList(), if necessary).\n   */\n  publicAPI.addCellReference = (cellId, ptId) => {\n    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;\n  };\n\n  /**\n   * Change the length of a point's link list (i.e., list of cells using a\n   * point) by the size specified.\n   */\n  publicAPI.resizeCellList = (ptId, size) => {\n    model.array[ptId].cells.length = size;\n  };\n\n  /**\n   * Reclaim any unused memory.\n   */\n  publicAPI.squeeze = () => {\n    resize(model, model.maxId + 1);\n  };\n\n  /**\n   * Reset to a state of no entries without freeing the memory.\n   */\n  publicAPI.reset = () => {\n    model.maxId = -1;\n  };\n\n  /**\n   * Standard DeepCopy method.  Since this object contains no reference\n   * to other objects, there is no ShallowCopy.\n   */\n  publicAPI.deepCopy = (src) => {\n    model.array = [...src.array];\n    model.extend = src.extend;\n    model.maxId = src.maxId;\n  };\n\n  /**\n   * Increment the count of the number of cells using the point.\n   */\n  publicAPI.incrementLinkCount = (ptId) => {\n    ++model.array[ptId].ncells;\n  };\n\n  publicAPI.allocateLinks = (n) => {\n    for (let i = 0; i < n; ++i) {\n      model.array[i].cells = new Array(model.array[i].ncells);\n    }\n  };\n\n  /**\n   * Insert a cell id into the list of cells using the point.\n   */\n  publicAPI.insertCellReference = (ptId, pos, cellId) => {\n    model.array[ptId].cells[pos] = cellId;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  array: null, // pointer to data\n  maxId: 0, // maximum index inserted thus far\n  extend: 0, // grow array by this point\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  macro.obj(publicAPI, model);\n\n  vtkCellLinks(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkCellLinks');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}