{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkPoints from 'vtk.js/Sources/Common/Core/Points'; // ----------------------------------------------------------------------------\n// vtkCell methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCell(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCell');\n\n  publicAPI.initialize = function (points) {\n    let pointIdsList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (!pointIdsList) {\n      model.points = points;\n      model.pointsIds = new Array(points.getNumberOfPoints());\n\n      for (let i = points.getNumberOfPoints() - 1; i >= 0; --i) {\n        model.pointsIds[i] = i;\n      }\n    } else {\n      model.pointsIds = pointIdsList;\n      let triangleData = model.points.getData();\n\n      if (triangleData.length !== 3 * model.pointsIds.length) {\n        triangleData = macro.newTypedArray(points.getDataType(), 3 * model.pointsIds.length);\n      }\n\n      const pointsData = points.getData();\n      model.pointsIds.forEach((pointId, index) => {\n        // const start = 3 * pointId;\n        // pointsData.set(p.subarray(start, start + 3), 3 * index);\n        let pointOffset = 3 * pointId;\n        let trianglePointOffset = 3 * index;\n        triangleData[trianglePointOffset] = pointsData[pointOffset];\n        triangleData[++trianglePointOffset] = pointsData[++pointOffset];\n        triangleData[++trianglePointOffset] = pointsData[++pointOffset];\n      });\n      model.points.setData(triangleData);\n    }\n  };\n\n  publicAPI.getBounds = () => {\n    const nbPoints = model.points.getNumberOfPoints();\n    const x = [];\n\n    if (nbPoints) {\n      model.points.getPoint(0, x);\n      model.bounds[0] = x[0];\n      model.bounds[1] = x[0];\n      model.bounds[2] = x[1];\n      model.bounds[3] = x[1];\n      model.bounds[4] = x[2];\n      model.bounds[5] = x[2];\n\n      for (let i = 1; i < nbPoints; i++) {\n        model.points.getPoint(i, x);\n        model.bounds[0] = x[0] < model.bounds[0] ? x[0] : model.bounds[0];\n        model.bounds[1] = x[0] > model.bounds[1] ? x[0] : model.bounds[1];\n        model.bounds[2] = x[1] < model.bounds[2] ? x[1] : model.bounds[2];\n        model.bounds[3] = x[1] > model.bounds[3] ? x[1] : model.bounds[3];\n        model.bounds[4] = x[2] < model.bounds[4] ? x[2] : model.bounds[4];\n        model.bounds[5] = x[2] > model.bounds[5] ? x[2] : model.bounds[5];\n      }\n    } else {\n      vtkMath.uninitializeBounds(model.bounds);\n    }\n\n    return model.bounds;\n  };\n\n  publicAPI.getLength2 = () => {\n    publicAPI.getBounds();\n    let length = 0.0;\n    let diff = 0;\n\n    for (let i = 0; i < 3; i++) {\n      diff = model.bounds[2 * i + 1] - model.bounds[2 * i];\n      length += diff * diff;\n    }\n\n    return length;\n  };\n\n  publicAPI.getParametricDistance = pcoords => {\n    let pDist;\n    let pDistMax = 0.0;\n\n    for (let i = 0; i < 3; i++) {\n      if (pcoords[i] < 0.0) {\n        pDist = -pcoords[i];\n      } else if (pcoords[i] > 1.0) {\n        pDist = pcoords[i] - 1.0;\n      } else {\n        // inside the cell in the parametric direction\n        pDist = 0.0;\n      }\n\n      if (pDist > pDistMax) {\n        pDistMax = pDist;\n      }\n    }\n\n    return pDistMax;\n  };\n\n  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();\n\n  publicAPI.deepCopy = cell => {\n    cell.initialize(model.points, model.pointsIds);\n  };\n\n  publicAPI.getCellDimension = () => {}; // virtual\n\n\n  publicAPI.intersectWithLine = (p1, p2, tol, t, x, pcoords, subId) => {}; // virtual\n\n\n  publicAPI.evaluatePosition = (x, closestPoint, subId, pcoords, dist2, weights) => {\n    macro.vtkErrorMacro('vtkCell.evaluatePosition is not implemented.');\n  }; // virtual\n\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  bounds: [-1, -1, -1, -1, -1, -1],\n  pointsIds: []\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n\n  if (!model.points) {\n    model.points = vtkPoints.newInstance();\n  }\n\n  macro.get(publicAPI, model, ['points', 'pointsIds']);\n  vtkCell(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkCell'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["macro","vtkMath","vtkPoints","vtkCell","publicAPI","model","classHierarchy","push","initialize","points","pointIdsList","pointsIds","Array","getNumberOfPoints","i","triangleData","getData","length","newTypedArray","getDataType","pointsData","forEach","pointId","index","pointOffset","trianglePointOffset","setData","getBounds","nbPoints","x","getPoint","bounds","uninitializeBounds","getLength2","diff","getParametricDistance","pcoords","pDist","pDistMax","deepCopy","cell","getCellDimension","intersectWithLine","p1","p2","tol","t","subId","evaluatePosition","closestPoint","dist2","weights","vtkErrorMacro","DEFAULT_VALUES","extend","initialValues","Object","assign","obj","newInstance","get"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Common/DataModel/Cell/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkPoints from 'vtk.js/Sources/Common/Core/Points';\n\n// ----------------------------------------------------------------------------\n// vtkCell methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCell(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCell');\n\n  publicAPI.initialize = (points, pointIdsList = null) => {\n    if (!pointIdsList) {\n      model.points = points;\n      model.pointsIds = new Array(points.getNumberOfPoints());\n      for (let i = points.getNumberOfPoints() - 1; i >= 0; --i) {\n        model.pointsIds[i] = i;\n      }\n    } else {\n      model.pointsIds = pointIdsList;\n      let triangleData = model.points.getData();\n      if (triangleData.length !== 3 * model.pointsIds.length) {\n        triangleData = macro.newTypedArray(\n          points.getDataType(),\n          3 * model.pointsIds.length\n        );\n      }\n      const pointsData = points.getData();\n      model.pointsIds.forEach((pointId, index) => {\n        // const start = 3 * pointId;\n        // pointsData.set(p.subarray(start, start + 3), 3 * index);\n        let pointOffset = 3 * pointId;\n        let trianglePointOffset = 3 * index;\n        triangleData[trianglePointOffset] = pointsData[pointOffset];\n        triangleData[++trianglePointOffset] = pointsData[++pointOffset];\n        triangleData[++trianglePointOffset] = pointsData[++pointOffset];\n      });\n      model.points.setData(triangleData);\n    }\n  };\n\n  publicAPI.getBounds = () => {\n    const nbPoints = model.points.getNumberOfPoints();\n    const x = [];\n    if (nbPoints) {\n      model.points.getPoint(0, x);\n      model.bounds[0] = x[0];\n      model.bounds[1] = x[0];\n      model.bounds[2] = x[1];\n      model.bounds[3] = x[1];\n      model.bounds[4] = x[2];\n      model.bounds[5] = x[2];\n\n      for (let i = 1; i < nbPoints; i++) {\n        model.points.getPoint(i, x);\n        model.bounds[0] = x[0] < model.bounds[0] ? x[0] : model.bounds[0];\n        model.bounds[1] = x[0] > model.bounds[1] ? x[0] : model.bounds[1];\n        model.bounds[2] = x[1] < model.bounds[2] ? x[1] : model.bounds[2];\n        model.bounds[3] = x[1] > model.bounds[3] ? x[1] : model.bounds[3];\n        model.bounds[4] = x[2] < model.bounds[4] ? x[2] : model.bounds[4];\n        model.bounds[5] = x[2] > model.bounds[5] ? x[2] : model.bounds[5];\n      }\n    } else {\n      vtkMath.uninitializeBounds(model.bounds);\n    }\n    return model.bounds;\n  };\n\n  publicAPI.getLength2 = () => {\n    publicAPI.getBounds();\n    let length = 0.0;\n    let diff = 0;\n    for (let i = 0; i < 3; i++) {\n      diff = model.bounds[2 * i + 1] - model.bounds[2 * i];\n      length += diff * diff;\n    }\n    return length;\n  };\n\n  publicAPI.getParametricDistance = (pcoords) => {\n    let pDist;\n    let pDistMax = 0.0;\n\n    for (let i = 0; i < 3; i++) {\n      if (pcoords[i] < 0.0) {\n        pDist = -pcoords[i];\n      } else if (pcoords[i] > 1.0) {\n        pDist = pcoords[i] - 1.0;\n      } else {\n        // inside the cell in the parametric direction\n        pDist = 0.0;\n      }\n      if (pDist > pDistMax) {\n        pDistMax = pDist;\n      }\n    }\n    return pDistMax;\n  };\n\n  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();\n\n  publicAPI.deepCopy = (cell) => {\n    cell.initialize(model.points, model.pointsIds);\n  };\n\n  publicAPI.getCellDimension = () => {}; // virtual\n  publicAPI.intersectWithLine = (p1, p2, tol, t, x, pcoords, subId) => {}; // virtual\n  publicAPI.evaluatePosition = (\n    x,\n    closestPoint,\n    subId,\n    pcoords,\n    dist2,\n    weights\n  ) => {\n    macro.vtkErrorMacro('vtkCell.evaluatePosition is not implemented.');\n  }; // virtual\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  bounds: [-1, -1, -1, -1, -1, -1],\n  pointsIds: [],\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  macro.obj(publicAPI, model);\n\n  if (!model.points) {\n    model.points = vtkPoints.newInstance();\n  }\n\n  macro.get(publicAPI, model, ['points', 'pointsIds']);\n\n  vtkCell(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkCell');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}