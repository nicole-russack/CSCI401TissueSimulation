{"ast":null,"code":"import { mat4, quat, vec3 } from 'gl-matrix';\nimport macro from 'vtk.js/Sources/macros';\nimport vtkBufferObject from 'vtk.js/Sources/Rendering/OpenGL/BufferObject';\nimport { ObjectType } from 'vtk.js/Sources/Rendering/OpenGL/BufferObject/Constants';\nimport { Representation } from 'vtk.js/Sources/Rendering/Core/Property/Constants';\nconst {\n  vtkErrorMacro\n} = macro; // ----------------------------------------------------------------------------\n// Static functions\n// ----------------------------------------------------------------------------\n\nfunction computeInverseShiftAndScaleMatrix(coordShift, coordScale) {\n  const inverseScale = new Float64Array(3);\n  vec3.inverse(inverseScale, coordScale);\n  const matrix = new Float64Array(16);\n  mat4.fromRotationTranslationScale(matrix, quat.create(), coordShift, inverseScale);\n  return matrix;\n}\n\nfunction shouldApplyCoordShiftAndScale(coordShift, coordScale) {\n  if (coordShift === null || coordScale === null) {\n    return false;\n  }\n\n  return !(vec3.exactEquals(coordShift, [0, 0, 0]) && vec3.exactEquals(coordScale, [1, 1, 1]));\n} // ----------------------------------------------------------------------------\n// vtkOpenGLCellArrayBufferObject methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkOpenGLCellArrayBufferObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLCellArrayBufferObject');\n  publicAPI.setType(ObjectType.ARRAY_BUFFER);\n\n  publicAPI.createVBO = function (cellArray, inRep, outRep, options) {\n    let selectionMaps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n    if (!cellArray.getData() || !cellArray.getData().length) {\n      model.elementCount = 0;\n      return 0;\n    } // Figure out how big each block will be, currently 6 or 7 floats.\n\n\n    model.blockSize = 3;\n    model.vertexOffset = 0;\n    model.normalOffset = 0;\n    model.tCoordOffset = 0;\n    model.tCoordComponents = 0;\n    model.colorComponents = 0;\n    model.colorOffset = 0;\n    model.customData = [];\n    const pointData = options.points.getData();\n    let normalData = null;\n    let tcoordData = null;\n    let colorData = null;\n    const colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;\n    const textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0; // the values of 4 below are because floats are 4 bytes\n\n    if (options.normals) {\n      model.normalOffset = 4 * model.blockSize;\n      model.blockSize += 3;\n      normalData = options.normals.getData();\n    }\n\n    if (options.customAttributes) {\n      options.customAttributes.forEach(a => {\n        if (a) {\n          model.customData.push({\n            data: a.getData(),\n            offset: 4 * model.blockSize,\n            components: a.getNumberOfComponents(),\n            name: a.getName()\n          });\n          model.blockSize += a.getNumberOfComponents();\n        }\n      });\n    }\n\n    if (options.tcoords) {\n      model.tCoordOffset = 4 * model.blockSize;\n      model.tCoordComponents = textureComponents;\n      model.blockSize += textureComponents;\n      tcoordData = options.tcoords.getData();\n    }\n\n    if (options.colors) {\n      model.colorComponents = options.colors.getNumberOfComponents();\n      model.colorOffset = 0;\n      colorData = options.colors.getData();\n\n      if (!model.colorBO) {\n        model.colorBO = vtkBufferObject.newInstance();\n      }\n\n      model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);\n    } else {\n      model.colorBO = null;\n    }\n\n    model.stride = 4 * model.blockSize;\n    let pointIdx = 0;\n    let normalIdx = 0;\n    let tcoordIdx = 0;\n    let colorIdx = 0;\n    let custIdx = 0;\n    let cellCount = 0;\n    let addAPoint;\n    const cellBuilders = {\n      // easy, every input point becomes an output point\n      anythingToPoints(numPoints, cellPts, offset) {\n        for (let i = 0; i < numPoints; ++i) {\n          addAPoint(cellPts[offset + i]);\n        }\n      },\n\n      linesToWireframe(numPoints, cellPts, offset) {\n        // for lines we add a bunch of segments\n        for (let i = 0; i < numPoints - 1; ++i) {\n          addAPoint(cellPts[offset + i]);\n          addAPoint(cellPts[offset + i + 1]);\n        }\n      },\n\n      polysToWireframe(numPoints, cellPts, offset) {\n        // for polys we add a bunch of segments and close it\n        if (numPoints > 2) {\n          for (let i = 0; i < numPoints; ++i) {\n            addAPoint(cellPts[offset + i]);\n            addAPoint(cellPts[offset + (i + 1) % numPoints]);\n          }\n        }\n      },\n\n      stripsToWireframe(numPoints, cellPts, offset) {\n        if (numPoints > 2) {\n          // for strips we add a bunch of segments and close it\n          for (let i = 0; i < numPoints - 1; ++i) {\n            addAPoint(cellPts[offset + i]);\n            addAPoint(cellPts[offset + i + 1]);\n          }\n\n          for (let i = 0; i < numPoints - 2; i++) {\n            addAPoint(cellPts[offset + i]);\n            addAPoint(cellPts[offset + i + 2]);\n          }\n        }\n      },\n\n      polysToSurface(npts, cellPts, offset) {\n        for (let i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + 0]);\n          addAPoint(cellPts[offset + i + 1]);\n          addAPoint(cellPts[offset + i + 2]);\n        }\n      },\n\n      stripsToSurface(npts, cellPts, offset) {\n        for (let i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + i]);\n          addAPoint(cellPts[offset + i + 1 + i % 2]);\n          addAPoint(cellPts[offset + i + 1 + (i + 1) % 2]);\n        }\n      }\n\n    };\n    const cellCounters = {\n      // easy, every input point becomes an output point\n      anythingToPoints(numPoints, cellPts) {\n        return numPoints;\n      },\n\n      linesToWireframe(numPoints, cellPts) {\n        if (numPoints > 1) {\n          return (numPoints - 1) * 2;\n        }\n\n        return 0;\n      },\n\n      polysToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 2;\n        }\n\n        return 0;\n      },\n\n      stripsToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 4 - 6;\n        }\n\n        return 0;\n      },\n\n      polysToSurface(npts, cellPts) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n\n        return 0;\n      },\n\n      stripsToSurface(npts, cellPts, offset) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n\n        return 0;\n      }\n\n    };\n    let func = null;\n    let countFunc = null;\n\n    if (outRep === Representation.POINTS || inRep === 'verts') {\n      func = cellBuilders.anythingToPoints;\n      countFunc = cellCounters.anythingToPoints;\n    } else if (outRep === Representation.WIREFRAME || inRep === 'lines') {\n      func = cellBuilders[`${inRep}ToWireframe`];\n      countFunc = cellCounters[`${inRep}ToWireframe`];\n    } else {\n      func = cellBuilders[`${inRep}ToSurface`];\n      countFunc = cellCounters[`${inRep}ToSurface`];\n    }\n\n    const array = cellArray.getData();\n    const size = array.length;\n    let caboCount = 0;\n\n    for (let index = 0; index < size;) {\n      caboCount += countFunc(array[index], array);\n      index += array[index] + 1;\n    }\n\n    let packedUCVBO = null;\n    const packedVBO = new Float32Array(caboCount * model.blockSize);\n\n    if (colorData) {\n      packedUCVBO = new Uint8Array(caboCount * 4);\n    }\n\n    let vboidx = 0;\n    let ucidx = 0; // Find out if shift scale should be used\n    // Compute squares of diagonal size and distance from the origin\n\n    let diagSq = 0.0;\n    let distSq = 0.0;\n\n    for (let i = 0; i < 3; ++i) {\n      const range = options.points.getRange(i);\n      const delta = range[1] - range[0];\n      diagSq += delta * delta;\n      const distShift = 0.5 * (range[1] + range[0]);\n      distSq += distShift * distShift;\n    }\n\n    const useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1.0e6 || // If data is far from the origin relative to its size\n    Math.abs(Math.log10(diagSq)) > 3.0 || // If the size is huge when not far from the origin\n    diagSq === 0 && distSq > 1.0e6); // If data is a point, but far from the origin\n\n    if (useShiftAndScale) {\n      // Compute shift and scale vectors\n      const coordShift = new Float64Array(3);\n      const coordScale = new Float64Array(3);\n\n      for (let i = 0; i < 3; ++i) {\n        const range = options.points.getRange(i);\n        const delta = range[1] - range[0];\n        coordShift[i] = 0.5 * (range[1] + range[0]);\n        coordScale[i] = delta > 0 ? 1.0 / delta : 1.0;\n      }\n\n      publicAPI.setCoordShiftAndScale(coordShift, coordScale);\n    } else if (model.coordShiftAndScaleEnabled === true) {\n      // Make sure to reset\n      publicAPI.setCoordShiftAndScale(null, null);\n    } // Initialize the structures used to keep track of point ids and cell ids for selectors\n\n\n    if (selectionMaps) {\n      if (!selectionMaps.points && !selectionMaps.cells) {\n        selectionMaps.points = new Int32Array(caboCount);\n        selectionMaps.cells = new Int32Array(caboCount);\n      } else {\n        const newPoints = new Int32Array(caboCount + selectionMaps.points.length);\n        newPoints.set(selectionMaps.points);\n        selectionMaps.points = newPoints;\n        const newCells = new Int32Array(caboCount + selectionMaps.points.length);\n        newCells.set(selectionMaps.cells);\n        selectionMaps.cells = newCells;\n      }\n    }\n\n    let pointCount = options.vertexOffset;\n\n    addAPoint = function addAPointFunc(i) {\n      // Keep track of original point and cell ids, for selection\n      if (selectionMaps) {\n        selectionMaps.points[pointCount] = i;\n        selectionMaps.cells[pointCount] = cellCount;\n      }\n\n      ++pointCount; // Vertices\n\n      pointIdx = i * 3;\n\n      if (!model.coordShiftAndScaleEnabled) {\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n      } else {\n        // Apply shift and scale\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];\n      }\n\n      if (normalData !== null) {\n        if (options.haveCellNormals) {\n          normalIdx = (cellCount + options.cellOffset) * 3;\n        } else {\n          normalIdx = i * 3;\n        }\n\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n      }\n\n      model.customData.forEach(attr => {\n        custIdx = i * attr.components;\n\n        for (let j = 0; j < attr.components; ++j) {\n          packedVBO[vboidx++] = attr.data[custIdx++];\n        }\n      });\n\n      if (tcoordData !== null) {\n        tcoordIdx = i * textureComponents;\n\n        for (let j = 0; j < textureComponents; ++j) {\n          packedVBO[vboidx++] = tcoordData[tcoordIdx++];\n        }\n      }\n\n      if (colorData !== null) {\n        if (options.haveCellScalars) {\n          colorIdx = (cellCount + options.cellOffset) * colorComponents;\n        } else {\n          colorIdx = i * colorComponents;\n        }\n\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;\n      }\n    };\n\n    for (let index = 0; index < size;) {\n      func(array[index], array, index + 1);\n      index += array[index] + 1;\n      cellCount++;\n    }\n\n    model.elementCount = caboCount;\n    publicAPI.upload(packedVBO, ObjectType.ARRAY_BUFFER);\n\n    if (model.colorBO) {\n      model.colorBOStride = 4;\n      model.colorBO.upload(packedUCVBO, ObjectType.ARRAY_BUFFER);\n    }\n\n    return cellCount;\n  };\n\n  publicAPI.setCoordShiftAndScale = (coordShift, coordScale) => {\n    if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {\n      vtkErrorMacro('Wrong type for coordShift, expected vec3 or null');\n      return;\n    }\n\n    if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {\n      vtkErrorMacro('Wrong type for coordScale, expected vec3 or null');\n      return;\n    }\n\n    if (model.coordShift === null || coordShift === null || !vec3.equals(coordShift, model.coordShift)) {\n      model.coordShift = coordShift;\n    }\n\n    if (model.coordScale === null || coordScale === null || !vec3.equals(coordScale, model.coordScale)) {\n      model.coordScale = coordScale;\n    }\n\n    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);\n\n    if (model.coordShiftAndScaleEnabled) {\n      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);\n    } else {\n      model.inverseShiftAndScaleMatrix = null;\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  elementCount: 0,\n  stride: 0,\n  colorBOStride: 0,\n  vertexOffset: 0,\n  normalOffset: 0,\n  tCoordOffset: 0,\n  tCoordComponents: 0,\n  colorOffset: 0,\n  colorComponents: 0,\n  tcoordBO: null,\n  customData: [],\n  coordShift: null,\n  coordScale: null,\n  coordShiftAndScaleEnabled: false,\n  inverseShiftAndScaleMatrix: null\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkBufferObject.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['colorBO', 'elementCount', 'stride', 'colorBOStride', 'vertexOffset', 'normalOffset', 'tCoordOffset', 'tCoordComponents', 'colorOffset', 'colorComponents', 'customData']);\n  macro.get(publicAPI, model, ['coordShift', 'coordScale', 'coordShiftAndScaleEnabled', 'inverseShiftAndScaleMatrix']); // Object specific methods\n\n  vtkOpenGLCellArrayBufferObject(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["mat4","quat","vec3","macro","vtkBufferObject","ObjectType","Representation","vtkErrorMacro","computeInverseShiftAndScaleMatrix","coordShift","coordScale","inverseScale","Float64Array","inverse","matrix","fromRotationTranslationScale","create","shouldApplyCoordShiftAndScale","exactEquals","vtkOpenGLCellArrayBufferObject","publicAPI","model","classHierarchy","push","setType","ARRAY_BUFFER","createVBO","cellArray","inRep","outRep","options","selectionMaps","getData","length","elementCount","blockSize","vertexOffset","normalOffset","tCoordOffset","tCoordComponents","colorComponents","colorOffset","customData","pointData","points","normalData","tcoordData","colorData","colors","getNumberOfComponents","textureComponents","tcoords","normals","customAttributes","forEach","a","data","offset","components","name","getName","colorBO","newInstance","setOpenGLRenderWindow","_openGLRenderWindow","stride","pointIdx","normalIdx","tcoordIdx","colorIdx","custIdx","cellCount","addAPoint","cellBuilders","anythingToPoints","numPoints","cellPts","i","linesToWireframe","polysToWireframe","stripsToWireframe","polysToSurface","npts","stripsToSurface","cellCounters","func","countFunc","POINTS","WIREFRAME","array","size","caboCount","index","packedUCVBO","packedVBO","Float32Array","Uint8Array","vboidx","ucidx","diagSq","distSq","range","getRange","delta","distShift","useShiftAndScale","Math","abs","log10","setCoordShiftAndScale","coordShiftAndScaleEnabled","cells","Int32Array","newPoints","set","newCells","pointCount","addAPointFunc","haveCellNormals","cellOffset","attr","j","haveCellScalars","upload","colorBOStride","constructor","equals","inverseShiftAndScaleMatrix","DEFAULT_VALUES","tcoordBO","extend","initialValues","Object","assign","setGet","get"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/OpenGL/CellArrayBufferObject/index.js"],"sourcesContent":["import { mat4, quat, vec3 } from 'gl-matrix';\n\nimport macro from 'vtk.js/Sources/macros';\nimport vtkBufferObject from 'vtk.js/Sources/Rendering/OpenGL/BufferObject';\nimport { ObjectType } from 'vtk.js/Sources/Rendering/OpenGL/BufferObject/Constants';\nimport { Representation } from 'vtk.js/Sources/Rendering/Core/Property/Constants';\n\nconst { vtkErrorMacro } = macro;\n\n// ----------------------------------------------------------------------------\n// Static functions\n// ----------------------------------------------------------------------------\n\nfunction computeInverseShiftAndScaleMatrix(coordShift, coordScale) {\n  const inverseScale = new Float64Array(3);\n  vec3.inverse(inverseScale, coordScale);\n\n  const matrix = new Float64Array(16);\n  mat4.fromRotationTranslationScale(\n    matrix,\n    quat.create(),\n    coordShift,\n    inverseScale\n  );\n\n  return matrix;\n}\n\nfunction shouldApplyCoordShiftAndScale(coordShift, coordScale) {\n  if (coordShift === null || coordScale === null) {\n    return false;\n  }\n\n  return !(\n    vec3.exactEquals(coordShift, [0, 0, 0]) &&\n    vec3.exactEquals(coordScale, [1, 1, 1])\n  );\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLCellArrayBufferObject methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLCellArrayBufferObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLCellArrayBufferObject');\n\n  publicAPI.setType(ObjectType.ARRAY_BUFFER);\n\n  publicAPI.createVBO = (\n    cellArray,\n    inRep,\n    outRep,\n    options,\n    selectionMaps = null\n  ) => {\n    if (!cellArray.getData() || !cellArray.getData().length) {\n      model.elementCount = 0;\n      return 0;\n    }\n\n    // Figure out how big each block will be, currently 6 or 7 floats.\n    model.blockSize = 3;\n    model.vertexOffset = 0;\n    model.normalOffset = 0;\n    model.tCoordOffset = 0;\n    model.tCoordComponents = 0;\n    model.colorComponents = 0;\n    model.colorOffset = 0;\n    model.customData = [];\n\n    const pointData = options.points.getData();\n    let normalData = null;\n    let tcoordData = null;\n    let colorData = null;\n\n    const colorComponents = options.colors\n      ? options.colors.getNumberOfComponents()\n      : 0;\n    const textureComponents = options.tcoords\n      ? options.tcoords.getNumberOfComponents()\n      : 0;\n\n    // the values of 4 below are because floats are 4 bytes\n\n    if (options.normals) {\n      model.normalOffset = 4 * model.blockSize;\n      model.blockSize += 3;\n      normalData = options.normals.getData();\n    }\n\n    if (options.customAttributes) {\n      options.customAttributes.forEach((a) => {\n        if (a) {\n          model.customData.push({\n            data: a.getData(),\n            offset: 4 * model.blockSize,\n            components: a.getNumberOfComponents(),\n            name: a.getName(),\n          });\n          model.blockSize += a.getNumberOfComponents();\n        }\n      });\n    }\n\n    if (options.tcoords) {\n      model.tCoordOffset = 4 * model.blockSize;\n      model.tCoordComponents = textureComponents;\n      model.blockSize += textureComponents;\n      tcoordData = options.tcoords.getData();\n    }\n\n    if (options.colors) {\n      model.colorComponents = options.colors.getNumberOfComponents();\n      model.colorOffset = 0;\n      colorData = options.colors.getData();\n      if (!model.colorBO) {\n        model.colorBO = vtkBufferObject.newInstance();\n      }\n      model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);\n    } else {\n      model.colorBO = null;\n    }\n    model.stride = 4 * model.blockSize;\n\n    let pointIdx = 0;\n    let normalIdx = 0;\n    let tcoordIdx = 0;\n    let colorIdx = 0;\n    let custIdx = 0;\n    let cellCount = 0;\n    let addAPoint;\n\n    const cellBuilders = {\n      // easy, every input point becomes an output point\n      anythingToPoints(numPoints, cellPts, offset) {\n        for (let i = 0; i < numPoints; ++i) {\n          addAPoint(cellPts[offset + i]);\n        }\n      },\n      linesToWireframe(numPoints, cellPts, offset) {\n        // for lines we add a bunch of segments\n        for (let i = 0; i < numPoints - 1; ++i) {\n          addAPoint(cellPts[offset + i]);\n          addAPoint(cellPts[offset + i + 1]);\n        }\n      },\n      polysToWireframe(numPoints, cellPts, offset) {\n        // for polys we add a bunch of segments and close it\n        if (numPoints > 2) {\n          for (let i = 0; i < numPoints; ++i) {\n            addAPoint(cellPts[offset + i]);\n            addAPoint(cellPts[offset + ((i + 1) % numPoints)]);\n          }\n        }\n      },\n      stripsToWireframe(numPoints, cellPts, offset) {\n        if (numPoints > 2) {\n          // for strips we add a bunch of segments and close it\n          for (let i = 0; i < numPoints - 1; ++i) {\n            addAPoint(cellPts[offset + i]);\n            addAPoint(cellPts[offset + i + 1]);\n          }\n          for (let i = 0; i < numPoints - 2; i++) {\n            addAPoint(cellPts[offset + i]);\n            addAPoint(cellPts[offset + i + 2]);\n          }\n        }\n      },\n      polysToSurface(npts, cellPts, offset) {\n        for (let i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + 0]);\n          addAPoint(cellPts[offset + i + 1]);\n          addAPoint(cellPts[offset + i + 2]);\n        }\n      },\n      stripsToSurface(npts, cellPts, offset) {\n        for (let i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + i]);\n          addAPoint(cellPts[offset + i + 1 + (i % 2)]);\n          addAPoint(cellPts[offset + i + 1 + ((i + 1) % 2)]);\n        }\n      },\n    };\n\n    const cellCounters = {\n      // easy, every input point becomes an output point\n      anythingToPoints(numPoints, cellPts) {\n        return numPoints;\n      },\n      linesToWireframe(numPoints, cellPts) {\n        if (numPoints > 1) {\n          return (numPoints - 1) * 2;\n        }\n        return 0;\n      },\n      polysToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 2;\n        }\n        return 0;\n      },\n      stripsToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 4 - 6;\n        }\n        return 0;\n      },\n      polysToSurface(npts, cellPts) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n        return 0;\n      },\n      stripsToSurface(npts, cellPts, offset) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n        return 0;\n      },\n    };\n\n    let func = null;\n    let countFunc = null;\n    if (outRep === Representation.POINTS || inRep === 'verts') {\n      func = cellBuilders.anythingToPoints;\n      countFunc = cellCounters.anythingToPoints;\n    } else if (outRep === Representation.WIREFRAME || inRep === 'lines') {\n      func = cellBuilders[`${inRep}ToWireframe`];\n      countFunc = cellCounters[`${inRep}ToWireframe`];\n    } else {\n      func = cellBuilders[`${inRep}ToSurface`];\n      countFunc = cellCounters[`${inRep}ToSurface`];\n    }\n\n    const array = cellArray.getData();\n    const size = array.length;\n    let caboCount = 0;\n    for (let index = 0; index < size; ) {\n      caboCount += countFunc(array[index], array);\n      index += array[index] + 1;\n    }\n\n    let packedUCVBO = null;\n    const packedVBO = new Float32Array(caboCount * model.blockSize);\n    if (colorData) {\n      packedUCVBO = new Uint8Array(caboCount * 4);\n    }\n    let vboidx = 0;\n    let ucidx = 0;\n\n    // Find out if shift scale should be used\n    // Compute squares of diagonal size and distance from the origin\n    let diagSq = 0.0;\n    let distSq = 0.0;\n    for (let i = 0; i < 3; ++i) {\n      const range = options.points.getRange(i);\n\n      const delta = range[1] - range[0];\n      diagSq += delta * delta;\n\n      const distShift = 0.5 * (range[1] + range[0]);\n      distSq += distShift * distShift;\n    }\n\n    const useShiftAndScale =\n      diagSq > 0 &&\n      (Math.abs(distSq) / diagSq > 1.0e6 || // If data is far from the origin relative to its size\n        Math.abs(Math.log10(diagSq)) > 3.0 || // If the size is huge when not far from the origin\n        (diagSq === 0 && distSq > 1.0e6)); // If data is a point, but far from the origin\n\n    if (useShiftAndScale) {\n      // Compute shift and scale vectors\n      const coordShift = new Float64Array(3);\n      const coordScale = new Float64Array(3);\n      for (let i = 0; i < 3; ++i) {\n        const range = options.points.getRange(i);\n        const delta = range[1] - range[0];\n\n        coordShift[i] = 0.5 * (range[1] + range[0]);\n        coordScale[i] = delta > 0 ? 1.0 / delta : 1.0;\n      }\n      publicAPI.setCoordShiftAndScale(coordShift, coordScale);\n    } else if (model.coordShiftAndScaleEnabled === true) {\n      // Make sure to reset\n      publicAPI.setCoordShiftAndScale(null, null);\n    }\n\n    // Initialize the structures used to keep track of point ids and cell ids for selectors\n    if (selectionMaps) {\n      if (!selectionMaps.points && !selectionMaps.cells) {\n        selectionMaps.points = new Int32Array(caboCount);\n        selectionMaps.cells = new Int32Array(caboCount);\n      } else {\n        const newPoints = new Int32Array(\n          caboCount + selectionMaps.points.length\n        );\n        newPoints.set(selectionMaps.points);\n        selectionMaps.points = newPoints;\n        const newCells = new Int32Array(\n          caboCount + selectionMaps.points.length\n        );\n        newCells.set(selectionMaps.cells);\n        selectionMaps.cells = newCells;\n      }\n    }\n\n    let pointCount = options.vertexOffset;\n    addAPoint = function addAPointFunc(i) {\n      // Keep track of original point and cell ids, for selection\n      if (selectionMaps) {\n        selectionMaps.points[pointCount] = i;\n        selectionMaps.cells[pointCount] = cellCount;\n      }\n      ++pointCount;\n\n      // Vertices\n      pointIdx = i * 3;\n\n      if (!model.coordShiftAndScaleEnabled) {\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n      } else {\n        // Apply shift and scale\n        packedVBO[vboidx++] =\n          (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];\n        packedVBO[vboidx++] =\n          (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];\n        packedVBO[vboidx++] =\n          (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];\n      }\n\n      if (normalData !== null) {\n        if (options.haveCellNormals) {\n          normalIdx = (cellCount + options.cellOffset) * 3;\n        } else {\n          normalIdx = i * 3;\n        }\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n      }\n\n      model.customData.forEach((attr) => {\n        custIdx = i * attr.components;\n        for (let j = 0; j < attr.components; ++j) {\n          packedVBO[vboidx++] = attr.data[custIdx++];\n        }\n      });\n\n      if (tcoordData !== null) {\n        tcoordIdx = i * textureComponents;\n        for (let j = 0; j < textureComponents; ++j) {\n          packedVBO[vboidx++] = tcoordData[tcoordIdx++];\n        }\n      }\n\n      if (colorData !== null) {\n        if (options.haveCellScalars) {\n          colorIdx = (cellCount + options.cellOffset) * colorComponents;\n        } else {\n          colorIdx = i * colorComponents;\n        }\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] =\n          colorComponents === 4 ? colorData[colorIdx++] : 255;\n      }\n    };\n\n    for (let index = 0; index < size; ) {\n      func(array[index], array, index + 1);\n      index += array[index] + 1;\n      cellCount++;\n    }\n    model.elementCount = caboCount;\n    publicAPI.upload(packedVBO, ObjectType.ARRAY_BUFFER);\n    if (model.colorBO) {\n      model.colorBOStride = 4;\n      model.colorBO.upload(packedUCVBO, ObjectType.ARRAY_BUFFER);\n    }\n    return cellCount;\n  };\n\n  publicAPI.setCoordShiftAndScale = (coordShift, coordScale) => {\n    if (\n      coordShift !== null &&\n      (coordShift.constructor !== Float64Array || coordShift.length !== 3)\n    ) {\n      vtkErrorMacro('Wrong type for coordShift, expected vec3 or null');\n      return;\n    }\n\n    if (\n      coordScale !== null &&\n      (coordScale.constructor !== Float64Array || coordScale.length !== 3)\n    ) {\n      vtkErrorMacro('Wrong type for coordScale, expected vec3 or null');\n      return;\n    }\n\n    if (\n      model.coordShift === null ||\n      coordShift === null ||\n      !vec3.equals(coordShift, model.coordShift)\n    ) {\n      model.coordShift = coordShift;\n    }\n\n    if (\n      model.coordScale === null ||\n      coordScale === null ||\n      !vec3.equals(coordScale, model.coordScale)\n    ) {\n      model.coordScale = coordScale;\n    }\n\n    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(\n      model.coordShift,\n      model.coordScale\n    );\n\n    if (model.coordShiftAndScaleEnabled) {\n      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(\n        model.coordShift,\n        model.coordScale\n      );\n    } else {\n      model.inverseShiftAndScaleMatrix = null;\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  elementCount: 0,\n  stride: 0,\n  colorBOStride: 0,\n  vertexOffset: 0,\n  normalOffset: 0,\n  tCoordOffset: 0,\n  tCoordComponents: 0,\n  colorOffset: 0,\n  colorComponents: 0,\n  tcoordBO: null,\n  customData: [],\n  coordShift: null,\n  coordScale: null,\n  coordShiftAndScaleEnabled: false,\n  inverseShiftAndScaleMatrix: null,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkBufferObject.extend(publicAPI, model, initialValues);\n\n  macro.setGet(publicAPI, model, [\n    'colorBO',\n    'elementCount',\n    'stride',\n    'colorBOStride',\n    'vertexOffset',\n    'normalOffset',\n    'tCoordOffset',\n    'tCoordComponents',\n    'colorOffset',\n    'colorComponents',\n    'customData',\n  ]);\n\n  macro.get(publicAPI, model, [\n    'coordShift',\n    'coordScale',\n    'coordShiftAndScaleEnabled',\n    'inverseShiftAndScaleMatrix',\n  ]);\n\n  // Object specific methods\n  vtkOpenGLCellArrayBufferObject(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}