{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport { mat4 } from 'gl-matrix';\nimport vtkWebGPUFullScreenQuad from 'vtk.js/Sources/Rendering/WebGPU/FullScreenQuad';\nimport vtkWebGPUUniformBuffer from 'vtk.js/Sources/Rendering/WebGPU/UniformBuffer';\nimport vtkWebGPUShaderCache from 'vtk.js/Sources/Rendering/WebGPU/ShaderCache';\nimport vtkWebGPUStorageBuffer from 'vtk.js/Sources/Rendering/WebGPU/StorageBuffer';\nimport vtkWebGPUSampler from 'vtk.js/Sources/Rendering/WebGPU/Sampler';\nimport vtkWebGPUTypes from 'vtk.js/Sources/Rendering/WebGPU/Types';\nimport { BlendMode } from 'vtk.js/Sources/Rendering/Core/VolumeMapper/Constants';\nconst volFragTemplate = `\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Volume::TraverseDec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\n{\n  // todo multicomponent support\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\n}\n\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\n{\n  var result: vec4<f32>;\n\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\n  result.w = 0.0;\n\n  // divide by spacing as that is our delta\n  result = result / volumeSSBO.values[vNum].spacing;\n  // now we have a gradient in unit tcoords\n\n  var grad: f32 = length(result.xyz);\n  if (grad > 0.0)\n  {\n    // rotate to View Coords, needed for lighting and shading\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\n    result = nMat * result;\n    result = result / length(result);\n  }\n\n  // store gradient magnitude in .w\n  result.w = grad;\n\n  return result;\n}\n\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\n{\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  // convert to tcoords and reject if outside the volume\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\n\n  var scalar: f32 = getTextureValue(vTex, tpos);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n\n  var gofactor: f32 = 1.0;\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    normal = getGradient(vTex, tpos, vNum, scalar);\n    if (componentSSBO.values[cNum].gomin <  1.0)\n    {\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\n    }\n  }\n\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    color = color*abs(normal.z);\n  }\n\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\n\n  return outColor;\n}\n\n// adjust the start and end point of a raycast such that it intersects the unit cube.\n// This function is used to take a raycast starting point and step vector\n// and numSteps and return the startijng and ending steps for intersecting the\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\n// and bound it to intersecting the texture.\n//\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\n{\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\n\n  // move tpos to the start of the volume\n  var adjust: f32 =\n    min(\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\n      min(\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\n  if (adjust < 0.0)\n  {\n    result.x = result.x - adjust;\n  }\n\n  // adjust length to the end\n  adjust =\n    max(\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\n      max(\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\n  if (adjust > 0.0)\n  {\n    result.y = result.y - adjust;\n  }\n\n  return result;\n}\n\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\n{\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n  return vec4<f32>(color.rgb, opacity);\n}\n\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var maxVal: f32 = -1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar > maxVal)\n    {\n      maxVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\n}\n\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var minVal: f32 = 1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar < minVal)\n    {\n      minVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\n}\n\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var avgVal: f32 = 0.0;\n  var sampleCount: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      avgVal = avgVal + sample;\n      sampleCount = sampleCount + 1.0;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  if (sampleCount <= 0.0)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\n}\n\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var sumVal: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      sumVal = sumVal + sample;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\n}\n\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\n{\n  // initial ray position is at the beginning\n  var rayPosSC: vec4<f32> = minPosSC;\n\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var curDist: f32 = 0.0;\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  var sampleColor: vec4<f32>;\n//VTK::Volume::TraverseCalls\n\n  loop\n  {\n    // for each volume, sample and accumulate color\n//VTK::Volume::CompositeCalls\n\n    // increment position\n    curDist = curDist + mapperUBO.SampleDistance;\n    rayPosSC = rayPosSC + rayStepSC;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayLengthSC) { break; }\n    if (computedColor.a > 0.98) { break; }\n  }\n  return computedColor;\n}\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\n\n  // discard empty rays\n  if (rayMax <= rayMin) { discard; }\n  else\n  {\n    // compute start and end ray positions in view coordinates\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\n\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\n    rayStepSC.w = 0.0;\n\n    var computedColor: vec4<f32>;\n\n//VTK::Volume::Loop\n\n//VTK::RenderEncoder::Impl\n  }\n\n  return output;\n}\n`;\nconst tmpMat4 = new Float64Array(16);\nconst tmp2Mat4 = new Float64Array(16); // ----------------------------------------------------------------------------\n// vtkWebGPUVolumePassFSQ methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUVolumePassFSQ(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUVolumePassFSQ');\n\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);', 'output.Position = vec4<f32>(vertexBC, 1.0);']).result;\n    vDesc.setCode(code);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinInput('vec4<f32>', '@builtin(position) fragPos');\n  };\n\n  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n\n  publicAPI.replaceShaderVolume = (hash, pipeline, vertexInput) => {\n    const fDesc = pipeline.getShaderDescription('fragment');\n    let code = fDesc.getCode();\n    const compositeCalls = [];\n    const traverseCalls = [];\n\n    for (let i = 0; i < model.volumes.length; i++) {\n      // todo pass rowPos\n      const blendMode = model.volumes[i].getRenderable().getMapper().getBlendMode();\n\n      if (blendMode === BlendMode.COMPOSITE_BLEND) {\n        compositeCalls.push(`    sampleColor = processVolume(volTexture${i}, ${i}, ${model.rowStarts[i]}, rayPosSC, tfunRows);`);\n        compositeCalls.push(`    computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);`);\n      } else {\n        traverseCalls.push(`  sampleColor = traverseVals[${i}];`);\n        traverseCalls.push(`  computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);`);\n      }\n    }\n\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::CompositeCalls', compositeCalls).result;\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::TraverseCalls', traverseCalls).result;\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::TraverseDec', [`var<private> traverseVals: array<vec4<f32>,${model.volumes.length}>;`]).result; // call the full and partial methods as needed\n\n    let compositeWhileTraversing = false;\n\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();\n\n      if (blendMode === BlendMode.COMPOSITE_BLEND) {\n        compositeWhileTraversing = true;\n      } else if (blendMode === BlendMode.MAXIMUM_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [`    traverseMax(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, '//VTK::Volume::Loop']).result;\n      } else if (blendMode === BlendMode.MINIMUM_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [`    traverseMin(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, '//VTK::Volume::Loop']).result;\n      } else if (blendMode === BlendMode.AVERAGE_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [`    traverseAverage(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, '//VTK::Volume::Loop']).result;\n      } else if (blendMode === BlendMode.ADDITIVE_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [`    traverseAdditive(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, '//VTK::Volume::Loop']).result;\n      }\n    }\n\n    if (compositeWhileTraversing) {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', ['    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);']).result;\n    }\n\n    fDesc.setCode(code);\n  };\n\n  model.shaderReplacements.set('replaceShaderVolume', publicAPI.replaceShaderVolume);\n\n  publicAPI.updateLUTImage = device => {\n    // depends on\n    // - volumes array (length and values) - mtime\n    // - tfun arrays - renderable/property mtime\n    let mtime = publicAPI.getMTime();\n\n    for (let i = 0; i < model.volumes.length; i++) {\n      const vol = model.volumes[i].getRenderable();\n      const image = vol.getMapper().getInputData();\n      mtime = Math.max(mtime, vol.getMTime(), image.getMTime());\n    }\n\n    if (mtime < model.lutBuildTime.getMTime()) {\n      return;\n    } // first determine how large the image should be\n\n\n    model.numRows = 0;\n    model.rowStarts = [];\n\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      model.rowStarts.push(model.numRows);\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const vprop = actor.getProperty();\n      const image = volMapr.getInputData();\n      const scalars = image.getPointData() && image.getPointData().getScalars();\n      const numComp = scalars.getNumberOfComponents();\n      const iComps = vprop.getIndependentComponents();\n      const numIComps = iComps ? numComp : 1;\n      model.numRows += numIComps;\n    } // allocate the image array\n\n\n    const colorArray = new Uint8Array(model.numRows * 2 * model.rowLength * 4);\n    const opacityArray = new Float32Array(model.numRows * 2 * model.rowLength);\n    let imgRow = 0;\n    const tmpTable = new Float32Array(model.rowLength * 3);\n    const rowLength = model.rowLength;\n\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const vprop = actor.getProperty();\n      const image = volMapr.getInputData();\n      const scalars = image.getPointData() && image.getPointData().getScalars();\n      const numComp = scalars.getNumberOfComponents();\n      const iComps = vprop.getIndependentComponents();\n      const numIComps = iComps ? numComp : 1;\n\n      for (let c = 0; c < numIComps; ++c) {\n        const cfun = vprop.getRGBTransferFunction(c);\n        const cRange = cfun.getRange();\n        cfun.getTable(cRange[0], cRange[1], rowLength, tmpTable, 1);\n        let ioffset = imgRow * rowLength * 4;\n\n        for (let i = 0; i < rowLength; ++i) {\n          colorArray[ioffset + i * 4] = 255.0 * tmpTable[i * 3];\n          colorArray[ioffset + i * 4 + 1] = 255.0 * tmpTable[i * 3 + 1];\n          colorArray[ioffset + i * 4 + 2] = 255.0 * tmpTable[i * 3 + 2];\n          colorArray[ioffset + i * 4 + 3] = 255.0;\n\n          for (let co = 0; co < 4; co++) {\n            colorArray[ioffset + (rowLength + i) * 4 + co] = colorArray[ioffset + i * 4 + co];\n          }\n        }\n\n        const ofun = vprop.getScalarOpacity(c);\n        const opacityFactor = model.sampleDist / vprop.getScalarOpacityUnitDistance(c);\n        const oRange = ofun.getRange();\n        ofun.getTable(oRange[0], oRange[1], rowLength, tmpTable, 1); // adjust for sample distance etc\n\n        ioffset = imgRow * rowLength;\n\n        for (let i = 0; i < rowLength; ++i) {\n          opacityArray[ioffset + i] = 1.0 - (1.0 - tmpTable[i]) ** opacityFactor;\n          opacityArray[ioffset + i + rowLength] = opacityArray[ioffset + i];\n        }\n\n        imgRow += 2;\n      }\n    }\n\n    {\n      const treq = {\n        nativeArray: colorArray,\n        width: model.rowLength,\n        height: model.numRows * 2,\n        depth: 1,\n        format: 'rgba8unorm'\n      };\n      const newTex = device.getTextureManager().getTexture(treq);\n      const tview = newTex.createView('tfunTexture');\n      model.textureViews[2] = tview;\n    }\n    {\n      const treq = {\n        nativeArray: opacityArray,\n        width: model.rowLength,\n        height: model.numRows * 2,\n        depth: 1,\n        format: 'r16float'\n      };\n      const newTex = device.getTextureManager().getTexture(treq);\n      const tview = newTex.createView('ofunTexture');\n      model.textureViews[3] = tview;\n    }\n    model.lutBuildTime.modified();\n  };\n\n  publicAPI.updateSSBO = device => {\n    // if any of\n    // - color or opacity tfun ranges changed - volume Mtime\n    // - any volume matrix changed - volume MTime\n    // - stabilized center changed - ren.stabilizedMTime\n    // - any volume's input data worldtoindex or dimensions changed - input's mtime\n    //\n    let mtime = Math.max(publicAPI.getMTime(), model.WebGPURenderer.getStabilizedTime());\n\n    for (let i = 0; i < model.volumes.length; i++) {\n      const vol = model.volumes[i].getRenderable();\n      const volMapr = vol.getMapper();\n      const image = volMapr.getInputData();\n      mtime = Math.max(mtime, vol.getMTime(), image.getMTime(), volMapr.getMTime());\n    }\n\n    if (mtime < model.SSBO.getSendTime()) {\n      return;\n    } // create the volumeSBBO\n\n\n    const center = model.WebGPURenderer.getStabilizedCenterByReference();\n    model.SSBO.clearData();\n    model.SSBO.setNumberOfInstances(model.volumes.length); // create SCTC matrices  SC -> world -> model -> index -> tcoord\n    //\n    // when doing coord conversions from A to C recall\n    // the order is mat4.mult(AtoC, BtoC, AtoB);\n    //\n\n    const marray = new Float64Array(model.volumes.length * 16);\n    const vPlaneArray = new Float64Array(model.volumes.length * 16);\n    const tstepArray = new Float64Array(model.volumes.length * 4);\n    const shadeArray = new Float64Array(model.volumes.length * 4);\n    const spacingArray = new Float64Array(model.volumes.length * 4);\n    const ipScalarRangeArray = new Float64Array(model.volumes.length * 4);\n\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const image = volMapr.getInputData();\n      mat4.identity(tmpMat4);\n      mat4.translate(tmpMat4, tmpMat4, center); // tmpMat4 is now SC->World\n\n      const mcwcmat = actor.getMatrix();\n      mat4.transpose(tmp2Mat4, mcwcmat);\n      mat4.invert(tmp2Mat4, tmp2Mat4); // tmp2Mat4 is now world to model\n\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4); // tmp4Mat is now SC->Model\n      // the method on the data is world to index but the volume is in\n      // model coordinates so really in this context it is model to index\n\n      const modelToIndex = image.getWorldToIndex();\n      mat4.multiply(tmpMat4, modelToIndex, tmpMat4); // tmpMat4 is now SC -> Index\n\n      const dims = image.getDimensions();\n      mat4.identity(tmp2Mat4);\n      mat4.scale(tmp2Mat4, tmp2Mat4, [1.0 / dims[0], 1.0 / dims[1], 1.0 / dims[2]]);\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4); // tmpMat4 is now SC -> Tcoord\n\n      for (let j = 0; j < 16; j++) {\n        marray[vidx * 16 + j] = tmpMat4[j];\n      }\n\n      mat4.invert(tmpMat4, tmpMat4); // now it is Tcoord To SC\n\n      for (let j = 0; j < 4; j++) {\n        vPlaneArray[vidx * 16 + j * 4] = tmpMat4[j * 4];\n        vPlaneArray[vidx * 16 + j * 4 + 1] = tmpMat4[j * 4 + 1];\n        vPlaneArray[vidx * 16 + j * 4 + 2] = tmpMat4[j * 4 + 2];\n        vPlaneArray[vidx * 16 + j * 4 + 3] = 0.0;\n      }\n\n      tstepArray[vidx * 4] = 1.0 / dims[0];\n      tstepArray[vidx * 4 + 1] = 1.0 / dims[1];\n      tstepArray[vidx * 4 + 2] = 1.0 / dims[2];\n      tstepArray[vidx * 4 + 3] = 1.0;\n      shadeArray[vidx * 4] = actor.getProperty().getShade() ? 1.0 : 0.0;\n      const spacing = image.getSpacing();\n      spacingArray[vidx * 4] = spacing[0];\n      spacingArray[vidx * 4 + 1] = spacing[1];\n      spacingArray[vidx * 4 + 2] = spacing[2];\n      spacingArray[vidx * 4 + 3] = 1.0; // handle filteringMode\n\n      const tScale = model.textureViews[vidx + 4].getTexture().getScale();\n      const ipScalarRange = volMapr.getIpScalarRange();\n      ipScalarRangeArray[vidx * 4] = ipScalarRange[0] / tScale;\n      ipScalarRangeArray[vidx * 4 + 1] = ipScalarRange[1] / tScale;\n      ipScalarRangeArray[vidx * 4 + 2] = volMapr.getFilterMode();\n    }\n\n    model.SSBO.addEntry('SCTCMatrix', 'mat4x4<f32>');\n    model.SSBO.addEntry('planeNormals', 'mat4x4<f32>');\n    model.SSBO.addEntry('shade', 'vec4<f32>');\n    model.SSBO.addEntry('tstep', 'vec4<f32>');\n    model.SSBO.addEntry('spacing', 'vec4<f32>');\n    model.SSBO.addEntry('ipScalarRange', 'vec4<f32>');\n    model.SSBO.setAllInstancesFromArray('SCTCMatrix', marray);\n    model.SSBO.setAllInstancesFromArray('planeNormals', vPlaneArray);\n    model.SSBO.setAllInstancesFromArray('shade', shadeArray);\n    model.SSBO.setAllInstancesFromArray('tstep', tstepArray);\n    model.SSBO.setAllInstancesFromArray('spacing', spacingArray);\n    model.SSBO.setAllInstancesFromArray('ipScalarRange', ipScalarRangeArray);\n    model.SSBO.send(device); // now create the componentSSBO\n\n    model.componentSSBO.clearData();\n    model.componentSSBO.setNumberOfInstances(model.numRows);\n    const cScaleArray = new Float64Array(model.numRows);\n    const cShiftArray = new Float64Array(model.numRows);\n    const oScaleArray = new Float64Array(model.numRows);\n    const oShiftArray = new Float64Array(model.numRows);\n    const gominArray = new Float64Array(model.numRows);\n    const gomaxArray = new Float64Array(model.numRows);\n    const goshiftArray = new Float64Array(model.numRows);\n    const goscaleArray = new Float64Array(model.numRows);\n    let rowIdx = 0;\n\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const vprop = actor.getProperty();\n      const image = volMapr.getInputData();\n      const scalars = image.getPointData() && image.getPointData().getScalars();\n      const numComp = scalars.getNumberOfComponents();\n      const iComps = vprop.getIndependentComponents(); // const numIComps = iComps ? numComp : 1;\n      // half float?\n\n      const tformat = model.textureViews[vidx + 4].getTexture().getFormat();\n      const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(tformat);\n      const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === 'float';\n      const volInfo = {\n        scale: [255.0],\n        offset: [0.0]\n      };\n\n      if (halfFloat) {\n        volInfo.scale[0] = 1.0;\n      } // three levels of shift scale combined into one\n      // for performance in the fragment shader\n\n\n      for (let compIdx = 0; compIdx < numComp; compIdx++) {\n        const target = iComps ? compIdx : 0;\n        const sscale = volInfo.scale[compIdx];\n        const ofun = vprop.getScalarOpacity(target);\n        const oRange = ofun.getRange();\n        const oscale = sscale / (oRange[1] - oRange[0]);\n        const oshift = (volInfo.offset[compIdx] - oRange[0]) / (oRange[1] - oRange[0]);\n        oShiftArray[rowIdx] = oshift;\n        oScaleArray[rowIdx] = oscale;\n        const cfun = vprop.getRGBTransferFunction(target);\n        const cRange = cfun.getRange();\n        cShiftArray[rowIdx] = (volInfo.offset[compIdx] - cRange[0]) / (cRange[1] - cRange[0]);\n        cScaleArray[rowIdx] = sscale / (cRange[1] - cRange[0]); // todo sscale for dependent should be based off of the A channel?\n        // not target (which is 0 in that case)\n\n        const useGO = vprop.getUseGradientOpacity(target);\n\n        if (useGO) {\n          const gomin = vprop.getGradientOpacityMinimumOpacity(target);\n          const gomax = vprop.getGradientOpacityMaximumOpacity(target);\n          gominArray[rowIdx] = gomin;\n          gomaxArray[rowIdx] = gomax;\n          const goRange = [vprop.getGradientOpacityMinimumValue(target), vprop.getGradientOpacityMaximumValue(target)];\n          goscaleArray[rowIdx] = sscale * (gomax - gomin) / (goRange[1] - goRange[0]);\n          goshiftArray[rowIdx] = -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin;\n        } else {\n          gominArray[rowIdx] = 1.0;\n          gomaxArray[rowIdx] = 1.0;\n          goscaleArray[rowIdx] = 0.0;\n          goshiftArray[rowIdx] = 1.0;\n        }\n\n        rowIdx++;\n      }\n    }\n\n    model.componentSSBO.addEntry('cScale', 'f32');\n    model.componentSSBO.addEntry('cShift', 'f32');\n    model.componentSSBO.addEntry('oScale', 'f32');\n    model.componentSSBO.addEntry('oShift', 'f32');\n    model.componentSSBO.addEntry('goShift', 'f32');\n    model.componentSSBO.addEntry('goScale', 'f32');\n    model.componentSSBO.addEntry('gomin', 'f32');\n    model.componentSSBO.addEntry('gomax', 'f32');\n    model.componentSSBO.setAllInstancesFromArray('cScale', cScaleArray);\n    model.componentSSBO.setAllInstancesFromArray('cShift', cShiftArray);\n    model.componentSSBO.setAllInstancesFromArray('oScale', oScaleArray);\n    model.componentSSBO.setAllInstancesFromArray('oShift', oShiftArray);\n    model.componentSSBO.setAllInstancesFromArray('goScale', goscaleArray);\n    model.componentSSBO.setAllInstancesFromArray('goShift', goshiftArray);\n    model.componentSSBO.setAllInstancesFromArray('gomin', gominArray);\n    model.componentSSBO.setAllInstancesFromArray('gomax', gomaxArray);\n    model.componentSSBO.send(device);\n  };\n\n  const superClassUpdateBuffers = publicAPI.updateBuffers;\n\n  publicAPI.updateBuffers = () => {\n    superClassUpdateBuffers(); // compute the min step size\n\n    let sampleDist = model.volumes[0].getRenderable().getMapper().getSampleDistance();\n\n    for (let i = 0; i < model.volumes.length; i++) {\n      const vol = model.volumes[i];\n      const volMapr = vol.getRenderable().getMapper();\n      const sd = volMapr.getSampleDistance();\n\n      if (sd < sampleDist) {\n        sampleDist = sd;\n      }\n    }\n\n    if (model.sampleDist !== sampleDist) {\n      model.sampleDist = sampleDist;\n      model.UBO.setValue('SampleDistance', sampleDist);\n      model.UBO.sendIfNeeded(model.device);\n    } // add in 3d volume textures\n\n\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const image = volMapr.getInputData();\n      const newTex = model.device.getTextureManager().getTextureForImageData(image);\n\n      if (!model.textureViews[vidx + 4] || model.textureViews[vidx + 4].getTexture() !== newTex) {\n        const tview = newTex.createView(`volTexture${vidx}`);\n        model.textureViews[vidx + 4] = tview;\n      }\n    } // clear any old leftovers\n\n\n    if (model.volumes.length < model.lastVolumeLength) {\n      // we may have gaps in the array right now so no splice\n      for (let i = model.volumes.length; i < model.lastVolumeLength; i++) {\n        model.textureViews.pop();\n      }\n    }\n\n    model.lastVolumeLength = model.volumes.length;\n    publicAPI.updateLUTImage(model.device);\n    publicAPI.updateSSBO(model.device);\n\n    if (!model.clampSampler) {\n      model.clampSampler = vtkWebGPUSampler.newInstance({\n        label: 'clampSampler'\n      });\n      model.clampSampler.create(model.device, {\n        minFilter: 'linear',\n        magFilter: 'linear'\n      });\n    }\n  };\n\n  publicAPI.computePipelineHash = () => {\n    model.pipelineHash = 'volfsq';\n\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();\n      model.pipelineHash += `${blendMode}`;\n    }\n  }; // marks modified when needed\n\n\n  publicAPI.setVolumes = val => {\n    if (!model.volumes || model.volumes.length !== val.length) {\n      model.volumes = [...val];\n      publicAPI.modified();\n      return;\n    }\n\n    for (let i = 0; i < val.length; i++) {\n      if (val[i] !== model.volumes[i]) {\n        model.volumes = [...val];\n        publicAPI.modified();\n        return;\n      }\n    }\n  };\n\n  const superclassGetBindables = publicAPI.getBindables;\n\n  publicAPI.getBindables = () => {\n    const bindables = superclassGetBindables();\n    bindables.push(model.componentSSBO);\n    bindables.push(model.clampSampler);\n    return bindables;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  volumes: null,\n  rowLength: 1024,\n  lastVolumeLength: 0\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkWebGPUFullScreenQuad.extend(publicAPI, model, initialValues);\n  model.fragmentShaderTemplate = volFragTemplate;\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({\n    label: 'mapperUBO'\n  });\n  model.UBO.addEntry('SampleDistance', 'f32');\n  model.SSBO = vtkWebGPUStorageBuffer.newInstance({\n    label: 'volumeSSBO'\n  });\n  model.componentSSBO = vtkWebGPUStorageBuffer.newInstance({\n    label: 'componentSSBO'\n  });\n  model.lutBuildTime = {};\n  macro.obj(model.lutBuildTime, {\n    mtime: 0\n  }); // Object methods\n\n  vtkWebGPUVolumePassFSQ(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkWebGPUVolumePassFSQ'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["macro","mat4","vtkWebGPUFullScreenQuad","vtkWebGPUUniformBuffer","vtkWebGPUShaderCache","vtkWebGPUStorageBuffer","vtkWebGPUSampler","vtkWebGPUTypes","BlendMode","volFragTemplate","tmpMat4","Float64Array","tmp2Mat4","vtkWebGPUVolumePassFSQ","publicAPI","model","classHierarchy","push","replaceShaderPosition","hash","pipeline","vertexInput","vDesc","getShaderDescription","addBuiltinOutput","code","getCode","substitute","result","setCode","fDesc","addBuiltinInput","shaderReplacements","set","replaceShaderVolume","compositeCalls","traverseCalls","i","volumes","length","blendMode","getRenderable","getMapper","getBlendMode","COMPOSITE_BLEND","rowStarts","compositeWhileTraversing","vidx","MAXIMUM_INTENSITY_BLEND","MINIMUM_INTENSITY_BLEND","AVERAGE_INTENSITY_BLEND","ADDITIVE_INTENSITY_BLEND","updateLUTImage","device","mtime","getMTime","vol","image","getInputData","Math","max","lutBuildTime","numRows","webgpuvol","actor","volMapr","vprop","getProperty","scalars","getPointData","getScalars","numComp","getNumberOfComponents","iComps","getIndependentComponents","numIComps","colorArray","Uint8Array","rowLength","opacityArray","Float32Array","imgRow","tmpTable","c","cfun","getRGBTransferFunction","cRange","getRange","getTable","ioffset","co","ofun","getScalarOpacity","opacityFactor","sampleDist","getScalarOpacityUnitDistance","oRange","treq","nativeArray","width","height","depth","format","newTex","getTextureManager","getTexture","tview","createView","textureViews","modified","updateSSBO","WebGPURenderer","getStabilizedTime","SSBO","getSendTime","center","getStabilizedCenterByReference","clearData","setNumberOfInstances","marray","vPlaneArray","tstepArray","shadeArray","spacingArray","ipScalarRangeArray","identity","translate","mcwcmat","getMatrix","transpose","invert","multiply","modelToIndex","getWorldToIndex","dims","getDimensions","scale","j","getShade","spacing","getSpacing","tScale","getScale","ipScalarRange","getIpScalarRange","getFilterMode","addEntry","setAllInstancesFromArray","send","componentSSBO","cScaleArray","cShiftArray","oScaleArray","oShiftArray","gominArray","gomaxArray","goshiftArray","goscaleArray","rowIdx","tformat","getFormat","tDetails","getDetailsFromTextureFormat","halfFloat","elementSize","sampleType","volInfo","offset","compIdx","target","sscale","oscale","oshift","useGO","getUseGradientOpacity","gomin","getGradientOpacityMinimumOpacity","gomax","getGradientOpacityMaximumOpacity","goRange","getGradientOpacityMinimumValue","getGradientOpacityMaximumValue","superClassUpdateBuffers","updateBuffers","getSampleDistance","sd","UBO","setValue","sendIfNeeded","getTextureForImageData","lastVolumeLength","pop","clampSampler","newInstance","label","create","minFilter","magFilter","computePipelineHash","pipelineHash","setVolumes","val","superclassGetBindables","getBindables","bindables","DEFAULT_VALUES","extend","initialValues","Object","assign","fragmentShaderTemplate","obj"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/WebGPU/VolumePassFSQ/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport { mat4 } from 'gl-matrix';\nimport vtkWebGPUFullScreenQuad from 'vtk.js/Sources/Rendering/WebGPU/FullScreenQuad';\nimport vtkWebGPUUniformBuffer from 'vtk.js/Sources/Rendering/WebGPU/UniformBuffer';\nimport vtkWebGPUShaderCache from 'vtk.js/Sources/Rendering/WebGPU/ShaderCache';\nimport vtkWebGPUStorageBuffer from 'vtk.js/Sources/Rendering/WebGPU/StorageBuffer';\nimport vtkWebGPUSampler from 'vtk.js/Sources/Rendering/WebGPU/Sampler';\nimport vtkWebGPUTypes from 'vtk.js/Sources/Rendering/WebGPU/Types';\n\nimport { BlendMode } from 'vtk.js/Sources/Rendering/Core/VolumeMapper/Constants';\n\nconst volFragTemplate = `\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Volume::TraverseDec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\n{\n  // todo multicomponent support\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\n}\n\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\n{\n  var result: vec4<f32>;\n\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\n  result.w = 0.0;\n\n  // divide by spacing as that is our delta\n  result = result / volumeSSBO.values[vNum].spacing;\n  // now we have a gradient in unit tcoords\n\n  var grad: f32 = length(result.xyz);\n  if (grad > 0.0)\n  {\n    // rotate to View Coords, needed for lighting and shading\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\n    result = nMat * result;\n    result = result / length(result);\n  }\n\n  // store gradient magnitude in .w\n  result.w = grad;\n\n  return result;\n}\n\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\n{\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  // convert to tcoords and reject if outside the volume\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\n\n  var scalar: f32 = getTextureValue(vTex, tpos);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n\n  var gofactor: f32 = 1.0;\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    normal = getGradient(vTex, tpos, vNum, scalar);\n    if (componentSSBO.values[cNum].gomin <  1.0)\n    {\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\n    }\n  }\n\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    color = color*abs(normal.z);\n  }\n\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\n\n  return outColor;\n}\n\n// adjust the start and end point of a raycast such that it intersects the unit cube.\n// This function is used to take a raycast starting point and step vector\n// and numSteps and return the startijng and ending steps for intersecting the\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\n// and bound it to intersecting the texture.\n//\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\n{\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\n\n  // move tpos to the start of the volume\n  var adjust: f32 =\n    min(\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\n      min(\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\n  if (adjust < 0.0)\n  {\n    result.x = result.x - adjust;\n  }\n\n  // adjust length to the end\n  adjust =\n    max(\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\n      max(\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\n  if (adjust > 0.0)\n  {\n    result.y = result.y - adjust;\n  }\n\n  return result;\n}\n\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\n{\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n  return vec4<f32>(color.rgb, opacity);\n}\n\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var maxVal: f32 = -1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar > maxVal)\n    {\n      maxVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\n}\n\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var minVal: f32 = 1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar < minVal)\n    {\n      minVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\n}\n\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var avgVal: f32 = 0.0;\n  var sampleCount: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      avgVal = avgVal + sample;\n      sampleCount = sampleCount + 1.0;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  if (sampleCount <= 0.0)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\n}\n\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var sumVal: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      sumVal = sumVal + sample;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\n}\n\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\n{\n  // initial ray position is at the beginning\n  var rayPosSC: vec4<f32> = minPosSC;\n\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var curDist: f32 = 0.0;\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  var sampleColor: vec4<f32>;\n//VTK::Volume::TraverseCalls\n\n  loop\n  {\n    // for each volume, sample and accumulate color\n//VTK::Volume::CompositeCalls\n\n    // increment position\n    curDist = curDist + mapperUBO.SampleDistance;\n    rayPosSC = rayPosSC + rayStepSC;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayLengthSC) { break; }\n    if (computedColor.a > 0.98) { break; }\n  }\n  return computedColor;\n}\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\n\n  // discard empty rays\n  if (rayMax <= rayMin) { discard; }\n  else\n  {\n    // compute start and end ray positions in view coordinates\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\n\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\n    rayStepSC.w = 0.0;\n\n    var computedColor: vec4<f32>;\n\n//VTK::Volume::Loop\n\n//VTK::RenderEncoder::Impl\n  }\n\n  return output;\n}\n`;\n\nconst tmpMat4 = new Float64Array(16);\nconst tmp2Mat4 = new Float64Array(16);\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUVolumePassFSQ methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUVolumePassFSQ(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUVolumePassFSQ');\n\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', [\n      'output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);',\n      'output.Position = vec4<f32>(vertexBC, 1.0);',\n    ]).result;\n    vDesc.setCode(code);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinInput('vec4<f32>', '@builtin(position) fragPos');\n  };\n  model.shaderReplacements.set(\n    'replaceShaderPosition',\n    publicAPI.replaceShaderPosition\n  );\n\n  publicAPI.replaceShaderVolume = (hash, pipeline, vertexInput) => {\n    const fDesc = pipeline.getShaderDescription('fragment');\n    let code = fDesc.getCode();\n    const compositeCalls = [];\n    const traverseCalls = [];\n    for (let i = 0; i < model.volumes.length; i++) {\n      // todo pass rowPos\n      const blendMode = model.volumes[i]\n        .getRenderable()\n        .getMapper()\n        .getBlendMode();\n      if (blendMode === BlendMode.COMPOSITE_BLEND) {\n        compositeCalls.push(\n          `    sampleColor = processVolume(volTexture${i}, ${i}, ${model.rowStarts[i]}, rayPosSC, tfunRows);`\n        );\n        compositeCalls.push(`    computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);`);\n      } else {\n        traverseCalls.push(`  sampleColor = traverseVals[${i}];`);\n        traverseCalls.push(`  computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);`);\n      }\n    }\n    code = vtkWebGPUShaderCache.substitute(\n      code,\n      '//VTK::Volume::CompositeCalls',\n      compositeCalls\n    ).result;\n    code = vtkWebGPUShaderCache.substitute(\n      code,\n      '//VTK::Volume::TraverseCalls',\n      traverseCalls\n    ).result;\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::TraverseDec', [\n      `var<private> traverseVals: array<vec4<f32>,${model.volumes.length}>;`,\n    ]).result;\n\n    // call the full and partial methods as needed\n    let compositeWhileTraversing = false;\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const blendMode = model.volumes[vidx]\n        .getRenderable()\n        .getMapper()\n        .getBlendMode();\n      if (blendMode === BlendMode.COMPOSITE_BLEND) {\n        compositeWhileTraversing = true;\n      } else if (blendMode === BlendMode.MAXIMUM_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [\n          `    traverseMax(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`,\n          `    computedColor = traverseVals[${vidx}];`,\n          '//VTK::Volume::Loop',\n        ]).result;\n      } else if (blendMode === BlendMode.MINIMUM_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [\n          `    traverseMin(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`,\n          `    computedColor = traverseVals[${vidx}];`,\n          '//VTK::Volume::Loop',\n        ]).result;\n      } else if (blendMode === BlendMode.AVERAGE_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [\n          `    traverseAverage(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`,\n          `    computedColor = traverseVals[${vidx}];`,\n          '//VTK::Volume::Loop',\n        ]).result;\n      } else if (blendMode === BlendMode.ADDITIVE_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [\n          `    traverseAdditive(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`,\n          `    computedColor = traverseVals[${vidx}];`,\n          '//VTK::Volume::Loop',\n        ]).result;\n      }\n    }\n    if (compositeWhileTraversing) {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [\n        '    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);',\n      ]).result;\n    }\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set(\n    'replaceShaderVolume',\n    publicAPI.replaceShaderVolume\n  );\n\n  publicAPI.updateLUTImage = (device) => {\n    // depends on\n    // - volumes array (length and values) - mtime\n    // - tfun arrays - renderable/property mtime\n\n    let mtime = publicAPI.getMTime();\n    for (let i = 0; i < model.volumes.length; i++) {\n      const vol = model.volumes[i].getRenderable();\n      const image = vol.getMapper().getInputData();\n      mtime = Math.max(mtime, vol.getMTime(), image.getMTime());\n    }\n\n    if (mtime < model.lutBuildTime.getMTime()) {\n      return;\n    }\n\n    // first determine how large the image should be\n    model.numRows = 0;\n    model.rowStarts = [];\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      model.rowStarts.push(model.numRows);\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const vprop = actor.getProperty();\n      const image = volMapr.getInputData();\n      const scalars = image.getPointData() && image.getPointData().getScalars();\n\n      const numComp = scalars.getNumberOfComponents();\n      const iComps = vprop.getIndependentComponents();\n      const numIComps = iComps ? numComp : 1;\n      model.numRows += numIComps;\n    }\n\n    // allocate the image array\n    const colorArray = new Uint8Array(model.numRows * 2 * model.rowLength * 4);\n    const opacityArray = new Float32Array(model.numRows * 2 * model.rowLength);\n\n    let imgRow = 0;\n    const tmpTable = new Float32Array(model.rowLength * 3);\n    const rowLength = model.rowLength;\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const vprop = actor.getProperty();\n      const image = volMapr.getInputData();\n      const scalars = image.getPointData() && image.getPointData().getScalars();\n\n      const numComp = scalars.getNumberOfComponents();\n      const iComps = vprop.getIndependentComponents();\n      const numIComps = iComps ? numComp : 1;\n\n      for (let c = 0; c < numIComps; ++c) {\n        const cfun = vprop.getRGBTransferFunction(c);\n        const cRange = cfun.getRange();\n        cfun.getTable(cRange[0], cRange[1], rowLength, tmpTable, 1);\n        let ioffset = imgRow * rowLength * 4;\n        for (let i = 0; i < rowLength; ++i) {\n          colorArray[ioffset + i * 4] = 255.0 * tmpTable[i * 3];\n          colorArray[ioffset + i * 4 + 1] = 255.0 * tmpTable[i * 3 + 1];\n          colorArray[ioffset + i * 4 + 2] = 255.0 * tmpTable[i * 3 + 2];\n          colorArray[ioffset + i * 4 + 3] = 255.0;\n          for (let co = 0; co < 4; co++) {\n            colorArray[ioffset + (rowLength + i) * 4 + co] =\n              colorArray[ioffset + i * 4 + co];\n          }\n        }\n\n        const ofun = vprop.getScalarOpacity(c);\n        const opacityFactor =\n          model.sampleDist / vprop.getScalarOpacityUnitDistance(c);\n\n        const oRange = ofun.getRange();\n        ofun.getTable(oRange[0], oRange[1], rowLength, tmpTable, 1);\n        // adjust for sample distance etc\n        ioffset = imgRow * rowLength;\n        for (let i = 0; i < rowLength; ++i) {\n          opacityArray[ioffset + i] =\n            1.0 - (1.0 - tmpTable[i]) ** opacityFactor;\n          opacityArray[ioffset + i + rowLength] = opacityArray[ioffset + i];\n        }\n        imgRow += 2;\n      }\n    }\n\n    {\n      const treq = {\n        nativeArray: colorArray,\n        width: model.rowLength,\n        height: model.numRows * 2,\n        depth: 1,\n        format: 'rgba8unorm',\n      };\n      const newTex = device.getTextureManager().getTexture(treq);\n      const tview = newTex.createView('tfunTexture');\n      model.textureViews[2] = tview;\n    }\n\n    {\n      const treq = {\n        nativeArray: opacityArray,\n        width: model.rowLength,\n        height: model.numRows * 2,\n        depth: 1,\n        format: 'r16float',\n      };\n      const newTex = device.getTextureManager().getTexture(treq);\n      const tview = newTex.createView('ofunTexture');\n      model.textureViews[3] = tview;\n    }\n\n    model.lutBuildTime.modified();\n  };\n\n  publicAPI.updateSSBO = (device) => {\n    // if any of\n    // - color or opacity tfun ranges changed - volume Mtime\n    // - any volume matrix changed - volume MTime\n    // - stabilized center changed - ren.stabilizedMTime\n    // - any volume's input data worldtoindex or dimensions changed - input's mtime\n    //\n    let mtime = Math.max(\n      publicAPI.getMTime(),\n      model.WebGPURenderer.getStabilizedTime()\n    );\n    for (let i = 0; i < model.volumes.length; i++) {\n      const vol = model.volumes[i].getRenderable();\n      const volMapr = vol.getMapper();\n      const image = volMapr.getInputData();\n      mtime = Math.max(\n        mtime,\n        vol.getMTime(),\n        image.getMTime(),\n        volMapr.getMTime()\n      );\n    }\n    if (mtime < model.SSBO.getSendTime()) {\n      return;\n    }\n\n    // create the volumeSBBO\n    const center = model.WebGPURenderer.getStabilizedCenterByReference();\n    model.SSBO.clearData();\n    model.SSBO.setNumberOfInstances(model.volumes.length);\n\n    // create SCTC matrices  SC -> world -> model -> index -> tcoord\n    //\n    // when doing coord conversions from A to C recall\n    // the order is mat4.mult(AtoC, BtoC, AtoB);\n    //\n    const marray = new Float64Array(model.volumes.length * 16);\n    const vPlaneArray = new Float64Array(model.volumes.length * 16);\n    const tstepArray = new Float64Array(model.volumes.length * 4);\n    const shadeArray = new Float64Array(model.volumes.length * 4);\n    const spacingArray = new Float64Array(model.volumes.length * 4);\n    const ipScalarRangeArray = new Float64Array(model.volumes.length * 4);\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const image = volMapr.getInputData();\n\n      mat4.identity(tmpMat4);\n      mat4.translate(tmpMat4, tmpMat4, center);\n      // tmpMat4 is now SC->World\n\n      const mcwcmat = actor.getMatrix();\n      mat4.transpose(tmp2Mat4, mcwcmat);\n      mat4.invert(tmp2Mat4, tmp2Mat4);\n      // tmp2Mat4 is now world to model\n\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4);\n      // tmp4Mat is now SC->Model\n\n      // the method on the data is world to index but the volume is in\n      // model coordinates so really in this context it is model to index\n      const modelToIndex = image.getWorldToIndex();\n      mat4.multiply(tmpMat4, modelToIndex, tmpMat4);\n      // tmpMat4 is now SC -> Index\n\n      const dims = image.getDimensions();\n      mat4.identity(tmp2Mat4);\n      mat4.scale(tmp2Mat4, tmp2Mat4, [\n        1.0 / dims[0],\n        1.0 / dims[1],\n        1.0 / dims[2],\n      ]);\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4);\n      // tmpMat4 is now SC -> Tcoord\n\n      for (let j = 0; j < 16; j++) {\n        marray[vidx * 16 + j] = tmpMat4[j];\n      }\n\n      mat4.invert(tmpMat4, tmpMat4);\n      // now it is Tcoord To SC\n\n      for (let j = 0; j < 4; j++) {\n        vPlaneArray[vidx * 16 + j * 4] = tmpMat4[j * 4];\n        vPlaneArray[vidx * 16 + j * 4 + 1] = tmpMat4[j * 4 + 1];\n        vPlaneArray[vidx * 16 + j * 4 + 2] = tmpMat4[j * 4 + 2];\n        vPlaneArray[vidx * 16 + j * 4 + 3] = 0.0;\n      }\n\n      tstepArray[vidx * 4] = 1.0 / dims[0];\n      tstepArray[vidx * 4 + 1] = 1.0 / dims[1];\n      tstepArray[vidx * 4 + 2] = 1.0 / dims[2];\n      tstepArray[vidx * 4 + 3] = 1.0;\n\n      shadeArray[vidx * 4] = actor.getProperty().getShade() ? 1.0 : 0.0;\n\n      const spacing = image.getSpacing();\n      spacingArray[vidx * 4] = spacing[0];\n      spacingArray[vidx * 4 + 1] = spacing[1];\n      spacingArray[vidx * 4 + 2] = spacing[2];\n      spacingArray[vidx * 4 + 3] = 1.0;\n\n      // handle filteringMode\n      const tScale = model.textureViews[vidx + 4].getTexture().getScale();\n      const ipScalarRange = volMapr.getIpScalarRange();\n      ipScalarRangeArray[vidx * 4] = ipScalarRange[0] / tScale;\n      ipScalarRangeArray[vidx * 4 + 1] = ipScalarRange[1] / tScale;\n      ipScalarRangeArray[vidx * 4 + 2] = volMapr.getFilterMode();\n    }\n    model.SSBO.addEntry('SCTCMatrix', 'mat4x4<f32>');\n    model.SSBO.addEntry('planeNormals', 'mat4x4<f32>');\n    model.SSBO.addEntry('shade', 'vec4<f32>');\n    model.SSBO.addEntry('tstep', 'vec4<f32>');\n    model.SSBO.addEntry('spacing', 'vec4<f32>');\n    model.SSBO.addEntry('ipScalarRange', 'vec4<f32>');\n    model.SSBO.setAllInstancesFromArray('SCTCMatrix', marray);\n    model.SSBO.setAllInstancesFromArray('planeNormals', vPlaneArray);\n    model.SSBO.setAllInstancesFromArray('shade', shadeArray);\n    model.SSBO.setAllInstancesFromArray('tstep', tstepArray);\n    model.SSBO.setAllInstancesFromArray('spacing', spacingArray);\n    model.SSBO.setAllInstancesFromArray('ipScalarRange', ipScalarRangeArray);\n    model.SSBO.send(device);\n\n    // now create the componentSSBO\n    model.componentSSBO.clearData();\n    model.componentSSBO.setNumberOfInstances(model.numRows);\n    const cScaleArray = new Float64Array(model.numRows);\n    const cShiftArray = new Float64Array(model.numRows);\n    const oScaleArray = new Float64Array(model.numRows);\n    const oShiftArray = new Float64Array(model.numRows);\n    const gominArray = new Float64Array(model.numRows);\n    const gomaxArray = new Float64Array(model.numRows);\n    const goshiftArray = new Float64Array(model.numRows);\n    const goscaleArray = new Float64Array(model.numRows);\n\n    let rowIdx = 0;\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const vprop = actor.getProperty();\n      const image = volMapr.getInputData();\n      const scalars = image.getPointData() && image.getPointData().getScalars();\n\n      const numComp = scalars.getNumberOfComponents();\n      const iComps = vprop.getIndependentComponents();\n      // const numIComps = iComps ? numComp : 1;\n\n      // half float?\n      const tformat = model.textureViews[vidx + 4].getTexture().getFormat();\n      const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(tformat);\n      const halfFloat =\n        tDetails.elementSize === 2 && tDetails.sampleType === 'float';\n\n      const volInfo = { scale: [255.0], offset: [0.0] };\n      if (halfFloat) {\n        volInfo.scale[0] = 1.0;\n      }\n\n      // three levels of shift scale combined into one\n      // for performance in the fragment shader\n      for (let compIdx = 0; compIdx < numComp; compIdx++) {\n        const target = iComps ? compIdx : 0;\n        const sscale = volInfo.scale[compIdx];\n        const ofun = vprop.getScalarOpacity(target);\n        const oRange = ofun.getRange();\n        const oscale = sscale / (oRange[1] - oRange[0]);\n        const oshift =\n          (volInfo.offset[compIdx] - oRange[0]) / (oRange[1] - oRange[0]);\n        oShiftArray[rowIdx] = oshift;\n        oScaleArray[rowIdx] = oscale;\n\n        const cfun = vprop.getRGBTransferFunction(target);\n        const cRange = cfun.getRange();\n        cShiftArray[rowIdx] =\n          (volInfo.offset[compIdx] - cRange[0]) / (cRange[1] - cRange[0]);\n        cScaleArray[rowIdx] = sscale / (cRange[1] - cRange[0]);\n\n        // todo sscale for dependent should be based off of the A channel?\n        // not target (which is 0 in that case)\n        const useGO = vprop.getUseGradientOpacity(target);\n        if (useGO) {\n          const gomin = vprop.getGradientOpacityMinimumOpacity(target);\n          const gomax = vprop.getGradientOpacityMaximumOpacity(target);\n          gominArray[rowIdx] = gomin;\n          gomaxArray[rowIdx] = gomax;\n          const goRange = [\n            vprop.getGradientOpacityMinimumValue(target),\n            vprop.getGradientOpacityMaximumValue(target),\n          ];\n          goscaleArray[rowIdx] =\n            (sscale * (gomax - gomin)) / (goRange[1] - goRange[0]);\n          goshiftArray[rowIdx] =\n            (-goRange[0] * (gomax - gomin)) / (goRange[1] - goRange[0]) + gomin;\n        } else {\n          gominArray[rowIdx] = 1.0;\n          gomaxArray[rowIdx] = 1.0;\n          goscaleArray[rowIdx] = 0.0;\n          goshiftArray[rowIdx] = 1.0;\n        }\n\n        rowIdx++;\n      }\n    }\n\n    model.componentSSBO.addEntry('cScale', 'f32');\n    model.componentSSBO.addEntry('cShift', 'f32');\n    model.componentSSBO.addEntry('oScale', 'f32');\n    model.componentSSBO.addEntry('oShift', 'f32');\n    model.componentSSBO.addEntry('goShift', 'f32');\n    model.componentSSBO.addEntry('goScale', 'f32');\n    model.componentSSBO.addEntry('gomin', 'f32');\n    model.componentSSBO.addEntry('gomax', 'f32');\n    model.componentSSBO.setAllInstancesFromArray('cScale', cScaleArray);\n    model.componentSSBO.setAllInstancesFromArray('cShift', cShiftArray);\n    model.componentSSBO.setAllInstancesFromArray('oScale', oScaleArray);\n    model.componentSSBO.setAllInstancesFromArray('oShift', oShiftArray);\n    model.componentSSBO.setAllInstancesFromArray('goScale', goscaleArray);\n    model.componentSSBO.setAllInstancesFromArray('goShift', goshiftArray);\n    model.componentSSBO.setAllInstancesFromArray('gomin', gominArray);\n    model.componentSSBO.setAllInstancesFromArray('gomax', gomaxArray);\n    model.componentSSBO.send(device);\n  };\n\n  const superClassUpdateBuffers = publicAPI.updateBuffers;\n  publicAPI.updateBuffers = () => {\n    superClassUpdateBuffers();\n    // compute the min step size\n    let sampleDist = model.volumes[0]\n      .getRenderable()\n      .getMapper()\n      .getSampleDistance();\n    for (let i = 0; i < model.volumes.length; i++) {\n      const vol = model.volumes[i];\n      const volMapr = vol.getRenderable().getMapper();\n      const sd = volMapr.getSampleDistance();\n      if (sd < sampleDist) {\n        sampleDist = sd;\n      }\n    }\n    if (model.sampleDist !== sampleDist) {\n      model.sampleDist = sampleDist;\n      model.UBO.setValue('SampleDistance', sampleDist);\n      model.UBO.sendIfNeeded(model.device);\n    }\n\n    // add in 3d volume textures\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const image = volMapr.getInputData();\n\n      const newTex = model.device\n        .getTextureManager()\n        .getTextureForImageData(image);\n      if (\n        !model.textureViews[vidx + 4] ||\n        model.textureViews[vidx + 4].getTexture() !== newTex\n      ) {\n        const tview = newTex.createView(`volTexture${vidx}`);\n        model.textureViews[vidx + 4] = tview;\n      }\n    }\n\n    // clear any old leftovers\n    if (model.volumes.length < model.lastVolumeLength) {\n      // we may have gaps in the array right now so no splice\n      for (let i = model.volumes.length; i < model.lastVolumeLength; i++) {\n        model.textureViews.pop();\n      }\n    }\n    model.lastVolumeLength = model.volumes.length;\n\n    publicAPI.updateLUTImage(model.device);\n\n    publicAPI.updateSSBO(model.device);\n\n    if (!model.clampSampler) {\n      model.clampSampler = vtkWebGPUSampler.newInstance({\n        label: 'clampSampler',\n      });\n      model.clampSampler.create(model.device, {\n        minFilter: 'linear',\n        magFilter: 'linear',\n      });\n    }\n  };\n\n  publicAPI.computePipelineHash = () => {\n    model.pipelineHash = 'volfsq';\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const blendMode = model.volumes[vidx]\n        .getRenderable()\n        .getMapper()\n        .getBlendMode();\n      model.pipelineHash += `${blendMode}`;\n    }\n  };\n\n  // marks modified when needed\n  publicAPI.setVolumes = (val) => {\n    if (!model.volumes || model.volumes.length !== val.length) {\n      model.volumes = [...val];\n      publicAPI.modified();\n      return;\n    }\n    for (let i = 0; i < val.length; i++) {\n      if (val[i] !== model.volumes[i]) {\n        model.volumes = [...val];\n        publicAPI.modified();\n        return;\n      }\n    }\n  };\n\n  const superclassGetBindables = publicAPI.getBindables;\n  publicAPI.getBindables = () => {\n    const bindables = superclassGetBindables();\n    bindables.push(model.componentSSBO);\n    bindables.push(model.clampSampler);\n    return bindables;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  volumes: null,\n  rowLength: 1024,\n  lastVolumeLength: 0,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkWebGPUFullScreenQuad.extend(publicAPI, model, initialValues);\n\n  model.fragmentShaderTemplate = volFragTemplate;\n\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({ label: 'mapperUBO' });\n  model.UBO.addEntry('SampleDistance', 'f32');\n\n  model.SSBO = vtkWebGPUStorageBuffer.newInstance({ label: 'volumeSSBO' });\n\n  model.componentSSBO = vtkWebGPUStorageBuffer.newInstance({\n    label: 'componentSSBO',\n  });\n\n  model.lutBuildTime = {};\n  macro.obj(model.lutBuildTime, { mtime: 0 });\n\n  // Object methods\n  vtkWebGPUVolumePassFSQ(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkWebGPUVolumePassFSQ');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,uBAAlB;AACA,SAASC,IAAT,QAAqB,WAArB;AACA,OAAOC,uBAAP,MAAoC,gDAApC;AACA,OAAOC,sBAAP,MAAmC,+CAAnC;AACA,OAAOC,oBAAP,MAAiC,6CAAjC;AACA,OAAOC,sBAAP,MAAmC,+CAAnC;AACA,OAAOC,gBAAP,MAA6B,yCAA7B;AACA,OAAOC,cAAP,MAA2B,uCAA3B;AAEA,SAASC,SAAT,QAA0B,sDAA1B;AAEA,MAAMC,eAAe,GAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAxXA;AA0XA,MAAMC,OAAO,GAAG,IAAIC,YAAJ,CAAiB,EAAjB,CAAhB;AACA,MAAMC,QAAQ,GAAG,IAAID,YAAJ,CAAiB,EAAjB,CAAjB,C,CAEA;AACA;AACA;;AAEA,SAASE,sBAAT,CAAgCC,SAAhC,EAA2CC,KAA3C,EAAkD;EAChD;EACAA,KAAK,CAACC,cAAN,CAAqBC,IAArB,CAA0B,wBAA1B;;EAEAH,SAAS,CAACI,qBAAV,GAAkC,CAACC,IAAD,EAAOC,QAAP,EAAiBC,WAAjB,KAAiC;IACjE,MAAMC,KAAK,GAAGF,QAAQ,CAACG,oBAAT,CAA8B,QAA9B,CAAd;IACAD,KAAK,CAACE,gBAAN,CAAuB,WAAvB,EAAoC,6BAApC;IACA,IAAIC,IAAI,GAAGH,KAAK,CAACI,OAAN,EAAX;IACAD,IAAI,GAAGrB,oBAAoB,CAACuB,UAArB,CAAgCF,IAAhC,EAAsC,uBAAtC,EAA+D,CACpE,oFADoE,EAEpE,6CAFoE,CAA/D,EAGJG,MAHH;IAIAN,KAAK,CAACO,OAAN,CAAcJ,IAAd;IACA,MAAMK,KAAK,GAAGV,QAAQ,CAACG,oBAAT,CAA8B,UAA9B,CAAd;IACAO,KAAK,CAACC,eAAN,CAAsB,WAAtB,EAAmC,4BAAnC;EACD,CAXD;;EAYAhB,KAAK,CAACiB,kBAAN,CAAyBC,GAAzB,CACE,uBADF,EAEEnB,SAAS,CAACI,qBAFZ;;EAKAJ,SAAS,CAACoB,mBAAV,GAAgC,CAACf,IAAD,EAAOC,QAAP,EAAiBC,WAAjB,KAAiC;IAC/D,MAAMS,KAAK,GAAGV,QAAQ,CAACG,oBAAT,CAA8B,UAA9B,CAAd;IACA,IAAIE,IAAI,GAAGK,KAAK,CAACJ,OAAN,EAAX;IACA,MAAMS,cAAc,GAAG,EAAvB;IACA,MAAMC,aAAa,GAAG,EAAtB;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtB,KAAK,CAACuB,OAAN,CAAcC,MAAlC,EAA0CF,CAAC,EAA3C,EAA+C;MAC7C;MACA,MAAMG,SAAS,GAAGzB,KAAK,CAACuB,OAAN,CAAcD,CAAd,EACfI,aADe,GAEfC,SAFe,GAGfC,YAHe,EAAlB;;MAIA,IAAIH,SAAS,KAAKhC,SAAS,CAACoC,eAA5B,EAA6C;QAC3CT,cAAc,CAAClB,IAAf,CACG,6CAA4CoB,CAAE,KAAIA,CAAE,KAAItB,KAAK,CAAC8B,SAAN,CAAgBR,CAAhB,CAAmB,wBAD9E;QAGAF,cAAc,CAAClB,IAAf,CAAqB;AAC7B;AACA,oEAFQ;MAGD,CAPD,MAOO;QACLmB,aAAa,CAACnB,IAAd,CAAoB,gCAA+BoB,CAAE,IAArD;QACAD,aAAa,CAACnB,IAAd,CAAoB;AAC5B;AACA,oEAFQ;MAGD;IACF;;IACDQ,IAAI,GAAGrB,oBAAoB,CAACuB,UAArB,CACLF,IADK,EAEL,+BAFK,EAGLU,cAHK,EAILP,MAJF;IAKAH,IAAI,GAAGrB,oBAAoB,CAACuB,UAArB,CACLF,IADK,EAEL,8BAFK,EAGLW,aAHK,EAILR,MAJF;IAKAH,IAAI,GAAGrB,oBAAoB,CAACuB,UAArB,CAAgCF,IAAhC,EAAsC,4BAAtC,EAAoE,CACxE,8CAA6CV,KAAK,CAACuB,OAAN,CAAcC,MAAO,IADM,CAApE,EAEJX,MAFH,CAnC+D,CAuC/D;;IACA,IAAIkB,wBAAwB,GAAG,KAA/B;;IACA,KAAK,IAAIC,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGhC,KAAK,CAACuB,OAAN,CAAcC,MAAxC,EAAgDQ,IAAI,EAApD,EAAwD;MACtD,MAAMP,SAAS,GAAGzB,KAAK,CAACuB,OAAN,CAAcS,IAAd,EACfN,aADe,GAEfC,SAFe,GAGfC,YAHe,EAAlB;;MAIA,IAAIH,SAAS,KAAKhC,SAAS,CAACoC,eAA5B,EAA6C;QAC3CE,wBAAwB,GAAG,IAA3B;MACD,CAFD,MAEO,IAAIN,SAAS,KAAKhC,SAAS,CAACwC,uBAA5B,EAAqD;QAC1DvB,IAAI,GAAGrB,oBAAoB,CAACuB,UAArB,CAAgCF,IAAhC,EAAsC,qBAAtC,EAA6D,CACjE,6BAA4BsB,IAAK,KAAIA,IAAK,KAAIA,IAAK,sCADc,EAEjE,oCAAmCA,IAAK,IAFyB,EAGlE,qBAHkE,CAA7D,EAIJnB,MAJH;MAKD,CANM,MAMA,IAAIY,SAAS,KAAKhC,SAAS,CAACyC,uBAA5B,EAAqD;QAC1DxB,IAAI,GAAGrB,oBAAoB,CAACuB,UAArB,CAAgCF,IAAhC,EAAsC,qBAAtC,EAA6D,CACjE,6BAA4BsB,IAAK,KAAIA,IAAK,KAAIA,IAAK,sCADc,EAEjE,oCAAmCA,IAAK,IAFyB,EAGlE,qBAHkE,CAA7D,EAIJnB,MAJH;MAKD,CANM,MAMA,IAAIY,SAAS,KAAKhC,SAAS,CAAC0C,uBAA5B,EAAqD;QAC1DzB,IAAI,GAAGrB,oBAAoB,CAACuB,UAArB,CAAgCF,IAAhC,EAAsC,qBAAtC,EAA6D,CACjE,iCAAgCsB,IAAK,KAAIA,IAAK,KAAIA,IAAK,sCADU,EAEjE,oCAAmCA,IAAK,IAFyB,EAGlE,qBAHkE,CAA7D,EAIJnB,MAJH;MAKD,CANM,MAMA,IAAIY,SAAS,KAAKhC,SAAS,CAAC2C,wBAA5B,EAAsD;QAC3D1B,IAAI,GAAGrB,oBAAoB,CAACuB,UAArB,CAAgCF,IAAhC,EAAsC,qBAAtC,EAA6D,CACjE,kCAAiCsB,IAAK,KAAIA,IAAK,KAAIA,IAAK,sCADS,EAEjE,oCAAmCA,IAAK,IAFyB,EAGlE,qBAHkE,CAA7D,EAIJnB,MAJH;MAKD;IACF;;IACD,IAAIkB,wBAAJ,EAA8B;MAC5BrB,IAAI,GAAGrB,oBAAoB,CAACuB,UAArB,CAAgCF,IAAhC,EAAsC,qBAAtC,EAA6D,CAClE,kEADkE,CAA7D,EAEJG,MAFH;IAGD;;IACDE,KAAK,CAACD,OAAN,CAAcJ,IAAd;EACD,CAhFD;;EAiFAV,KAAK,CAACiB,kBAAN,CAAyBC,GAAzB,CACE,qBADF,EAEEnB,SAAS,CAACoB,mBAFZ;;EAKApB,SAAS,CAACsC,cAAV,GAA4BC,MAAD,IAAY;IACrC;IACA;IACA;IAEA,IAAIC,KAAK,GAAGxC,SAAS,CAACyC,QAAV,EAAZ;;IACA,KAAK,IAAIlB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtB,KAAK,CAACuB,OAAN,CAAcC,MAAlC,EAA0CF,CAAC,EAA3C,EAA+C;MAC7C,MAAMmB,GAAG,GAAGzC,KAAK,CAACuB,OAAN,CAAcD,CAAd,EAAiBI,aAAjB,EAAZ;MACA,MAAMgB,KAAK,GAAGD,GAAG,CAACd,SAAJ,GAAgBgB,YAAhB,EAAd;MACAJ,KAAK,GAAGK,IAAI,CAACC,GAAL,CAASN,KAAT,EAAgBE,GAAG,CAACD,QAAJ,EAAhB,EAAgCE,KAAK,CAACF,QAAN,EAAhC,CAAR;IACD;;IAED,IAAID,KAAK,GAAGvC,KAAK,CAAC8C,YAAN,CAAmBN,QAAnB,EAAZ,EAA2C;MACzC;IACD,CAdoC,CAgBrC;;;IACAxC,KAAK,CAAC+C,OAAN,GAAgB,CAAhB;IACA/C,KAAK,CAAC8B,SAAN,GAAkB,EAAlB;;IACA,KAAK,IAAIE,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGhC,KAAK,CAACuB,OAAN,CAAcC,MAAxC,EAAgDQ,IAAI,EAApD,EAAwD;MACtDhC,KAAK,CAAC8B,SAAN,CAAgB5B,IAAhB,CAAqBF,KAAK,CAAC+C,OAA3B;MACA,MAAMC,SAAS,GAAGhD,KAAK,CAACuB,OAAN,CAAcS,IAAd,CAAlB;MACA,MAAMiB,KAAK,GAAGD,SAAS,CAACtB,aAAV,EAAd;MACA,MAAMwB,OAAO,GAAGD,KAAK,CAACtB,SAAN,EAAhB;MACA,MAAMwB,KAAK,GAAGF,KAAK,CAACG,WAAN,EAAd;MACA,MAAMV,KAAK,GAAGQ,OAAO,CAACP,YAAR,EAAd;MACA,MAAMU,OAAO,GAAGX,KAAK,CAACY,YAAN,MAAwBZ,KAAK,CAACY,YAAN,GAAqBC,UAArB,EAAxC;MAEA,MAAMC,OAAO,GAAGH,OAAO,CAACI,qBAAR,EAAhB;MACA,MAAMC,MAAM,GAAGP,KAAK,CAACQ,wBAAN,EAAf;MACA,MAAMC,SAAS,GAAGF,MAAM,GAAGF,OAAH,GAAa,CAArC;MACAxD,KAAK,CAAC+C,OAAN,IAAiBa,SAAjB;IACD,CAhCoC,CAkCrC;;;IACA,MAAMC,UAAU,GAAG,IAAIC,UAAJ,CAAe9D,KAAK,CAAC+C,OAAN,GAAgB,CAAhB,GAAoB/C,KAAK,CAAC+D,SAA1B,GAAsC,CAArD,CAAnB;IACA,MAAMC,YAAY,GAAG,IAAIC,YAAJ,CAAiBjE,KAAK,CAAC+C,OAAN,GAAgB,CAAhB,GAAoB/C,KAAK,CAAC+D,SAA3C,CAArB;IAEA,IAAIG,MAAM,GAAG,CAAb;IACA,MAAMC,QAAQ,GAAG,IAAIF,YAAJ,CAAiBjE,KAAK,CAAC+D,SAAN,GAAkB,CAAnC,CAAjB;IACA,MAAMA,SAAS,GAAG/D,KAAK,CAAC+D,SAAxB;;IACA,KAAK,IAAI/B,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGhC,KAAK,CAACuB,OAAN,CAAcC,MAAxC,EAAgDQ,IAAI,EAApD,EAAwD;MACtD,MAAMgB,SAAS,GAAGhD,KAAK,CAACuB,OAAN,CAAcS,IAAd,CAAlB;MACA,MAAMiB,KAAK,GAAGD,SAAS,CAACtB,aAAV,EAAd;MACA,MAAMwB,OAAO,GAAGD,KAAK,CAACtB,SAAN,EAAhB;MACA,MAAMwB,KAAK,GAAGF,KAAK,CAACG,WAAN,EAAd;MACA,MAAMV,KAAK,GAAGQ,OAAO,CAACP,YAAR,EAAd;MACA,MAAMU,OAAO,GAAGX,KAAK,CAACY,YAAN,MAAwBZ,KAAK,CAACY,YAAN,GAAqBC,UAArB,EAAxC;MAEA,MAAMC,OAAO,GAAGH,OAAO,CAACI,qBAAR,EAAhB;MACA,MAAMC,MAAM,GAAGP,KAAK,CAACQ,wBAAN,EAAf;MACA,MAAMC,SAAS,GAAGF,MAAM,GAAGF,OAAH,GAAa,CAArC;;MAEA,KAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,SAApB,EAA+B,EAAEQ,CAAjC,EAAoC;QAClC,MAAMC,IAAI,GAAGlB,KAAK,CAACmB,sBAAN,CAA6BF,CAA7B,CAAb;QACA,MAAMG,MAAM,GAAGF,IAAI,CAACG,QAAL,EAAf;QACAH,IAAI,CAACI,QAAL,CAAcF,MAAM,CAAC,CAAD,CAApB,EAAyBA,MAAM,CAAC,CAAD,CAA/B,EAAoCR,SAApC,EAA+CI,QAA/C,EAAyD,CAAzD;QACA,IAAIO,OAAO,GAAGR,MAAM,GAAGH,SAAT,GAAqB,CAAnC;;QACA,KAAK,IAAIzC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyC,SAApB,EAA+B,EAAEzC,CAAjC,EAAoC;UAClCuC,UAAU,CAACa,OAAO,GAAGpD,CAAC,GAAG,CAAf,CAAV,GAA8B,QAAQ6C,QAAQ,CAAC7C,CAAC,GAAG,CAAL,CAA9C;UACAuC,UAAU,CAACa,OAAO,GAAGpD,CAAC,GAAG,CAAd,GAAkB,CAAnB,CAAV,GAAkC,QAAQ6C,QAAQ,CAAC7C,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAlD;UACAuC,UAAU,CAACa,OAAO,GAAGpD,CAAC,GAAG,CAAd,GAAkB,CAAnB,CAAV,GAAkC,QAAQ6C,QAAQ,CAAC7C,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAlD;UACAuC,UAAU,CAACa,OAAO,GAAGpD,CAAC,GAAG,CAAd,GAAkB,CAAnB,CAAV,GAAkC,KAAlC;;UACA,KAAK,IAAIqD,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAG,CAAtB,EAAyBA,EAAE,EAA3B,EAA+B;YAC7Bd,UAAU,CAACa,OAAO,GAAG,CAACX,SAAS,GAAGzC,CAAb,IAAkB,CAA5B,GAAgCqD,EAAjC,CAAV,GACEd,UAAU,CAACa,OAAO,GAAGpD,CAAC,GAAG,CAAd,GAAkBqD,EAAnB,CADZ;UAED;QACF;;QAED,MAAMC,IAAI,GAAGzB,KAAK,CAAC0B,gBAAN,CAAuBT,CAAvB,CAAb;QACA,MAAMU,aAAa,GACjB9E,KAAK,CAAC+E,UAAN,GAAmB5B,KAAK,CAAC6B,4BAAN,CAAmCZ,CAAnC,CADrB;QAGA,MAAMa,MAAM,GAAGL,IAAI,CAACJ,QAAL,EAAf;QACAI,IAAI,CAACH,QAAL,CAAcQ,MAAM,CAAC,CAAD,CAApB,EAAyBA,MAAM,CAAC,CAAD,CAA/B,EAAoClB,SAApC,EAA+CI,QAA/C,EAAyD,CAAzD,EArBkC,CAsBlC;;QACAO,OAAO,GAAGR,MAAM,GAAGH,SAAnB;;QACA,KAAK,IAAIzC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyC,SAApB,EAA+B,EAAEzC,CAAjC,EAAoC;UAClC0C,YAAY,CAACU,OAAO,GAAGpD,CAAX,CAAZ,GACE,MAAM,CAAC,MAAM6C,QAAQ,CAAC7C,CAAD,CAAf,KAAuBwD,aAD/B;UAEAd,YAAY,CAACU,OAAO,GAAGpD,CAAV,GAAcyC,SAAf,CAAZ,GAAwCC,YAAY,CAACU,OAAO,GAAGpD,CAAX,CAApD;QACD;;QACD4C,MAAM,IAAI,CAAV;MACD;IACF;;IAED;MACE,MAAMgB,IAAI,GAAG;QACXC,WAAW,EAAEtB,UADF;QAEXuB,KAAK,EAAEpF,KAAK,CAAC+D,SAFF;QAGXsB,MAAM,EAAErF,KAAK,CAAC+C,OAAN,GAAgB,CAHb;QAIXuC,KAAK,EAAE,CAJI;QAKXC,MAAM,EAAE;MALG,CAAb;MAOA,MAAMC,MAAM,GAAGlD,MAAM,CAACmD,iBAAP,GAA2BC,UAA3B,CAAsCR,IAAtC,CAAf;MACA,MAAMS,KAAK,GAAGH,MAAM,CAACI,UAAP,CAAkB,aAAlB,CAAd;MACA5F,KAAK,CAAC6F,YAAN,CAAmB,CAAnB,IAAwBF,KAAxB;IACD;IAED;MACE,MAAMT,IAAI,GAAG;QACXC,WAAW,EAAEnB,YADF;QAEXoB,KAAK,EAAEpF,KAAK,CAAC+D,SAFF;QAGXsB,MAAM,EAAErF,KAAK,CAAC+C,OAAN,GAAgB,CAHb;QAIXuC,KAAK,EAAE,CAJI;QAKXC,MAAM,EAAE;MALG,CAAb;MAOA,MAAMC,MAAM,GAAGlD,MAAM,CAACmD,iBAAP,GAA2BC,UAA3B,CAAsCR,IAAtC,CAAf;MACA,MAAMS,KAAK,GAAGH,MAAM,CAACI,UAAP,CAAkB,aAAlB,CAAd;MACA5F,KAAK,CAAC6F,YAAN,CAAmB,CAAnB,IAAwBF,KAAxB;IACD;IAED3F,KAAK,CAAC8C,YAAN,CAAmBgD,QAAnB;EACD,CAjHD;;EAmHA/F,SAAS,CAACgG,UAAV,GAAwBzD,MAAD,IAAY;IACjC;IACA;IACA;IACA;IACA;IACA;IACA,IAAIC,KAAK,GAAGK,IAAI,CAACC,GAAL,CACV9C,SAAS,CAACyC,QAAV,EADU,EAEVxC,KAAK,CAACgG,cAAN,CAAqBC,iBAArB,EAFU,CAAZ;;IAIA,KAAK,IAAI3E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtB,KAAK,CAACuB,OAAN,CAAcC,MAAlC,EAA0CF,CAAC,EAA3C,EAA+C;MAC7C,MAAMmB,GAAG,GAAGzC,KAAK,CAACuB,OAAN,CAAcD,CAAd,EAAiBI,aAAjB,EAAZ;MACA,MAAMwB,OAAO,GAAGT,GAAG,CAACd,SAAJ,EAAhB;MACA,MAAMe,KAAK,GAAGQ,OAAO,CAACP,YAAR,EAAd;MACAJ,KAAK,GAAGK,IAAI,CAACC,GAAL,CACNN,KADM,EAENE,GAAG,CAACD,QAAJ,EAFM,EAGNE,KAAK,CAACF,QAAN,EAHM,EAINU,OAAO,CAACV,QAAR,EAJM,CAAR;IAMD;;IACD,IAAID,KAAK,GAAGvC,KAAK,CAACkG,IAAN,CAAWC,WAAX,EAAZ,EAAsC;MACpC;IACD,CAxBgC,CA0BjC;;;IACA,MAAMC,MAAM,GAAGpG,KAAK,CAACgG,cAAN,CAAqBK,8BAArB,EAAf;IACArG,KAAK,CAACkG,IAAN,CAAWI,SAAX;IACAtG,KAAK,CAACkG,IAAN,CAAWK,oBAAX,CAAgCvG,KAAK,CAACuB,OAAN,CAAcC,MAA9C,EA7BiC,CA+BjC;IACA;IACA;IACA;IACA;;IACA,MAAMgF,MAAM,GAAG,IAAI5G,YAAJ,CAAiBI,KAAK,CAACuB,OAAN,CAAcC,MAAd,GAAuB,EAAxC,CAAf;IACA,MAAMiF,WAAW,GAAG,IAAI7G,YAAJ,CAAiBI,KAAK,CAACuB,OAAN,CAAcC,MAAd,GAAuB,EAAxC,CAApB;IACA,MAAMkF,UAAU,GAAG,IAAI9G,YAAJ,CAAiBI,KAAK,CAACuB,OAAN,CAAcC,MAAd,GAAuB,CAAxC,CAAnB;IACA,MAAMmF,UAAU,GAAG,IAAI/G,YAAJ,CAAiBI,KAAK,CAACuB,OAAN,CAAcC,MAAd,GAAuB,CAAxC,CAAnB;IACA,MAAMoF,YAAY,GAAG,IAAIhH,YAAJ,CAAiBI,KAAK,CAACuB,OAAN,CAAcC,MAAd,GAAuB,CAAxC,CAArB;IACA,MAAMqF,kBAAkB,GAAG,IAAIjH,YAAJ,CAAiBI,KAAK,CAACuB,OAAN,CAAcC,MAAd,GAAuB,CAAxC,CAA3B;;IACA,KAAK,IAAIQ,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGhC,KAAK,CAACuB,OAAN,CAAcC,MAAxC,EAAgDQ,IAAI,EAApD,EAAwD;MACtD,MAAMgB,SAAS,GAAGhD,KAAK,CAACuB,OAAN,CAAcS,IAAd,CAAlB;MACA,MAAMiB,KAAK,GAAGD,SAAS,CAACtB,aAAV,EAAd;MACA,MAAMwB,OAAO,GAAGD,KAAK,CAACtB,SAAN,EAAhB;MACA,MAAMe,KAAK,GAAGQ,OAAO,CAACP,YAAR,EAAd;MAEAzD,IAAI,CAAC4H,QAAL,CAAcnH,OAAd;MACAT,IAAI,CAAC6H,SAAL,CAAepH,OAAf,EAAwBA,OAAxB,EAAiCyG,MAAjC,EAPsD,CAQtD;;MAEA,MAAMY,OAAO,GAAG/D,KAAK,CAACgE,SAAN,EAAhB;MACA/H,IAAI,CAACgI,SAAL,CAAerH,QAAf,EAAyBmH,OAAzB;MACA9H,IAAI,CAACiI,MAAL,CAAYtH,QAAZ,EAAsBA,QAAtB,EAZsD,CAatD;;MAEAX,IAAI,CAACkI,QAAL,CAAczH,OAAd,EAAuBE,QAAvB,EAAiCF,OAAjC,EAfsD,CAgBtD;MAEA;MACA;;MACA,MAAM0H,YAAY,GAAG3E,KAAK,CAAC4E,eAAN,EAArB;MACApI,IAAI,CAACkI,QAAL,CAAczH,OAAd,EAAuB0H,YAAvB,EAAqC1H,OAArC,EArBsD,CAsBtD;;MAEA,MAAM4H,IAAI,GAAG7E,KAAK,CAAC8E,aAAN,EAAb;MACAtI,IAAI,CAAC4H,QAAL,CAAcjH,QAAd;MACAX,IAAI,CAACuI,KAAL,CAAW5H,QAAX,EAAqBA,QAArB,EAA+B,CAC7B,MAAM0H,IAAI,CAAC,CAAD,CADmB,EAE7B,MAAMA,IAAI,CAAC,CAAD,CAFmB,EAG7B,MAAMA,IAAI,CAAC,CAAD,CAHmB,CAA/B;MAKArI,IAAI,CAACkI,QAAL,CAAczH,OAAd,EAAuBE,QAAvB,EAAiCF,OAAjC,EA/BsD,CAgCtD;;MAEA,KAAK,IAAI+H,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwBA,CAAC,EAAzB,EAA6B;QAC3BlB,MAAM,CAACxE,IAAI,GAAG,EAAP,GAAY0F,CAAb,CAAN,GAAwB/H,OAAO,CAAC+H,CAAD,CAA/B;MACD;;MAEDxI,IAAI,CAACiI,MAAL,CAAYxH,OAAZ,EAAqBA,OAArB,EAtCsD,CAuCtD;;MAEA,KAAK,IAAI+H,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;QAC1BjB,WAAW,CAACzE,IAAI,GAAG,EAAP,GAAY0F,CAAC,GAAG,CAAjB,CAAX,GAAiC/H,OAAO,CAAC+H,CAAC,GAAG,CAAL,CAAxC;QACAjB,WAAW,CAACzE,IAAI,GAAG,EAAP,GAAY0F,CAAC,GAAG,CAAhB,GAAoB,CAArB,CAAX,GAAqC/H,OAAO,CAAC+H,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAA5C;QACAjB,WAAW,CAACzE,IAAI,GAAG,EAAP,GAAY0F,CAAC,GAAG,CAAhB,GAAoB,CAArB,CAAX,GAAqC/H,OAAO,CAAC+H,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAA5C;QACAjB,WAAW,CAACzE,IAAI,GAAG,EAAP,GAAY0F,CAAC,GAAG,CAAhB,GAAoB,CAArB,CAAX,GAAqC,GAArC;MACD;;MAEDhB,UAAU,CAAC1E,IAAI,GAAG,CAAR,CAAV,GAAuB,MAAMuF,IAAI,CAAC,CAAD,CAAjC;MACAb,UAAU,CAAC1E,IAAI,GAAG,CAAP,GAAW,CAAZ,CAAV,GAA2B,MAAMuF,IAAI,CAAC,CAAD,CAArC;MACAb,UAAU,CAAC1E,IAAI,GAAG,CAAP,GAAW,CAAZ,CAAV,GAA2B,MAAMuF,IAAI,CAAC,CAAD,CAArC;MACAb,UAAU,CAAC1E,IAAI,GAAG,CAAP,GAAW,CAAZ,CAAV,GAA2B,GAA3B;MAEA2E,UAAU,CAAC3E,IAAI,GAAG,CAAR,CAAV,GAAuBiB,KAAK,CAACG,WAAN,GAAoBuE,QAApB,KAAiC,GAAjC,GAAuC,GAA9D;MAEA,MAAMC,OAAO,GAAGlF,KAAK,CAACmF,UAAN,EAAhB;MACAjB,YAAY,CAAC5E,IAAI,GAAG,CAAR,CAAZ,GAAyB4F,OAAO,CAAC,CAAD,CAAhC;MACAhB,YAAY,CAAC5E,IAAI,GAAG,CAAP,GAAW,CAAZ,CAAZ,GAA6B4F,OAAO,CAAC,CAAD,CAApC;MACAhB,YAAY,CAAC5E,IAAI,GAAG,CAAP,GAAW,CAAZ,CAAZ,GAA6B4F,OAAO,CAAC,CAAD,CAApC;MACAhB,YAAY,CAAC5E,IAAI,GAAG,CAAP,GAAW,CAAZ,CAAZ,GAA6B,GAA7B,CA3DsD,CA6DtD;;MACA,MAAM8F,MAAM,GAAG9H,KAAK,CAAC6F,YAAN,CAAmB7D,IAAI,GAAG,CAA1B,EAA6B0D,UAA7B,GAA0CqC,QAA1C,EAAf;MACA,MAAMC,aAAa,GAAG9E,OAAO,CAAC+E,gBAAR,EAAtB;MACApB,kBAAkB,CAAC7E,IAAI,GAAG,CAAR,CAAlB,GAA+BgG,aAAa,CAAC,CAAD,CAAb,GAAmBF,MAAlD;MACAjB,kBAAkB,CAAC7E,IAAI,GAAG,CAAP,GAAW,CAAZ,CAAlB,GAAmCgG,aAAa,CAAC,CAAD,CAAb,GAAmBF,MAAtD;MACAjB,kBAAkB,CAAC7E,IAAI,GAAG,CAAP,GAAW,CAAZ,CAAlB,GAAmCkB,OAAO,CAACgF,aAAR,EAAnC;IACD;;IACDlI,KAAK,CAACkG,IAAN,CAAWiC,QAAX,CAAoB,YAApB,EAAkC,aAAlC;IACAnI,KAAK,CAACkG,IAAN,CAAWiC,QAAX,CAAoB,cAApB,EAAoC,aAApC;IACAnI,KAAK,CAACkG,IAAN,CAAWiC,QAAX,CAAoB,OAApB,EAA6B,WAA7B;IACAnI,KAAK,CAACkG,IAAN,CAAWiC,QAAX,CAAoB,OAApB,EAA6B,WAA7B;IACAnI,KAAK,CAACkG,IAAN,CAAWiC,QAAX,CAAoB,SAApB,EAA+B,WAA/B;IACAnI,KAAK,CAACkG,IAAN,CAAWiC,QAAX,CAAoB,eAApB,EAAqC,WAArC;IACAnI,KAAK,CAACkG,IAAN,CAAWkC,wBAAX,CAAoC,YAApC,EAAkD5B,MAAlD;IACAxG,KAAK,CAACkG,IAAN,CAAWkC,wBAAX,CAAoC,cAApC,EAAoD3B,WAApD;IACAzG,KAAK,CAACkG,IAAN,CAAWkC,wBAAX,CAAoC,OAApC,EAA6CzB,UAA7C;IACA3G,KAAK,CAACkG,IAAN,CAAWkC,wBAAX,CAAoC,OAApC,EAA6C1B,UAA7C;IACA1G,KAAK,CAACkG,IAAN,CAAWkC,wBAAX,CAAoC,SAApC,EAA+CxB,YAA/C;IACA5G,KAAK,CAACkG,IAAN,CAAWkC,wBAAX,CAAoC,eAApC,EAAqDvB,kBAArD;IACA7G,KAAK,CAACkG,IAAN,CAAWmC,IAAX,CAAgB/F,MAAhB,EA1HiC,CA4HjC;;IACAtC,KAAK,CAACsI,aAAN,CAAoBhC,SAApB;IACAtG,KAAK,CAACsI,aAAN,CAAoB/B,oBAApB,CAAyCvG,KAAK,CAAC+C,OAA/C;IACA,MAAMwF,WAAW,GAAG,IAAI3I,YAAJ,CAAiBI,KAAK,CAAC+C,OAAvB,CAApB;IACA,MAAMyF,WAAW,GAAG,IAAI5I,YAAJ,CAAiBI,KAAK,CAAC+C,OAAvB,CAApB;IACA,MAAM0F,WAAW,GAAG,IAAI7I,YAAJ,CAAiBI,KAAK,CAAC+C,OAAvB,CAApB;IACA,MAAM2F,WAAW,GAAG,IAAI9I,YAAJ,CAAiBI,KAAK,CAAC+C,OAAvB,CAApB;IACA,MAAM4F,UAAU,GAAG,IAAI/I,YAAJ,CAAiBI,KAAK,CAAC+C,OAAvB,CAAnB;IACA,MAAM6F,UAAU,GAAG,IAAIhJ,YAAJ,CAAiBI,KAAK,CAAC+C,OAAvB,CAAnB;IACA,MAAM8F,YAAY,GAAG,IAAIjJ,YAAJ,CAAiBI,KAAK,CAAC+C,OAAvB,CAArB;IACA,MAAM+F,YAAY,GAAG,IAAIlJ,YAAJ,CAAiBI,KAAK,CAAC+C,OAAvB,CAArB;IAEA,IAAIgG,MAAM,GAAG,CAAb;;IACA,KAAK,IAAI/G,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGhC,KAAK,CAACuB,OAAN,CAAcC,MAAxC,EAAgDQ,IAAI,EAApD,EAAwD;MACtD,MAAMgB,SAAS,GAAGhD,KAAK,CAACuB,OAAN,CAAcS,IAAd,CAAlB;MACA,MAAMiB,KAAK,GAAGD,SAAS,CAACtB,aAAV,EAAd;MACA,MAAMwB,OAAO,GAAGD,KAAK,CAACtB,SAAN,EAAhB;MACA,MAAMwB,KAAK,GAAGF,KAAK,CAACG,WAAN,EAAd;MACA,MAAMV,KAAK,GAAGQ,OAAO,CAACP,YAAR,EAAd;MACA,MAAMU,OAAO,GAAGX,KAAK,CAACY,YAAN,MAAwBZ,KAAK,CAACY,YAAN,GAAqBC,UAArB,EAAxC;MAEA,MAAMC,OAAO,GAAGH,OAAO,CAACI,qBAAR,EAAhB;MACA,MAAMC,MAAM,GAAGP,KAAK,CAACQ,wBAAN,EAAf,CATsD,CAUtD;MAEA;;MACA,MAAMqF,OAAO,GAAGhJ,KAAK,CAAC6F,YAAN,CAAmB7D,IAAI,GAAG,CAA1B,EAA6B0D,UAA7B,GAA0CuD,SAA1C,EAAhB;MACA,MAAMC,QAAQ,GAAG1J,cAAc,CAAC2J,2BAAf,CAA2CH,OAA3C,CAAjB;MACA,MAAMI,SAAS,GACbF,QAAQ,CAACG,WAAT,KAAyB,CAAzB,IAA8BH,QAAQ,CAACI,UAAT,KAAwB,OADxD;MAGA,MAAMC,OAAO,GAAG;QAAE9B,KAAK,EAAE,CAAC,KAAD,CAAT;QAAkB+B,MAAM,EAAE,CAAC,GAAD;MAA1B,CAAhB;;MACA,IAAIJ,SAAJ,EAAe;QACbG,OAAO,CAAC9B,KAAR,CAAc,CAAd,IAAmB,GAAnB;MACD,CArBqD,CAuBtD;MACA;;;MACA,KAAK,IAAIgC,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAGjG,OAAhC,EAAyCiG,OAAO,EAAhD,EAAoD;QAClD,MAAMC,MAAM,GAAGhG,MAAM,GAAG+F,OAAH,GAAa,CAAlC;QACA,MAAME,MAAM,GAAGJ,OAAO,CAAC9B,KAAR,CAAcgC,OAAd,CAAf;QACA,MAAM7E,IAAI,GAAGzB,KAAK,CAAC0B,gBAAN,CAAuB6E,MAAvB,CAAb;QACA,MAAMzE,MAAM,GAAGL,IAAI,CAACJ,QAAL,EAAf;QACA,MAAMoF,MAAM,GAAGD,MAAM,IAAI1E,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAAtB,CAArB;QACA,MAAM4E,MAAM,GACV,CAACN,OAAO,CAACC,MAAR,CAAeC,OAAf,IAA0BxE,MAAM,CAAC,CAAD,CAAjC,KAAyCA,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAA3D,CADF;QAEAyD,WAAW,CAACK,MAAD,CAAX,GAAsBc,MAAtB;QACApB,WAAW,CAACM,MAAD,CAAX,GAAsBa,MAAtB;QAEA,MAAMvF,IAAI,GAAGlB,KAAK,CAACmB,sBAAN,CAA6BoF,MAA7B,CAAb;QACA,MAAMnF,MAAM,GAAGF,IAAI,CAACG,QAAL,EAAf;QACAgE,WAAW,CAACO,MAAD,CAAX,GACE,CAACQ,OAAO,CAACC,MAAR,CAAeC,OAAf,IAA0BlF,MAAM,CAAC,CAAD,CAAjC,KAAyCA,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAA3D,CADF;QAEAgE,WAAW,CAACQ,MAAD,CAAX,GAAsBY,MAAM,IAAIpF,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAAtB,CAA5B,CAfkD,CAiBlD;QACA;;QACA,MAAMuF,KAAK,GAAG3G,KAAK,CAAC4G,qBAAN,CAA4BL,MAA5B,CAAd;;QACA,IAAII,KAAJ,EAAW;UACT,MAAME,KAAK,GAAG7G,KAAK,CAAC8G,gCAAN,CAAuCP,MAAvC,CAAd;UACA,MAAMQ,KAAK,GAAG/G,KAAK,CAACgH,gCAAN,CAAuCT,MAAvC,CAAd;UACAf,UAAU,CAACI,MAAD,CAAV,GAAqBiB,KAArB;UACApB,UAAU,CAACG,MAAD,CAAV,GAAqBmB,KAArB;UACA,MAAME,OAAO,GAAG,CACdjH,KAAK,CAACkH,8BAAN,CAAqCX,MAArC,CADc,EAEdvG,KAAK,CAACmH,8BAAN,CAAqCZ,MAArC,CAFc,CAAhB;UAIAZ,YAAY,CAACC,MAAD,CAAZ,GACGY,MAAM,IAAIO,KAAK,GAAGF,KAAZ,CAAP,IAA8BI,OAAO,CAAC,CAAD,CAAP,GAAaA,OAAO,CAAC,CAAD,CAAlD,CADF;UAEAvB,YAAY,CAACE,MAAD,CAAZ,GACG,CAACqB,OAAO,CAAC,CAAD,CAAR,IAAeF,KAAK,GAAGF,KAAvB,CAAD,IAAmCI,OAAO,CAAC,CAAD,CAAP,GAAaA,OAAO,CAAC,CAAD,CAAvD,IAA8DJ,KADhE;QAED,CAbD,MAaO;UACLrB,UAAU,CAACI,MAAD,CAAV,GAAqB,GAArB;UACAH,UAAU,CAACG,MAAD,CAAV,GAAqB,GAArB;UACAD,YAAY,CAACC,MAAD,CAAZ,GAAuB,GAAvB;UACAF,YAAY,CAACE,MAAD,CAAZ,GAAuB,GAAvB;QACD;;QAEDA,MAAM;MACP;IACF;;IAED/I,KAAK,CAACsI,aAAN,CAAoBH,QAApB,CAA6B,QAA7B,EAAuC,KAAvC;IACAnI,KAAK,CAACsI,aAAN,CAAoBH,QAApB,CAA6B,QAA7B,EAAuC,KAAvC;IACAnI,KAAK,CAACsI,aAAN,CAAoBH,QAApB,CAA6B,QAA7B,EAAuC,KAAvC;IACAnI,KAAK,CAACsI,aAAN,CAAoBH,QAApB,CAA6B,QAA7B,EAAuC,KAAvC;IACAnI,KAAK,CAACsI,aAAN,CAAoBH,QAApB,CAA6B,SAA7B,EAAwC,KAAxC;IACAnI,KAAK,CAACsI,aAAN,CAAoBH,QAApB,CAA6B,SAA7B,EAAwC,KAAxC;IACAnI,KAAK,CAACsI,aAAN,CAAoBH,QAApB,CAA6B,OAA7B,EAAsC,KAAtC;IACAnI,KAAK,CAACsI,aAAN,CAAoBH,QAApB,CAA6B,OAA7B,EAAsC,KAAtC;IACAnI,KAAK,CAACsI,aAAN,CAAoBF,wBAApB,CAA6C,QAA7C,EAAuDG,WAAvD;IACAvI,KAAK,CAACsI,aAAN,CAAoBF,wBAApB,CAA6C,QAA7C,EAAuDI,WAAvD;IACAxI,KAAK,CAACsI,aAAN,CAAoBF,wBAApB,CAA6C,QAA7C,EAAuDK,WAAvD;IACAzI,KAAK,CAACsI,aAAN,CAAoBF,wBAApB,CAA6C,QAA7C,EAAuDM,WAAvD;IACA1I,KAAK,CAACsI,aAAN,CAAoBF,wBAApB,CAA6C,SAA7C,EAAwDU,YAAxD;IACA9I,KAAK,CAACsI,aAAN,CAAoBF,wBAApB,CAA6C,SAA7C,EAAwDS,YAAxD;IACA7I,KAAK,CAACsI,aAAN,CAAoBF,wBAApB,CAA6C,OAA7C,EAAsDO,UAAtD;IACA3I,KAAK,CAACsI,aAAN,CAAoBF,wBAApB,CAA6C,OAA7C,EAAsDQ,UAAtD;IACA5I,KAAK,CAACsI,aAAN,CAAoBD,IAApB,CAAyB/F,MAAzB;EACD,CA/ND;;EAiOA,MAAMiI,uBAAuB,GAAGxK,SAAS,CAACyK,aAA1C;;EACAzK,SAAS,CAACyK,aAAV,GAA0B,MAAM;IAC9BD,uBAAuB,GADO,CAE9B;;IACA,IAAIxF,UAAU,GAAG/E,KAAK,CAACuB,OAAN,CAAc,CAAd,EACdG,aADc,GAEdC,SAFc,GAGd8I,iBAHc,EAAjB;;IAIA,KAAK,IAAInJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtB,KAAK,CAACuB,OAAN,CAAcC,MAAlC,EAA0CF,CAAC,EAA3C,EAA+C;MAC7C,MAAMmB,GAAG,GAAGzC,KAAK,CAACuB,OAAN,CAAcD,CAAd,CAAZ;MACA,MAAM4B,OAAO,GAAGT,GAAG,CAACf,aAAJ,GAAoBC,SAApB,EAAhB;MACA,MAAM+I,EAAE,GAAGxH,OAAO,CAACuH,iBAAR,EAAX;;MACA,IAAIC,EAAE,GAAG3F,UAAT,EAAqB;QACnBA,UAAU,GAAG2F,EAAb;MACD;IACF;;IACD,IAAI1K,KAAK,CAAC+E,UAAN,KAAqBA,UAAzB,EAAqC;MACnC/E,KAAK,CAAC+E,UAAN,GAAmBA,UAAnB;MACA/E,KAAK,CAAC2K,GAAN,CAAUC,QAAV,CAAmB,gBAAnB,EAAqC7F,UAArC;MACA/E,KAAK,CAAC2K,GAAN,CAAUE,YAAV,CAAuB7K,KAAK,CAACsC,MAA7B;IACD,CAnB6B,CAqB9B;;;IACA,KAAK,IAAIN,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGhC,KAAK,CAACuB,OAAN,CAAcC,MAAxC,EAAgDQ,IAAI,EAApD,EAAwD;MACtD,MAAMgB,SAAS,GAAGhD,KAAK,CAACuB,OAAN,CAAcS,IAAd,CAAlB;MACA,MAAMiB,KAAK,GAAGD,SAAS,CAACtB,aAAV,EAAd;MACA,MAAMwB,OAAO,GAAGD,KAAK,CAACtB,SAAN,EAAhB;MACA,MAAMe,KAAK,GAAGQ,OAAO,CAACP,YAAR,EAAd;MAEA,MAAM6C,MAAM,GAAGxF,KAAK,CAACsC,MAAN,CACZmD,iBADY,GAEZqF,sBAFY,CAEWpI,KAFX,CAAf;;MAGA,IACE,CAAC1C,KAAK,CAAC6F,YAAN,CAAmB7D,IAAI,GAAG,CAA1B,CAAD,IACAhC,KAAK,CAAC6F,YAAN,CAAmB7D,IAAI,GAAG,CAA1B,EAA6B0D,UAA7B,OAA8CF,MAFhD,EAGE;QACA,MAAMG,KAAK,GAAGH,MAAM,CAACI,UAAP,CAAmB,aAAY5D,IAAK,EAApC,CAAd;QACAhC,KAAK,CAAC6F,YAAN,CAAmB7D,IAAI,GAAG,CAA1B,IAA+B2D,KAA/B;MACD;IACF,CAtC6B,CAwC9B;;;IACA,IAAI3F,KAAK,CAACuB,OAAN,CAAcC,MAAd,GAAuBxB,KAAK,CAAC+K,gBAAjC,EAAmD;MACjD;MACA,KAAK,IAAIzJ,CAAC,GAAGtB,KAAK,CAACuB,OAAN,CAAcC,MAA3B,EAAmCF,CAAC,GAAGtB,KAAK,CAAC+K,gBAA7C,EAA+DzJ,CAAC,EAAhE,EAAoE;QAClEtB,KAAK,CAAC6F,YAAN,CAAmBmF,GAAnB;MACD;IACF;;IACDhL,KAAK,CAAC+K,gBAAN,GAAyB/K,KAAK,CAACuB,OAAN,CAAcC,MAAvC;IAEAzB,SAAS,CAACsC,cAAV,CAAyBrC,KAAK,CAACsC,MAA/B;IAEAvC,SAAS,CAACgG,UAAV,CAAqB/F,KAAK,CAACsC,MAA3B;;IAEA,IAAI,CAACtC,KAAK,CAACiL,YAAX,EAAyB;MACvBjL,KAAK,CAACiL,YAAN,GAAqB1L,gBAAgB,CAAC2L,WAAjB,CAA6B;QAChDC,KAAK,EAAE;MADyC,CAA7B,CAArB;MAGAnL,KAAK,CAACiL,YAAN,CAAmBG,MAAnB,CAA0BpL,KAAK,CAACsC,MAAhC,EAAwC;QACtC+I,SAAS,EAAE,QAD2B;QAEtCC,SAAS,EAAE;MAF2B,CAAxC;IAID;EACF,CA9DD;;EAgEAvL,SAAS,CAACwL,mBAAV,GAAgC,MAAM;IACpCvL,KAAK,CAACwL,YAAN,GAAqB,QAArB;;IACA,KAAK,IAAIxJ,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGhC,KAAK,CAACuB,OAAN,CAAcC,MAAxC,EAAgDQ,IAAI,EAApD,EAAwD;MACtD,MAAMP,SAAS,GAAGzB,KAAK,CAACuB,OAAN,CAAcS,IAAd,EACfN,aADe,GAEfC,SAFe,GAGfC,YAHe,EAAlB;MAIA5B,KAAK,CAACwL,YAAN,IAAuB,GAAE/J,SAAU,EAAnC;IACD;EACF,CATD,CAhgBgD,CA2gBhD;;;EACA1B,SAAS,CAAC0L,UAAV,GAAwBC,GAAD,IAAS;IAC9B,IAAI,CAAC1L,KAAK,CAACuB,OAAP,IAAkBvB,KAAK,CAACuB,OAAN,CAAcC,MAAd,KAAyBkK,GAAG,CAAClK,MAAnD,EAA2D;MACzDxB,KAAK,CAACuB,OAAN,GAAgB,CAAC,GAAGmK,GAAJ,CAAhB;MACA3L,SAAS,CAAC+F,QAAV;MACA;IACD;;IACD,KAAK,IAAIxE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoK,GAAG,CAAClK,MAAxB,EAAgCF,CAAC,EAAjC,EAAqC;MACnC,IAAIoK,GAAG,CAACpK,CAAD,CAAH,KAAWtB,KAAK,CAACuB,OAAN,CAAcD,CAAd,CAAf,EAAiC;QAC/BtB,KAAK,CAACuB,OAAN,GAAgB,CAAC,GAAGmK,GAAJ,CAAhB;QACA3L,SAAS,CAAC+F,QAAV;QACA;MACD;IACF;EACF,CAbD;;EAeA,MAAM6F,sBAAsB,GAAG5L,SAAS,CAAC6L,YAAzC;;EACA7L,SAAS,CAAC6L,YAAV,GAAyB,MAAM;IAC7B,MAAMC,SAAS,GAAGF,sBAAsB,EAAxC;IACAE,SAAS,CAAC3L,IAAV,CAAeF,KAAK,CAACsI,aAArB;IACAuD,SAAS,CAAC3L,IAAV,CAAeF,KAAK,CAACiL,YAArB;IACA,OAAOY,SAAP;EACD,CALD;AAMD,C,CAED;AACA;AACA;;;AAEA,MAAMC,cAAc,GAAG;EACrBvK,OAAO,EAAE,IADY;EAErBwC,SAAS,EAAE,IAFU;EAGrBgH,gBAAgB,EAAE;AAHG,CAAvB,C,CAMA;;AAEA,OAAO,SAASgB,MAAT,CAAgBhM,SAAhB,EAA2BC,KAA3B,EAAsD;EAAA,IAApBgM,aAAoB,uEAAJ,EAAI;EAC3DC,MAAM,CAACC,MAAP,CAAclM,KAAd,EAAqB8L,cAArB,EAAqCE,aAArC,EAD2D,CAG3D;;EACA7M,uBAAuB,CAAC4M,MAAxB,CAA+BhM,SAA/B,EAA0CC,KAA1C,EAAiDgM,aAAjD;EAEAhM,KAAK,CAACmM,sBAAN,GAA+BzM,eAA/B;EAEAM,KAAK,CAAC2K,GAAN,GAAYvL,sBAAsB,CAAC8L,WAAvB,CAAmC;IAAEC,KAAK,EAAE;EAAT,CAAnC,CAAZ;EACAnL,KAAK,CAAC2K,GAAN,CAAUxC,QAAV,CAAmB,gBAAnB,EAAqC,KAArC;EAEAnI,KAAK,CAACkG,IAAN,GAAa5G,sBAAsB,CAAC4L,WAAvB,CAAmC;IAAEC,KAAK,EAAE;EAAT,CAAnC,CAAb;EAEAnL,KAAK,CAACsI,aAAN,GAAsBhJ,sBAAsB,CAAC4L,WAAvB,CAAmC;IACvDC,KAAK,EAAE;EADgD,CAAnC,CAAtB;EAIAnL,KAAK,CAAC8C,YAAN,GAAqB,EAArB;EACA7D,KAAK,CAACmN,GAAN,CAAUpM,KAAK,CAAC8C,YAAhB,EAA8B;IAAEP,KAAK,EAAE;EAAT,CAA9B,EAlB2D,CAoB3D;;EACAzC,sBAAsB,CAACC,SAAD,EAAYC,KAAZ,CAAtB;AACD,C,CAED;;AAEA,OAAO,MAAMkL,WAAW,GAAGjM,KAAK,CAACiM,WAAN,CAAkBa,MAAlB,EAA0B,wBAA1B,CAApB,C,CAEP;;AAEA,eAAe;EAAEb,WAAF;EAAea;AAAf,CAAf"},"metadata":{},"sourceType":"module"}