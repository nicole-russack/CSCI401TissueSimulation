{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nimport Constants from 'vtk.js/Sources/Common/Core/ScalarsToColors/Constants';\nimport vtkMapper from 'vtk.js/Sources/Rendering/Core/Mapper/Constants'; // Need to go inside Constants otherwise dependency loop\n\nconst {\n  ScalarMappingTarget,\n  VectorMode\n} = Constants;\nconst {\n  VtkDataTypes\n} = vtkDataArray;\nconst {\n  ColorMode\n} = vtkMapper;\nconst {\n  vtkErrorMacro\n} = macro; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n// Add module-level functions or api that you want to expose statically via\n// the next section...\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nfunction intColorToUChar(c) {\n  return c;\n}\n\nfunction floatColorToUChar(c) {\n  return Math.floor(c * 255.0 + 0.5);\n} // ----------------------------------------------------------------------------\n// vtkScalarsToColors methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkScalarsToColors(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkScalarsToColors');\n\n  publicAPI.setVectorModeToMagnitude = () => publicAPI.setVectorMode(VectorMode.MAGNITUDE);\n\n  publicAPI.setVectorModeToComponent = () => publicAPI.setVectorMode(VectorMode.COMPONENT);\n\n  publicAPI.setVectorModeToRGBColors = () => publicAPI.setVectorMode(VectorMode.RGBCOLORS);\n\n  publicAPI.build = () => {};\n\n  publicAPI.isOpaque = () => true; //----------------------------------------------------------------------------\n\n\n  publicAPI.setAnnotations = (values, annotations) => {\n    if (values && !annotations || !values && annotations) {\n      return;\n    }\n\n    if (values && annotations && values.length !== annotations.length) {\n      vtkErrorMacro('Values and annotations do not have the same number of tuples so ignoring');\n      return;\n    }\n\n    model.annotationArray = [];\n\n    if (annotations && values) {\n      const num = annotations.length;\n\n      for (let i = 0; i < num; i++) {\n        model.annotationArray.push({\n          value: values[i],\n          annotation: String(annotations[i])\n        });\n      }\n    }\n\n    publicAPI.updateAnnotatedValueMap();\n    publicAPI.modified();\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.setAnnotation = (value, annotation) => {\n    let i = publicAPI.checkForAnnotatedValue(value);\n    let modified = false;\n\n    if (i >= 0) {\n      if (model.annotationArray[i].annotation !== annotation) {\n        model.annotationArray[i].annotation = annotation;\n        modified = true;\n      }\n    } else {\n      model.annotationArray.push({\n        value,\n        annotation\n      });\n      i = model.annotationArray.length - 1;\n      modified = true;\n    }\n\n    if (modified) {\n      publicAPI.updateAnnotatedValueMap();\n      publicAPI.modified();\n    }\n\n    return i;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getNumberOfAnnotatedValues = () => model.annotationArray.length; //----------------------------------------------------------------------------\n\n\n  publicAPI.getAnnotatedValue = idx => {\n    if (idx < 0 || idx >= model.annotationArray.length) {\n      return null;\n    }\n\n    return model.annotationArray[idx].value;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getAnnotation = idx => {\n    if (model.annotationArray[idx] === undefined) {\n      return null;\n    }\n\n    return model.annotationArray[idx].annotation;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getAnnotatedValueIndex = val => model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1; //----------------------------------------------------------------------------\n\n\n  publicAPI.removeAnnotation = value => {\n    const i = publicAPI.checkForAnnotatedValue(value);\n    const needToRemove = i >= 0;\n\n    if (needToRemove) {\n      model.annotationArray.splice(i, 1);\n      publicAPI.updateAnnotatedValueMap();\n      publicAPI.modified();\n    }\n\n    return needToRemove;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.resetAnnotations = () => {\n    model.annotationArray = [];\n    model.annotatedValueMap = [];\n    publicAPI.modified();\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getAnnotationColor = (val, rgba) => {\n    if (model.indexedLookup) {\n      const i = publicAPI.getAnnotatedValueIndex(val);\n      publicAPI.getIndexedColor(i, rgba);\n    } else {\n      publicAPI.getColor(parseFloat(val), rgba);\n      rgba[3] = 1.0;\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.checkForAnnotatedValue = value => publicAPI.getAnnotatedValueIndexInternal(value); //----------------------------------------------------------------------------\n  // An unsafe version of vtkScalarsToColors::CheckForAnnotatedValue for\n  // internal use (no pointer checks performed)\n\n\n  publicAPI.getAnnotatedValueIndexInternal = value => {\n    if (model.annotatedValueMap[value] !== undefined) {\n      const na = model.annotationArray.length;\n      return model.annotatedValueMap[value] % na;\n    } // Treat as a NaN\n\n\n    return -1;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getIndexedColor = (val, rgba) => {\n    rgba[0] = 0.0;\n    rgba[1] = 0.0;\n    rgba[2] = 0.0;\n    rgba[3] = 0.0;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.updateAnnotatedValueMap = () => {\n    model.annotatedValueMap = [];\n    const na = model.annotationArray.length;\n\n    for (let i = 0; i < na; i++) {\n      model.annotatedValueMap[model.annotationArray[i].value] = i;\n    }\n  }; // Description:\n  // Internal methods that map a data array into a 4-component,\n  // unsigned char RGBA array. The color mode determines the behavior\n  // of mapping. If ColorMode.DEFAULT is set, then unsigned char\n  // data arrays are treated as colors (and converted to RGBA if\n  // necessary); If ColorMode.DIRECT_SCALARS is set, then all arrays\n  // are treated as colors (integer types are clamped in the range 0-255,\n  // floating point arrays are clamped in the range 0.0-1.0. Note 'char' does\n  // not have enough values to represent a color so mapping this type is\n  // considered an error);\n  // otherwise, the data is mapped through this instance\n  // of ScalarsToColors. The component argument is used for data\n  // arrays with more than one component; it indicates which component\n  // to use to do the blending.  When the component argument is -1,\n  // then the this object uses its own selected technique to change a\n  // vector into a scalar to map.\n\n\n  publicAPI.mapScalars = (scalars, colorMode, componentIn) => {\n    const numberOfComponents = scalars.getNumberOfComponents();\n    let newColors = null; // map scalars through lookup table only if needed\n\n    if (colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || colorMode === ColorMode.DIRECT_SCALARS && scalars) {\n      newColors = publicAPI.convertToRGBA(scalars, numberOfComponents, scalars.getNumberOfTuples());\n    } else {\n      const newscalars = {\n        type: 'vtkDataArray',\n        name: 'temp',\n        numberOfComponents: 4,\n        dataType: VtkDataTypes.UNSIGNED_CHAR\n      };\n      const s = macro.newTypedArray(newscalars.dataType, 4 * scalars.getNumberOfTuples());\n      newscalars.values = s;\n      newscalars.size = s.length;\n      newColors = vtkDataArray.newInstance(newscalars);\n      let component = componentIn; // If mapper did not specify a component, use the VectorMode\n\n      if (component < 0 && numberOfComponents > 1) {\n        publicAPI.mapVectorsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, -1, -1);\n      } else {\n        if (component < 0) {\n          component = 0;\n        }\n\n        if (component >= numberOfComponents) {\n          component = numberOfComponents - 1;\n        } // Map the scalars to colors\n\n\n        publicAPI.mapScalarsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, component);\n      }\n    }\n\n    return newColors;\n  };\n\n  publicAPI.mapVectorsToMagnitude = (input, output, compsToUse) => {\n    const length = input.getNumberOfTuples();\n    const inIncr = input.getNumberOfComponents();\n    const outputV = output.getData();\n    const inputV = input.getData();\n\n    for (let i = 0; i < length; i++) {\n      let sum = 0.0;\n\n      for (let j = 0; j < compsToUse; j++) {\n        sum += inputV[i * inIncr + j] * inputV[i * inIncr + j];\n      }\n\n      outputV[i] = Math.sqrt(sum);\n    }\n  }; //----------------------------------------------------------------------------\n  // Map a set of vector values through the table\n\n\n  publicAPI.mapVectorsThroughTable = (input, output, outputFormat, vectorComponentIn, vectorSizeIn) => {\n    let vectorMode = publicAPI.getVectorMode();\n    let vectorSize = vectorSizeIn;\n    let vectorComponent = vectorComponentIn;\n    const inComponents = input.getNumberOfComponents();\n\n    if (vectorMode === VectorMode.COMPONENT) {\n      // make sure vectorComponent is within allowed range\n      if (vectorComponent === -1) {\n        // if set to -1, use default value provided by table\n        vectorComponent = publicAPI.getVectorComponent();\n      }\n\n      if (vectorComponent < 0) {\n        vectorComponent = 0;\n      }\n\n      if (vectorComponent >= inComponents) {\n        vectorComponent = inComponents - 1;\n      }\n    } else {\n      // make sure vectorSize is within allowed range\n      if (vectorSize === -1) {\n        // if set to -1, use default value provided by table\n        vectorSize = publicAPI.getVectorSize();\n      }\n\n      if (vectorSize <= 0) {\n        vectorComponent = 0;\n        vectorSize = inComponents;\n      } else {\n        if (vectorComponent < 0) {\n          vectorComponent = 0;\n        }\n\n        if (vectorComponent >= inComponents) {\n          vectorComponent = inComponents - 1;\n        }\n\n        if (vectorComponent + vectorSize > inComponents) {\n          vectorSize = inComponents - vectorComponent;\n        }\n      }\n\n      if (vectorMode === VectorMode.MAGNITUDE && (inComponents === 1 || vectorSize === 1)) {\n        vectorMode = VectorMode.COMPONENT;\n      }\n    } // increment input pointer to the first component to map\n\n\n    let inputOffset = 0;\n\n    if (vectorComponent > 0) {\n      inputOffset = vectorComponent;\n    } // map according to the current vector mode\n\n\n    switch (vectorMode) {\n      case VectorMode.COMPONENT:\n        {\n          publicAPI.mapScalarsThroughTable(input, output, outputFormat, inputOffset);\n          break;\n        }\n\n      case VectorMode.RGBCOLORS:\n        {\n          // publicAPI.mapColorsToColors(\n          //   input, output, inComponents, vectorSize,\n          //   outputFormat);\n          break;\n        }\n      // MAGNITUDE is considered default\n\n      case VectorMode.MAGNITUDE:\n      default:\n        {\n          const magValues = vtkDataArray.newInstance({\n            numberOfComponents: 1,\n            values: new Float32Array(input.getNumberOfTuples())\n          });\n          publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);\n          publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);\n          break;\n        }\n    }\n  };\n\n  publicAPI.luminanceToRGBA = (newColors, colors, alpha, convtFun) => {\n    const a = convtFun(alpha);\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 1;\n    let count = 0;\n\n    for (let i = component; i < size; i += tuple) {\n      const l = convtFun(values[i]);\n      newValues[count * 4] = l;\n      newValues[count * 4 + 1] = l;\n      newValues[count * 4 + 2] = l;\n      newValues[count * 4 + 3] = a;\n      count++;\n    }\n  };\n\n  publicAPI.luminanceAlphaToRGBA = (newColors, colors, alpha, convtFun) => {\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 2;\n    let count = 0;\n\n    for (let i = component; i < size; i += tuple) {\n      const l = convtFun(values[i]);\n      newValues[count] = l;\n      newValues[count + 1] = l;\n      newValues[count + 2] = l;\n      newValues[count + 3] = convtFun(values[i + 1]) * alpha;\n      count += 4;\n    }\n  };\n\n  publicAPI.rGBToRGBA = (newColors, colors, alpha, convtFun) => {\n    const a = floatColorToUChar(alpha);\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 3;\n    let count = 0;\n\n    for (let i = component; i < size; i += tuple) {\n      newValues[count * 4] = convtFun(values[i]);\n      newValues[count * 4 + 1] = convtFun(values[i + 1]);\n      newValues[count * 4 + 2] = convtFun(values[i + 2]);\n      newValues[count * 4 + 3] = a;\n      count++;\n    }\n  };\n\n  publicAPI.rGBAToRGBA = (newColors, colors, alpha, convtFun) => {\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 4;\n    let count = 0;\n\n    for (let i = component; i < size; i += tuple) {\n      newValues[count * 4] = convtFun(values[i]);\n      newValues[count * 4 + 1] = convtFun(values[i + 1]);\n      newValues[count * 4 + 2] = convtFun(values[i + 2]);\n      newValues[count * 4 + 3] = convtFun(values[i + 3]) * alpha;\n      count++;\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.convertToRGBA = (colors, numComp, numTuples) => {\n    let {\n      alpha\n    } = model;\n\n    if (numComp === 4 && alpha >= 1.0 && colors.getDataType() === VtkDataTypes.UNSIGNED_CHAR) {\n      return colors;\n    }\n\n    const newColors = vtkDataArray.newInstance({\n      numberOfComponents: 4,\n      empty: true,\n      size: 4 * numTuples,\n      dataType: VtkDataTypes.UNSIGNED_CHAR\n    });\n\n    if (numTuples <= 0) {\n      return newColors;\n    }\n\n    alpha = alpha > 0 ? alpha : 0;\n    alpha = alpha < 1 ? alpha : 1;\n    let convtFun = intColorToUChar;\n\n    if (colors.getDataType() === VtkDataTypes.FLOAT || colors.getDataType() === VtkDataTypes.DOUBLE) {\n      convtFun = floatColorToUChar;\n    }\n\n    switch (numComp) {\n      case 1:\n        publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);\n        break;\n\n      case 2:\n        publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);\n        break;\n\n      case 3:\n        publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);\n        break;\n\n      case 4:\n        publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);\n        break;\n\n      default:\n        vtkErrorMacro('Cannot convert colors');\n        return null;\n    }\n\n    return newColors;\n  };\n\n  publicAPI.usingLogScale = () => false;\n\n  publicAPI.getNumberOfAvailableColors = () => 256 * 256 * 256;\n\n  publicAPI.setRange = (min, max) => publicAPI.setMappingRange(min, max);\n\n  publicAPI.getRange = (min, max) => publicAPI.getMappingRange();\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  alpha: 1.0,\n  vectorComponent: 0,\n  vectorSize: -1,\n  vectorMode: VectorMode.COMPONENT,\n  mappingRange: null,\n  annotationArray: null,\n  annotatedValueMap: null,\n  indexedLookup: false\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Object methods\n\n  macro.obj(publicAPI, model);\n  model.mappingRange = [0, 255];\n  model.annotationArray = [];\n  model.annotatedValueMap = []; // Create get-set macros\n\n  macro.setGet(publicAPI, model, ['vectorSize', 'vectorComponent', 'vectorMode', 'alpha', 'indexedLookup']); // Create set macros for array (needs to know size)\n\n  macro.setArray(publicAPI, model, ['mappingRange'], 2); // Create get macros for array\n\n  macro.getArray(publicAPI, model, ['mappingRange']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkScalarsToColors(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkScalarsToColors'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend,\n  ...Constants\n};","map":{"version":3,"names":["macro","vtkDataArray","Constants","vtkMapper","ScalarMappingTarget","VectorMode","VtkDataTypes","ColorMode","vtkErrorMacro","intColorToUChar","c","floatColorToUChar","Math","floor","vtkScalarsToColors","publicAPI","model","classHierarchy","push","setVectorModeToMagnitude","setVectorMode","MAGNITUDE","setVectorModeToComponent","COMPONENT","setVectorModeToRGBColors","RGBCOLORS","build","isOpaque","setAnnotations","values","annotations","length","annotationArray","num","i","value","annotation","String","updateAnnotatedValueMap","modified","setAnnotation","checkForAnnotatedValue","getNumberOfAnnotatedValues","getAnnotatedValue","idx","getAnnotation","undefined","getAnnotatedValueIndex","val","removeAnnotation","needToRemove","splice","resetAnnotations","annotatedValueMap","getAnnotationColor","rgba","indexedLookup","getIndexedColor","getColor","parseFloat","getAnnotatedValueIndexInternal","na","mapScalars","scalars","colorMode","componentIn","numberOfComponents","getNumberOfComponents","newColors","DEFAULT","getDataType","UNSIGNED_CHAR","DIRECT_SCALARS","convertToRGBA","getNumberOfTuples","newscalars","type","name","dataType","s","newTypedArray","size","newInstance","component","mapVectorsThroughTable","RGBA","mapScalarsThroughTable","mapVectorsToMagnitude","input","output","compsToUse","inIncr","outputV","getData","inputV","sum","j","sqrt","outputFormat","vectorComponentIn","vectorSizeIn","vectorMode","getVectorMode","vectorSize","vectorComponent","inComponents","getVectorComponent","getVectorSize","inputOffset","magValues","Float32Array","luminanceToRGBA","colors","alpha","convtFun","a","newValues","tuple","count","l","luminanceAlphaToRGBA","rGBToRGBA","rGBAToRGBA","numComp","numTuples","empty","FLOAT","DOUBLE","usingLogScale","getNumberOfAvailableColors","setRange","min","max","setMappingRange","getRange","getMappingRange","DEFAULT_VALUES","mappingRange","extend","initialValues","Object","assign","obj","setGet","setArray","getArray"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Common/Core/ScalarsToColors/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nimport Constants from 'vtk.js/Sources/Common/Core/ScalarsToColors/Constants';\nimport vtkMapper from 'vtk.js/Sources/Rendering/Core/Mapper/Constants'; // Need to go inside Constants otherwise dependency loop\n\nconst { ScalarMappingTarget, VectorMode } = Constants;\nconst { VtkDataTypes } = vtkDataArray;\nconst { ColorMode } = vtkMapper;\nconst { vtkErrorMacro } = macro;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n// Add module-level functions or api that you want to expose statically via\n// the next section...\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nfunction intColorToUChar(c) {\n  return c;\n}\nfunction floatColorToUChar(c) {\n  return Math.floor(c * 255.0 + 0.5);\n}\n\n// ----------------------------------------------------------------------------\n// vtkScalarsToColors methods\n// ----------------------------------------------------------------------------\n\nfunction vtkScalarsToColors(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkScalarsToColors');\n\n  publicAPI.setVectorModeToMagnitude = () =>\n    publicAPI.setVectorMode(VectorMode.MAGNITUDE);\n  publicAPI.setVectorModeToComponent = () =>\n    publicAPI.setVectorMode(VectorMode.COMPONENT);\n  publicAPI.setVectorModeToRGBColors = () =>\n    publicAPI.setVectorMode(VectorMode.RGBCOLORS);\n\n  publicAPI.build = () => {};\n\n  publicAPI.isOpaque = () => true;\n\n  //----------------------------------------------------------------------------\n  publicAPI.setAnnotations = (values, annotations) => {\n    if ((values && !annotations) || (!values && annotations)) {\n      return;\n    }\n\n    if (values && annotations && values.length !== annotations.length) {\n      vtkErrorMacro(\n        'Values and annotations do not have the same number of tuples so ignoring'\n      );\n      return;\n    }\n\n    model.annotationArray = [];\n\n    if (annotations && values) {\n      const num = annotations.length;\n      for (let i = 0; i < num; i++) {\n        model.annotationArray.push({\n          value: values[i],\n          annotation: String(annotations[i]),\n        });\n      }\n    }\n\n    publicAPI.updateAnnotatedValueMap();\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.setAnnotation = (value, annotation) => {\n    let i = publicAPI.checkForAnnotatedValue(value);\n    let modified = false;\n    if (i >= 0) {\n      if (model.annotationArray[i].annotation !== annotation) {\n        model.annotationArray[i].annotation = annotation;\n        modified = true;\n      }\n    } else {\n      model.annotationArray.push({ value, annotation });\n      i = model.annotationArray.length - 1;\n      modified = true;\n    }\n    if (modified) {\n      publicAPI.updateAnnotatedValueMap();\n      publicAPI.modified();\n    }\n    return i;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getNumberOfAnnotatedValues = () => model.annotationArray.length;\n\n  //----------------------------------------------------------------------------\n  publicAPI.getAnnotatedValue = (idx) => {\n    if (idx < 0 || idx >= model.annotationArray.length) {\n      return null;\n    }\n    return model.annotationArray[idx].value;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getAnnotation = (idx) => {\n    if (model.annotationArray[idx] === undefined) {\n      return null;\n    }\n    return model.annotationArray[idx].annotation;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getAnnotatedValueIndex = (val) =>\n    model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1;\n\n  //----------------------------------------------------------------------------\n  publicAPI.removeAnnotation = (value) => {\n    const i = publicAPI.checkForAnnotatedValue(value);\n    const needToRemove = i >= 0;\n    if (needToRemove) {\n      model.annotationArray.splice(i, 1);\n      publicAPI.updateAnnotatedValueMap();\n      publicAPI.modified();\n    }\n    return needToRemove;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.resetAnnotations = () => {\n    model.annotationArray = [];\n    model.annotatedValueMap = [];\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getAnnotationColor = (val, rgba) => {\n    if (model.indexedLookup) {\n      const i = publicAPI.getAnnotatedValueIndex(val);\n      publicAPI.getIndexedColor(i, rgba);\n    } else {\n      publicAPI.getColor(parseFloat(val), rgba);\n      rgba[3] = 1.0;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.checkForAnnotatedValue = (value) =>\n    publicAPI.getAnnotatedValueIndexInternal(value);\n\n  //----------------------------------------------------------------------------\n  // An unsafe version of vtkScalarsToColors::CheckForAnnotatedValue for\n  // internal use (no pointer checks performed)\n  publicAPI.getAnnotatedValueIndexInternal = (value) => {\n    if (model.annotatedValueMap[value] !== undefined) {\n      const na = model.annotationArray.length;\n      return model.annotatedValueMap[value] % na;\n    }\n    // Treat as a NaN\n    return -1;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getIndexedColor = (val, rgba) => {\n    rgba[0] = 0.0;\n    rgba[1] = 0.0;\n    rgba[2] = 0.0;\n    rgba[3] = 0.0;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.updateAnnotatedValueMap = () => {\n    model.annotatedValueMap = [];\n\n    const na = model.annotationArray.length;\n    for (let i = 0; i < na; i++) {\n      model.annotatedValueMap[model.annotationArray[i].value] = i;\n    }\n  };\n\n  // Description:\n  // Internal methods that map a data array into a 4-component,\n  // unsigned char RGBA array. The color mode determines the behavior\n  // of mapping. If ColorMode.DEFAULT is set, then unsigned char\n  // data arrays are treated as colors (and converted to RGBA if\n  // necessary); If ColorMode.DIRECT_SCALARS is set, then all arrays\n  // are treated as colors (integer types are clamped in the range 0-255,\n  // floating point arrays are clamped in the range 0.0-1.0. Note 'char' does\n  // not have enough values to represent a color so mapping this type is\n  // considered an error);\n  // otherwise, the data is mapped through this instance\n  // of ScalarsToColors. The component argument is used for data\n  // arrays with more than one component; it indicates which component\n  // to use to do the blending.  When the component argument is -1,\n  // then the this object uses its own selected technique to change a\n  // vector into a scalar to map.\n  publicAPI.mapScalars = (scalars, colorMode, componentIn) => {\n    const numberOfComponents = scalars.getNumberOfComponents();\n\n    let newColors = null;\n\n    // map scalars through lookup table only if needed\n    if (\n      (colorMode === ColorMode.DEFAULT &&\n        scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR) ||\n      (colorMode === ColorMode.DIRECT_SCALARS && scalars)\n    ) {\n      newColors = publicAPI.convertToRGBA(\n        scalars,\n        numberOfComponents,\n        scalars.getNumberOfTuples()\n      );\n    } else {\n      const newscalars = {\n        type: 'vtkDataArray',\n        name: 'temp',\n        numberOfComponents: 4,\n        dataType: VtkDataTypes.UNSIGNED_CHAR,\n      };\n\n      const s = macro.newTypedArray(\n        newscalars.dataType,\n        4 * scalars.getNumberOfTuples()\n      );\n      newscalars.values = s;\n      newscalars.size = s.length;\n      newColors = vtkDataArray.newInstance(newscalars);\n\n      let component = componentIn;\n\n      // If mapper did not specify a component, use the VectorMode\n      if (component < 0 && numberOfComponents > 1) {\n        publicAPI.mapVectorsThroughTable(\n          scalars,\n          newColors,\n          ScalarMappingTarget.RGBA,\n          -1,\n          -1\n        );\n      } else {\n        if (component < 0) {\n          component = 0;\n        }\n        if (component >= numberOfComponents) {\n          component = numberOfComponents - 1;\n        }\n\n        // Map the scalars to colors\n        publicAPI.mapScalarsThroughTable(\n          scalars,\n          newColors,\n          ScalarMappingTarget.RGBA,\n          component\n        );\n      }\n    }\n\n    return newColors;\n  };\n\n  publicAPI.mapVectorsToMagnitude = (input, output, compsToUse) => {\n    const length = input.getNumberOfTuples();\n    const inIncr = input.getNumberOfComponents();\n\n    const outputV = output.getData();\n    const inputV = input.getData();\n\n    for (let i = 0; i < length; i++) {\n      let sum = 0.0;\n      for (let j = 0; j < compsToUse; j++) {\n        sum += inputV[i * inIncr + j] * inputV[i * inIncr + j];\n      }\n      outputV[i] = Math.sqrt(sum);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  // Map a set of vector values through the table\n  publicAPI.mapVectorsThroughTable = (\n    input,\n    output,\n    outputFormat,\n    vectorComponentIn,\n    vectorSizeIn\n  ) => {\n    let vectorMode = publicAPI.getVectorMode();\n    let vectorSize = vectorSizeIn;\n    let vectorComponent = vectorComponentIn;\n    const inComponents = input.getNumberOfComponents();\n\n    if (vectorMode === VectorMode.COMPONENT) {\n      // make sure vectorComponent is within allowed range\n      if (vectorComponent === -1) {\n        // if set to -1, use default value provided by table\n        vectorComponent = publicAPI.getVectorComponent();\n      }\n      if (vectorComponent < 0) {\n        vectorComponent = 0;\n      }\n      if (vectorComponent >= inComponents) {\n        vectorComponent = inComponents - 1;\n      }\n    } else {\n      // make sure vectorSize is within allowed range\n      if (vectorSize === -1) {\n        // if set to -1, use default value provided by table\n        vectorSize = publicAPI.getVectorSize();\n      }\n      if (vectorSize <= 0) {\n        vectorComponent = 0;\n        vectorSize = inComponents;\n      } else {\n        if (vectorComponent < 0) {\n          vectorComponent = 0;\n        }\n        if (vectorComponent >= inComponents) {\n          vectorComponent = inComponents - 1;\n        }\n        if (vectorComponent + vectorSize > inComponents) {\n          vectorSize = inComponents - vectorComponent;\n        }\n      }\n\n      if (\n        vectorMode === VectorMode.MAGNITUDE &&\n        (inComponents === 1 || vectorSize === 1)\n      ) {\n        vectorMode = VectorMode.COMPONENT;\n      }\n    }\n\n    // increment input pointer to the first component to map\n    let inputOffset = 0;\n    if (vectorComponent > 0) {\n      inputOffset = vectorComponent;\n    }\n\n    // map according to the current vector mode\n    switch (vectorMode) {\n      case VectorMode.COMPONENT: {\n        publicAPI.mapScalarsThroughTable(\n          input,\n          output,\n          outputFormat,\n          inputOffset\n        );\n        break;\n      }\n\n      case VectorMode.RGBCOLORS: {\n        // publicAPI.mapColorsToColors(\n        //   input, output, inComponents, vectorSize,\n        //   outputFormat);\n        break;\n      }\n\n      // MAGNITUDE is considered default\n      case VectorMode.MAGNITUDE:\n      default: {\n        const magValues = vtkDataArray.newInstance({\n          numberOfComponents: 1,\n          values: new Float32Array(input.getNumberOfTuples()),\n        });\n\n        publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);\n        publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);\n        break;\n      }\n    }\n  };\n\n  publicAPI.luminanceToRGBA = (newColors, colors, alpha, convtFun) => {\n    const a = convtFun(alpha);\n\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 1;\n\n    let count = 0;\n    for (let i = component; i < size; i += tuple) {\n      const l = convtFun(values[i]);\n      newValues[count * 4] = l;\n      newValues[count * 4 + 1] = l;\n      newValues[count * 4 + 2] = l;\n      newValues[count * 4 + 3] = a;\n      count++;\n    }\n  };\n\n  publicAPI.luminanceAlphaToRGBA = (newColors, colors, alpha, convtFun) => {\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 2;\n\n    let count = 0;\n    for (let i = component; i < size; i += tuple) {\n      const l = convtFun(values[i]);\n      newValues[count] = l;\n      newValues[count + 1] = l;\n      newValues[count + 2] = l;\n      newValues[count + 3] = convtFun(values[i + 1]) * alpha;\n      count += 4;\n    }\n  };\n\n  publicAPI.rGBToRGBA = (newColors, colors, alpha, convtFun) => {\n    const a = floatColorToUChar(alpha);\n\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 3;\n\n    let count = 0;\n    for (let i = component; i < size; i += tuple) {\n      newValues[count * 4] = convtFun(values[i]);\n      newValues[count * 4 + 1] = convtFun(values[i + 1]);\n      newValues[count * 4 + 2] = convtFun(values[i + 2]);\n      newValues[count * 4 + 3] = a;\n      count++;\n    }\n  };\n\n  publicAPI.rGBAToRGBA = (newColors, colors, alpha, convtFun) => {\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 4;\n\n    let count = 0;\n    for (let i = component; i < size; i += tuple) {\n      newValues[count * 4] = convtFun(values[i]);\n      newValues[count * 4 + 1] = convtFun(values[i + 1]);\n      newValues[count * 4 + 2] = convtFun(values[i + 2]);\n      newValues[count * 4 + 3] = convtFun(values[i + 3]) * alpha;\n      count++;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.convertToRGBA = (colors, numComp, numTuples) => {\n    let { alpha } = model;\n    if (\n      numComp === 4 &&\n      alpha >= 1.0 &&\n      colors.getDataType() === VtkDataTypes.UNSIGNED_CHAR\n    ) {\n      return colors;\n    }\n\n    const newColors = vtkDataArray.newInstance({\n      numberOfComponents: 4,\n      empty: true,\n      size: 4 * numTuples,\n      dataType: VtkDataTypes.UNSIGNED_CHAR,\n    });\n\n    if (numTuples <= 0) {\n      return newColors;\n    }\n\n    alpha = alpha > 0 ? alpha : 0;\n    alpha = alpha < 1 ? alpha : 1;\n\n    let convtFun = intColorToUChar;\n    if (\n      colors.getDataType() === VtkDataTypes.FLOAT ||\n      colors.getDataType() === VtkDataTypes.DOUBLE\n    ) {\n      convtFun = floatColorToUChar;\n    }\n\n    switch (numComp) {\n      case 1:\n        publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);\n        break;\n\n      case 2:\n        publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);\n        break;\n\n      case 3:\n        publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);\n        break;\n\n      case 4:\n        publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);\n        break;\n\n      default:\n        vtkErrorMacro('Cannot convert colors');\n        return null;\n    }\n\n    return newColors;\n  };\n\n  publicAPI.usingLogScale = () => false;\n\n  publicAPI.getNumberOfAvailableColors = () => 256 * 256 * 256;\n\n  publicAPI.setRange = (min, max) => publicAPI.setMappingRange(min, max);\n  publicAPI.getRange = (min, max) => publicAPI.getMappingRange();\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  alpha: 1.0,\n  vectorComponent: 0,\n  vectorSize: -1,\n  vectorMode: VectorMode.COMPONENT,\n  mappingRange: null,\n  annotationArray: null,\n  annotatedValueMap: null,\n  indexedLookup: false,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n\n  model.mappingRange = [0, 255];\n  model.annotationArray = [];\n  model.annotatedValueMap = [];\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, [\n    'vectorSize',\n    'vectorComponent',\n    'vectorMode',\n    'alpha',\n    'indexedLookup',\n  ]);\n\n  // Create set macros for array (needs to know size)\n  macro.setArray(publicAPI, model, ['mappingRange'], 2);\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, ['mappingRange']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkScalarsToColors(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkScalarsToColors');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend, ...Constants };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}