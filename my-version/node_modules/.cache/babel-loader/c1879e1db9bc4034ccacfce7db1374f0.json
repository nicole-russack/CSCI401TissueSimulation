{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport { CellType, CellTypesStrings } from 'vtk.js/Sources/Common/DataModel/CellTypes/Constants'; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n/**\n * Given an int (as defined in vtkCellType.h) identifier for a class\n * return it's classname.\n */\n\nfunction getClassNameFromTypeId(typeId) {\n  return typeId < CellTypesStrings.length ? CellTypesStrings[typeId] : 'UnknownClass';\n}\n/**\n * Given a data object classname, return it's int identified (as\n * defined in vtkCellType.h)\n */\n\n\nfunction getTypeIdFromClassName(cellTypeString) {\n  return CellTypesStrings.findIndex(cellTypeString);\n}\n/**\n * This convenience method is a fast check to determine if a cell type\n * represents a linear or nonlinear cell.  This is generally much more\n * efficient than getting the appropriate vtkCell and checking its IsLinear\n * method.\n */\n\n\nfunction isLinear(type) {\n  return type < CellType.VTK_QUADRATIC_EDGE || type === CellType.VTK_CONVEX_POINT_SET || type === CellType.VTK_POLYHEDRON;\n}\n\nfunction hasSubCells(cellType) {\n  return cellType === CellType.VTK_TRIANGLE_STRIP || cellType === CellType.VTK_POLY_LINE || cellType === CellType.VTK_POLY_VERTEX;\n} // ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\n\nexport const STATIC = {\n  getClassNameFromTypeId,\n  getTypeIdFromClassName,\n  isLinear,\n  hasSubCells\n}; // ----------------------------------------------------------------------------\n// vtkCellTypes methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellTypes(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellTypes');\n  /**\n   * Allocate memory for this array. Delete old storage only if necessary.\n   */\n\n  publicAPI.allocate = function () {\n    let sz = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 512;\n    let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    model.size = sz > 0 ? sz : 1;\n    model.extend = ext > 0 ? ext : 1;\n    model.maxId = -1;\n    model.typeArray = new Uint8Array(sz);\n    model.locationArray = new Uint32Array(sz);\n  };\n  /**\n   * Add a cell at specified id.\n   */\n\n\n  publicAPI.insertCell = (cellId, type, loc) => {\n    model.typeArray[cellId] = type;\n    model.locationArray[cellId] = loc;\n\n    if (cellId > model.maxId) {\n      model.maxId = cellId;\n    }\n  };\n  /**\n   * Add a cell to the object in the next available slot.\n   */\n\n\n  publicAPI.insertNextCell = (type, loc) => {\n    publicAPI.insertCell(++model.maxId, type, loc);\n    return model.maxId;\n  };\n  /**\n   * Specify a group of cell types. This version is provided to maintain\n   * backwards compatibility and does a copy of the cellLocations\n   */\n\n\n  publicAPI.setCellTypes = (ncells, cellTypes, cellLocations) => {\n    model.size = ncells;\n    model.typeArray = cellTypes;\n    model.locationArray = cellLocations;\n    model.maxId = ncells - 1;\n  };\n  /**\n   * Return the location of the cell in the associated vtkCellArray.\n   */\n\n\n  publicAPI.getCellLocation = cellId => model.locationArray[cellId];\n  /**\n   * Delete cell by setting to nullptr cell type.\n   */\n\n\n  publicAPI.deleteCell = cellId => {\n    model.typeArray[cellId] = CellType.VTK_EMPTY_CELL;\n  };\n  /**\n   * Return the number of types in the list.\n   */\n\n\n  publicAPI.getNumberOfTypes = () => model.maxId + 1;\n  /**\n   * Return true if type specified is contained in list; false otherwise.\n   */\n\n\n  publicAPI.isType = type => {\n    const numTypes = publicAPI.getNumberOfTypes();\n\n    for (let i = 0; i < numTypes; ++i) {\n      if (type === publicAPI.getCellType(i)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Add the type specified to the end of the list. Range checking is performed.\n   */\n\n\n  publicAPI.insertNextType = type => publicAPI.insertNextCell(type, -1);\n  /**\n   * Return the type of cell.\n   */\n\n\n  publicAPI.getCellType = cellId => model.typeArray[cellId];\n  /**\n   * Reclaim any extra memory.\n   */\n  // TODO: publicAPI.squeeze = () =>  {};\n\n  /**\n   * Initialize object without releasing memory.\n   */\n\n\n  publicAPI.reset = () => {\n    model.maxId = -1;\n  };\n  /**\n   * Standard DeepCopy method.  Since this object contains no reference\n   * to other objects, there is no ShallowCopy.\n   */\n\n\n  publicAPI.deepCopy = src => {\n    publicAPI.allocate(src.getSize(), src.getExtend());\n    model.typeArray.set(src.getTypeArray());\n    model.locationArray.set(src.getLocationArray());\n    model.maxId = src.getMaxId();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  // typeArray: null, // pointer to types array\n  // locationArray: null;   // pointer to array of offsets\n  size: 0,\n  // allocated size of data\n  maxId: -1,\n  // maximum index inserted thus far\n  extend: 1000 // grow array by this point\n\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['size', 'maxId', 'extend']);\n  macro.getArray(publicAPI, model, ['typeArray', 'locationArray']);\n  vtkCellTypes(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkCellTypes'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend,\n  ...STATIC\n};","map":{"version":3,"names":["macro","CellType","CellTypesStrings","getClassNameFromTypeId","typeId","length","getTypeIdFromClassName","cellTypeString","findIndex","isLinear","type","VTK_QUADRATIC_EDGE","VTK_CONVEX_POINT_SET","VTK_POLYHEDRON","hasSubCells","cellType","VTK_TRIANGLE_STRIP","VTK_POLY_LINE","VTK_POLY_VERTEX","STATIC","vtkCellTypes","publicAPI","model","classHierarchy","push","allocate","sz","ext","size","extend","maxId","typeArray","Uint8Array","locationArray","Uint32Array","insertCell","cellId","loc","insertNextCell","setCellTypes","ncells","cellTypes","cellLocations","getCellLocation","deleteCell","VTK_EMPTY_CELL","getNumberOfTypes","isType","numTypes","i","getCellType","insertNextType","reset","deepCopy","src","getSize","getExtend","set","getTypeArray","getLocationArray","getMaxId","DEFAULT_VALUES","initialValues","Object","assign","obj","get","getArray","newInstance"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Common/DataModel/CellTypes/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport {\n  CellType,\n  CellTypesStrings,\n} from 'vtk.js/Sources/Common/DataModel/CellTypes/Constants';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n/**\n * Given an int (as defined in vtkCellType.h) identifier for a class\n * return it's classname.\n */\nfunction getClassNameFromTypeId(typeId) {\n  return typeId < CellTypesStrings.length\n    ? CellTypesStrings[typeId]\n    : 'UnknownClass';\n}\n\n/**\n * Given a data object classname, return it's int identified (as\n * defined in vtkCellType.h)\n */\nfunction getTypeIdFromClassName(cellTypeString) {\n  return CellTypesStrings.findIndex(cellTypeString);\n}\n\n/**\n * This convenience method is a fast check to determine if a cell type\n * represents a linear or nonlinear cell.  This is generally much more\n * efficient than getting the appropriate vtkCell and checking its IsLinear\n * method.\n */\nfunction isLinear(type) {\n  return (\n    type < CellType.VTK_QUADRATIC_EDGE ||\n    type === CellType.VTK_CONVEX_POINT_SET ||\n    type === CellType.VTK_POLYHEDRON\n  );\n}\n\nfunction hasSubCells(cellType) {\n  return (\n    cellType === CellType.VTK_TRIANGLE_STRIP ||\n    cellType === CellType.VTK_POLY_LINE ||\n    cellType === CellType.VTK_POLY_VERTEX\n  );\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nexport const STATIC = {\n  getClassNameFromTypeId,\n  getTypeIdFromClassName,\n  isLinear,\n  hasSubCells,\n};\n\n// ----------------------------------------------------------------------------\n// vtkCellTypes methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellTypes(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellTypes');\n\n  /**\n   * Allocate memory for this array. Delete old storage only if necessary.\n   */\n  publicAPI.allocate = (sz = 512, ext = 1000) => {\n    model.size = sz > 0 ? sz : 1;\n    model.extend = ext > 0 ? ext : 1;\n    model.maxId = -1;\n    model.typeArray = new Uint8Array(sz);\n    model.locationArray = new Uint32Array(sz);\n  };\n\n  /**\n   * Add a cell at specified id.\n   */\n  publicAPI.insertCell = (cellId, type, loc) => {\n    model.typeArray[cellId] = type;\n    model.locationArray[cellId] = loc;\n\n    if (cellId > model.maxId) {\n      model.maxId = cellId;\n    }\n  };\n\n  /**\n   * Add a cell to the object in the next available slot.\n   */\n  publicAPI.insertNextCell = (type, loc) => {\n    publicAPI.insertCell(++model.maxId, type, loc);\n    return model.maxId;\n  };\n\n  /**\n   * Specify a group of cell types. This version is provided to maintain\n   * backwards compatibility and does a copy of the cellLocations\n   */\n  publicAPI.setCellTypes = (ncells, cellTypes, cellLocations) => {\n    model.size = ncells;\n\n    model.typeArray = cellTypes;\n    model.locationArray = cellLocations;\n\n    model.maxId = ncells - 1;\n  };\n\n  /**\n   * Return the location of the cell in the associated vtkCellArray.\n   */\n  publicAPI.getCellLocation = (cellId) => model.locationArray[cellId];\n\n  /**\n   * Delete cell by setting to nullptr cell type.\n   */\n  publicAPI.deleteCell = (cellId) => {\n    model.typeArray[cellId] = CellType.VTK_EMPTY_CELL;\n  };\n\n  /**\n   * Return the number of types in the list.\n   */\n  publicAPI.getNumberOfTypes = () => model.maxId + 1;\n\n  /**\n   * Return true if type specified is contained in list; false otherwise.\n   */\n  publicAPI.isType = (type) => {\n    const numTypes = publicAPI.getNumberOfTypes();\n\n    for (let i = 0; i < numTypes; ++i) {\n      if (type === publicAPI.getCellType(i)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Add the type specified to the end of the list. Range checking is performed.\n   */\n  publicAPI.insertNextType = (type) => publicAPI.insertNextCell(type, -1);\n\n  /**\n   * Return the type of cell.\n   */\n  publicAPI.getCellType = (cellId) => model.typeArray[cellId];\n\n  /**\n   * Reclaim any extra memory.\n   */\n  // TODO: publicAPI.squeeze = () =>  {};\n\n  /**\n   * Initialize object without releasing memory.\n   */\n  publicAPI.reset = () => {\n    model.maxId = -1;\n  };\n\n  /**\n   * Standard DeepCopy method.  Since this object contains no reference\n   * to other objects, there is no ShallowCopy.\n   */\n  publicAPI.deepCopy = (src) => {\n    publicAPI.allocate(src.getSize(), src.getExtend());\n    model.typeArray.set(src.getTypeArray());\n    model.locationArray.set(src.getLocationArray());\n    model.maxId = src.getMaxId();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // typeArray: null, // pointer to types array\n  // locationArray: null;   // pointer to array of offsets\n  size: 0, // allocated size of data\n  maxId: -1, // maximum index inserted thus far\n  extend: 1000, // grow array by this point\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  macro.obj(publicAPI, model);\n\n  macro.get(publicAPI, model, ['size', 'maxId', 'extend']);\n  macro.getArray(publicAPI, model, ['typeArray', 'locationArray']);\n\n  vtkCellTypes(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkCellTypes');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend, ...STATIC };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}