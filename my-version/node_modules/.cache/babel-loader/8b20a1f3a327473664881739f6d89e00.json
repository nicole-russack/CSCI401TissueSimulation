{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport vtkFieldData from 'vtk.js/Sources/Common/DataModel/DataSetAttributes/FieldData';\nimport Constants from 'vtk.js/Sources/Common/DataModel/DataSetAttributes/Constants';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nconst {\n  AttributeTypes,\n  AttributeCopyOperations\n} = Constants;\nconst {\n  vtkWarningMacro\n} = macro; // ----------------------------------------------------------------------------\n// vtkDataSetAttributes methods\n// ----------------------------------------------------------------------------\n\nfunction vtkDataSetAttributes(publicAPI, model) {\n  const attrTypes = ['Scalars', 'Vectors', 'Normals', 'TCoords', 'Tensors', 'GlobalIds', 'PedigreeIds'];\n\n  function cleanAttributeType(attType) {\n    // Given an integer or string, convert the result to one of the\n    // strings in the \"attrTypes\" array above or null (if\n    // no match is found)\n    let cleanAttType = attrTypes.find(ee => AttributeTypes[ee.toUpperCase()] === attType || typeof attType !== 'number' && ee.toLowerCase() === attType.toLowerCase());\n\n    if (typeof cleanAttType === 'undefined') {\n      cleanAttType = null;\n    }\n\n    return cleanAttType;\n  } // Set our className\n\n\n  model.classHierarchy.push('vtkDataSetAttributes');\n\n  publicAPI.checkNumberOfComponents = x => true; // TODO\n\n\n  publicAPI.setAttribute = (arr, uncleanAttType) => {\n    const attType = cleanAttributeType(uncleanAttType);\n\n    if (arr && attType.toUpperCase() === 'PEDIGREEIDS' && !arr.isA('vtkDataArray')) {\n      vtkWarningMacro(`Cannot set attribute ${attType}. The attribute must be a vtkDataArray.`);\n      return -1;\n    }\n\n    if (arr && !publicAPI.checkNumberOfComponents(arr, attType)) {\n      vtkWarningMacro(`Cannot set attribute ${attType}. Incorrect number of components.`);\n      return -1;\n    }\n\n    let currentAttribute = model[`active${attType}`];\n\n    if (currentAttribute >= 0 && currentAttribute < model.arrays.length) {\n      if (model.arrays[currentAttribute] === arr) {\n        return currentAttribute;\n      }\n\n      publicAPI.removeArrayByIndex(currentAttribute);\n    }\n\n    if (arr) {\n      currentAttribute = publicAPI.addArray(arr);\n      model[`active${attType}`] = currentAttribute;\n    } else {\n      model[`active${attType}`] = -1;\n    }\n\n    publicAPI.modified();\n    return model[`active${attType}`];\n  };\n\n  publicAPI.getAttributes = arr => attrTypes.filter(attrType => publicAPI[`get${attrType}`]() === arr);\n\n  publicAPI.setActiveAttributeByName = (arrayName, attType) => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, attType);\n\n  publicAPI.setActiveAttributeByIndex = (arrayIdx, uncleanAttType) => {\n    const attType = cleanAttributeType(uncleanAttType);\n\n    if (arrayIdx >= 0 && arrayIdx < model.arrays.length) {\n      if (attType.toUpperCase() !== 'PEDIGREEIDS') {\n        const arr = publicAPI.getArrayByIndex(arrayIdx);\n\n        if (!arr.isA('vtkDataArray')) {\n          vtkWarningMacro(`Cannot set attribute ${attType}. Only vtkDataArray subclasses can be set as active attributes.`);\n          return -1;\n        }\n\n        if (!publicAPI.checkNumberOfComponents(arr, attType)) {\n          vtkWarningMacro(`Cannot set attribute ${attType}. Incorrect number of components.`);\n          return -1;\n        }\n      }\n\n      model[`active${attType}`] = arrayIdx;\n      publicAPI.modified();\n      return arrayIdx;\n    }\n\n    if (arrayIdx === -1) {\n      model[`active${attType}`] = arrayIdx;\n      publicAPI.modified();\n    }\n\n    return -1;\n  };\n\n  publicAPI.getActiveAttribute = attType => {\n    // Given an integer enum value or a string (with random capitalization),\n    // find the matching string in attrTypes.\n    const cleanAttType = cleanAttributeType(attType);\n    return publicAPI[`get${cleanAttType}`]();\n  }; // Override to allow proper handling of active attributes\n\n\n  publicAPI.removeAllArrays = () => {\n    model.arrays = [];\n    attrTypes.forEach(attType => {\n      model[`active${attType}`] = -1;\n    });\n  }; // Override to allow proper handling of active attributes\n\n\n  publicAPI.removeArray = arrayName => {\n    model.arrays = model.arrays.filter((entry, idx) => {\n      if (arrayName === entry.data.getName()) {\n        // Found the array to remove, but is it an active attribute?\n        attrTypes.forEach(attType => {\n          if (idx === model[`active${attType}`]) {\n            model[`active${attType}`] = -1;\n          }\n        });\n        return false;\n      }\n\n      return true;\n    });\n  }; // Override to allow proper handling of active attributes\n\n\n  publicAPI.removeArrayByIndex = arrayIdx => {\n    model.arrays = model.arrays.filter((entry, idx) => idx !== arrayIdx);\n    attrTypes.forEach(attType => {\n      if (arrayIdx === model[`active${attType}`]) {\n        model[`active${attType}`] = -1;\n      }\n    });\n  };\n\n  attrTypes.forEach(value => {\n    const activeVal = `active${value}`;\n\n    publicAPI[`get${value}`] = () => publicAPI.getArrayByIndex(model[activeVal]);\n\n    publicAPI[`set${value}`] = da => publicAPI.setAttribute(da, value);\n\n    publicAPI[`setActive${value}`] = arrayName => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, value);\n\n    publicAPI[`copy${value}Off`] = () => {\n      const attType = value.toUpperCase();\n      model.copyAttributeFlags[AttributeCopyOperations.PASSDATA][AttributeTypes[attType]] = false;\n    };\n\n    publicAPI[`copy${value}On`] = () => {\n      const attType = value.toUpperCase();\n      model.copyAttributeFlags[AttributeCopyOperations.PASSDATA][AttributeTypes[attType]] = true;\n    };\n  });\n\n  publicAPI.initializeAttributeCopyFlags = () => {\n    // Default to copying all attributes in every circumstance:\n    model.copyAttributeFlags = [];\n    Object.keys(AttributeCopyOperations).filter(op => op !== 'ALLCOPY').forEach(attCopyOp => {\n      model.copyAttributeFlags[AttributeCopyOperations[attCopyOp]] = Object.keys(AttributeTypes).filter(ty => ty !== 'NUM_ATTRIBUTES').reduce((a, b) => {\n        a[AttributeTypes[b]] = true;\n        return a;\n      }, []);\n    }); // Override some operations where we don't want to copy:\n\n    model.copyAttributeFlags[AttributeCopyOperations.COPYTUPLE][AttributeTypes.GLOBALIDS] = false;\n    model.copyAttributeFlags[AttributeCopyOperations.INTERPOLATE][AttributeTypes.GLOBALIDS] = false;\n    model.copyAttributeFlags[AttributeCopyOperations.COPYTUPLE][AttributeTypes.PEDIGREEIDS] = false;\n  };\n\n  publicAPI.initialize = macro.chain(publicAPI.initialize, publicAPI.initializeAttributeCopyFlags); // Process dataArrays if any\n\n  if (model.dataArrays && Object.keys(model.dataArrays).length) {\n    Object.keys(model.dataArrays).forEach(name => {\n      if (!model.dataArrays[name].ref && model.dataArrays[name].type === 'vtkDataArray') {\n        publicAPI.addArray(vtkDataArray.newInstance(model.dataArrays[name]));\n      }\n    });\n  }\n\n  const superShallowCopy = publicAPI.shallowCopy;\n\n  publicAPI.shallowCopy = (other, debug) => {\n    superShallowCopy(other, debug);\n    model.arrays = other.getArrays().map(arr => {\n      const arrNew = arr.newClone();\n      arrNew.shallowCopy(arr, debug);\n      return {\n        data: arrNew\n      };\n    });\n  };\n\n  publicAPI.initializeAttributeCopyFlags();\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  activeScalars: -1,\n  activeVectors: -1,\n  activeTensors: -1,\n  activeNormals: -1,\n  activeTCoords: -1,\n  activeGlobalIds: -1,\n  activePedigreeIds: -1\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Object methods\n\n  vtkFieldData.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['activeScalars', 'activeNormals', 'activeTCoords', 'activeVectors', 'activeTensors', 'activeGlobalIds', 'activePedigreeIds']);\n\n  if (!model.arrays) {\n    model.arrays = {};\n  } // Object specific methods\n\n\n  vtkDataSetAttributes(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkDataSetAttributes'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend,\n  ...Constants\n};","map":{"version":3,"names":["macro","vtkFieldData","Constants","vtkDataArray","AttributeTypes","AttributeCopyOperations","vtkWarningMacro","vtkDataSetAttributes","publicAPI","model","attrTypes","cleanAttributeType","attType","cleanAttType","find","ee","toUpperCase","toLowerCase","classHierarchy","push","checkNumberOfComponents","x","setAttribute","arr","uncleanAttType","isA","currentAttribute","arrays","length","removeArrayByIndex","addArray","modified","getAttributes","filter","attrType","setActiveAttributeByName","arrayName","setActiveAttributeByIndex","getArrayWithIndex","index","arrayIdx","getArrayByIndex","getActiveAttribute","removeAllArrays","forEach","removeArray","entry","idx","data","getName","value","activeVal","da","copyAttributeFlags","PASSDATA","initializeAttributeCopyFlags","Object","keys","op","attCopyOp","ty","reduce","a","b","COPYTUPLE","GLOBALIDS","INTERPOLATE","PEDIGREEIDS","initialize","chain","dataArrays","name","ref","type","newInstance","superShallowCopy","shallowCopy","other","debug","getArrays","map","arrNew","newClone","DEFAULT_VALUES","activeScalars","activeVectors","activeTensors","activeNormals","activeTCoords","activeGlobalIds","activePedigreeIds","extend","initialValues","assign","setGet"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Common/DataModel/DataSetAttributes/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport vtkFieldData from 'vtk.js/Sources/Common/DataModel/DataSetAttributes/FieldData';\nimport Constants from 'vtk.js/Sources/Common/DataModel/DataSetAttributes/Constants';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\n\nconst { AttributeTypes, AttributeCopyOperations } = Constants;\nconst { vtkWarningMacro } = macro;\n\n// ----------------------------------------------------------------------------\n// vtkDataSetAttributes methods\n// ----------------------------------------------------------------------------\n\nfunction vtkDataSetAttributes(publicAPI, model) {\n  const attrTypes = [\n    'Scalars',\n    'Vectors',\n    'Normals',\n    'TCoords',\n    'Tensors',\n    'GlobalIds',\n    'PedigreeIds',\n  ];\n\n  function cleanAttributeType(attType) {\n    // Given an integer or string, convert the result to one of the\n    // strings in the \"attrTypes\" array above or null (if\n    // no match is found)\n    let cleanAttType = attrTypes.find(\n      (ee) =>\n        AttributeTypes[ee.toUpperCase()] === attType ||\n        (typeof attType !== 'number' &&\n          ee.toLowerCase() === attType.toLowerCase())\n    );\n    if (typeof cleanAttType === 'undefined') {\n      cleanAttType = null;\n    }\n    return cleanAttType;\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkDataSetAttributes');\n\n  publicAPI.checkNumberOfComponents = (x) => true; // TODO\n\n  publicAPI.setAttribute = (arr, uncleanAttType) => {\n    const attType = cleanAttributeType(uncleanAttType);\n    if (\n      arr &&\n      attType.toUpperCase() === 'PEDIGREEIDS' &&\n      !arr.isA('vtkDataArray')\n    ) {\n      vtkWarningMacro(\n        `Cannot set attribute ${attType}. The attribute must be a vtkDataArray.`\n      );\n      return -1;\n    }\n    if (arr && !publicAPI.checkNumberOfComponents(arr, attType)) {\n      vtkWarningMacro(\n        `Cannot set attribute ${attType}. Incorrect number of components.`\n      );\n      return -1;\n    }\n    let currentAttribute = model[`active${attType}`];\n    if (currentAttribute >= 0 && currentAttribute < model.arrays.length) {\n      if (model.arrays[currentAttribute] === arr) {\n        return currentAttribute;\n      }\n      publicAPI.removeArrayByIndex(currentAttribute);\n    }\n\n    if (arr) {\n      currentAttribute = publicAPI.addArray(arr);\n      model[`active${attType}`] = currentAttribute;\n    } else {\n      model[`active${attType}`] = -1;\n    }\n    publicAPI.modified();\n    return model[`active${attType}`];\n  };\n\n  publicAPI.getAttributes = (arr) =>\n    attrTypes.filter((attrType) => publicAPI[`get${attrType}`]() === arr);\n\n  publicAPI.setActiveAttributeByName = (arrayName, attType) =>\n    publicAPI.setActiveAttributeByIndex(\n      publicAPI.getArrayWithIndex(arrayName).index,\n      attType\n    );\n\n  publicAPI.setActiveAttributeByIndex = (arrayIdx, uncleanAttType) => {\n    const attType = cleanAttributeType(uncleanAttType);\n    if (arrayIdx >= 0 && arrayIdx < model.arrays.length) {\n      if (attType.toUpperCase() !== 'PEDIGREEIDS') {\n        const arr = publicAPI.getArrayByIndex(arrayIdx);\n        if (!arr.isA('vtkDataArray')) {\n          vtkWarningMacro(\n            `Cannot set attribute ${attType}. Only vtkDataArray subclasses can be set as active attributes.`\n          );\n          return -1;\n        }\n        if (!publicAPI.checkNumberOfComponents(arr, attType)) {\n          vtkWarningMacro(\n            `Cannot set attribute ${attType}. Incorrect number of components.`\n          );\n          return -1;\n        }\n      }\n      model[`active${attType}`] = arrayIdx;\n      publicAPI.modified();\n      return arrayIdx;\n    }\n\n    if (arrayIdx === -1) {\n      model[`active${attType}`] = arrayIdx;\n      publicAPI.modified();\n    }\n\n    return -1;\n  };\n\n  publicAPI.getActiveAttribute = (attType) => {\n    // Given an integer enum value or a string (with random capitalization),\n    // find the matching string in attrTypes.\n    const cleanAttType = cleanAttributeType(attType);\n    return publicAPI[`get${cleanAttType}`]();\n  };\n\n  // Override to allow proper handling of active attributes\n  publicAPI.removeAllArrays = () => {\n    model.arrays = [];\n    attrTypes.forEach((attType) => {\n      model[`active${attType}`] = -1;\n    });\n  };\n\n  // Override to allow proper handling of active attributes\n  publicAPI.removeArray = (arrayName) => {\n    model.arrays = model.arrays.filter((entry, idx) => {\n      if (arrayName === entry.data.getName()) {\n        // Found the array to remove, but is it an active attribute?\n        attrTypes.forEach((attType) => {\n          if (idx === model[`active${attType}`]) {\n            model[`active${attType}`] = -1;\n          }\n        });\n        return false;\n      }\n      return true;\n    });\n  };\n\n  // Override to allow proper handling of active attributes\n  publicAPI.removeArrayByIndex = (arrayIdx) => {\n    model.arrays = model.arrays.filter((entry, idx) => idx !== arrayIdx);\n    attrTypes.forEach((attType) => {\n      if (arrayIdx === model[`active${attType}`]) {\n        model[`active${attType}`] = -1;\n      }\n    });\n  };\n\n  attrTypes.forEach((value) => {\n    const activeVal = `active${value}`;\n    publicAPI[`get${value}`] = () =>\n      publicAPI.getArrayByIndex(model[activeVal]);\n    publicAPI[`set${value}`] = (da) => publicAPI.setAttribute(da, value);\n    publicAPI[`setActive${value}`] = (arrayName) =>\n      publicAPI.setActiveAttributeByIndex(\n        publicAPI.getArrayWithIndex(arrayName).index,\n        value\n      );\n    publicAPI[`copy${value}Off`] = () => {\n      const attType = value.toUpperCase();\n      model.copyAttributeFlags[AttributeCopyOperations.PASSDATA][\n        AttributeTypes[attType]\n      ] = false;\n    };\n    publicAPI[`copy${value}On`] = () => {\n      const attType = value.toUpperCase();\n      model.copyAttributeFlags[AttributeCopyOperations.PASSDATA][\n        AttributeTypes[attType]\n      ] = true;\n    };\n  });\n\n  publicAPI.initializeAttributeCopyFlags = () => {\n    // Default to copying all attributes in every circumstance:\n    model.copyAttributeFlags = [];\n    Object.keys(AttributeCopyOperations)\n      .filter((op) => op !== 'ALLCOPY')\n      .forEach((attCopyOp) => {\n        model.copyAttributeFlags[AttributeCopyOperations[attCopyOp]] =\n          Object.keys(AttributeTypes)\n            .filter((ty) => ty !== 'NUM_ATTRIBUTES')\n            .reduce((a, b) => {\n              a[AttributeTypes[b]] = true;\n              return a;\n            }, []);\n      });\n    // Override some operations where we don't want to copy:\n    model.copyAttributeFlags[AttributeCopyOperations.COPYTUPLE][\n      AttributeTypes.GLOBALIDS\n    ] = false;\n    model.copyAttributeFlags[AttributeCopyOperations.INTERPOLATE][\n      AttributeTypes.GLOBALIDS\n    ] = false;\n    model.copyAttributeFlags[AttributeCopyOperations.COPYTUPLE][\n      AttributeTypes.PEDIGREEIDS\n    ] = false;\n  };\n\n  publicAPI.initialize = macro.chain(\n    publicAPI.initialize,\n    publicAPI.initializeAttributeCopyFlags\n  );\n\n  // Process dataArrays if any\n  if (model.dataArrays && Object.keys(model.dataArrays).length) {\n    Object.keys(model.dataArrays).forEach((name) => {\n      if (\n        !model.dataArrays[name].ref &&\n        model.dataArrays[name].type === 'vtkDataArray'\n      ) {\n        publicAPI.addArray(vtkDataArray.newInstance(model.dataArrays[name]));\n      }\n    });\n  }\n\n  const superShallowCopy = publicAPI.shallowCopy;\n  publicAPI.shallowCopy = (other, debug) => {\n    superShallowCopy(other, debug);\n    model.arrays = other.getArrays().map((arr) => {\n      const arrNew = arr.newClone();\n      arrNew.shallowCopy(arr, debug);\n      return { data: arrNew };\n    });\n  };\n\n  publicAPI.initializeAttributeCopyFlags();\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  activeScalars: -1,\n  activeVectors: -1,\n  activeTensors: -1,\n  activeNormals: -1,\n  activeTCoords: -1,\n  activeGlobalIds: -1,\n  activePedigreeIds: -1,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  vtkFieldData.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, [\n    'activeScalars',\n    'activeNormals',\n    'activeTCoords',\n    'activeVectors',\n    'activeTensors',\n    'activeGlobalIds',\n    'activePedigreeIds',\n  ]);\n\n  if (!model.arrays) {\n    model.arrays = {};\n  }\n\n  // Object specific methods\n  vtkDataSetAttributes(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkDataSetAttributes');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend, ...Constants };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}