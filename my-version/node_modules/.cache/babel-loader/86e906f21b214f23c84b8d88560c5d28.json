{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nimport vtkWebGPUTexture from 'vtk.js/Sources/Rendering/WebGPU/Texture';\nconst {\n  VtkDataTypes\n} = vtkDataArray; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// vtkWebGPUTextureManager methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUTextureManager(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUTextureManager'); // fills in request values based on what is missing/provided\n\n  function _fillRequest(req) {\n    // fill in values based on imageData if the request has it\n    if (req.imageData) {\n      req.dataArray = req.imageData.getPointData().getScalars();\n      req.time = req.dataArray.getMTime();\n      req.nativeArray = req.dataArray.getData();\n      const dims = req.imageData.getDimensions();\n      req.width = dims[0];\n      req.height = dims[1];\n      req.depth = dims[2];\n      const numComp = req.dataArray.getNumberOfComponents(); // todo fix handling of 3 component\n\n      switch (numComp) {\n        case 1:\n          req.format = 'r';\n          break;\n\n        case 2:\n          req.format = 'rg';\n          break;\n\n        case 3:\n        case 4:\n        default:\n          req.format = 'rgba';\n          break;\n      }\n\n      const dataType = req.dataArray.getDataType();\n\n      switch (dataType) {\n        case VtkDataTypes.UNSIGNED_CHAR:\n          req.format += '8unorm';\n          break;\n        // todo extend to other types that are not filterable\n        // as they can be useful\n\n        case VtkDataTypes.FLOAT:\n        case VtkDataTypes.UNSIGNED_INT:\n        case VtkDataTypes.INT:\n        case VtkDataTypes.DOUBLE:\n        case VtkDataTypes.UNSIGNED_SHORT:\n        case VtkDataTypes.SHORT:\n        default:\n          req.format += '16float';\n          break;\n      }\n    } // fill in values based on image if the request has it\n\n\n    if (req.image) {\n      req.width = req.image.width;\n      req.height = req.image.height;\n      req.depth = 1;\n      req.format = 'rgba8unorm';\n    } // fill in based on js imageData\n\n\n    if (req.jsImageData) {\n      req.width = req.jsImageData.width;\n      req.height = req.jsImageData.height;\n      req.depth = 1;\n      req.format = 'rgba8unorm';\n      req.flip = true;\n      req.nativeArray = req.jsImageData.data;\n    }\n\n    if (req.canvas) {\n      req.width = req.canvas.width;\n      req.height = req.canvas.height;\n      req.depth = 1;\n      req.format = 'rgba8unorm';\n      req.flip = true;\n      /* eslint-disable no-undef */\n\n      /* eslint-disable no-bitwise */\n\n      req.usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT;\n      /* eslint-enable no-undef */\n\n      /* eslint-enable no-bitwise */\n    }\n  } // create a texture (used by getTexture)\n\n\n  function _createTexture(req) {\n    const newTex = vtkWebGPUTexture.newInstance();\n    newTex.create(model.device, {\n      width: req.width,\n      height: req.height,\n      depth: req.depth,\n      format: req.format,\n      usage: req.usage,\n      mipLevel: req.mipLevel\n    }); // fill the texture if we have data\n\n    if (req.nativeArray || req.image || req.canvas) {\n      newTex.writeImageData(req);\n    }\n\n    return newTex;\n  } // get a texture or create it if not cached.\n  // this is the main entry point\n\n\n  publicAPI.getTexture = req => {\n    // if we have a source the get/create/cache the texture\n    if (req.hash) {\n      // if a matching texture already exists then return it\n      return model.device.getCachedObject(req.hash, _createTexture, req);\n    }\n\n    return _createTexture(req);\n  };\n\n  publicAPI.getTextureForImageData = imgData => {\n    const treq = {\n      time: imgData.getMTime()\n    };\n    treq.imageData = imgData; // fill out the req time and format based on imageData/image\n\n    _fillRequest(treq);\n\n    treq.hash = treq.time + treq.format + treq.mipLevel;\n    return model.device.getTextureManager().getTexture(treq);\n  };\n\n  publicAPI.getTextureForVTKTexture = srcTexture => {\n    const treq = {\n      time: srcTexture.getMTime()\n    };\n\n    if (srcTexture.getInputData()) {\n      treq.imageData = srcTexture.getInputData();\n    } else if (srcTexture.getImage()) {\n      treq.image = srcTexture.getImage();\n    } else if (srcTexture.getJsImageData()) {\n      treq.jsImageData = srcTexture.getJsImageData();\n    } else if (srcTexture.getCanvas()) {\n      treq.canvas = srcTexture.getCanvas();\n    } // fill out the req time and format based on imageData/image\n\n\n    _fillRequest(treq);\n\n    treq.mipLevel = srcTexture.getMipLevel();\n    treq.hash = treq.time + treq.format + treq.mipLevel;\n    return model.device.getTextureManager().getTexture(treq);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  handle: null,\n  device: null\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Object methods\n\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['device']);\n  vtkWebGPUTextureManager(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["macro","vtkDataArray","vtkWebGPUTexture","VtkDataTypes","vtkWebGPUTextureManager","publicAPI","model","classHierarchy","push","_fillRequest","req","imageData","dataArray","getPointData","getScalars","time","getMTime","nativeArray","getData","dims","getDimensions","width","height","depth","numComp","getNumberOfComponents","format","dataType","getDataType","UNSIGNED_CHAR","FLOAT","UNSIGNED_INT","INT","DOUBLE","UNSIGNED_SHORT","SHORT","image","jsImageData","flip","data","canvas","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","RENDER_ATTACHMENT","_createTexture","newTex","newInstance","create","device","mipLevel","writeImageData","getTexture","hash","getCachedObject","getTextureForImageData","imgData","treq","getTextureManager","getTextureForVTKTexture","srcTexture","getInputData","getImage","getJsImageData","getCanvas","getMipLevel","DEFAULT_VALUES","handle","extend","initialValues","Object","assign","obj","setGet"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/WebGPU/TextureManager/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nimport vtkWebGPUTexture from 'vtk.js/Sources/Rendering/WebGPU/Texture';\n\nconst { VtkDataTypes } = vtkDataArray;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUTextureManager methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUTextureManager(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUTextureManager');\n\n  // fills in request values based on what is missing/provided\n  function _fillRequest(req) {\n    // fill in values based on imageData if the request has it\n    if (req.imageData) {\n      req.dataArray = req.imageData.getPointData().getScalars();\n      req.time = req.dataArray.getMTime();\n      req.nativeArray = req.dataArray.getData();\n      const dims = req.imageData.getDimensions();\n      req.width = dims[0];\n      req.height = dims[1];\n      req.depth = dims[2];\n      const numComp = req.dataArray.getNumberOfComponents();\n      // todo fix handling of 3 component\n      switch (numComp) {\n        case 1:\n          req.format = 'r';\n          break;\n        case 2:\n          req.format = 'rg';\n          break;\n        case 3:\n        case 4:\n        default:\n          req.format = 'rgba';\n          break;\n      }\n\n      const dataType = req.dataArray.getDataType();\n      switch (dataType) {\n        case VtkDataTypes.UNSIGNED_CHAR:\n          req.format += '8unorm';\n          break;\n        // todo extend to other types that are not filterable\n        // as they can be useful\n        case VtkDataTypes.FLOAT:\n        case VtkDataTypes.UNSIGNED_INT:\n        case VtkDataTypes.INT:\n        case VtkDataTypes.DOUBLE:\n        case VtkDataTypes.UNSIGNED_SHORT:\n        case VtkDataTypes.SHORT:\n        default:\n          req.format += '16float';\n          break;\n      }\n    }\n\n    // fill in values based on image if the request has it\n    if (req.image) {\n      req.width = req.image.width;\n      req.height = req.image.height;\n      req.depth = 1;\n      req.format = 'rgba8unorm';\n    }\n\n    // fill in based on js imageData\n    if (req.jsImageData) {\n      req.width = req.jsImageData.width;\n      req.height = req.jsImageData.height;\n      req.depth = 1;\n      req.format = 'rgba8unorm';\n      req.flip = true;\n      req.nativeArray = req.jsImageData.data;\n    }\n\n    if (req.canvas) {\n      req.width = req.canvas.width;\n      req.height = req.canvas.height;\n      req.depth = 1;\n      req.format = 'rgba8unorm';\n      req.flip = true;\n      /* eslint-disable no-undef */\n      /* eslint-disable no-bitwise */\n      req.usage =\n        GPUTextureUsage.TEXTURE_BINDING |\n        GPUTextureUsage.COPY_DST |\n        GPUTextureUsage.RENDER_ATTACHMENT;\n      /* eslint-enable no-undef */\n      /* eslint-enable no-bitwise */\n    }\n  }\n\n  // create a texture (used by getTexture)\n  function _createTexture(req) {\n    const newTex = vtkWebGPUTexture.newInstance();\n\n    newTex.create(model.device, {\n      width: req.width,\n      height: req.height,\n      depth: req.depth,\n      format: req.format,\n      usage: req.usage,\n      mipLevel: req.mipLevel,\n    });\n\n    // fill the texture if we have data\n    if (req.nativeArray || req.image || req.canvas) {\n      newTex.writeImageData(req);\n    }\n    return newTex;\n  }\n\n  // get a texture or create it if not cached.\n  // this is the main entry point\n  publicAPI.getTexture = (req) => {\n    // if we have a source the get/create/cache the texture\n    if (req.hash) {\n      // if a matching texture already exists then return it\n      return model.device.getCachedObject(req.hash, _createTexture, req);\n    }\n\n    return _createTexture(req);\n  };\n\n  publicAPI.getTextureForImageData = (imgData) => {\n    const treq = { time: imgData.getMTime() };\n    treq.imageData = imgData;\n    // fill out the req time and format based on imageData/image\n    _fillRequest(treq);\n    treq.hash = treq.time + treq.format + treq.mipLevel;\n    return model.device.getTextureManager().getTexture(treq);\n  };\n\n  publicAPI.getTextureForVTKTexture = (srcTexture) => {\n    const treq = { time: srcTexture.getMTime() };\n    if (srcTexture.getInputData()) {\n      treq.imageData = srcTexture.getInputData();\n    } else if (srcTexture.getImage()) {\n      treq.image = srcTexture.getImage();\n    } else if (srcTexture.getJsImageData()) {\n      treq.jsImageData = srcTexture.getJsImageData();\n    } else if (srcTexture.getCanvas()) {\n      treq.canvas = srcTexture.getCanvas();\n    }\n    // fill out the req time and format based on imageData/image\n    _fillRequest(treq);\n    treq.mipLevel = srcTexture.getMipLevel();\n    treq.hash = treq.time + treq.format + treq.mipLevel;\n    return model.device.getTextureManager().getTexture(treq);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  handle: null,\n  device: null,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n\n  macro.setGet(publicAPI, model, ['device']);\n\n  vtkWebGPUTextureManager(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}