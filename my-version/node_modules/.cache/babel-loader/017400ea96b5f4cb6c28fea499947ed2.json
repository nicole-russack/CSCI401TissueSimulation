{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport Constants from 'vtk.js/Sources/Rendering/WebGPU/BufferManager/Constants';\nimport vtkProperty from 'vtk.js/Sources/Rendering/Core/Property';\nimport vtkWebGPUBuffer from 'vtk.js/Sources/Rendering/WebGPU/Buffer';\nconst {\n  Representation\n} = vtkProperty;\nconst {\n  PrimitiveTypes\n} = Constants; // Simulate a small map of pointId to flatId for a cell. The original code\n// used a map and was 2.6x slower (4.7 to 1.9 seconds). Using two fixed\n// length arrays with a count is so much faster even with the required for\n// loops and if statements. This only works as we know the usage is\n// restricted to clear(), set() get() and has() so the count is always\n// incrmenting except for clear where it goes back to 0. Performance\n// improvement is probably due to this appoach not hitting the heap but wow\n// it is so much faster. Code that adds to these vectors checks against 9 to\n// make sure there is room. Switching to test against vec.length -1 results\n// in a small performance hit, so if you change 10, search for 9 in this\n// small class and change those as well.\n\nclass _LimitedMap {\n  constructor() {\n    this.keys = new Uint32Array(10);\n    this.values = new Uint32Array(10);\n    this.count = 0;\n  }\n\n  clear() {\n    this.count = 0;\n  }\n\n  has(key) {\n    for (let i = 0; i < this.count; i++) {\n      if (this.keys[i] === key) {\n        return true;\n      }\n    }\n\n    return undefined;\n  }\n\n  get(key) {\n    for (let i = 0; i < this.count; i++) {\n      if (this.keys[i] === key) {\n        return this.values[i];\n      }\n    }\n\n    return undefined;\n  }\n\n  set(key, value) {\n    if (this.count < 9) {\n      this.keys[this.count] = key;\n      this.values[this.count++] = value;\n    }\n  }\n\n}\n\nfunction getPrimitiveName(primType) {\n  switch (primType) {\n    case PrimitiveTypes.Points:\n      return 'points';\n\n    case PrimitiveTypes.Lines:\n      return 'lines';\n\n    case PrimitiveTypes.Triangles:\n    case PrimitiveTypes.TriangleEdges:\n      return 'polys';\n\n    case PrimitiveTypes.TriangleStripEdges:\n    case PrimitiveTypes.TriangleStrips:\n      return 'strips';\n\n    default:\n      return '';\n  }\n}\n\nfunction _getOrAddFlatId(state, ptId, cellId) {\n  let flatId = state.pointIdToFlatId[ptId];\n\n  if (flatId < 0) {\n    flatId = state.flatId;\n    state.pointIdToFlatId[ptId] = flatId;\n    state.flatIdToPointId[state.flatId] = ptId;\n    state.flatIdToCellId[state.flatId] = cellId;\n    state.flatId++;\n  }\n\n  return flatId;\n}\n\nfunction fillCell(ptIds, cellId, state) {\n  const numPtIds = ptIds.length; // are any points already marked for this cell? If so use that as the provoking point\n\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    let ptId = ptIds[ptIdx];\n\n    if (state.cellProvokedMap.has(ptId)) {\n      state.ibo[state.iboId++] = state.cellProvokedMap.get(ptId); // insert remaining ptIds (they do not need to provoke)\n\n      for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {\n        ptId = ptIds[ptIdx2 % numPtIds];\n\n        const flatId = _getOrAddFlatId(state, ptId, cellId); // add to ibo\n\n\n        state.ibo[state.iboId++] = flatId;\n      } // all done now\n\n\n      return;\n    }\n  } // else have any of the points not been used yet? (not in provokedPointIds)\n\n\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    let ptId = ptIds[ptIdx];\n\n    if (!state.provokedPointIds[ptId]) {\n      let flatId = _getOrAddFlatId(state, ptId, cellId); // mark provoking and add to ibo\n\n\n      state.provokedPointIds[ptId] = 1;\n      state.cellProvokedMap.set(ptId, flatId); // when provoking always set the cellId as an original non-provoking value\n      // will have been stored and we need to overwrite that\n\n      state.flatIdToCellId[flatId] = cellId;\n      state.ibo[state.iboId++] = flatId; // insert remaining ptIds (they do not need to provoke)\n\n      for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {\n        ptId = ptIds[ptIdx2 % numPtIds];\n        flatId = _getOrAddFlatId(state, ptId, cellId); // add to ibo\n\n        state.ibo[state.iboId++] = flatId;\n      } // all done now\n\n\n      return;\n    }\n  } // if we got here then none of the ptIds could be used to provoke\n  // so just duplicate the first one\n\n\n  let ptId = ptIds[0];\n  let flatId = state.flatId;\n  state.cellProvokedMap.set(ptId, flatId);\n  state.flatIdToPointId[state.flatId] = ptId;\n  state.flatIdToCellId[state.flatId] = cellId;\n  state.flatId++; // add to ibo\n\n  state.ibo[state.iboId++] = flatId; // insert remaining ptIds (they do not need to provoke)\n\n  for (let ptIdx2 = 1; ptIdx2 < numPtIds; ptIdx2++) {\n    ptId = ptIds[ptIdx2];\n    flatId = _getOrAddFlatId(state, ptId, cellId); // add to ibo\n\n    state.ibo[state.iboId++] = flatId;\n  }\n}\n\nfunction countCell(ptIds, cellId, state) {\n  const numPtIds = ptIds.length;\n  state.iboSize += numPtIds; // are any points already marked for this cell? If so use that as the provoking point\n\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    const ptId = ptIds[ptIdx];\n\n    if (state.cellProvokedMap.has(ptId)) {\n      return;\n    }\n  } // else have any of the points not been used yet? (not in provokedPointIds)\n\n\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    const ptId = ptIds[ptIdx];\n\n    if (!state.provokedPointIds[ptId]) {\n      state.provokedPointIds[ptId] = 1;\n      state.cellProvokedMap.set(ptId, 1);\n      return;\n    }\n  } // if we got here then none of the ptIds could be used to provoke\n\n\n  state.cellProvokedMap.set(ptIds[0], 1);\n  state.extraPoints++;\n}\n\nlet processCell;\n\nconst _single = new Uint32Array(1);\n\nconst _double = new Uint32Array(2);\n\nconst _triple = new Uint32Array(3);\n\nconst _indexCellBuilders = {\n  // easy, every input point becomes an output point\n  anythingToPoints(numPoints, cellPts, offset, cellId, state) {\n    for (let i = 0; i < numPoints; ++i) {\n      _single[0] = cellPts[offset + i];\n      processCell(_single, cellId, state);\n    }\n  },\n\n  linesToWireframe(numPoints, cellPts, offset, cellId, state) {\n    // for lines we add a bunch of segments\n    for (let i = 0; i < numPoints - 1; ++i) {\n      _double[0] = cellPts[offset + i];\n      _double[1] = cellPts[offset + i + 1];\n      processCell(_double, cellId, state);\n    }\n  },\n\n  polysToWireframe(numPoints, cellPts, offset, cellId, state) {\n    // for polys we add a bunch of segments and close it\n    if (numPoints > 2) {\n      for (let i = 0; i < numPoints; ++i) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + (i + 1) % numPoints];\n        processCell(_double, cellId, state);\n      }\n    }\n  },\n\n  stripsToWireframe(numPoints, cellPts, offset, cellId, state) {\n    if (numPoints > 2) {\n      // for strips we add a bunch of segments and close it\n      for (let i = 0; i < numPoints - 1; ++i) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + i + 1];\n        processCell(_double, cellId, state);\n      }\n\n      for (let i = 0; i < numPoints - 2; i++) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + i + 2];\n        processCell(_double, cellId, state);\n      }\n    }\n  },\n\n  polysToSurface(npts, cellPts, offset, cellId, state) {\n    for (let i = 0; i < npts - 2; i++) {\n      _triple[0] = cellPts[offset];\n      _triple[1] = cellPts[offset + i + 1];\n      _triple[2] = cellPts[offset + i + 2];\n      processCell(_triple, cellId, state);\n    }\n  },\n\n  stripsToSurface(npts, cellPts, offset, cellId, state) {\n    for (let i = 0; i < npts - 2; i++) {\n      _triple[0] = cellPts[offset + i];\n      _triple[1] = cellPts[offset + i + 1 + i % 2];\n      _triple[2] = cellPts[offset + i + 1 + (i + 1) % 2];\n      processCell(_triple, cellId, state);\n    }\n  }\n\n}; // ----------------------------------------------------------------------------\n// vtkWebGPUIndexBufferManager methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUIndexBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUIndexBuffer');\n\n  publicAPI.buildIndexBuffer = req => {\n    const cellArray = req.cells;\n    const primitiveType = req.primitiveType;\n    const representation = req.representation;\n    const cellOffset = req.cellOffset;\n    const array = cellArray.getData();\n    const cellArraySize = array.length;\n    const inRepName = getPrimitiveName(primitiveType);\n    const numPts = req.numberOfPoints;\n    const state = {\n      provokedPointIds: new Uint8Array(numPts),\n      // size is good\n      extraPoints: 0,\n      iboSize: 0,\n      flatId: 0,\n      iboId: 0,\n      cellProvokedMap: new _LimitedMap()\n    };\n    let func = null;\n\n    if (representation === Representation.POINTS || primitiveType === PrimitiveTypes.Points) {\n      func = _indexCellBuilders.anythingToPoints;\n    } else if (representation === Representation.WIREFRAME || primitiveType === PrimitiveTypes.Lines) {\n      func = _indexCellBuilders[`${inRepName}ToWireframe`];\n    } else {\n      func = _indexCellBuilders[`${inRepName}ToSurface`];\n    } // first we count how many extra provoking points we need\n\n\n    processCell = countCell;\n    let cellId = cellOffset || 0;\n\n    for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize;) {\n      state.cellProvokedMap.clear();\n      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);\n      cellArrayIndex += array[cellArrayIndex] + 1;\n      cellId++;\n    } // then we allocate the remaining structures\n    // (we pick the best size to save space and transfer costs)\n\n\n    if (numPts <= 0xffff) {\n      state.flatIdToPointId = new Uint16Array(numPts + state.extraPoints);\n    } else {\n      state.flatIdToPointId = new Uint32Array(numPts + state.extraPoints);\n    }\n\n    if (numPts + state.extraPoints < 0x8fff) {\n      state.pointIdToFlatId = new Int16Array(numPts);\n    } else {\n      state.pointIdToFlatId = new Int32Array(numPts);\n    }\n\n    if (numPts + state.extraPoints <= 0xffff) {\n      state.ibo = new Uint16Array(state.iboSize);\n      req.format = 'uint16';\n    } else {\n      state.ibo = new Uint32Array(state.iboSize);\n      req.format = 'uint32';\n    }\n\n    if (cellId <= 0xffff) {\n      state.flatIdToCellId = new Uint16Array(numPts + state.extraPoints);\n    } else {\n      state.flatIdToCellId = new Uint32Array(numPts + state.extraPoints);\n    }\n\n    state.pointIdToFlatId.fill(-1);\n    state.provokedPointIds.fill(0); // and fill them in\n\n    processCell = fillCell;\n    cellId = cellOffset || 0;\n\n    for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize;) {\n      state.cellProvokedMap.clear();\n      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);\n      cellArrayIndex += array[cellArrayIndex] + 1;\n      cellId++;\n    }\n\n    delete state.provokedPointIds;\n    delete state.pointIdToFlatId; // store the results we need\n\n    req.nativeArray = state.ibo;\n    model.flatIdToPointId = state.flatIdToPointId;\n    model.flatIdToCellId = state.flatIdToCellId;\n    model.flatSize = state.flatId;\n    model.indexCount = state.iboId;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  flatIdToPointId: null,\n  flatIdToCellId: null,\n  flatSize: 0,\n  indexCount: 0\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkWebGPUBuffer.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['flatIdToPointId', 'flatIdToCellId', 'flatSize', 'indexCount']);\n  vtkWebGPUIndexBuffer(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend,\n  ...Constants\n};","map":{"version":3,"names":["macro","Constants","vtkProperty","vtkWebGPUBuffer","Representation","PrimitiveTypes","_LimitedMap","constructor","keys","Uint32Array","values","count","clear","has","key","i","undefined","get","set","value","getPrimitiveName","primType","Points","Lines","Triangles","TriangleEdges","TriangleStripEdges","TriangleStrips","_getOrAddFlatId","state","ptId","cellId","flatId","pointIdToFlatId","flatIdToPointId","flatIdToCellId","fillCell","ptIds","numPtIds","length","ptIdx","cellProvokedMap","ibo","iboId","ptIdx2","provokedPointIds","countCell","iboSize","extraPoints","processCell","_single","_double","_triple","_indexCellBuilders","anythingToPoints","numPoints","cellPts","offset","linesToWireframe","polysToWireframe","stripsToWireframe","polysToSurface","npts","stripsToSurface","vtkWebGPUIndexBuffer","publicAPI","model","classHierarchy","push","buildIndexBuffer","req","cellArray","cells","primitiveType","representation","cellOffset","array","getData","cellArraySize","inRepName","numPts","numberOfPoints","Uint8Array","func","POINTS","WIREFRAME","cellArrayIndex","Uint16Array","Int16Array","Int32Array","format","fill","nativeArray","flatSize","indexCount","DEFAULT_VALUES","extend","initialValues","Object","assign","setGet","newInstance"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/WebGPU/IndexBuffer/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport Constants from 'vtk.js/Sources/Rendering/WebGPU/BufferManager/Constants';\nimport vtkProperty from 'vtk.js/Sources/Rendering/Core/Property';\nimport vtkWebGPUBuffer from 'vtk.js/Sources/Rendering/WebGPU/Buffer';\n\nconst { Representation } = vtkProperty;\nconst { PrimitiveTypes } = Constants;\n\n// Simulate a small map of pointId to flatId for a cell. The original code\n// used a map and was 2.6x slower (4.7 to 1.9 seconds). Using two fixed\n// length arrays with a count is so much faster even with the required for\n// loops and if statements. This only works as we know the usage is\n// restricted to clear(), set() get() and has() so the count is always\n// incrmenting except for clear where it goes back to 0. Performance\n// improvement is probably due to this appoach not hitting the heap but wow\n// it is so much faster. Code that adds to these vectors checks against 9 to\n// make sure there is room. Switching to test against vec.length -1 results\n// in a small performance hit, so if you change 10, search for 9 in this\n// small class and change those as well.\nclass _LimitedMap {\n  constructor() {\n    this.keys = new Uint32Array(10);\n    this.values = new Uint32Array(10);\n    this.count = 0;\n  }\n\n  clear() {\n    this.count = 0;\n  }\n\n  has(key) {\n    for (let i = 0; i < this.count; i++) {\n      if (this.keys[i] === key) {\n        return true;\n      }\n    }\n    return undefined;\n  }\n\n  get(key) {\n    for (let i = 0; i < this.count; i++) {\n      if (this.keys[i] === key) {\n        return this.values[i];\n      }\n    }\n    return undefined;\n  }\n\n  set(key, value) {\n    if (this.count < 9) {\n      this.keys[this.count] = key;\n      this.values[this.count++] = value;\n    }\n  }\n}\n\nfunction getPrimitiveName(primType) {\n  switch (primType) {\n    case PrimitiveTypes.Points:\n      return 'points';\n    case PrimitiveTypes.Lines:\n      return 'lines';\n    case PrimitiveTypes.Triangles:\n    case PrimitiveTypes.TriangleEdges:\n      return 'polys';\n    case PrimitiveTypes.TriangleStripEdges:\n    case PrimitiveTypes.TriangleStrips:\n      return 'strips';\n    default:\n      return '';\n  }\n}\n\nfunction _getOrAddFlatId(state, ptId, cellId) {\n  let flatId = state.pointIdToFlatId[ptId];\n  if (flatId < 0) {\n    flatId = state.flatId;\n    state.pointIdToFlatId[ptId] = flatId;\n    state.flatIdToPointId[state.flatId] = ptId;\n    state.flatIdToCellId[state.flatId] = cellId;\n    state.flatId++;\n  }\n  return flatId;\n}\n\nfunction fillCell(ptIds, cellId, state) {\n  const numPtIds = ptIds.length;\n  // are any points already marked for this cell? If so use that as the provoking point\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    let ptId = ptIds[ptIdx];\n    if (state.cellProvokedMap.has(ptId)) {\n      state.ibo[state.iboId++] = state.cellProvokedMap.get(ptId);\n\n      // insert remaining ptIds (they do not need to provoke)\n      for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {\n        ptId = ptIds[ptIdx2 % numPtIds];\n        const flatId = _getOrAddFlatId(state, ptId, cellId);\n        // add to ibo\n        state.ibo[state.iboId++] = flatId;\n      }\n      // all done now\n      return;\n    }\n  }\n\n  // else have any of the points not been used yet? (not in provokedPointIds)\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    let ptId = ptIds[ptIdx];\n    if (!state.provokedPointIds[ptId]) {\n      let flatId = _getOrAddFlatId(state, ptId, cellId);\n      // mark provoking and add to ibo\n      state.provokedPointIds[ptId] = 1;\n      state.cellProvokedMap.set(ptId, flatId);\n      // when provoking always set the cellId as an original non-provoking value\n      // will have been stored and we need to overwrite that\n      state.flatIdToCellId[flatId] = cellId;\n      state.ibo[state.iboId++] = flatId;\n\n      // insert remaining ptIds (they do not need to provoke)\n      for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {\n        ptId = ptIds[ptIdx2 % numPtIds];\n        flatId = _getOrAddFlatId(state, ptId, cellId);\n        // add to ibo\n        state.ibo[state.iboId++] = flatId;\n      }\n      // all done now\n      return;\n    }\n  }\n\n  // if we got here then none of the ptIds could be used to provoke\n  // so just duplicate the first one\n  let ptId = ptIds[0];\n  let flatId = state.flatId;\n  state.cellProvokedMap.set(ptId, flatId);\n  state.flatIdToPointId[state.flatId] = ptId;\n  state.flatIdToCellId[state.flatId] = cellId;\n  state.flatId++;\n\n  // add to ibo\n  state.ibo[state.iboId++] = flatId;\n\n  // insert remaining ptIds (they do not need to provoke)\n  for (let ptIdx2 = 1; ptIdx2 < numPtIds; ptIdx2++) {\n    ptId = ptIds[ptIdx2];\n    flatId = _getOrAddFlatId(state, ptId, cellId);\n    // add to ibo\n    state.ibo[state.iboId++] = flatId;\n  }\n}\n\nfunction countCell(ptIds, cellId, state) {\n  const numPtIds = ptIds.length;\n  state.iboSize += numPtIds;\n\n  // are any points already marked for this cell? If so use that as the provoking point\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    const ptId = ptIds[ptIdx];\n    if (state.cellProvokedMap.has(ptId)) {\n      return;\n    }\n  }\n\n  // else have any of the points not been used yet? (not in provokedPointIds)\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    const ptId = ptIds[ptIdx];\n    if (!state.provokedPointIds[ptId]) {\n      state.provokedPointIds[ptId] = 1;\n      state.cellProvokedMap.set(ptId, 1);\n      return;\n    }\n  }\n  // if we got here then none of the ptIds could be used to provoke\n  state.cellProvokedMap.set(ptIds[0], 1);\n  state.extraPoints++;\n}\n\nlet processCell;\n\nconst _single = new Uint32Array(1);\nconst _double = new Uint32Array(2);\nconst _triple = new Uint32Array(3);\nconst _indexCellBuilders = {\n  // easy, every input point becomes an output point\n  anythingToPoints(numPoints, cellPts, offset, cellId, state) {\n    for (let i = 0; i < numPoints; ++i) {\n      _single[0] = cellPts[offset + i];\n      processCell(_single, cellId, state);\n    }\n  },\n  linesToWireframe(numPoints, cellPts, offset, cellId, state) {\n    // for lines we add a bunch of segments\n    for (let i = 0; i < numPoints - 1; ++i) {\n      _double[0] = cellPts[offset + i];\n      _double[1] = cellPts[offset + i + 1];\n      processCell(_double, cellId, state);\n    }\n  },\n  polysToWireframe(numPoints, cellPts, offset, cellId, state) {\n    // for polys we add a bunch of segments and close it\n    if (numPoints > 2) {\n      for (let i = 0; i < numPoints; ++i) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + ((i + 1) % numPoints)];\n        processCell(_double, cellId, state);\n      }\n    }\n  },\n  stripsToWireframe(numPoints, cellPts, offset, cellId, state) {\n    if (numPoints > 2) {\n      // for strips we add a bunch of segments and close it\n      for (let i = 0; i < numPoints - 1; ++i) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + i + 1];\n        processCell(_double, cellId, state);\n      }\n      for (let i = 0; i < numPoints - 2; i++) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + i + 2];\n        processCell(_double, cellId, state);\n      }\n    }\n  },\n  polysToSurface(npts, cellPts, offset, cellId, state) {\n    for (let i = 0; i < npts - 2; i++) {\n      _triple[0] = cellPts[offset];\n      _triple[1] = cellPts[offset + i + 1];\n      _triple[2] = cellPts[offset + i + 2];\n      processCell(_triple, cellId, state);\n    }\n  },\n  stripsToSurface(npts, cellPts, offset, cellId, state) {\n    for (let i = 0; i < npts - 2; i++) {\n      _triple[0] = cellPts[offset + i];\n      _triple[1] = cellPts[offset + i + 1 + (i % 2)];\n      _triple[2] = cellPts[offset + i + 1 + ((i + 1) % 2)];\n      processCell(_triple, cellId, state);\n    }\n  },\n};\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUIndexBufferManager methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUIndexBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUIndexBuffer');\n\n  publicAPI.buildIndexBuffer = (req) => {\n    const cellArray = req.cells;\n    const primitiveType = req.primitiveType;\n    const representation = req.representation;\n    const cellOffset = req.cellOffset;\n\n    const array = cellArray.getData();\n    const cellArraySize = array.length;\n\n    const inRepName = getPrimitiveName(primitiveType);\n\n    const numPts = req.numberOfPoints;\n    const state = {\n      provokedPointIds: new Uint8Array(numPts), // size is good\n      extraPoints: 0,\n      iboSize: 0,\n      flatId: 0,\n      iboId: 0,\n      cellProvokedMap: new _LimitedMap(),\n    };\n\n    let func = null;\n    if (\n      representation === Representation.POINTS ||\n      primitiveType === PrimitiveTypes.Points\n    ) {\n      func = _indexCellBuilders.anythingToPoints;\n    } else if (\n      representation === Representation.WIREFRAME ||\n      primitiveType === PrimitiveTypes.Lines\n    ) {\n      func = _indexCellBuilders[`${inRepName}ToWireframe`];\n    } else {\n      func = _indexCellBuilders[`${inRepName}ToSurface`];\n    }\n\n    // first we count how many extra provoking points we need\n    processCell = countCell;\n    let cellId = cellOffset || 0;\n    for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize; ) {\n      state.cellProvokedMap.clear();\n      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);\n      cellArrayIndex += array[cellArrayIndex] + 1;\n      cellId++;\n    }\n\n    // then we allocate the remaining structures\n    // (we pick the best size to save space and transfer costs)\n    if (numPts <= 0xffff) {\n      state.flatIdToPointId = new Uint16Array(numPts + state.extraPoints);\n    } else {\n      state.flatIdToPointId = new Uint32Array(numPts + state.extraPoints);\n    }\n    if (numPts + state.extraPoints < 0x8fff) {\n      state.pointIdToFlatId = new Int16Array(numPts);\n    } else {\n      state.pointIdToFlatId = new Int32Array(numPts);\n    }\n    if (numPts + state.extraPoints <= 0xffff) {\n      state.ibo = new Uint16Array(state.iboSize);\n      req.format = 'uint16';\n    } else {\n      state.ibo = new Uint32Array(state.iboSize);\n      req.format = 'uint32';\n    }\n    if (cellId <= 0xffff) {\n      state.flatIdToCellId = new Uint16Array(numPts + state.extraPoints);\n    } else {\n      state.flatIdToCellId = new Uint32Array(numPts + state.extraPoints);\n    }\n    state.pointIdToFlatId.fill(-1);\n    state.provokedPointIds.fill(0);\n\n    // and fill them in\n    processCell = fillCell;\n    cellId = cellOffset || 0;\n    for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize; ) {\n      state.cellProvokedMap.clear();\n      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);\n      cellArrayIndex += array[cellArrayIndex] + 1;\n      cellId++;\n    }\n\n    delete state.provokedPointIds;\n    delete state.pointIdToFlatId;\n\n    // store the results we need\n    req.nativeArray = state.ibo;\n    model.flatIdToPointId = state.flatIdToPointId;\n    model.flatIdToCellId = state.flatIdToCellId;\n    model.flatSize = state.flatId;\n    model.indexCount = state.iboId;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  flatIdToPointId: null,\n  flatIdToCellId: null,\n  flatSize: 0,\n  indexCount: 0,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkWebGPUBuffer.extend(publicAPI, model, initialValues);\n\n  macro.setGet(publicAPI, model, [\n    'flatIdToPointId',\n    'flatIdToCellId',\n    'flatSize',\n    'indexCount',\n  ]);\n\n  vtkWebGPUIndexBuffer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend, ...Constants };\n"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,uBAAlB;AACA,OAAOC,SAAP,MAAsB,yDAAtB;AACA,OAAOC,WAAP,MAAwB,wCAAxB;AACA,OAAOC,eAAP,MAA4B,wCAA5B;AAEA,MAAM;EAAEC;AAAF,IAAqBF,WAA3B;AACA,MAAM;EAAEG;AAAF,IAAqBJ,SAA3B,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMK,WAAN,CAAkB;EAChBC,WAAW,GAAG;IACZ,KAAKC,IAAL,GAAY,IAAIC,WAAJ,CAAgB,EAAhB,CAAZ;IACA,KAAKC,MAAL,GAAc,IAAID,WAAJ,CAAgB,EAAhB,CAAd;IACA,KAAKE,KAAL,GAAa,CAAb;EACD;;EAEDC,KAAK,GAAG;IACN,KAAKD,KAAL,GAAa,CAAb;EACD;;EAEDE,GAAG,CAACC,GAAD,EAAM;IACP,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKJ,KAAzB,EAAgCI,CAAC,EAAjC,EAAqC;MACnC,IAAI,KAAKP,IAAL,CAAUO,CAAV,MAAiBD,GAArB,EAA0B;QACxB,OAAO,IAAP;MACD;IACF;;IACD,OAAOE,SAAP;EACD;;EAEDC,GAAG,CAACH,GAAD,EAAM;IACP,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKJ,KAAzB,EAAgCI,CAAC,EAAjC,EAAqC;MACnC,IAAI,KAAKP,IAAL,CAAUO,CAAV,MAAiBD,GAArB,EAA0B;QACxB,OAAO,KAAKJ,MAAL,CAAYK,CAAZ,CAAP;MACD;IACF;;IACD,OAAOC,SAAP;EACD;;EAEDE,GAAG,CAACJ,GAAD,EAAMK,KAAN,EAAa;IACd,IAAI,KAAKR,KAAL,GAAa,CAAjB,EAAoB;MAClB,KAAKH,IAAL,CAAU,KAAKG,KAAf,IAAwBG,GAAxB;MACA,KAAKJ,MAAL,CAAY,KAAKC,KAAL,EAAZ,IAA4BQ,KAA5B;IACD;EACF;;AAlCe;;AAqClB,SAASC,gBAAT,CAA0BC,QAA1B,EAAoC;EAClC,QAAQA,QAAR;IACE,KAAKhB,cAAc,CAACiB,MAApB;MACE,OAAO,QAAP;;IACF,KAAKjB,cAAc,CAACkB,KAApB;MACE,OAAO,OAAP;;IACF,KAAKlB,cAAc,CAACmB,SAApB;IACA,KAAKnB,cAAc,CAACoB,aAApB;MACE,OAAO,OAAP;;IACF,KAAKpB,cAAc,CAACqB,kBAApB;IACA,KAAKrB,cAAc,CAACsB,cAApB;MACE,OAAO,QAAP;;IACF;MACE,OAAO,EAAP;EAZJ;AAcD;;AAED,SAASC,eAAT,CAAyBC,KAAzB,EAAgCC,IAAhC,EAAsCC,MAAtC,EAA8C;EAC5C,IAAIC,MAAM,GAAGH,KAAK,CAACI,eAAN,CAAsBH,IAAtB,CAAb;;EACA,IAAIE,MAAM,GAAG,CAAb,EAAgB;IACdA,MAAM,GAAGH,KAAK,CAACG,MAAf;IACAH,KAAK,CAACI,eAAN,CAAsBH,IAAtB,IAA8BE,MAA9B;IACAH,KAAK,CAACK,eAAN,CAAsBL,KAAK,CAACG,MAA5B,IAAsCF,IAAtC;IACAD,KAAK,CAACM,cAAN,CAAqBN,KAAK,CAACG,MAA3B,IAAqCD,MAArC;IACAF,KAAK,CAACG,MAAN;EACD;;EACD,OAAOA,MAAP;AACD;;AAED,SAASI,QAAT,CAAkBC,KAAlB,EAAyBN,MAAzB,EAAiCF,KAAjC,EAAwC;EACtC,MAAMS,QAAQ,GAAGD,KAAK,CAACE,MAAvB,CADsC,CAEtC;;EACA,KAAK,IAAIC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGF,QAA5B,EAAsCE,KAAK,EAA3C,EAA+C;IAC7C,IAAIV,IAAI,GAAGO,KAAK,CAACG,KAAD,CAAhB;;IACA,IAAIX,KAAK,CAACY,eAAN,CAAsB5B,GAAtB,CAA0BiB,IAA1B,CAAJ,EAAqC;MACnCD,KAAK,CAACa,GAAN,CAAUb,KAAK,CAACc,KAAN,EAAV,IAA2Bd,KAAK,CAACY,eAAN,CAAsBxB,GAAtB,CAA0Ba,IAA1B,CAA3B,CADmC,CAGnC;;MACA,KAAK,IAAIc,MAAM,GAAGJ,KAAK,GAAG,CAA1B,EAA6BI,MAAM,GAAGJ,KAAK,GAAGF,QAA9C,EAAwDM,MAAM,EAA9D,EAAkE;QAChEd,IAAI,GAAGO,KAAK,CAACO,MAAM,GAAGN,QAAV,CAAZ;;QACA,MAAMN,MAAM,GAAGJ,eAAe,CAACC,KAAD,EAAQC,IAAR,EAAcC,MAAd,CAA9B,CAFgE,CAGhE;;;QACAF,KAAK,CAACa,GAAN,CAAUb,KAAK,CAACc,KAAN,EAAV,IAA2BX,MAA3B;MACD,CATkC,CAUnC;;;MACA;IACD;EACF,CAlBqC,CAoBtC;;;EACA,KAAK,IAAIQ,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGF,QAA5B,EAAsCE,KAAK,EAA3C,EAA+C;IAC7C,IAAIV,IAAI,GAAGO,KAAK,CAACG,KAAD,CAAhB;;IACA,IAAI,CAACX,KAAK,CAACgB,gBAAN,CAAuBf,IAAvB,CAAL,EAAmC;MACjC,IAAIE,MAAM,GAAGJ,eAAe,CAACC,KAAD,EAAQC,IAAR,EAAcC,MAAd,CAA5B,CADiC,CAEjC;;;MACAF,KAAK,CAACgB,gBAAN,CAAuBf,IAAvB,IAA+B,CAA/B;MACAD,KAAK,CAACY,eAAN,CAAsBvB,GAAtB,CAA0BY,IAA1B,EAAgCE,MAAhC,EAJiC,CAKjC;MACA;;MACAH,KAAK,CAACM,cAAN,CAAqBH,MAArB,IAA+BD,MAA/B;MACAF,KAAK,CAACa,GAAN,CAAUb,KAAK,CAACc,KAAN,EAAV,IAA2BX,MAA3B,CARiC,CAUjC;;MACA,KAAK,IAAIY,MAAM,GAAGJ,KAAK,GAAG,CAA1B,EAA6BI,MAAM,GAAGJ,KAAK,GAAGF,QAA9C,EAAwDM,MAAM,EAA9D,EAAkE;QAChEd,IAAI,GAAGO,KAAK,CAACO,MAAM,GAAGN,QAAV,CAAZ;QACAN,MAAM,GAAGJ,eAAe,CAACC,KAAD,EAAQC,IAAR,EAAcC,MAAd,CAAxB,CAFgE,CAGhE;;QACAF,KAAK,CAACa,GAAN,CAAUb,KAAK,CAACc,KAAN,EAAV,IAA2BX,MAA3B;MACD,CAhBgC,CAiBjC;;;MACA;IACD;EACF,CA3CqC,CA6CtC;EACA;;;EACA,IAAIF,IAAI,GAAGO,KAAK,CAAC,CAAD,CAAhB;EACA,IAAIL,MAAM,GAAGH,KAAK,CAACG,MAAnB;EACAH,KAAK,CAACY,eAAN,CAAsBvB,GAAtB,CAA0BY,IAA1B,EAAgCE,MAAhC;EACAH,KAAK,CAACK,eAAN,CAAsBL,KAAK,CAACG,MAA5B,IAAsCF,IAAtC;EACAD,KAAK,CAACM,cAAN,CAAqBN,KAAK,CAACG,MAA3B,IAAqCD,MAArC;EACAF,KAAK,CAACG,MAAN,GApDsC,CAsDtC;;EACAH,KAAK,CAACa,GAAN,CAAUb,KAAK,CAACc,KAAN,EAAV,IAA2BX,MAA3B,CAvDsC,CAyDtC;;EACA,KAAK,IAAIY,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAGN,QAA9B,EAAwCM,MAAM,EAA9C,EAAkD;IAChDd,IAAI,GAAGO,KAAK,CAACO,MAAD,CAAZ;IACAZ,MAAM,GAAGJ,eAAe,CAACC,KAAD,EAAQC,IAAR,EAAcC,MAAd,CAAxB,CAFgD,CAGhD;;IACAF,KAAK,CAACa,GAAN,CAAUb,KAAK,CAACc,KAAN,EAAV,IAA2BX,MAA3B;EACD;AACF;;AAED,SAASc,SAAT,CAAmBT,KAAnB,EAA0BN,MAA1B,EAAkCF,KAAlC,EAAyC;EACvC,MAAMS,QAAQ,GAAGD,KAAK,CAACE,MAAvB;EACAV,KAAK,CAACkB,OAAN,IAAiBT,QAAjB,CAFuC,CAIvC;;EACA,KAAK,IAAIE,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGF,QAA5B,EAAsCE,KAAK,EAA3C,EAA+C;IAC7C,MAAMV,IAAI,GAAGO,KAAK,CAACG,KAAD,CAAlB;;IACA,IAAIX,KAAK,CAACY,eAAN,CAAsB5B,GAAtB,CAA0BiB,IAA1B,CAAJ,EAAqC;MACnC;IACD;EACF,CAVsC,CAYvC;;;EACA,KAAK,IAAIU,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGF,QAA5B,EAAsCE,KAAK,EAA3C,EAA+C;IAC7C,MAAMV,IAAI,GAAGO,KAAK,CAACG,KAAD,CAAlB;;IACA,IAAI,CAACX,KAAK,CAACgB,gBAAN,CAAuBf,IAAvB,CAAL,EAAmC;MACjCD,KAAK,CAACgB,gBAAN,CAAuBf,IAAvB,IAA+B,CAA/B;MACAD,KAAK,CAACY,eAAN,CAAsBvB,GAAtB,CAA0BY,IAA1B,EAAgC,CAAhC;MACA;IACD;EACF,CApBsC,CAqBvC;;;EACAD,KAAK,CAACY,eAAN,CAAsBvB,GAAtB,CAA0BmB,KAAK,CAAC,CAAD,CAA/B,EAAoC,CAApC;EACAR,KAAK,CAACmB,WAAN;AACD;;AAED,IAAIC,WAAJ;;AAEA,MAAMC,OAAO,GAAG,IAAIzC,WAAJ,CAAgB,CAAhB,CAAhB;;AACA,MAAM0C,OAAO,GAAG,IAAI1C,WAAJ,CAAgB,CAAhB,CAAhB;;AACA,MAAM2C,OAAO,GAAG,IAAI3C,WAAJ,CAAgB,CAAhB,CAAhB;;AACA,MAAM4C,kBAAkB,GAAG;EACzB;EACAC,gBAAgB,CAACC,SAAD,EAAYC,OAAZ,EAAqBC,MAArB,EAA6B1B,MAA7B,EAAqCF,KAArC,EAA4C;IAC1D,KAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwC,SAApB,EAA+B,EAAExC,CAAjC,EAAoC;MAClCmC,OAAO,CAAC,CAAD,CAAP,GAAaM,OAAO,CAACC,MAAM,GAAG1C,CAAV,CAApB;MACAkC,WAAW,CAACC,OAAD,EAAUnB,MAAV,EAAkBF,KAAlB,CAAX;IACD;EACF,CAPwB;;EAQzB6B,gBAAgB,CAACH,SAAD,EAAYC,OAAZ,EAAqBC,MAArB,EAA6B1B,MAA7B,EAAqCF,KAArC,EAA4C;IAC1D;IACA,KAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwC,SAAS,GAAG,CAAhC,EAAmC,EAAExC,CAArC,EAAwC;MACtCoC,OAAO,CAAC,CAAD,CAAP,GAAaK,OAAO,CAACC,MAAM,GAAG1C,CAAV,CAApB;MACAoC,OAAO,CAAC,CAAD,CAAP,GAAaK,OAAO,CAACC,MAAM,GAAG1C,CAAT,GAAa,CAAd,CAApB;MACAkC,WAAW,CAACE,OAAD,EAAUpB,MAAV,EAAkBF,KAAlB,CAAX;IACD;EACF,CAfwB;;EAgBzB8B,gBAAgB,CAACJ,SAAD,EAAYC,OAAZ,EAAqBC,MAArB,EAA6B1B,MAA7B,EAAqCF,KAArC,EAA4C;IAC1D;IACA,IAAI0B,SAAS,GAAG,CAAhB,EAAmB;MACjB,KAAK,IAAIxC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwC,SAApB,EAA+B,EAAExC,CAAjC,EAAoC;QAClCoC,OAAO,CAAC,CAAD,CAAP,GAAaK,OAAO,CAACC,MAAM,GAAG1C,CAAV,CAApB;QACAoC,OAAO,CAAC,CAAD,CAAP,GAAaK,OAAO,CAACC,MAAM,GAAI,CAAC1C,CAAC,GAAG,CAAL,IAAUwC,SAArB,CAApB;QACAN,WAAW,CAACE,OAAD,EAAUpB,MAAV,EAAkBF,KAAlB,CAAX;MACD;IACF;EACF,CAzBwB;;EA0BzB+B,iBAAiB,CAACL,SAAD,EAAYC,OAAZ,EAAqBC,MAArB,EAA6B1B,MAA7B,EAAqCF,KAArC,EAA4C;IAC3D,IAAI0B,SAAS,GAAG,CAAhB,EAAmB;MACjB;MACA,KAAK,IAAIxC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwC,SAAS,GAAG,CAAhC,EAAmC,EAAExC,CAArC,EAAwC;QACtCoC,OAAO,CAAC,CAAD,CAAP,GAAaK,OAAO,CAACC,MAAM,GAAG1C,CAAV,CAApB;QACAoC,OAAO,CAAC,CAAD,CAAP,GAAaK,OAAO,CAACC,MAAM,GAAG1C,CAAT,GAAa,CAAd,CAApB;QACAkC,WAAW,CAACE,OAAD,EAAUpB,MAAV,EAAkBF,KAAlB,CAAX;MACD;;MACD,KAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwC,SAAS,GAAG,CAAhC,EAAmCxC,CAAC,EAApC,EAAwC;QACtCoC,OAAO,CAAC,CAAD,CAAP,GAAaK,OAAO,CAACC,MAAM,GAAG1C,CAAV,CAApB;QACAoC,OAAO,CAAC,CAAD,CAAP,GAAaK,OAAO,CAACC,MAAM,GAAG1C,CAAT,GAAa,CAAd,CAApB;QACAkC,WAAW,CAACE,OAAD,EAAUpB,MAAV,EAAkBF,KAAlB,CAAX;MACD;IACF;EACF,CAxCwB;;EAyCzBgC,cAAc,CAACC,IAAD,EAAON,OAAP,EAAgBC,MAAhB,EAAwB1B,MAAxB,EAAgCF,KAAhC,EAAuC;IACnD,KAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+C,IAAI,GAAG,CAA3B,EAA8B/C,CAAC,EAA/B,EAAmC;MACjCqC,OAAO,CAAC,CAAD,CAAP,GAAaI,OAAO,CAACC,MAAD,CAApB;MACAL,OAAO,CAAC,CAAD,CAAP,GAAaI,OAAO,CAACC,MAAM,GAAG1C,CAAT,GAAa,CAAd,CAApB;MACAqC,OAAO,CAAC,CAAD,CAAP,GAAaI,OAAO,CAACC,MAAM,GAAG1C,CAAT,GAAa,CAAd,CAApB;MACAkC,WAAW,CAACG,OAAD,EAAUrB,MAAV,EAAkBF,KAAlB,CAAX;IACD;EACF,CAhDwB;;EAiDzBkC,eAAe,CAACD,IAAD,EAAON,OAAP,EAAgBC,MAAhB,EAAwB1B,MAAxB,EAAgCF,KAAhC,EAAuC;IACpD,KAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+C,IAAI,GAAG,CAA3B,EAA8B/C,CAAC,EAA/B,EAAmC;MACjCqC,OAAO,CAAC,CAAD,CAAP,GAAaI,OAAO,CAACC,MAAM,GAAG1C,CAAV,CAApB;MACAqC,OAAO,CAAC,CAAD,CAAP,GAAaI,OAAO,CAACC,MAAM,GAAG1C,CAAT,GAAa,CAAb,GAAkBA,CAAC,GAAG,CAAvB,CAApB;MACAqC,OAAO,CAAC,CAAD,CAAP,GAAaI,OAAO,CAACC,MAAM,GAAG1C,CAAT,GAAa,CAAb,GAAkB,CAACA,CAAC,GAAG,CAAL,IAAU,CAA7B,CAApB;MACAkC,WAAW,CAACG,OAAD,EAAUrB,MAAV,EAAkBF,KAAlB,CAAX;IACD;EACF;;AAxDwB,CAA3B,C,CA2DA;AACA;AACA;;AAEA,SAASmC,oBAAT,CAA8BC,SAA9B,EAAyCC,KAAzC,EAAgD;EAC9C;EACAA,KAAK,CAACC,cAAN,CAAqBC,IAArB,CAA0B,sBAA1B;;EAEAH,SAAS,CAACI,gBAAV,GAA8BC,GAAD,IAAS;IACpC,MAAMC,SAAS,GAAGD,GAAG,CAACE,KAAtB;IACA,MAAMC,aAAa,GAAGH,GAAG,CAACG,aAA1B;IACA,MAAMC,cAAc,GAAGJ,GAAG,CAACI,cAA3B;IACA,MAAMC,UAAU,GAAGL,GAAG,CAACK,UAAvB;IAEA,MAAMC,KAAK,GAAGL,SAAS,CAACM,OAAV,EAAd;IACA,MAAMC,aAAa,GAAGF,KAAK,CAACrC,MAA5B;IAEA,MAAMwC,SAAS,GAAG3D,gBAAgB,CAACqD,aAAD,CAAlC;IAEA,MAAMO,MAAM,GAAGV,GAAG,CAACW,cAAnB;IACA,MAAMpD,KAAK,GAAG;MACZgB,gBAAgB,EAAE,IAAIqC,UAAJ,CAAeF,MAAf,CADN;MAC8B;MAC1ChC,WAAW,EAAE,CAFD;MAGZD,OAAO,EAAE,CAHG;MAIZf,MAAM,EAAE,CAJI;MAKZW,KAAK,EAAE,CALK;MAMZF,eAAe,EAAE,IAAInC,WAAJ;IANL,CAAd;IASA,IAAI6E,IAAI,GAAG,IAAX;;IACA,IACET,cAAc,KAAKtE,cAAc,CAACgF,MAAlC,IACAX,aAAa,KAAKpE,cAAc,CAACiB,MAFnC,EAGE;MACA6D,IAAI,GAAG9B,kBAAkB,CAACC,gBAA1B;IACD,CALD,MAKO,IACLoB,cAAc,KAAKtE,cAAc,CAACiF,SAAlC,IACAZ,aAAa,KAAKpE,cAAc,CAACkB,KAF5B,EAGL;MACA4D,IAAI,GAAG9B,kBAAkB,CAAE,GAAE0B,SAAU,aAAd,CAAzB;IACD,CALM,MAKA;MACLI,IAAI,GAAG9B,kBAAkB,CAAE,GAAE0B,SAAU,WAAd,CAAzB;IACD,CAlCmC,CAoCpC;;;IACA9B,WAAW,GAAGH,SAAd;IACA,IAAIf,MAAM,GAAG4C,UAAU,IAAI,CAA3B;;IACA,KAAK,IAAIW,cAAc,GAAG,CAA1B,EAA6BA,cAAc,GAAGR,aAA9C,GAA+D;MAC7DjD,KAAK,CAACY,eAAN,CAAsB7B,KAAtB;MACAuE,IAAI,CAACP,KAAK,CAACU,cAAD,CAAN,EAAwBV,KAAxB,EAA+BU,cAAc,GAAG,CAAhD,EAAmDvD,MAAnD,EAA2DF,KAA3D,CAAJ;MACAyD,cAAc,IAAIV,KAAK,CAACU,cAAD,CAAL,GAAwB,CAA1C;MACAvD,MAAM;IACP,CA5CmC,CA8CpC;IACA;;;IACA,IAAIiD,MAAM,IAAI,MAAd,EAAsB;MACpBnD,KAAK,CAACK,eAAN,GAAwB,IAAIqD,WAAJ,CAAgBP,MAAM,GAAGnD,KAAK,CAACmB,WAA/B,CAAxB;IACD,CAFD,MAEO;MACLnB,KAAK,CAACK,eAAN,GAAwB,IAAIzB,WAAJ,CAAgBuE,MAAM,GAAGnD,KAAK,CAACmB,WAA/B,CAAxB;IACD;;IACD,IAAIgC,MAAM,GAAGnD,KAAK,CAACmB,WAAf,GAA6B,MAAjC,EAAyC;MACvCnB,KAAK,CAACI,eAAN,GAAwB,IAAIuD,UAAJ,CAAeR,MAAf,CAAxB;IACD,CAFD,MAEO;MACLnD,KAAK,CAACI,eAAN,GAAwB,IAAIwD,UAAJ,CAAeT,MAAf,CAAxB;IACD;;IACD,IAAIA,MAAM,GAAGnD,KAAK,CAACmB,WAAf,IAA8B,MAAlC,EAA0C;MACxCnB,KAAK,CAACa,GAAN,GAAY,IAAI6C,WAAJ,CAAgB1D,KAAK,CAACkB,OAAtB,CAAZ;MACAuB,GAAG,CAACoB,MAAJ,GAAa,QAAb;IACD,CAHD,MAGO;MACL7D,KAAK,CAACa,GAAN,GAAY,IAAIjC,WAAJ,CAAgBoB,KAAK,CAACkB,OAAtB,CAAZ;MACAuB,GAAG,CAACoB,MAAJ,GAAa,QAAb;IACD;;IACD,IAAI3D,MAAM,IAAI,MAAd,EAAsB;MACpBF,KAAK,CAACM,cAAN,GAAuB,IAAIoD,WAAJ,CAAgBP,MAAM,GAAGnD,KAAK,CAACmB,WAA/B,CAAvB;IACD,CAFD,MAEO;MACLnB,KAAK,CAACM,cAAN,GAAuB,IAAI1B,WAAJ,CAAgBuE,MAAM,GAAGnD,KAAK,CAACmB,WAA/B,CAAvB;IACD;;IACDnB,KAAK,CAACI,eAAN,CAAsB0D,IAAtB,CAA2B,CAAC,CAA5B;IACA9D,KAAK,CAACgB,gBAAN,CAAuB8C,IAAvB,CAA4B,CAA5B,EAvEoC,CAyEpC;;IACA1C,WAAW,GAAGb,QAAd;IACAL,MAAM,GAAG4C,UAAU,IAAI,CAAvB;;IACA,KAAK,IAAIW,cAAc,GAAG,CAA1B,EAA6BA,cAAc,GAAGR,aAA9C,GAA+D;MAC7DjD,KAAK,CAACY,eAAN,CAAsB7B,KAAtB;MACAuE,IAAI,CAACP,KAAK,CAACU,cAAD,CAAN,EAAwBV,KAAxB,EAA+BU,cAAc,GAAG,CAAhD,EAAmDvD,MAAnD,EAA2DF,KAA3D,CAAJ;MACAyD,cAAc,IAAIV,KAAK,CAACU,cAAD,CAAL,GAAwB,CAA1C;MACAvD,MAAM;IACP;;IAED,OAAOF,KAAK,CAACgB,gBAAb;IACA,OAAOhB,KAAK,CAACI,eAAb,CApFoC,CAsFpC;;IACAqC,GAAG,CAACsB,WAAJ,GAAkB/D,KAAK,CAACa,GAAxB;IACAwB,KAAK,CAAChC,eAAN,GAAwBL,KAAK,CAACK,eAA9B;IACAgC,KAAK,CAAC/B,cAAN,GAAuBN,KAAK,CAACM,cAA7B;IACA+B,KAAK,CAAC2B,QAAN,GAAiBhE,KAAK,CAACG,MAAvB;IACAkC,KAAK,CAAC4B,UAAN,GAAmBjE,KAAK,CAACc,KAAzB;EACD,CA5FD;AA6FD,C,CAED;AACA;AACA;;;AAEA,MAAMoD,cAAc,GAAG;EACrB7D,eAAe,EAAE,IADI;EAErBC,cAAc,EAAE,IAFK;EAGrB0D,QAAQ,EAAE,CAHW;EAIrBC,UAAU,EAAE;AAJS,CAAvB,C,CAOA;;AAEA,OAAO,SAASE,MAAT,CAAgB/B,SAAhB,EAA2BC,KAA3B,EAAsD;EAAA,IAApB+B,aAAoB,uEAAJ,EAAI;EAC3DC,MAAM,CAACC,MAAP,CAAcjC,KAAd,EAAqB6B,cAArB,EAAqCE,aAArC,EAD2D,CAG3D;;EACA9F,eAAe,CAAC6F,MAAhB,CAAuB/B,SAAvB,EAAkCC,KAAlC,EAAyC+B,aAAzC;EAEAjG,KAAK,CAACoG,MAAN,CAAanC,SAAb,EAAwBC,KAAxB,EAA+B,CAC7B,iBAD6B,EAE7B,gBAF6B,EAG7B,UAH6B,EAI7B,YAJ6B,CAA/B;EAOAF,oBAAoB,CAACC,SAAD,EAAYC,KAAZ,CAApB;AACD,C,CAED;;AAEA,OAAO,MAAMmC,WAAW,GAAGrG,KAAK,CAACqG,WAAN,CAAkBL,MAAlB,CAApB,C,CAEP;;AAEA,eAAe;EAAEK,WAAF;EAAeL,MAAf;EAAuB,GAAG/F;AAA1B,CAAf"},"metadata":{},"sourceType":"module"}