{"ast":null,"code":"import Constants from 'vtk.js/Sources/Rendering/OpenGL/Texture/Constants';\nimport HalfFloat from 'vtk.js/Sources/Common/Core/HalfFloat';\nimport * as macro from 'vtk.js/Sources/macros';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkViewNode from 'vtk.js/Sources/Rendering/SceneGraph/ViewNode';\nimport { registerOverride } from 'vtk.js/Sources/Rendering/OpenGL/ViewNodeFactory';\nconst {\n  Wrap,\n  Filter\n} = Constants;\nconst {\n  VtkDataTypes\n} = vtkDataArray;\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro; // ----------------------------------------------------------------------------\n// vtkOpenGLTexture methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLTexture(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLTexture'); // Renders myself\n\n  publicAPI.render = function () {\n    let renWin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    if (renWin) {\n      model._openGLRenderWindow = renWin;\n    } else {\n      model.openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer'); // sync renderable properties\n\n      model._openGLRenderWindow = model.openGLRenderer.getParent();\n    }\n\n    model.context = model._openGLRenderWindow.getContext();\n\n    if (model.renderable.getInterpolate()) {\n      if (model.generateMipmap) {\n        publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n      } else {\n        publicAPI.setMinificationFilter(Filter.LINEAR);\n      }\n\n      publicAPI.setMagnificationFilter(Filter.LINEAR);\n    } else {\n      publicAPI.setMinificationFilter(Filter.NEAREST);\n      publicAPI.setMagnificationFilter(Filter.NEAREST);\n    }\n\n    if (model.renderable.getRepeat()) {\n      publicAPI.setWrapR(Wrap.REPEAT);\n      publicAPI.setWrapS(Wrap.REPEAT);\n      publicAPI.setWrapT(Wrap.REPEAT);\n    } // clear image if input data is set\n\n\n    if (model.renderable.getInputData()) {\n      model.renderable.setImage(null);\n    } // create the texture if it is not done already\n\n\n    if (!model.handle || model.renderable.getMTime() > model.textureBuildTime.getMTime()) {\n      // if we have an Image\n      if (model.renderable.getImage() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        } // Have an Image which may not be complete\n\n\n        if (model.renderable.getImage() && model.renderable.getImageLoaded()) {\n          publicAPI.create2DFromImage(model.renderable.getImage());\n          publicAPI.activate();\n          publicAPI.sendParameters();\n          model.textureBuildTime.modified();\n        }\n      } // if we have a canvas\n\n\n      if (model.renderable.getCanvas() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n\n        const canvas = model.renderable.getCanvas();\n        publicAPI.create2DFromRaw(canvas.width, canvas.height, 4, VtkDataTypes.UNSIGNED_CHAR, canvas, true);\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      } // if we have jsImageData\n\n\n      if (model.renderable.getJsImageData() !== null) {\n        const jsid = model.renderable.getJsImageData();\n\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n\n        publicAPI.create2DFromRaw(jsid.width, jsid.height, 4, VtkDataTypes.UNSIGNED_CHAR, jsid.data, true);\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      } // if we have InputData\n\n\n      const input = model.renderable.getInputData(0);\n\n      if (input && input.getPointData().getScalars()) {\n        const ext = input.getExtent();\n        const inScalars = input.getPointData().getScalars(); // do we have a cube map? Six inputs\n\n        const data = [];\n\n        for (let i = 0; i < model.renderable.getNumberOfInputPorts(); ++i) {\n          const indata = model.renderable.getInputData(i);\n          const scalars = indata ? indata.getPointData().getScalars().getData() : null;\n\n          if (scalars) {\n            data.push(scalars);\n          }\n        }\n\n        if (model.renderable.getInterpolate() && inScalars.getNumberOfComponents() === 4) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n\n        if (data.length % 6 === 0) {\n          publicAPI.createCubeFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), data);\n        } else {\n          publicAPI.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());\n        }\n\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n    }\n\n    if (model.handle) {\n      publicAPI.activate();\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.destroyTexture = () => {\n    // deactivate it first\n    publicAPI.deactivate();\n\n    if (model.context && model.handle) {\n      model.context.deleteTexture(model.handle);\n    }\n\n    model.handle = 0;\n    model.numberOfDimensions = 0;\n    model.target = 0;\n    model.components = 0;\n    model.width = 0;\n    model.height = 0;\n    model.depth = 0;\n    publicAPI.resetFormatAndType();\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.createTexture = () => {\n    // reuse the existing handle if we have one\n    if (!model.handle) {\n      model.handle = model.context.createTexture();\n\n      if (model.target) {\n        model.context.bindTexture(model.target, model.handle); // See: http://www.openmodel.context..org/wiki/Common_Mistakes#Creating_a_complete_texture\n        // turn off mip map filter or set the base and max level correctly. here\n        // both are done.\n\n        model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));\n        model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));\n        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));\n        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));\n\n        if (model._openGLRenderWindow.getWebgl2()) {\n          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));\n        }\n\n        model.context.bindTexture(model.target, null);\n      }\n    }\n  }; //---------------------------------------------------------------------------\n\n\n  publicAPI.getTextureUnit = () => {\n    if (model._openGLRenderWindow) {\n      return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);\n    }\n\n    return -1;\n  }; //---------------------------------------------------------------------------\n\n\n  publicAPI.activate = () => {\n    // activate a free texture unit for this texture\n    model._openGLRenderWindow.activateTexture(publicAPI);\n\n    publicAPI.bind();\n  }; //---------------------------------------------------------------------------\n\n\n  publicAPI.deactivate = () => {\n    if (model._openGLRenderWindow) {\n      model._openGLRenderWindow.deactivateTexture(publicAPI);\n    }\n  }; //---------------------------------------------------------------------------\n\n\n  publicAPI.releaseGraphicsResources = rwin => {\n    if (rwin && model.handle) {\n      rwin.activateTexture(publicAPI);\n      rwin.deactivateTexture(publicAPI);\n      model.context.deleteTexture(model.handle);\n      model.handle = 0;\n      model.numberOfDimensions = 0;\n      model.target = 0;\n      model.internalFormat = 0;\n      model.format = 0;\n      model.openGLDataType = 0;\n      model.components = 0;\n      model.width = 0;\n      model.height = 0;\n      model.depth = 0;\n    }\n\n    if (model.shaderProgram) {\n      model.shaderProgram.releaseGraphicsResources(rwin);\n      model.shaderProgram = null;\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.bind = () => {\n    model.context.bindTexture(model.target, model.handle);\n\n    if (model.autoParameters && publicAPI.getMTime() > model.sendParametersTime.getMTime()) {\n      publicAPI.sendParameters();\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.isBound = () => {\n    let result = false;\n\n    if (model.context && model.handle) {\n      let target = 0;\n\n      switch (model.target) {\n        case model.context.TEXTURE_2D:\n          target = model.context.TEXTURE_BINDING_2D;\n          break;\n\n        default:\n          vtkWarningMacro('impossible case');\n          break;\n      }\n\n      const oid = model.context.getIntegerv(target);\n      result = oid === model.handle;\n    }\n\n    return result;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.sendParameters = () => {\n    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));\n    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));\n\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));\n    }\n\n    model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));\n    model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));\n\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.context.texParameteri(model.target, model.context.TEXTURE_BASE_LEVEL, model.baseLevel);\n      model.context.texParameteri(model.target, model.context.TEXTURE_MAX_LEVEL, model.maxLevel);\n    } // model.context.texParameterf(model.target, model.context.TEXTURE_MIN_LOD, model.minLOD);\n    // model.context.texParameterf(model.target, model.context.TEXTURE_MAX_LOD, model.maxLOD);\n\n\n    model.sendParametersTime.modified();\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getInternalFormat = (vtktype, numComps) => {\n    if (!model.internalFormat) {\n      model.internalFormat = publicAPI.getDefaultInternalFormat(vtktype, numComps);\n    }\n\n    if (!model.internalFormat) {\n      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);\n    }\n\n    return model.internalFormat;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getDefaultInternalFormat = (vtktype, numComps) => {\n    let result = 0; // try default next\n\n    result = model._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, false);\n\n    if (result) {\n      return result;\n    } // try floating point\n\n\n    result = this._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, true);\n\n    if (!result) {\n      vtkDebugMacro('Unsupported internal texture type!');\n      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);\n    }\n\n    return result;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.setInternalFormat = iFormat => {\n    if (iFormat !== model.internalFormat) {\n      model.internalFormat = iFormat;\n      publicAPI.modified();\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getFormat = (vtktype, numComps) => {\n    model.format = publicAPI.getDefaultFormat(vtktype, numComps);\n    return model.format;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getDefaultFormat = (vtktype, numComps) => {\n    if (model._openGLRenderWindow.getWebgl2()) {\n      switch (numComps) {\n        case 1:\n          return model.context.RED;\n\n        case 2:\n          return model.context.RG;\n\n        case 3:\n          return model.context.RGB;\n\n        case 4:\n          return model.context.RGBA;\n\n        default:\n          return model.context.RGB;\n      }\n    } else {\n      // webgl1\n      switch (numComps) {\n        case 1:\n          return model.context.LUMINANCE;\n\n        case 2:\n          return model.context.LUMINANCE_ALPHA;\n\n        case 3:\n          return model.context.RGB;\n\n        case 4:\n          return model.context.RGBA;\n\n        default:\n          return model.context.RGB;\n      }\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.resetFormatAndType = () => {\n    model.format = 0;\n    model.internalFormat = 0;\n    model.openGLDataType = 0;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getDefaultDataType = function (vtkScalarType) {\n    let useHalfFloatType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    // DON'T DEAL with VTK_CHAR as this is platform dependent.\n    if (model._openGLRenderWindow.getWebgl2()) {\n      switch (vtkScalarType) {\n        // case VtkDataTypes.SIGNED_CHAR:\n        //   return model.context.BYTE;\n        case VtkDataTypes.UNSIGNED_CHAR:\n          return model.context.UNSIGNED_BYTE;\n\n        case useHalfFloatType && VtkDataTypes.SHORT:\n          return model.context.HALF_FLOAT;\n\n        case useHalfFloatType && VtkDataTypes.UNSIGNED_SHORT:\n          return model.context.HALF_FLOAT;\n        // case VtkDataTypes.INT:\n        //   return model.context.INT;\n        // case VtkDataTypes.UNSIGNED_INT:\n        //   return model.context.UNSIGNED_INT;\n\n        case VtkDataTypes.FLOAT:\n        case VtkDataTypes.VOID: // used for depth component textures.\n\n        default:\n          return model.context.FLOAT;\n      }\n    }\n\n    switch (vtkScalarType) {\n      // case VtkDataTypes.SIGNED_CHAR:\n      //   return model.context.BYTE;\n      case VtkDataTypes.UNSIGNED_CHAR:\n        return model.context.UNSIGNED_BYTE;\n      // case VtkDataTypes.SHORT:\n      //   return model.context.SHORT;\n      // case VtkDataTypes.UNSIGNED_SHORT:\n      //   return model.context.UNSIGNED_SHORT;\n      // case VtkDataTypes.INT:\n      //   return model.context.INT;\n      // case VtkDataTypes.UNSIGNED_INT:\n      //   return model.context.UNSIGNED_INT;\n\n      case VtkDataTypes.FLOAT:\n      case VtkDataTypes.VOID: // used for depth component textures.\n\n      default:\n        if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n          return model.context.FLOAT;\n        }\n\n        {\n          const halfFloat = model.context.getExtension('OES_texture_half_float');\n\n          if (halfFloat && model.context.getExtension('OES_texture_half_float_linear')) {\n            return halfFloat.HALF_FLOAT_OES;\n          }\n        }\n        return model.context.UNSIGNED_BYTE;\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getOpenGLDataType = function (vtkScalarType) {\n    let useHalfFloatType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (!model.openGLDataType) {\n      model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType, useHalfFloatType);\n    }\n\n    return model.openGLDataType;\n  };\n\n  publicAPI.getShiftAndScale = () => {\n    let shift = 0.0;\n    let scale = 1.0; // for all float type internal formats\n\n    switch (model.openGLDataType) {\n      case model.context.BYTE:\n        scale = 127.5;\n        shift = scale - 128.0;\n        break;\n\n      case model.context.UNSIGNED_BYTE:\n        scale = 255.0;\n        shift = 0.0;\n        break;\n\n      case model.context.SHORT:\n        scale = 32767.5;\n        shift = scale - 32768.0;\n        break;\n\n      case model.context.UNSIGNED_SHORT:\n        scale = 65536.0;\n        shift = 0.0;\n        break;\n\n      case model.context.INT:\n        scale = 2147483647.5;\n        shift = scale - 2147483648.0;\n        break;\n\n      case model.context.UNSIGNED_INT:\n        scale = 4294967295.0;\n        shift = 0.0;\n        break;\n\n      case model.context.FLOAT:\n      default:\n        break;\n    }\n\n    return {\n      shift,\n      scale\n    };\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getOpenGLFilterMode = emode => {\n    switch (emode) {\n      case Filter.NEAREST:\n        return model.context.NEAREST;\n\n      case Filter.LINEAR:\n        return model.context.LINEAR;\n\n      case Filter.NEAREST_MIPMAP_NEAREST:\n        return model.context.NEAREST_MIPMAP_NEAREST;\n\n      case Filter.NEAREST_MIPMAP_LINEAR:\n        return model.context.NEAREST_MIPMAP_LINEAR;\n\n      case Filter.LINEAR_MIPMAP_NEAREST:\n        return model.context.LINEAR_MIPMAP_NEAREST;\n\n      case Filter.LINEAR_MIPMAP_LINEAR:\n        return model.context.LINEAR_MIPMAP_LINEAR;\n\n      default:\n        return model.context.NEAREST;\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getOpenGLWrapMode = vtktype => {\n    switch (vtktype) {\n      case Wrap.CLAMP_TO_EDGE:\n        return model.context.CLAMP_TO_EDGE;\n\n      case Wrap.REPEAT:\n        return model.context.REPEAT;\n\n      case Wrap.MIRRORED_REPEAT:\n        return model.context.MIRRORED_REPEAT;\n\n      default:\n        return model.context.CLAMP_TO_EDGE;\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  function updateArrayDataType(dataType, data) {\n    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const pixData = [];\n    let pixCount = model.width * model.height * model.components;\n\n    if (depth) {\n      pixCount *= model.depth;\n    } // if the opengl data type is float\n    // then the data array must be float\n\n\n    if (dataType !== VtkDataTypes.FLOAT && model.openGLDataType === model.context.FLOAT) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];\n          pixData.push(new Float32Array(dataArrayToCopy));\n        } else {\n          pixData.push(null);\n        }\n      }\n    } // if the opengl data type is ubyte\n    // then the data array must be u8, we currently simply truncate the data\n\n\n    if (dataType !== VtkDataTypes.UNSIGNED_CHAR && model.openGLDataType === model.context.UNSIGNED_BYTE) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];\n          pixData.push(new Uint8Array(dataArrayToCopy));\n        } else {\n          pixData.push(null);\n        }\n      }\n    } // if the opengl data type is half float\n    // then the data array must be u16\n\n\n    const halfFloatExt = model.context.getExtension('OES_texture_half_float');\n    const halfFloat = model._openGLRenderWindow.getWebgl2() ? model.openGLDataType === model.context.HALF_FLOAT : halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;\n\n    if (halfFloat) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const newArray = new Uint16Array(pixCount);\n\n          for (let i = 0; i < pixCount; i++) {\n            newArray[i] = HalfFloat.toHalf(data[idx][i]);\n          }\n\n          pixData.push(newArray);\n        } else {\n          pixData.push(null);\n        }\n      }\n    } // The output has to be filled\n\n\n    if (pixData.length === 0) {\n      for (let i = 0; i < data.length; i++) {\n        pixData.push(data[i]);\n      }\n    }\n\n    return pixData;\n  } //----------------------------------------------------------------------------\n\n\n  function scaleTextureToHighestPowerOfTwo(data) {\n    if (model._openGLRenderWindow.getWebgl2()) {\n      // No need if webGL2\n      return data;\n    }\n\n    const pixData = [];\n    const width = model.width;\n    const height = model.height;\n    const numComps = model.components;\n\n    if (data && (!vtkMath.isPowerOfTwo(width) || !vtkMath.isPowerOfTwo(height))) {\n      // Scale up the texture to the next highest power of two dimensions.\n      const halfFloat = model.context.getExtension('OES_texture_half_float');\n      const newWidth = vtkMath.nearestPowerOfTwo(width);\n      const newHeight = vtkMath.nearestPowerOfTwo(height);\n      const pixCount = newWidth * newHeight * model.components;\n\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx] !== null) {\n          let newArray = null;\n          const jFactor = height / newHeight;\n          const iFactor = width / newWidth;\n          let usingHalf = false;\n\n          if (model.openGLDataType === model.context.FLOAT) {\n            newArray = new Float32Array(pixCount);\n          } else if (halfFloat && model.openGLDataType === halfFloat.HALF_FLOAT_OES) {\n            newArray = new Uint16Array(pixCount);\n            usingHalf = true;\n          } else {\n            newArray = new Uint8Array(pixCount);\n          }\n\n          for (let j = 0; j < newHeight; j++) {\n            const joff = j * newWidth * numComps;\n            const jidx = j * jFactor;\n            let jlow = Math.floor(jidx);\n            let jhi = Math.ceil(jidx);\n\n            if (jhi >= height) {\n              jhi = height - 1;\n            }\n\n            const jmix = jidx - jlow;\n            const jmix1 = 1.0 - jmix;\n            jlow = jlow * width * numComps;\n            jhi = jhi * width * numComps;\n\n            for (let i = 0; i < newWidth; i++) {\n              const ioff = i * numComps;\n              const iidx = i * iFactor;\n              let ilow = Math.floor(iidx);\n              let ihi = Math.ceil(iidx);\n\n              if (ihi >= width) {\n                ihi = width - 1;\n              }\n\n              const imix = iidx - ilow;\n              ilow *= numComps;\n              ihi *= numComps;\n\n              for (let c = 0; c < numComps; c++) {\n                if (usingHalf) {\n                  newArray[joff + ioff + c] = HalfFloat.toHalf(HalfFloat.fromHalf(data[idx][jlow + ilow + c]) * jmix1 * (1.0 - imix) + HalfFloat.fromHalf(data[idx][jlow + ihi + c]) * jmix1 * imix + HalfFloat.fromHalf(data[idx][jhi + ilow + c]) * jmix * (1.0 - imix) + HalfFloat.fromHalf(data[idx][jhi + ihi + c]) * jmix * imix);\n                } else {\n                  newArray[joff + ioff + c] = data[idx][jlow + ilow + c] * jmix1 * (1.0 - imix) + data[idx][jlow + ihi + c] * jmix1 * imix + data[idx][jhi + ilow + c] * jmix * (1.0 - imix) + data[idx][jhi + ihi + c] * jmix * imix;\n                }\n              }\n            }\n          }\n\n          pixData.push(newArray);\n          model.width = newWidth;\n          model.height = newHeight;\n        } else {\n          pixData.push(null);\n        }\n      }\n    } // The output has to be filled\n\n\n    if (pixData.length === 0) {\n      for (let i = 0; i < data.length; i++) {\n        pixData.push(data[i]);\n      }\n    }\n\n    return pixData;\n  } //----------------------------------------------------------------------------\n\n\n  publicAPI.create2DFromRaw = function (width, height, numComps, dataType, data) {\n    let flip = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n\n    model.target = model.context.TEXTURE_2D;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n\n    model._openGLRenderWindow.activateTexture(publicAPI);\n\n    publicAPI.createTexture();\n    publicAPI.bind(); // Create an array of texture with one texture\n\n    const dataArray = [data];\n    const pixData = updateArrayDataType(dataType, dataArray);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData); // Source texture data from the PBO.\n\n    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, scaledData[0]);\n\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    } // always reset the flip\n\n\n    if (flip) {\n      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);\n    }\n\n    publicAPI.deactivate();\n    return true;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.createCubeFromRaw = (width, height, numComps, dataType, data) => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n\n    model.target = model.context.TEXTURE_CUBE_MAP;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n\n    model._openGLRenderWindow.activateTexture(publicAPI);\n\n    model.maxLevel = data.length / 6 - 1;\n    publicAPI.createTexture();\n    publicAPI.bind();\n    const pixData = updateArrayDataType(dataType, data);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData); // invert the data because opengl is messed up with cube maps\n    // and uses the old renderman standard with Y going down\n    // even though it is completely at odds with OpenGL standards\n\n    const invertedData = [];\n    let widthLevel = model.width;\n    let heightLevel = model.height;\n\n    for (let i = 0; i < scaledData.length; i++) {\n      if (i % 6 === 0 && i !== 0) {\n        widthLevel /= 2;\n        heightLevel /= 2;\n      }\n\n      invertedData[i] = macro.newTypedArray(dataType, heightLevel * widthLevel * model.components);\n\n      for (let y = 0; y < heightLevel; ++y) {\n        const row1 = y * widthLevel * model.components;\n        const row2 = (heightLevel - y - 1) * widthLevel * model.components;\n        invertedData[i].set(scaledData[i].slice(row2, row2 + widthLevel * model.components), row1);\n      }\n    } // Source texture data from the PBO.\n\n\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1); // We get the 6 images\n\n    for (let i = 0; i < 6; i++) {\n      // For each mipmap level\n      let j = 0;\n      let w = model.width;\n      let h = model.height;\n\n      while (w >= 1 && h >= 1) {\n        // In webgl 1, all levels need to be defined. So if the latest level size is\n        // 8x8, we have to add 3 more null textures (4x4, 2x2, 1x1)\n        // In webgl 2, the attribute maxLevel will be use.\n        let tempData = null;\n\n        if (j <= model.maxLevel) {\n          tempData = invertedData[6 * j + i];\n        }\n\n        model.context.texImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, model.internalFormat, w, h, 0, model.format, model.openGLDataType, tempData);\n        j++;\n        w /= 2;\n        h /= 2;\n      }\n    } // generateMipmap must not be called here because we manually upload all levels\n    // if it is called, all levels will be overwritten\n\n\n    publicAPI.deactivate();\n    return true;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.createDepthFromRaw = (width, height, dataType, data) => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    model.format = model.context.DEPTH_COMPONENT;\n\n    if (model._openGLRenderWindow.getWebgl2()) {\n      if (dataType === VtkDataTypes.FLOAT) {\n        model.internalFormat = model.context.DEPTH_COMPONENT32F;\n      } else {\n        model.internalFormat = model.context.DEPTH_COMPONENT16;\n      }\n    } else {\n      model.internalFormat = model.context.DEPTH_COMPONENT;\n    }\n\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n\n    model.target = model.context.TEXTURE_2D;\n    model.components = 1;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n\n    model._openGLRenderWindow.activateTexture(publicAPI);\n\n    publicAPI.createTexture();\n    publicAPI.bind(); // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, data);\n\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n\n    publicAPI.deactivate();\n    return true;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.create2DFromImage = image => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(VtkDataTypes.UNSIGNED_CHAR);\n    publicAPI.getInternalFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n    publicAPI.getFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n\n    model.target = model.context.TEXTURE_2D;\n    model.components = 4;\n    model.width = image.width;\n    model.height = image.height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n\n    model._openGLRenderWindow.activateTexture(publicAPI);\n\n    publicAPI.createTexture();\n    publicAPI.bind(); // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1); // Scale up the texture to the next highest power of two dimensions (if needed) and flip y.\n\n    const needNearestPowerOfTwo = !vtkMath.isPowerOfTwo(image.width) || !vtkMath.isPowerOfTwo(image.height);\n    const canvas = document.createElement('canvas');\n    canvas.width = needNearestPowerOfTwo ? vtkMath.nearestPowerOfTwo(image.width) : image.width;\n    canvas.height = needNearestPowerOfTwo ? vtkMath.nearestPowerOfTwo(image.height) : image.height;\n    const ctx = canvas.getContext('2d');\n    ctx.translate(0, canvas.height);\n    ctx.scale(1, -1);\n    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);\n    const safeImage = canvas;\n    model.context.texImage2D(model.target, 0, model.internalFormat, model.format, model.openGLDataType, safeImage);\n\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n\n    publicAPI.deactivate();\n    return true;\n  };\n\n  function computeScaleOffsets(numComps, numPixelsIn, data) {\n    // compute min and max values per component\n    const min = [];\n    const max = [];\n\n    for (let c = 0; c < numComps; ++c) {\n      min[c] = data[c];\n      max[c] = data[c];\n    }\n\n    let count = 0;\n\n    for (let i = 0; i < numPixelsIn; ++i) {\n      for (let c = 0; c < numComps; ++c) {\n        if (data[count] < min[c]) {\n          min[c] = data[count];\n        }\n\n        if (data[count] > max[c]) {\n          max[c] = data[count];\n        }\n\n        count++;\n      }\n    }\n\n    const offset = [];\n    const scale = [];\n\n    for (let c = 0; c < numComps; ++c) {\n      if (min[c] === max[c]) {\n        max[c] = min[c] + 1.0;\n      }\n\n      offset[c] = min[c];\n      scale[c] = max[c] - min[c];\n    }\n\n    return {\n      scale,\n      offset\n    };\n  } // HalfFloat only represents numbers between [-2048, 2048] exactly accurate,\n  // for numbers outside of this range there is a precision limitation\n\n\n  function hasExactHalfFloat(offset, scale) {\n    // Per Component\n    for (let c = 0; c < offset.length; c++) {\n      const min = offset[c];\n      const max = scale[c] + min;\n\n      if (min < -2048 || min > 2048 || max < -2048 || max > 2048) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function checkUseHalfFloat(dataType, offset, scale, preferSizeOverAccuracy) {\n    const useHalfFloatType = true;\n    publicAPI.getOpenGLDataType(dataType, useHalfFloatType);\n    const halfFloatExt = model.context.getExtension('OES_texture_half_float');\n    const useHalfFloat = model._openGLRenderWindow.getWebgl2() ? model.openGLDataType === model.context.HALF_FLOAT : halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;\n\n    if (!useHalfFloat) {\n      return false;\n    } // Don't consider halfFloat and convert back to Float when the range of data does not generate an accurate halfFloat\n    // AND it is not preferable to have a smaller texture than an exact texture.\n\n\n    if (!hasExactHalfFloat(offset, scale) && !preferSizeOverAccuracy) {\n      return false;\n    }\n\n    return true;\n  } //----------------------------------------------------------------------------\n\n\n  publicAPI.create3DFromRaw = (width, height, depth, numComps, dataType, data) => {\n    // Permit OpenGLDataType to be half float, if applicable, for 3D\n    const useHalfFloatType = true;\n    publicAPI.getOpenGLDataType(dataType, useHalfFloatType); // Now determine the texture parameters using the arguments.\n\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n\n    model.target = model.context.TEXTURE_3D;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = depth;\n    model.numberOfDimensions = 3;\n\n    model._openGLRenderWindow.activateTexture(publicAPI);\n\n    publicAPI.createTexture();\n    publicAPI.bind(); // Create an array of texture with one texture\n\n    const dataArray = [data];\n    const is3DArray = true;\n    const pixData = updateArrayDataType(dataType, dataArray, is3DArray);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData); // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    // model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n\n    model.context.texImage3D(model.target, 0, model.internalFormat, model.width, model.height, model.depth, 0, model.format, model.openGLDataType, scaledData[0]);\n\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n\n    publicAPI.deactivate();\n    return true;\n  }; //----------------------------------------------------------------------------\n  // This method simulates a 3D texture using 2D\n\n\n  publicAPI.create3DFilterableFromRaw = function (width, height, depth, numComps, dataType, data) {\n    let preferSizeOverAccuracy = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    const numPixelsIn = width * height * depth; // initialize offset/scale\n\n    const offset = [];\n    const scale = [];\n\n    for (let c = 0; c < numComps; ++c) {\n      offset[c] = 0.0;\n      scale[c] = 1.0;\n    } // store the information, we will need it later\n    // offset and scale are the offset and scale required to get\n    // the texture value back to data values ala\n    // data = texture * scale + offset\n    // and texture = (data - offset)/scale\n\n\n    model.volumeInfo = {\n      scale,\n      offset,\n      width,\n      height,\n      depth\n    }; // Check if we can accurately use halfFloat or whether it is preferred to have a smaller size texture\n    // compute min and max values\n\n    const {\n      offset: computedOffset,\n      scale: computedScale\n    } = computeScaleOffsets(numComps, numPixelsIn, data);\n    model.volumeInfo.dataComputedScale = computedScale;\n    model.volumeInfo.dataComputedOffset = computedOffset;\n    const useHalfFloat = checkUseHalfFloat(dataType, computedOffset, computedScale, preferSizeOverAccuracy); // WebGL2 path, we have 3d textures etc\n\n    if (model._openGLRenderWindow.getWebgl2()) {\n      if (dataType === VtkDataTypes.FLOAT || useHalfFloat && (dataType === VtkDataTypes.SHORT || dataType === VtkDataTypes.UNSIGNED_SHORT)) {\n        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);\n      }\n\n      if (dataType === VtkDataTypes.UNSIGNED_CHAR) {\n        for (let c = 0; c < numComps; ++c) {\n          model.volumeInfo.scale[c] = 255.0;\n        }\n\n        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);\n      } // otherwise convert to float\n\n\n      const newArray = new Float32Array(numPixelsIn * numComps); // compute min and max values\n\n      model.volumeInfo.offset = computedOffset;\n      model.volumeInfo.scale = computedScale;\n      let count = 0;\n      const scaleInverse = computedScale.map(s => 1 / s);\n\n      for (let i = 0; i < numPixelsIn; i++) {\n        for (let nc = 0; nc < numComps; nc++) {\n          newArray[count] = (data[count] - computedOffset[nc]) * scaleInverse[nc];\n          count++;\n        }\n      }\n\n      return publicAPI.create3DFromRaw(width, height, depth, numComps, VtkDataTypes.FLOAT, newArray);\n    } // not webgl2, deal with webgl1, no 3d textures\n    // and maybe no float textures\n    // compute min and max values\n\n\n    const res = computeScaleOffsets(numComps, numPixelsIn, data);\n\n    let volCopyData = (outArray, outIdx, inValue, smin, smax) => {\n      outArray[outIdx] = inValue;\n    };\n\n    let dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR; // unsigned char gets used as is\n\n    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {\n      for (let c = 0; c < numComps; ++c) {\n        res.offset[c] = 0.0;\n        res.scale[c] = 255.0;\n      }\n    } else if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n      // use float textures scaled to 0.0 to 1.0\n      dataTypeToUse = VtkDataTypes.FLOAT;\n\n      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {\n        outArray[outIdx] = (inValue - soffset) / sscale;\n      };\n    } else {\n      // worst case, scale data to uchar\n      dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;\n\n      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {\n        outArray[outIdx] = 255.0 * (inValue - soffset) / sscale;\n      };\n    } // Now determine the texture parameters using the arguments.\n\n\n    publicAPI.getOpenGLDataType(dataTypeToUse);\n    publicAPI.getInternalFormat(dataTypeToUse, numComps);\n    publicAPI.getFormat(dataTypeToUse, numComps);\n\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    } // have to pack this 3D texture into pot 2D texture\n\n\n    model.target = model.context.TEXTURE_2D;\n    model.components = numComps;\n    model.depth = 1;\n    model.numberOfDimensions = 2; // MAX_TEXTURE_SIZE gives the max dimensions that can be supported by the GPU,\n    // but it doesn't mean it will fit in memory. If we have to use a float data type\n    // or 4 components, there are good chances that the texture size will blow up\n    // and could not fit in the GPU memory. Use a smaller texture size in that case,\n    // which will force a downsampling of the dataset.\n    // That problem does not occur when using webGL2 since we can pack the data in\n    // denser textures based on our data type.\n    // TODO: try to fit in the biggest supported texture, catch the gl error if it\n    // does not fix (OUT_OF_MEMORY), then attempt with smaller texture\n\n    let maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);\n\n    if (maxTexDim > 4096 && (dataTypeToUse === VtkDataTypes.FLOAT || numComps >= 3)) {\n      maxTexDim = 4096;\n    } // compute estimate for XY subsample\n\n\n    let xstride = 1;\n    let ystride = 1;\n\n    if (numPixelsIn > maxTexDim * maxTexDim) {\n      xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));\n      ystride = xstride;\n    }\n\n    let targetWidth = Math.sqrt(numPixelsIn) / xstride;\n    targetWidth = vtkMath.nearestPowerOfTwo(targetWidth); // determine X reps\n\n    const xreps = Math.floor(targetWidth * xstride / width);\n    const yreps = Math.ceil(depth / xreps);\n    const targetHeight = vtkMath.nearestPowerOfTwo(height * yreps / ystride);\n    model.width = targetWidth;\n    model.height = targetHeight;\n\n    model._openGLRenderWindow.activateTexture(publicAPI);\n\n    publicAPI.createTexture();\n    publicAPI.bind(); // store the information, we will need it later\n\n    model.volumeInfo.xreps = xreps;\n    model.volumeInfo.yreps = yreps;\n    model.volumeInfo.xstride = xstride;\n    model.volumeInfo.ystride = ystride;\n    model.volumeInfo.offset = res.offset;\n    model.volumeInfo.scale = res.scale; // OK stuff the data into the 2d TEXTURE\n    // first allocate the new texture\n\n    let newArray;\n    const pixCount = targetWidth * targetHeight * numComps;\n\n    if (dataTypeToUse === VtkDataTypes.FLOAT) {\n      newArray = new Float32Array(pixCount);\n    } else {\n      newArray = new Uint8Array(pixCount);\n    } // then stuff the data into it, nothing fancy right now\n    // for stride\n\n\n    let outIdx = 0;\n    const tileWidth = Math.floor(width / xstride);\n    const tileHeight = Math.floor(height / ystride);\n\n    for (let yRep = 0; yRep < yreps; yRep++) {\n      const xrepsThisRow = Math.min(xreps, depth - yRep * xreps);\n      const outXContIncr = numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));\n\n      for (let tileY = 0; tileY < tileHeight; tileY++) {\n        for (let xRep = 0; xRep < xrepsThisRow; xRep++) {\n          const inOffset = numComps * ((yRep * xreps + xRep) * width * height + ystride * tileY * width);\n\n          for (let tileX = 0; tileX < tileWidth; tileX++) {\n            // copy value\n            for (let nc = 0; nc < numComps; nc++) {\n              volCopyData(newArray, outIdx, data[inOffset + xstride * tileX * numComps + nc], res.offset[nc], res.scale[nc]);\n              outIdx++;\n            }\n          }\n        }\n\n        outIdx += outXContIncr;\n      }\n    } // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n\n\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, newArray);\n    publicAPI.deactivate();\n    return true;\n  };\n\n  publicAPI.setOpenGLRenderWindow = rw => {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getMaximumTextureSize = ctx => {\n    if (ctx && ctx.isCurrent()) {\n      return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);\n    }\n\n    return -1;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  _openGLRenderWindow: null,\n  context: null,\n  handle: 0,\n  sendParametersTime: null,\n  textureBuildTime: null,\n  numberOfDimensions: 0,\n  target: 0,\n  format: 0,\n  openGLDataType: 0,\n  components: 0,\n  width: 0,\n  height: 0,\n  depth: 0,\n  autoParameters: true,\n  wrapS: Wrap.CLAMP_TO_EDGE,\n  wrapT: Wrap.CLAMP_TO_EDGE,\n  wrapR: Wrap.CLAMP_TO_EDGE,\n  minificationFilter: Filter.NEAREST,\n  magnificationFilter: Filter.NEAREST,\n  minLOD: -1000.0,\n  maxLOD: 1000.0,\n  baseLevel: 0,\n  maxLevel: 1000,\n  generateMipmap: false\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.sendParametersTime = {};\n  macro.obj(model.sendParametersTime, {\n    mtime: 0\n  });\n  model.textureBuildTime = {};\n  macro.obj(model.textureBuildTime, {\n    mtime: 0\n  }); // Build VTK API\n\n  macro.set(publicAPI, model, ['format', 'openGLDataType']);\n  macro.setGet(publicAPI, model, ['keyMatrixTime', 'minificationFilter', 'magnificationFilter', 'wrapS', 'wrapT', 'wrapR', 'generateMipmap']);\n  macro.get(publicAPI, model, ['width', 'height', 'volumeInfo', 'components', 'handle', 'target']); // Object methods\n\n  vtkOpenGLTexture(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkOpenGLTexture'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend,\n  ...Constants\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkTexture', newInstance);","map":{"version":3,"names":["Constants","HalfFloat","macro","vtkDataArray","vtkMath","vtkViewNode","registerOverride","Wrap","Filter","VtkDataTypes","vtkDebugMacro","vtkErrorMacro","vtkWarningMacro","vtkOpenGLTexture","publicAPI","model","classHierarchy","push","render","renWin","_openGLRenderWindow","openGLRenderer","getFirstAncestorOfType","getParent","context","getContext","renderable","getInterpolate","generateMipmap","setMinificationFilter","LINEAR_MIPMAP_LINEAR","LINEAR","setMagnificationFilter","NEAREST","getRepeat","setWrapR","REPEAT","setWrapS","setWrapT","getInputData","setImage","handle","getMTime","textureBuildTime","getImage","getImageLoaded","create2DFromImage","activate","sendParameters","modified","getCanvas","canvas","create2DFromRaw","width","height","UNSIGNED_CHAR","getJsImageData","jsid","data","input","getPointData","getScalars","ext","getExtent","inScalars","i","getNumberOfInputPorts","indata","scalars","getData","getNumberOfComponents","length","createCubeFromRaw","getDataType","destroyTexture","deactivate","deleteTexture","numberOfDimensions","target","components","depth","resetFormatAndType","createTexture","bindTexture","texParameteri","TEXTURE_MIN_FILTER","getOpenGLFilterMode","minificationFilter","TEXTURE_MAG_FILTER","magnificationFilter","TEXTURE_WRAP_S","getOpenGLWrapMode","wrapS","TEXTURE_WRAP_T","wrapT","getWebgl2","TEXTURE_WRAP_R","wrapR","getTextureUnit","getTextureUnitForTexture","activateTexture","bind","deactivateTexture","releaseGraphicsResources","rwin","internalFormat","format","openGLDataType","shaderProgram","autoParameters","sendParametersTime","isBound","result","TEXTURE_2D","TEXTURE_BINDING_2D","oid","getIntegerv","TEXTURE_BASE_LEVEL","baseLevel","TEXTURE_MAX_LEVEL","maxLevel","getInternalFormat","vtktype","numComps","getDefaultInternalFormat","getDefaultTextureInternalFormat","setInternalFormat","iFormat","getFormat","getDefaultFormat","RED","RG","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","getDefaultDataType","vtkScalarType","useHalfFloatType","UNSIGNED_BYTE","SHORT","HALF_FLOAT","UNSIGNED_SHORT","FLOAT","VOID","getExtension","halfFloat","HALF_FLOAT_OES","getOpenGLDataType","getShiftAndScale","shift","scale","BYTE","INT","UNSIGNED_INT","emode","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","CLAMP_TO_EDGE","MIRRORED_REPEAT","updateArrayDataType","dataType","pixData","pixCount","idx","dataArrayToCopy","subarray","Float32Array","Uint8Array","halfFloatExt","newArray","Uint16Array","toHalf","scaleTextureToHighestPowerOfTwo","isPowerOfTwo","newWidth","nearestPowerOfTwo","newHeight","jFactor","iFactor","usingHalf","j","joff","jidx","jlow","Math","floor","jhi","ceil","jmix","jmix1","ioff","iidx","ilow","ihi","imix","c","fromHalf","flip","dataArray","scaledData","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_ALIGNMENT","texImage2D","TEXTURE_CUBE_MAP","invertedData","widthLevel","heightLevel","newTypedArray","y","row1","row2","set","slice","w","h","tempData","TEXTURE_CUBE_MAP_POSITIVE_X","createDepthFromRaw","DEPTH_COMPONENT","DEPTH_COMPONENT32F","DEPTH_COMPONENT16","image","needNearestPowerOfTwo","document","createElement","ctx","translate","drawImage","safeImage","computeScaleOffsets","numPixelsIn","min","max","count","offset","hasExactHalfFloat","checkUseHalfFloat","preferSizeOverAccuracy","useHalfFloat","create3DFromRaw","TEXTURE_3D","is3DArray","texImage3D","create3DFilterableFromRaw","volumeInfo","computedOffset","computedScale","dataComputedScale","dataComputedOffset","scaleInverse","map","s","nc","res","volCopyData","outArray","outIdx","inValue","smin","smax","dataTypeToUse","soffset","sscale","maxTexDim","getParameter","MAX_TEXTURE_SIZE","xstride","ystride","sqrt","targetWidth","xreps","yreps","targetHeight","tileWidth","tileHeight","yRep","xrepsThisRow","outXContIncr","tileY","xRep","inOffset","tileX","setOpenGLRenderWindow","rw","getMaximumTextureSize","isCurrent","DEFAULT_VALUES","minLOD","maxLOD","extend","initialValues","Object","assign","obj","mtime","setGet","get","newInstance"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/OpenGL/Texture/index.js"],"sourcesContent":["import Constants from 'vtk.js/Sources/Rendering/OpenGL/Texture/Constants';\nimport HalfFloat from 'vtk.js/Sources/Common/Core/HalfFloat';\nimport * as macro from 'vtk.js/Sources/macros';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkViewNode from 'vtk.js/Sources/Rendering/SceneGraph/ViewNode';\n\nimport { registerOverride } from 'vtk.js/Sources/Rendering/OpenGL/ViewNodeFactory';\n\nconst { Wrap, Filter } = Constants;\nconst { VtkDataTypes } = vtkDataArray;\nconst { vtkDebugMacro, vtkErrorMacro, vtkWarningMacro } = macro;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLTexture methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLTexture(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLTexture');\n  // Renders myself\n  publicAPI.render = (renWin = null) => {\n    if (renWin) {\n      model._openGLRenderWindow = renWin;\n    } else {\n      model.openGLRenderer =\n        publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      // sync renderable properties\n      model._openGLRenderWindow = model.openGLRenderer.getParent();\n    }\n    model.context = model._openGLRenderWindow.getContext();\n    if (model.renderable.getInterpolate()) {\n      if (model.generateMipmap) {\n        publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n      } else {\n        publicAPI.setMinificationFilter(Filter.LINEAR);\n      }\n      publicAPI.setMagnificationFilter(Filter.LINEAR);\n    } else {\n      publicAPI.setMinificationFilter(Filter.NEAREST);\n      publicAPI.setMagnificationFilter(Filter.NEAREST);\n    }\n    if (model.renderable.getRepeat()) {\n      publicAPI.setWrapR(Wrap.REPEAT);\n      publicAPI.setWrapS(Wrap.REPEAT);\n      publicAPI.setWrapT(Wrap.REPEAT);\n    }\n    // clear image if input data is set\n    if (model.renderable.getInputData()) {\n      model.renderable.setImage(null);\n    }\n    // create the texture if it is not done already\n    if (\n      !model.handle ||\n      model.renderable.getMTime() > model.textureBuildTime.getMTime()\n    ) {\n      // if we have an Image\n      if (model.renderable.getImage() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        // Have an Image which may not be complete\n        if (model.renderable.getImage() && model.renderable.getImageLoaded()) {\n          publicAPI.create2DFromImage(model.renderable.getImage());\n          publicAPI.activate();\n          publicAPI.sendParameters();\n          model.textureBuildTime.modified();\n        }\n      }\n      // if we have a canvas\n      if (model.renderable.getCanvas() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        const canvas = model.renderable.getCanvas();\n        publicAPI.create2DFromRaw(\n          canvas.width,\n          canvas.height,\n          4,\n          VtkDataTypes.UNSIGNED_CHAR,\n          canvas,\n          true\n        );\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n      // if we have jsImageData\n      if (model.renderable.getJsImageData() !== null) {\n        const jsid = model.renderable.getJsImageData();\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        publicAPI.create2DFromRaw(\n          jsid.width,\n          jsid.height,\n          4,\n          VtkDataTypes.UNSIGNED_CHAR,\n          jsid.data,\n          true\n        );\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n      // if we have InputData\n      const input = model.renderable.getInputData(0);\n      if (input && input.getPointData().getScalars()) {\n        const ext = input.getExtent();\n        const inScalars = input.getPointData().getScalars();\n\n        // do we have a cube map? Six inputs\n        const data = [];\n        for (let i = 0; i < model.renderable.getNumberOfInputPorts(); ++i) {\n          const indata = model.renderable.getInputData(i);\n          const scalars = indata\n            ? indata.getPointData().getScalars().getData()\n            : null;\n          if (scalars) {\n            data.push(scalars);\n          }\n        }\n        if (\n          model.renderable.getInterpolate() &&\n          inScalars.getNumberOfComponents() === 4\n        ) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        if (data.length % 6 === 0) {\n          publicAPI.createCubeFromRaw(\n            ext[1] - ext[0] + 1,\n            ext[3] - ext[2] + 1,\n            inScalars.getNumberOfComponents(),\n            inScalars.getDataType(),\n            data\n          );\n        } else {\n          publicAPI.create2DFromRaw(\n            ext[1] - ext[0] + 1,\n            ext[3] - ext[2] + 1,\n            inScalars.getNumberOfComponents(),\n            inScalars.getDataType(),\n            inScalars.getData()\n          );\n        }\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n    }\n    if (model.handle) {\n      publicAPI.activate();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.destroyTexture = () => {\n    // deactivate it first\n    publicAPI.deactivate();\n\n    if (model.context && model.handle) {\n      model.context.deleteTexture(model.handle);\n    }\n    model.handle = 0;\n    model.numberOfDimensions = 0;\n    model.target = 0;\n    model.components = 0;\n    model.width = 0;\n    model.height = 0;\n    model.depth = 0;\n    publicAPI.resetFormatAndType();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createTexture = () => {\n    // reuse the existing handle if we have one\n    if (!model.handle) {\n      model.handle = model.context.createTexture();\n\n      if (model.target) {\n        model.context.bindTexture(model.target, model.handle);\n\n        // See: http://www.openmodel.context..org/wiki/Common_Mistakes#Creating_a_complete_texture\n        // turn off mip map filter or set the base and max level correctly. here\n        // both are done.\n        model.context.texParameteri(\n          model.target,\n          model.context.TEXTURE_MIN_FILTER,\n          publicAPI.getOpenGLFilterMode(model.minificationFilter)\n        );\n        model.context.texParameteri(\n          model.target,\n          model.context.TEXTURE_MAG_FILTER,\n          publicAPI.getOpenGLFilterMode(model.magnificationFilter)\n        );\n\n        model.context.texParameteri(\n          model.target,\n          model.context.TEXTURE_WRAP_S,\n          publicAPI.getOpenGLWrapMode(model.wrapS)\n        );\n        model.context.texParameteri(\n          model.target,\n          model.context.TEXTURE_WRAP_T,\n          publicAPI.getOpenGLWrapMode(model.wrapT)\n        );\n        if (model._openGLRenderWindow.getWebgl2()) {\n          model.context.texParameteri(\n            model.target,\n            model.context.TEXTURE_WRAP_R,\n            publicAPI.getOpenGLWrapMode(model.wrapR)\n          );\n        }\n\n        model.context.bindTexture(model.target, null);\n      }\n    }\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.getTextureUnit = () => {\n    if (model._openGLRenderWindow) {\n      return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);\n    }\n    return -1;\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.activate = () => {\n    // activate a free texture unit for this texture\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.bind();\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.deactivate = () => {\n    if (model._openGLRenderWindow) {\n      model._openGLRenderWindow.deactivateTexture(publicAPI);\n    }\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.releaseGraphicsResources = (rwin) => {\n    if (rwin && model.handle) {\n      rwin.activateTexture(publicAPI);\n      rwin.deactivateTexture(publicAPI);\n      model.context.deleteTexture(model.handle);\n      model.handle = 0;\n      model.numberOfDimensions = 0;\n      model.target = 0;\n      model.internalFormat = 0;\n      model.format = 0;\n      model.openGLDataType = 0;\n      model.components = 0;\n      model.width = 0;\n      model.height = 0;\n      model.depth = 0;\n    }\n    if (model.shaderProgram) {\n      model.shaderProgram.releaseGraphicsResources(rwin);\n      model.shaderProgram = null;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.bind = () => {\n    model.context.bindTexture(model.target, model.handle);\n    if (\n      model.autoParameters &&\n      publicAPI.getMTime() > model.sendParametersTime.getMTime()\n    ) {\n      publicAPI.sendParameters();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.isBound = () => {\n    let result = false;\n    if (model.context && model.handle) {\n      let target = 0;\n      switch (model.target) {\n        case model.context.TEXTURE_2D:\n          target = model.context.TEXTURE_BINDING_2D;\n          break;\n        default:\n          vtkWarningMacro('impossible case');\n          break;\n      }\n      const oid = model.context.getIntegerv(target);\n      result = oid === model.handle;\n    }\n    return result;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.sendParameters = () => {\n    model.context.texParameteri(\n      model.target,\n      model.context.TEXTURE_WRAP_S,\n      publicAPI.getOpenGLWrapMode(model.wrapS)\n    );\n    model.context.texParameteri(\n      model.target,\n      model.context.TEXTURE_WRAP_T,\n      publicAPI.getOpenGLWrapMode(model.wrapT)\n    );\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.context.texParameteri(\n        model.target,\n        model.context.TEXTURE_WRAP_R,\n        publicAPI.getOpenGLWrapMode(model.wrapR)\n      );\n    }\n\n    model.context.texParameteri(\n      model.target,\n      model.context.TEXTURE_MIN_FILTER,\n      publicAPI.getOpenGLFilterMode(model.minificationFilter)\n    );\n\n    model.context.texParameteri(\n      model.target,\n      model.context.TEXTURE_MAG_FILTER,\n      publicAPI.getOpenGLFilterMode(model.magnificationFilter)\n    );\n\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.context.texParameteri(\n        model.target,\n        model.context.TEXTURE_BASE_LEVEL,\n        model.baseLevel\n      );\n\n      model.context.texParameteri(\n        model.target,\n        model.context.TEXTURE_MAX_LEVEL,\n        model.maxLevel\n      );\n    }\n\n    // model.context.texParameterf(model.target, model.context.TEXTURE_MIN_LOD, model.minLOD);\n    // model.context.texParameterf(model.target, model.context.TEXTURE_MAX_LOD, model.maxLOD);\n\n    model.sendParametersTime.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getInternalFormat = (vtktype, numComps) => {\n    if (!model.internalFormat) {\n      model.internalFormat = publicAPI.getDefaultInternalFormat(\n        vtktype,\n        numComps\n      );\n    }\n\n    if (!model.internalFormat) {\n      vtkDebugMacro(\n        `Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`\n      );\n    }\n\n    return model.internalFormat;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultInternalFormat = (vtktype, numComps) => {\n    let result = 0;\n\n    // try default next\n    result = model._openGLRenderWindow.getDefaultTextureInternalFormat(\n      vtktype,\n      numComps,\n      false\n    );\n    if (result) {\n      return result;\n    }\n\n    // try floating point\n    result = this._openGLRenderWindow.getDefaultTextureInternalFormat(\n      vtktype,\n      numComps,\n      true\n    );\n\n    if (!result) {\n      vtkDebugMacro('Unsupported internal texture type!');\n      vtkDebugMacro(\n        `Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`\n      );\n    }\n\n    return result;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.setInternalFormat = (iFormat) => {\n    if (iFormat !== model.internalFormat) {\n      model.internalFormat = iFormat;\n      publicAPI.modified();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getFormat = (vtktype, numComps) => {\n    model.format = publicAPI.getDefaultFormat(vtktype, numComps);\n    return model.format;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultFormat = (vtktype, numComps) => {\n    if (model._openGLRenderWindow.getWebgl2()) {\n      switch (numComps) {\n        case 1:\n          return model.context.RED;\n        case 2:\n          return model.context.RG;\n        case 3:\n          return model.context.RGB;\n        case 4:\n          return model.context.RGBA;\n        default:\n          return model.context.RGB;\n      }\n    } else {\n      // webgl1\n      switch (numComps) {\n        case 1:\n          return model.context.LUMINANCE;\n        case 2:\n          return model.context.LUMINANCE_ALPHA;\n        case 3:\n          return model.context.RGB;\n        case 4:\n          return model.context.RGBA;\n        default:\n          return model.context.RGB;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.resetFormatAndType = () => {\n    model.format = 0;\n    model.internalFormat = 0;\n    model.openGLDataType = 0;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultDataType = (vtkScalarType, useHalfFloatType = false) => {\n    // DON'T DEAL with VTK_CHAR as this is platform dependent.\n    if (model._openGLRenderWindow.getWebgl2()) {\n      switch (vtkScalarType) {\n        // case VtkDataTypes.SIGNED_CHAR:\n        //   return model.context.BYTE;\n        case VtkDataTypes.UNSIGNED_CHAR:\n          return model.context.UNSIGNED_BYTE;\n        case useHalfFloatType && VtkDataTypes.SHORT:\n          return model.context.HALF_FLOAT;\n        case useHalfFloatType && VtkDataTypes.UNSIGNED_SHORT:\n          return model.context.HALF_FLOAT;\n        // case VtkDataTypes.INT:\n        //   return model.context.INT;\n        // case VtkDataTypes.UNSIGNED_INT:\n        //   return model.context.UNSIGNED_INT;\n        case VtkDataTypes.FLOAT:\n        case VtkDataTypes.VOID: // used for depth component textures.\n        default:\n          return model.context.FLOAT;\n      }\n    }\n\n    switch (vtkScalarType) {\n      // case VtkDataTypes.SIGNED_CHAR:\n      //   return model.context.BYTE;\n      case VtkDataTypes.UNSIGNED_CHAR:\n        return model.context.UNSIGNED_BYTE;\n      // case VtkDataTypes.SHORT:\n      //   return model.context.SHORT;\n      // case VtkDataTypes.UNSIGNED_SHORT:\n      //   return model.context.UNSIGNED_SHORT;\n      // case VtkDataTypes.INT:\n      //   return model.context.INT;\n      // case VtkDataTypes.UNSIGNED_INT:\n      //   return model.context.UNSIGNED_INT;\n      case VtkDataTypes.FLOAT:\n      case VtkDataTypes.VOID: // used for depth component textures.\n      default:\n        if (\n          model.context.getExtension('OES_texture_float') &&\n          model.context.getExtension('OES_texture_float_linear')\n        ) {\n          return model.context.FLOAT;\n        }\n        {\n          const halfFloat = model.context.getExtension(\n            'OES_texture_half_float'\n          );\n          if (\n            halfFloat &&\n            model.context.getExtension('OES_texture_half_float_linear')\n          ) {\n            return halfFloat.HALF_FLOAT_OES;\n          }\n        }\n        return model.context.UNSIGNED_BYTE;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLDataType = (vtkScalarType, useHalfFloatType = false) => {\n    if (!model.openGLDataType) {\n      model.openGLDataType = publicAPI.getDefaultDataType(\n        vtkScalarType,\n        useHalfFloatType\n      );\n    }\n    return model.openGLDataType;\n  };\n\n  publicAPI.getShiftAndScale = () => {\n    let shift = 0.0;\n    let scale = 1.0;\n\n    // for all float type internal formats\n    switch (model.openGLDataType) {\n      case model.context.BYTE:\n        scale = 127.5;\n        shift = scale - 128.0;\n        break;\n      case model.context.UNSIGNED_BYTE:\n        scale = 255.0;\n        shift = 0.0;\n        break;\n      case model.context.SHORT:\n        scale = 32767.5;\n        shift = scale - 32768.0;\n        break;\n      case model.context.UNSIGNED_SHORT:\n        scale = 65536.0;\n        shift = 0.0;\n        break;\n      case model.context.INT:\n        scale = 2147483647.5;\n        shift = scale - 2147483648.0;\n        break;\n      case model.context.UNSIGNED_INT:\n        scale = 4294967295.0;\n        shift = 0.0;\n        break;\n      case model.context.FLOAT:\n      default:\n        break;\n    }\n    return { shift, scale };\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLFilterMode = (emode) => {\n    switch (emode) {\n      case Filter.NEAREST:\n        return model.context.NEAREST;\n      case Filter.LINEAR:\n        return model.context.LINEAR;\n      case Filter.NEAREST_MIPMAP_NEAREST:\n        return model.context.NEAREST_MIPMAP_NEAREST;\n      case Filter.NEAREST_MIPMAP_LINEAR:\n        return model.context.NEAREST_MIPMAP_LINEAR;\n      case Filter.LINEAR_MIPMAP_NEAREST:\n        return model.context.LINEAR_MIPMAP_NEAREST;\n      case Filter.LINEAR_MIPMAP_LINEAR:\n        return model.context.LINEAR_MIPMAP_LINEAR;\n      default:\n        return model.context.NEAREST;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLWrapMode = (vtktype) => {\n    switch (vtktype) {\n      case Wrap.CLAMP_TO_EDGE:\n        return model.context.CLAMP_TO_EDGE;\n      case Wrap.REPEAT:\n        return model.context.REPEAT;\n      case Wrap.MIRRORED_REPEAT:\n        return model.context.MIRRORED_REPEAT;\n      default:\n        return model.context.CLAMP_TO_EDGE;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  function updateArrayDataType(dataType, data, depth = false) {\n    const pixData = [];\n\n    let pixCount = model.width * model.height * model.components;\n    if (depth) {\n      pixCount *= model.depth;\n    }\n\n    // if the opengl data type is float\n    // then the data array must be float\n    if (\n      dataType !== VtkDataTypes.FLOAT &&\n      model.openGLDataType === model.context.FLOAT\n    ) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const dataArrayToCopy =\n            data[idx].length > pixCount\n              ? data[idx].subarray(0, pixCount)\n              : data[idx];\n          pixData.push(new Float32Array(dataArrayToCopy));\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // if the opengl data type is ubyte\n    // then the data array must be u8, we currently simply truncate the data\n    if (\n      dataType !== VtkDataTypes.UNSIGNED_CHAR &&\n      model.openGLDataType === model.context.UNSIGNED_BYTE\n    ) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const dataArrayToCopy =\n            data[idx].length > pixCount\n              ? data[idx].subarray(0, pixCount)\n              : data[idx];\n          pixData.push(new Uint8Array(dataArrayToCopy));\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // if the opengl data type is half float\n    // then the data array must be u16\n    const halfFloatExt = model.context.getExtension('OES_texture_half_float');\n    const halfFloat = model._openGLRenderWindow.getWebgl2()\n      ? model.openGLDataType === model.context.HALF_FLOAT\n      : halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;\n\n    if (halfFloat) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const newArray = new Uint16Array(pixCount);\n          for (let i = 0; i < pixCount; i++) {\n            newArray[i] = HalfFloat.toHalf(data[idx][i]);\n          }\n          pixData.push(newArray);\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // The output has to be filled\n    if (pixData.length === 0) {\n      for (let i = 0; i < data.length; i++) {\n        pixData.push(data[i]);\n      }\n    }\n\n    return pixData;\n  }\n\n  //----------------------------------------------------------------------------\n  function scaleTextureToHighestPowerOfTwo(data) {\n    if (model._openGLRenderWindow.getWebgl2()) {\n      // No need if webGL2\n      return data;\n    }\n    const pixData = [];\n    const width = model.width;\n    const height = model.height;\n    const numComps = model.components;\n    if (\n      data &&\n      (!vtkMath.isPowerOfTwo(width) || !vtkMath.isPowerOfTwo(height))\n    ) {\n      // Scale up the texture to the next highest power of two dimensions.\n      const halfFloat = model.context.getExtension('OES_texture_half_float');\n      const newWidth = vtkMath.nearestPowerOfTwo(width);\n      const newHeight = vtkMath.nearestPowerOfTwo(height);\n      const pixCount = newWidth * newHeight * model.components;\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx] !== null) {\n          let newArray = null;\n          const jFactor = height / newHeight;\n          const iFactor = width / newWidth;\n          let usingHalf = false;\n          if (model.openGLDataType === model.context.FLOAT) {\n            newArray = new Float32Array(pixCount);\n          } else if (\n            halfFloat &&\n            model.openGLDataType === halfFloat.HALF_FLOAT_OES\n          ) {\n            newArray = new Uint16Array(pixCount);\n            usingHalf = true;\n          } else {\n            newArray = new Uint8Array(pixCount);\n          }\n          for (let j = 0; j < newHeight; j++) {\n            const joff = j * newWidth * numComps;\n            const jidx = j * jFactor;\n            let jlow = Math.floor(jidx);\n            let jhi = Math.ceil(jidx);\n            if (jhi >= height) {\n              jhi = height - 1;\n            }\n            const jmix = jidx - jlow;\n            const jmix1 = 1.0 - jmix;\n            jlow = jlow * width * numComps;\n            jhi = jhi * width * numComps;\n            for (let i = 0; i < newWidth; i++) {\n              const ioff = i * numComps;\n              const iidx = i * iFactor;\n              let ilow = Math.floor(iidx);\n              let ihi = Math.ceil(iidx);\n              if (ihi >= width) {\n                ihi = width - 1;\n              }\n              const imix = iidx - ilow;\n              ilow *= numComps;\n              ihi *= numComps;\n              for (let c = 0; c < numComps; c++) {\n                if (usingHalf) {\n                  newArray[joff + ioff + c] = HalfFloat.toHalf(\n                    HalfFloat.fromHalf(data[idx][jlow + ilow + c]) *\n                      jmix1 *\n                      (1.0 - imix) +\n                      HalfFloat.fromHalf(data[idx][jlow + ihi + c]) *\n                        jmix1 *\n                        imix +\n                      HalfFloat.fromHalf(data[idx][jhi + ilow + c]) *\n                        jmix *\n                        (1.0 - imix) +\n                      HalfFloat.fromHalf(data[idx][jhi + ihi + c]) * jmix * imix\n                  );\n                } else {\n                  newArray[joff + ioff + c] =\n                    data[idx][jlow + ilow + c] * jmix1 * (1.0 - imix) +\n                    data[idx][jlow + ihi + c] * jmix1 * imix +\n                    data[idx][jhi + ilow + c] * jmix * (1.0 - imix) +\n                    data[idx][jhi + ihi + c] * jmix * imix;\n                }\n              }\n            }\n          }\n          pixData.push(newArray);\n          model.width = newWidth;\n          model.height = newHeight;\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // The output has to be filled\n    if (pixData.length === 0) {\n      for (let i = 0; i < data.length; i++) {\n        pixData.push(data[i]);\n      }\n    }\n\n    return pixData;\n  }\n\n  //----------------------------------------------------------------------------\n  publicAPI.create2DFromRaw = (\n    width,\n    height,\n    numComps,\n    dataType,\n    data,\n    flip = false\n  ) => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n\n    model.target = model.context.TEXTURE_2D;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Create an array of texture with one texture\n    const dataArray = [data];\n    const pixData = updateArrayDataType(dataType, dataArray);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // Source texture data from the PBO.\n    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n\n    model.context.texImage2D(\n      model.target,\n      0,\n      model.internalFormat,\n      model.width,\n      model.height,\n      0,\n      model.format,\n      model.openGLDataType,\n      scaledData[0]\n    );\n\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n\n    // always reset the flip\n    if (flip) {\n      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);\n    }\n\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createCubeFromRaw = (width, height, numComps, dataType, data) => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n\n    model.target = model.context.TEXTURE_CUBE_MAP;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    model.maxLevel = data.length / 6 - 1;\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    const pixData = updateArrayDataType(dataType, data);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // invert the data because opengl is messed up with cube maps\n    // and uses the old renderman standard with Y going down\n    // even though it is completely at odds with OpenGL standards\n    const invertedData = [];\n    let widthLevel = model.width;\n    let heightLevel = model.height;\n    for (let i = 0; i < scaledData.length; i++) {\n      if (i % 6 === 0 && i !== 0) {\n        widthLevel /= 2;\n        heightLevel /= 2;\n      }\n      invertedData[i] = macro.newTypedArray(\n        dataType,\n        heightLevel * widthLevel * model.components\n      );\n      for (let y = 0; y < heightLevel; ++y) {\n        const row1 = y * widthLevel * model.components;\n        const row2 = (heightLevel - y - 1) * widthLevel * model.components;\n        invertedData[i].set(\n          scaledData[i].slice(row2, row2 + widthLevel * model.components),\n          row1\n        );\n      }\n    }\n\n    // Source texture data from the PBO.\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n\n    // We get the 6 images\n    for (let i = 0; i < 6; i++) {\n      // For each mipmap level\n      let j = 0;\n      let w = model.width;\n      let h = model.height;\n      while (w >= 1 && h >= 1) {\n        // In webgl 1, all levels need to be defined. So if the latest level size is\n        // 8x8, we have to add 3 more null textures (4x4, 2x2, 1x1)\n        // In webgl 2, the attribute maxLevel will be use.\n        let tempData = null;\n        if (j <= model.maxLevel) {\n          tempData = invertedData[6 * j + i];\n        }\n        model.context.texImage2D(\n          model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i,\n          j,\n          model.internalFormat,\n          w,\n          h,\n          0,\n          model.format,\n          model.openGLDataType,\n          tempData\n        );\n        j++;\n        w /= 2;\n        h /= 2;\n      }\n    }\n\n    // generateMipmap must not be called here because we manually upload all levels\n    // if it is called, all levels will be overwritten\n\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createDepthFromRaw = (width, height, dataType, data) => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    model.format = model.context.DEPTH_COMPONENT;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      if (dataType === VtkDataTypes.FLOAT) {\n        model.internalFormat = model.context.DEPTH_COMPONENT32F;\n      } else {\n        model.internalFormat = model.context.DEPTH_COMPONENT16;\n      }\n    } else {\n      model.internalFormat = model.context.DEPTH_COMPONENT;\n    }\n\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n\n    model.target = model.context.TEXTURE_2D;\n    model.components = 1;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n\n    model.context.texImage2D(\n      model.target,\n      0,\n      model.internalFormat,\n      model.width,\n      model.height,\n      0,\n      model.format,\n      model.openGLDataType,\n      data\n    );\n\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.create2DFromImage = (image) => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(VtkDataTypes.UNSIGNED_CHAR);\n    publicAPI.getInternalFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n    publicAPI.getFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n\n    model.target = model.context.TEXTURE_2D;\n    model.components = 4;\n    model.width = image.width;\n    model.height = image.height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n\n    // Scale up the texture to the next highest power of two dimensions (if needed) and flip y.\n    const needNearestPowerOfTwo =\n      !vtkMath.isPowerOfTwo(image.width) || !vtkMath.isPowerOfTwo(image.height);\n    const canvas = document.createElement('canvas');\n    canvas.width = needNearestPowerOfTwo\n      ? vtkMath.nearestPowerOfTwo(image.width)\n      : image.width;\n    canvas.height = needNearestPowerOfTwo\n      ? vtkMath.nearestPowerOfTwo(image.height)\n      : image.height;\n    const ctx = canvas.getContext('2d');\n    ctx.translate(0, canvas.height);\n    ctx.scale(1, -1);\n    ctx.drawImage(\n      image,\n      0,\n      0,\n      image.width,\n      image.height,\n      0,\n      0,\n      canvas.width,\n      canvas.height\n    );\n    const safeImage = canvas;\n\n    model.context.texImage2D(\n      model.target,\n      0,\n      model.internalFormat,\n      model.format,\n      model.openGLDataType,\n      safeImage\n    );\n\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n\n    publicAPI.deactivate();\n    return true;\n  };\n\n  function computeScaleOffsets(numComps, numPixelsIn, data) {\n    // compute min and max values per component\n    const min = [];\n    const max = [];\n    for (let c = 0; c < numComps; ++c) {\n      min[c] = data[c];\n      max[c] = data[c];\n    }\n    let count = 0;\n    for (let i = 0; i < numPixelsIn; ++i) {\n      for (let c = 0; c < numComps; ++c) {\n        if (data[count] < min[c]) {\n          min[c] = data[count];\n        }\n        if (data[count] > max[c]) {\n          max[c] = data[count];\n        }\n        count++;\n      }\n    }\n    const offset = [];\n    const scale = [];\n    for (let c = 0; c < numComps; ++c) {\n      if (min[c] === max[c]) {\n        max[c] = min[c] + 1.0;\n      }\n      offset[c] = min[c];\n      scale[c] = max[c] - min[c];\n    }\n    return { scale, offset };\n  }\n\n  // HalfFloat only represents numbers between [-2048, 2048] exactly accurate,\n  // for numbers outside of this range there is a precision limitation\n  function hasExactHalfFloat(offset, scale) {\n    // Per Component\n    for (let c = 0; c < offset.length; c++) {\n      const min = offset[c];\n      const max = scale[c] + min;\n      if (min < -2048 || min > 2048 || max < -2048 || max > 2048) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function checkUseHalfFloat(dataType, offset, scale, preferSizeOverAccuracy) {\n    const useHalfFloatType = true;\n    publicAPI.getOpenGLDataType(dataType, useHalfFloatType);\n\n    const halfFloatExt = model.context.getExtension('OES_texture_half_float');\n    const useHalfFloat = model._openGLRenderWindow.getWebgl2()\n      ? model.openGLDataType === model.context.HALF_FLOAT\n      : halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;\n\n    if (!useHalfFloat) {\n      return false;\n    }\n\n    // Don't consider halfFloat and convert back to Float when the range of data does not generate an accurate halfFloat\n    // AND it is not preferable to have a smaller texture than an exact texture.\n    if (!hasExactHalfFloat(offset, scale) && !preferSizeOverAccuracy) {\n      return false;\n    }\n\n    return true;\n  }\n\n  //----------------------------------------------------------------------------\n  publicAPI.create3DFromRaw = (\n    width,\n    height,\n    depth,\n    numComps,\n    dataType,\n    data\n  ) => {\n    // Permit OpenGLDataType to be half float, if applicable, for 3D\n    const useHalfFloatType = true;\n    publicAPI.getOpenGLDataType(dataType, useHalfFloatType);\n\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n\n    model.target = model.context.TEXTURE_3D;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = depth;\n    model.numberOfDimensions = 3;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n    // Create an array of texture with one texture\n    const dataArray = [data];\n    const is3DArray = true;\n    const pixData = updateArrayDataType(dataType, dataArray, is3DArray);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    // model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n\n    model.context.texImage3D(\n      model.target,\n      0,\n      model.internalFormat,\n      model.width,\n      model.height,\n      model.depth,\n      0,\n      model.format,\n      model.openGLDataType,\n      scaledData[0]\n    );\n\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  // This method simulates a 3D texture using 2D\n  publicAPI.create3DFilterableFromRaw = (\n    width,\n    height,\n    depth,\n    numComps,\n    dataType,\n    data,\n    preferSizeOverAccuracy = false\n  ) => {\n    const numPixelsIn = width * height * depth;\n\n    // initialize offset/scale\n    const offset = [];\n    const scale = [];\n    for (let c = 0; c < numComps; ++c) {\n      offset[c] = 0.0;\n      scale[c] = 1.0;\n    }\n\n    // store the information, we will need it later\n    // offset and scale are the offset and scale required to get\n    // the texture value back to data values ala\n    // data = texture * scale + offset\n    // and texture = (data - offset)/scale\n    model.volumeInfo = { scale, offset, width, height, depth };\n\n    // Check if we can accurately use halfFloat or whether it is preferred to have a smaller size texture\n    // compute min and max values\n    const { offset: computedOffset, scale: computedScale } =\n      computeScaleOffsets(numComps, numPixelsIn, data);\n    model.volumeInfo.dataComputedScale = computedScale;\n    model.volumeInfo.dataComputedOffset = computedOffset;\n\n    const useHalfFloat = checkUseHalfFloat(\n      dataType,\n      computedOffset,\n      computedScale,\n      preferSizeOverAccuracy\n    );\n\n    // WebGL2 path, we have 3d textures etc\n    if (model._openGLRenderWindow.getWebgl2()) {\n      if (\n        dataType === VtkDataTypes.FLOAT ||\n        (useHalfFloat &&\n          (dataType === VtkDataTypes.SHORT ||\n            dataType === VtkDataTypes.UNSIGNED_SHORT))\n      ) {\n        return publicAPI.create3DFromRaw(\n          width,\n          height,\n          depth,\n          numComps,\n          dataType,\n          data\n        );\n      }\n      if (dataType === VtkDataTypes.UNSIGNED_CHAR) {\n        for (let c = 0; c < numComps; ++c) {\n          model.volumeInfo.scale[c] = 255.0;\n        }\n        return publicAPI.create3DFromRaw(\n          width,\n          height,\n          depth,\n          numComps,\n          dataType,\n          data\n        );\n      }\n      // otherwise convert to float\n      const newArray = new Float32Array(numPixelsIn * numComps);\n      // compute min and max values\n      model.volumeInfo.offset = computedOffset;\n      model.volumeInfo.scale = computedScale;\n      let count = 0;\n      const scaleInverse = computedScale.map((s) => 1 / s);\n      for (let i = 0; i < numPixelsIn; i++) {\n        for (let nc = 0; nc < numComps; nc++) {\n          newArray[count] =\n            (data[count] - computedOffset[nc]) * scaleInverse[nc];\n          count++;\n        }\n      }\n      return publicAPI.create3DFromRaw(\n        width,\n        height,\n        depth,\n        numComps,\n        VtkDataTypes.FLOAT,\n        newArray\n      );\n    }\n\n    // not webgl2, deal with webgl1, no 3d textures\n    // and maybe no float textures\n\n    // compute min and max values\n    const res = computeScaleOffsets(numComps, numPixelsIn, data);\n\n    let volCopyData = (outArray, outIdx, inValue, smin, smax) => {\n      outArray[outIdx] = inValue;\n    };\n    let dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;\n    // unsigned char gets used as is\n    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {\n      for (let c = 0; c < numComps; ++c) {\n        res.offset[c] = 0.0;\n        res.scale[c] = 255.0;\n      }\n    } else if (\n      model.context.getExtension('OES_texture_float') &&\n      model.context.getExtension('OES_texture_float_linear')\n    ) {\n      // use float textures scaled to 0.0 to 1.0\n      dataTypeToUse = VtkDataTypes.FLOAT;\n      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {\n        outArray[outIdx] = (inValue - soffset) / sscale;\n      };\n    } else {\n      // worst case, scale data to uchar\n      dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;\n      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {\n        outArray[outIdx] = (255.0 * (inValue - soffset)) / sscale;\n      };\n    }\n\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataTypeToUse);\n    publicAPI.getInternalFormat(dataTypeToUse, numComps);\n    publicAPI.getFormat(dataTypeToUse, numComps);\n\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n\n    // have to pack this 3D texture into pot 2D texture\n    model.target = model.context.TEXTURE_2D;\n    model.components = numComps;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n\n    // MAX_TEXTURE_SIZE gives the max dimensions that can be supported by the GPU,\n    // but it doesn't mean it will fit in memory. If we have to use a float data type\n    // or 4 components, there are good chances that the texture size will blow up\n    // and could not fit in the GPU memory. Use a smaller texture size in that case,\n    // which will force a downsampling of the dataset.\n    // That problem does not occur when using webGL2 since we can pack the data in\n    // denser textures based on our data type.\n    // TODO: try to fit in the biggest supported texture, catch the gl error if it\n    // does not fix (OUT_OF_MEMORY), then attempt with smaller texture\n    let maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);\n    if (\n      maxTexDim > 4096 &&\n      (dataTypeToUse === VtkDataTypes.FLOAT || numComps >= 3)\n    ) {\n      maxTexDim = 4096;\n    }\n\n    // compute estimate for XY subsample\n    let xstride = 1;\n    let ystride = 1;\n    if (numPixelsIn > maxTexDim * maxTexDim) {\n      xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));\n      ystride = xstride;\n    }\n    let targetWidth = Math.sqrt(numPixelsIn) / xstride;\n    targetWidth = vtkMath.nearestPowerOfTwo(targetWidth);\n    // determine X reps\n    const xreps = Math.floor((targetWidth * xstride) / width);\n    const yreps = Math.ceil(depth / xreps);\n    const targetHeight = vtkMath.nearestPowerOfTwo((height * yreps) / ystride);\n\n    model.width = targetWidth;\n    model.height = targetHeight;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // store the information, we will need it later\n    model.volumeInfo.xreps = xreps;\n    model.volumeInfo.yreps = yreps;\n    model.volumeInfo.xstride = xstride;\n    model.volumeInfo.ystride = ystride;\n    model.volumeInfo.offset = res.offset;\n    model.volumeInfo.scale = res.scale;\n\n    // OK stuff the data into the 2d TEXTURE\n\n    // first allocate the new texture\n    let newArray;\n    const pixCount = targetWidth * targetHeight * numComps;\n    if (dataTypeToUse === VtkDataTypes.FLOAT) {\n      newArray = new Float32Array(pixCount);\n    } else {\n      newArray = new Uint8Array(pixCount);\n    }\n\n    // then stuff the data into it, nothing fancy right now\n    // for stride\n    let outIdx = 0;\n\n    const tileWidth = Math.floor(width / xstride);\n    const tileHeight = Math.floor(height / ystride);\n\n    for (let yRep = 0; yRep < yreps; yRep++) {\n      const xrepsThisRow = Math.min(xreps, depth - yRep * xreps);\n      const outXContIncr =\n        numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));\n      for (let tileY = 0; tileY < tileHeight; tileY++) {\n        for (let xRep = 0; xRep < xrepsThisRow; xRep++) {\n          const inOffset =\n            numComps *\n            ((yRep * xreps + xRep) * width * height + ystride * tileY * width);\n\n          for (let tileX = 0; tileX < tileWidth; tileX++) {\n            // copy value\n            for (let nc = 0; nc < numComps; nc++) {\n              volCopyData(\n                newArray,\n                outIdx,\n                data[inOffset + xstride * tileX * numComps + nc],\n                res.offset[nc],\n                res.scale[nc]\n              );\n              outIdx++;\n            }\n          }\n        }\n        outIdx += outXContIncr;\n      }\n    }\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n\n    model.context.texImage2D(\n      model.target,\n      0,\n      model.internalFormat,\n      model.width,\n      model.height,\n      0,\n      model.format,\n      model.openGLDataType,\n      newArray\n    );\n\n    publicAPI.deactivate();\n    return true;\n  };\n\n  publicAPI.setOpenGLRenderWindow = (rw) => {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getMaximumTextureSize = (ctx) => {\n    if (ctx && ctx.isCurrent()) {\n      return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);\n    }\n\n    return -1;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  _openGLRenderWindow: null,\n  context: null,\n  handle: 0,\n  sendParametersTime: null,\n  textureBuildTime: null,\n  numberOfDimensions: 0,\n  target: 0,\n  format: 0,\n  openGLDataType: 0,\n  components: 0,\n  width: 0,\n  height: 0,\n  depth: 0,\n  autoParameters: true,\n  wrapS: Wrap.CLAMP_TO_EDGE,\n  wrapT: Wrap.CLAMP_TO_EDGE,\n  wrapR: Wrap.CLAMP_TO_EDGE,\n  minificationFilter: Filter.NEAREST,\n  magnificationFilter: Filter.NEAREST,\n  minLOD: -1000.0,\n  maxLOD: 1000.0,\n  baseLevel: 0,\n  maxLevel: 1000,\n  generateMipmap: false,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n\n  model.sendParametersTime = {};\n  macro.obj(model.sendParametersTime, { mtime: 0 });\n\n  model.textureBuildTime = {};\n  macro.obj(model.textureBuildTime, { mtime: 0 });\n\n  // Build VTK API\n  macro.set(publicAPI, model, ['format', 'openGLDataType']);\n\n  macro.setGet(publicAPI, model, [\n    'keyMatrixTime',\n    'minificationFilter',\n    'magnificationFilter',\n    'wrapS',\n    'wrapT',\n    'wrapR',\n    'generateMipmap',\n  ]);\n\n  macro.get(publicAPI, model, [\n    'width',\n    'height',\n    'volumeInfo',\n    'components',\n    'handle',\n    'target',\n  ]);\n\n  // Object methods\n  vtkOpenGLTexture(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkOpenGLTexture');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend, ...Constants };\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkTexture', newInstance);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}