{"ast":null,"code":"export function createContextProxyHandler() {\n  const cache = new Map();\n  const getParameterHandler = {\n    apply(target, gl, args) {\n      if (cache.has(args[0])) {\n        return cache.get(args[0]);\n      }\n\n      return target.apply(gl, args);\n    }\n\n  }; // only supports single-value setters\n\n  function cachedSetterHandler(key) {\n    return {\n      apply(target, gl, args) {\n        cache.set(key, args[0]);\n        return target.apply(gl, args);\n      }\n\n    };\n  } // When a property is accessed on the webgl context proxy,\n  // it's accessed is intercepted. If the property name matches\n  // any of the keys of `propHandlers`, then that handler is called\n  // with the following arguments: (gl, prop, receiver, propValue)\n  // - gl (WebGL2RenderingContext): the underlying webgl context\n  // - propName (string): the property name\n  // - receiver (Proxy): the webgl context proxy\n  // - propValue (unknown): the value of `gl[propName]`\n\n\n  const propHandlers = Object.create(null); // Sets getParameter(property) as a cached getter proxy.\n  // propValue.bind(gl) is to avoid Illegal Invocation errors.\n\n  propHandlers.getParameter = (gl, prop, receiver, propValue) => new Proxy(propValue.bind(gl), getParameterHandler); // Sets depthMask(flag) as a cached setter proxy.\n\n\n  propHandlers.depthMask = (gl, prop, receiver, propValue) => new Proxy(propValue.bind(gl), cachedSetterHandler(gl.DEPTH_WRITEMASK));\n\n  return {\n    get(gl, prop, receiver) {\n      let value = Reflect.get(gl, prop, gl);\n\n      if (value instanceof Function) {\n        // prevents Illegal Invocation errors\n        value = value.bind(gl);\n      }\n\n      const propHandler = propHandlers[prop];\n\n      if (propHandler) {\n        return propHandler(gl, prop, receiver, value);\n      }\n\n      return value;\n    }\n\n  };\n}\nexport default {\n  createContextProxyHandler\n};","map":{"version":3,"names":["createContextProxyHandler","cache","Map","getParameterHandler","apply","target","gl","args","has","get","cachedSetterHandler","key","set","propHandlers","Object","create","getParameter","prop","receiver","propValue","Proxy","bind","depthMask","DEPTH_WRITEMASK","value","Reflect","Function","propHandler"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/OpenGL/RenderWindow/ContextProxy.js"],"sourcesContent":["export function createContextProxyHandler() {\n  const cache = new Map();\n\n  const getParameterHandler = {\n    apply(target, gl, args) {\n      if (cache.has(args[0])) {\n        return cache.get(args[0]);\n      }\n      return target.apply(gl, args);\n    },\n  };\n\n  // only supports single-value setters\n  function cachedSetterHandler(key) {\n    return {\n      apply(target, gl, args) {\n        cache.set(key, args[0]);\n        return target.apply(gl, args);\n      },\n    };\n  }\n\n  // When a property is accessed on the webgl context proxy,\n  // it's accessed is intercepted. If the property name matches\n  // any of the keys of `propHandlers`, then that handler is called\n  // with the following arguments: (gl, prop, receiver, propValue)\n  // - gl (WebGL2RenderingContext): the underlying webgl context\n  // - propName (string): the property name\n  // - receiver (Proxy): the webgl context proxy\n  // - propValue (unknown): the value of `gl[propName]`\n\n  const propHandlers = Object.create(null);\n\n  // Sets getParameter(property) as a cached getter proxy.\n  // propValue.bind(gl) is to avoid Illegal Invocation errors.\n  propHandlers.getParameter = (gl, prop, receiver, propValue) =>\n    new Proxy(propValue.bind(gl), getParameterHandler);\n\n  // Sets depthMask(flag) as a cached setter proxy.\n  propHandlers.depthMask = (gl, prop, receiver, propValue) =>\n    new Proxy(propValue.bind(gl), cachedSetterHandler(gl.DEPTH_WRITEMASK));\n\n  return {\n    get(gl, prop, receiver) {\n      let value = Reflect.get(gl, prop, gl);\n      if (value instanceof Function) {\n        // prevents Illegal Invocation errors\n        value = value.bind(gl);\n      }\n\n      const propHandler = propHandlers[prop];\n      if (propHandler) {\n        return propHandler(gl, prop, receiver, value);\n      }\n\n      return value;\n    },\n  };\n}\n\nexport default { createContextProxyHandler };\n"],"mappings":"AAAA,OAAO,SAASA,yBAAT,GAAqC;EAC1C,MAAMC,KAAK,GAAG,IAAIC,GAAJ,EAAd;EAEA,MAAMC,mBAAmB,GAAG;IAC1BC,KAAK,CAACC,MAAD,EAASC,EAAT,EAAaC,IAAb,EAAmB;MACtB,IAAIN,KAAK,CAACO,GAAN,CAAUD,IAAI,CAAC,CAAD,CAAd,CAAJ,EAAwB;QACtB,OAAON,KAAK,CAACQ,GAAN,CAAUF,IAAI,CAAC,CAAD,CAAd,CAAP;MACD;;MACD,OAAOF,MAAM,CAACD,KAAP,CAAaE,EAAb,EAAiBC,IAAjB,CAAP;IACD;;EANyB,CAA5B,CAH0C,CAY1C;;EACA,SAASG,mBAAT,CAA6BC,GAA7B,EAAkC;IAChC,OAAO;MACLP,KAAK,CAACC,MAAD,EAASC,EAAT,EAAaC,IAAb,EAAmB;QACtBN,KAAK,CAACW,GAAN,CAAUD,GAAV,EAAeJ,IAAI,CAAC,CAAD,CAAnB;QACA,OAAOF,MAAM,CAACD,KAAP,CAAaE,EAAb,EAAiBC,IAAjB,CAAP;MACD;;IAJI,CAAP;EAMD,CApByC,CAsB1C;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EAEA,MAAMM,YAAY,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAArB,CA/B0C,CAiC1C;EACA;;EACAF,YAAY,CAACG,YAAb,GAA4B,CAACV,EAAD,EAAKW,IAAL,EAAWC,QAAX,EAAqBC,SAArB,KAC1B,IAAIC,KAAJ,CAAUD,SAAS,CAACE,IAAV,CAAef,EAAf,CAAV,EAA8BH,mBAA9B,CADF,CAnC0C,CAsC1C;;;EACAU,YAAY,CAACS,SAAb,GAAyB,CAAChB,EAAD,EAAKW,IAAL,EAAWC,QAAX,EAAqBC,SAArB,KACvB,IAAIC,KAAJ,CAAUD,SAAS,CAACE,IAAV,CAAef,EAAf,CAAV,EAA8BI,mBAAmB,CAACJ,EAAE,CAACiB,eAAJ,CAAjD,CADF;;EAGA,OAAO;IACLd,GAAG,CAACH,EAAD,EAAKW,IAAL,EAAWC,QAAX,EAAqB;MACtB,IAAIM,KAAK,GAAGC,OAAO,CAAChB,GAAR,CAAYH,EAAZ,EAAgBW,IAAhB,EAAsBX,EAAtB,CAAZ;;MACA,IAAIkB,KAAK,YAAYE,QAArB,EAA+B;QAC7B;QACAF,KAAK,GAAGA,KAAK,CAACH,IAAN,CAAWf,EAAX,CAAR;MACD;;MAED,MAAMqB,WAAW,GAAGd,YAAY,CAACI,IAAD,CAAhC;;MACA,IAAIU,WAAJ,EAAiB;QACf,OAAOA,WAAW,CAACrB,EAAD,EAAKW,IAAL,EAAWC,QAAX,EAAqBM,KAArB,CAAlB;MACD;;MAED,OAAOA,KAAP;IACD;;EAdI,CAAP;AAgBD;AAED,eAAe;EAAExB;AAAF,CAAf"},"metadata":{},"sourceType":"module"}