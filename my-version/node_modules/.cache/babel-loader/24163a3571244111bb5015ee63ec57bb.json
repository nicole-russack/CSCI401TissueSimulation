{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nconst {\n  vtkErrorMacro\n} = macro; // ----------------------------------------------------------------------------\n// vtkPiecewiseFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPiecewiseFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPiecewiseFunction'); // Return the number of points which specify this function\n\n  publicAPI.getSize = () => model.nodes.length; // Return the type of function stored in object:\n  // Function Types:\n  //    0 : Constant        (No change in slope between end points)\n  //    1 : NonDecreasing   (Always increasing or zero slope)\n  //    2 : NonIncreasing   (Always decreasing or zero slope)\n  //    3 : Varied          (Contains both decreasing and increasing slopes)\n  //    4 : Unknown         (Error condition)\n  //\n\n\n  publicAPI.getType = () => {\n    let value;\n    let prevValue = 0.0;\n    let functionType = 0;\n\n    if (model.nodes.length > 0) {\n      prevValue = model.nodes[0].y;\n    }\n\n    for (let i = 1; i < model.nodes.length; i++) {\n      value = model.nodes[i].y; // Do not change the function type if equal\n\n      if (value !== prevValue) {\n        if (value > prevValue) {\n          switch (functionType) {\n            case 0:\n            case 1:\n              // NonDecreasing\n              functionType = 1;\n              break;\n\n            case 2:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        } else {\n          // value < prev_value\n          switch (functionType) {\n            case 0:\n            case 2:\n              // NonIncreasing\n              functionType = 2;\n              break;\n\n            case 1:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        }\n      }\n\n      prevValue = value; // Exit loop if we find a Varied function\n\n      if (functionType === 3) {\n        break;\n      }\n    }\n\n    switch (functionType) {\n      case 0:\n        return 'Constant';\n\n      case 1:\n        return 'NonDecreasing';\n\n      case 2:\n        return 'NonIncreasing';\n\n      case 3:\n      default:\n        return 'Varied';\n    }\n  }; // Since we no longer store the data in an array, we must\n  // copy out of the vector into an array. No modified check -\n  // could be added if performance is a problem\n\n\n  publicAPI.getDataPointer = () => {\n    const size = model.nodes.length;\n    model.function = null;\n\n    if (size > 0) {\n      model.function = [];\n\n      for (let i = 0; i < size; i++) {\n        model.function[2 * i] = model.nodes[i].x;\n        model.function[2 * i + 1] = model.nodes[i].y;\n      }\n    }\n\n    return model.function;\n  }; // Returns the first point location which starts a non-zero segment of the\n  // function. Note that the value at this point may be zero.\n\n\n  publicAPI.getFirstNonZeroValue = () => {\n    // Check if no points specified\n    if (model.nodes.length === 0) {\n      return 0;\n    }\n\n    let allZero = 1;\n    let x = 0.0;\n    let i = 0;\n\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].y !== 0.0) {\n        allZero = 0;\n        break;\n      }\n    } // If every specified point has a zero value then return\n    // a large value\n\n\n    if (allZero) {\n      x = Number.MAX_VALUE;\n    } else if (i > 0) {\n      // A point was found with a non-zero value\n      // Return the value of the point that precedes this one\n      x = model.nodes[i - 1].x;\n    } else if (model.clamping) {\n      // If this is the first point in the function, return its\n      // value is clamping is off, otherwise VTK_DOUBLE_MIN if\n      // clamping is on.\n      x = -Number.MAX_VALUE;\n    } else {\n      x = model.nodes[0].x;\n    }\n\n    return x;\n  }; // For a specified index value, get the node parameters\n\n\n  publicAPI.getNodeValue = (index, val) => {\n    const size = model.nodes.length;\n\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].y;\n    val[2] = model.nodes[index].midpoint;\n    val[3] = model.nodes[index].sharpness;\n    return 1;\n  }; // For a specified index value, get the node parameters\n\n\n  publicAPI.setNodeValue = (index, val) => {\n    const size = model.nodes.length;\n\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n\n    const oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].y = val[1];\n    model.nodes[index].midpoint = val[2];\n    model.nodes[index].sharpness = val[3];\n\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange(); // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n\n    return 1;\n  }; // Adds a point to the function. If a duplicate point is inserted\n  // then the function value at that location is set to the new value.\n  // This is the legacy version that assumes midpoint = 0.5 and\n  // sharpness = 0.0\n\n\n  publicAPI.addPoint = (x, y) => publicAPI.addPointLong(x, y, 0.5, 0.0); // Adds a point to the function and returns the array index of the point.\n\n\n  publicAPI.addPointLong = (x, y, midpoint, sharpness) => {\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    } // remove any node already at this X location\n\n\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    } // Create the new node\n\n\n    const node = {\n      x,\n      y,\n      midpoint,\n      sharpness\n    }; // Add it, then sort to get everything in order\n\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange(); // Now find this node so we can return the index\n\n    let i;\n\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    } // If we didn't find it, something went horribly wrong so\n    // return -1\n\n\n    if (i < model.nodes.length) {\n      return i;\n    }\n\n    return -1;\n  };\n\n  publicAPI.setNodes = nodes => {\n    if (model.nodes !== nodes) {\n      model.nodes = nodes;\n      publicAPI.sortAndUpdateRange();\n    }\n  }; // Sort the vector in increasing order, then fill in\n  // the Range\n\n\n  publicAPI.sortAndUpdateRange = () => {\n    model.nodes.sort((a, b) => a.x - b.x);\n    const modifiedInvoked = publicAPI.updateRange(); // If range is updated, Modified() has been called, don't call it again.\n\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.updateRange = () => {\n    const oldRange = model.range.slice();\n    const size = model.nodes.length;\n\n    if (size) {\n      model.range[0] = model.nodes[0].x;\n      model.range[1] = model.nodes[size - 1].x;\n    } else {\n      model.range[0] = 0;\n      model.range[1] = 0;\n    } // If the rage is the same, then no need to call Modified()\n\n\n    if (oldRange[0] === model.range[0] && oldRange[1] === model.range[1]) {\n      return false;\n    }\n\n    publicAPI.modified();\n    return true;\n  }; // Removes a point from the function. If no point is found then function\n  // remains the same.\n\n\n  publicAPI.removePoint = x => {\n    // First find the node since we need to know its\n    // index as our return value\n    let i;\n\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    } // If the node doesn't exist, we return -1\n\n\n    if (i >= model.nodes.length) {\n      return -1;\n    }\n\n    const retVal = i; // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n\n    let modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n\n    return retVal;\n  }; // Removes all points from the function.\n\n\n  publicAPI.removeAllPoints = () => {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  }; // Add in end points of line and remove any points between them\n  // Legacy method with no way to specify midpoint and sharpness\n\n\n  publicAPI.addSegment = (x1, y1, x2, y2) => {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    } // Now add the points\n\n\n    publicAPI.addPoint(x1, y1, 0.5, 0.0);\n    publicAPI.addPoint(x2, y2, 0.5, 0.0);\n  }; // Return the value of the function at a position\n\n\n  publicAPI.getValue = x => {\n    const table = [];\n    publicAPI.getTable(x, x, 1, table);\n    return table[0];\n  }; // Remove all points outside the range, and make sure a point\n  // exists at each end of the range. Used as a convenience method\n  // for transfer function editors\n\n\n  publicAPI.adjustRange = range => {\n    if (range.length < 2) {\n      return 0;\n    }\n\n    const functionRange = publicAPI.getRange(); // Make sure we have points at each end of the range\n\n    if (functionRange[0] < range[0]) {\n      publicAPI.addPoint(range[0], publicAPI.getValue(range[0]));\n    } else {\n      publicAPI.addPoint(range[0], publicAPI.getValue(functionRange[0]));\n    }\n\n    if (functionRange[1] > range[1]) {\n      publicAPI.addPoint(range[1], publicAPI.getValue(range[1]));\n    } else {\n      publicAPI.addPoint(range[1], publicAPI.getValue(functionRange[1]));\n    } // Remove all points out-of-range\n\n\n    publicAPI.sortAndUpdateRange();\n\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n\n    publicAPI.sortAndUpdateRange();\n    return 1;\n  }; //--------------------------------------------------------------------------\n\n\n  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {\n    const d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.findMinimumXDistance = () => {\n    const size = model.nodes.length;\n\n    if (size < 2) {\n      return -1.0;\n    }\n\n    let distance = model.nodes[1].x - model.nodes[0].x;\n\n    for (let i = 0; i < size - 1; i++) {\n      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n\n    return distance;\n  }; // Returns a table of function values evaluated at regular intervals\n\n  /* eslint-disable prefer-destructuring */\n\n  /* eslint-disable no-continue */\n\n\n  publicAPI.getTable = function (xStart, xEnd, size, table) {\n    let stride = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    let i;\n    let idx = 0;\n    const numNodes = model.nodes.length; // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n\n    let lastValue = 0.0;\n\n    if (numNodes !== 0) {\n      lastValue = model.nodes[numNodes - 1].y;\n    }\n\n    let x = 0.0;\n    let x1 = 0.0;\n    let x2 = 0.0;\n    let y1 = 0.0;\n    let y2 = 0.0;\n    let midpoint = 0.0;\n    let sharpness = 0.0; // For each table entry\n\n    for (i = 0; i < size; i++) {\n      // Find our location in the table\n      const tidx = stride * i; // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n\n      if (size > 1) {\n        x = xStart + i / (size - 1.0) * (xEnd - xStart);\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      } // Do we need to move to the next node?\n\n\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++; // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n          y1 = model.nodes[idx - 1].y;\n          y2 = model.nodes[idx].y; // We only need the previous midpoint and sharpness\n          // since these control this region\n\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness; // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      } // Are we at the end? If so, just use the last value\n\n\n      if (idx >= numNodes) {\n        table[tidx] = model.clamping ? lastValue : 0.0;\n      } else if (idx === 0) {\n        // Are we before the first node? If so, duplicate this nodes values\n        table[tidx] = model.clamping ? model.nodes[0].y : 0.0;\n      } else {\n        // Otherwise, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        let s = (x - x1) / (x2 - x1); // Readjust based on the midpoint - linear adjustment\n\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        } // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n\n\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = y1;\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = y2;\n            continue;\n          }\n        } // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n\n\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          table[tidx] = (1 - s) * y1 + s * y2;\n          continue;\n        } // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n\n\n        if (s < 0.5) {\n          s = 0.5 * (s * 2) ** (1.0 + 10 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10 * sharpness);\n        } // Compute some coefficients we will need for the hermite curve\n\n\n        const ss = s * s;\n        const sss = ss * s;\n        const h1 = 2 * sss - 3 * ss + 1;\n        const h2 = -2 * sss + 3 * ss;\n        const h3 = sss - 2 * ss + s;\n        const h4 = sss - ss; // Use one slope for both end points\n\n        const slope = y2 - y1;\n        const t = (1.0 - sharpness) * slope; // Compute the value\n\n        table[tidx] = h1 * y1 + h2 * y2 + h3 * t + h4 * t; // Final error check to make sure we don't go outside\n        // the Y range\n\n        const min = y1 < y2 ? y1 : y2;\n        const max = y1 > y2 ? y1 : y2;\n        table[tidx] = table[tidx] < min ? min : table[tidx];\n        table[tidx] = table[tidx] > max ? max : table[tidx];\n      }\n    }\n  };\n}\n/* eslint-enable prefer-destructuring */\n\n/* eslint-enable no-continue */\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  // model.function = NULL;\n  range: [0, 0],\n  clamping: true,\n  allowDuplicateScalars: false\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  macro.obj(publicAPI, model); // Internal objects initialization\n\n  model.nodes = []; // Create get-set macros\n\n  macro.setGet(publicAPI, model, ['allowDuplicateScalars', 'clamping']);\n  macro.setArray(publicAPI, model, ['range'], 2); // Create get macros for array\n\n  macro.getArray(publicAPI, model, ['range']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkPiecewiseFunction(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkPiecewiseFunction'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["macro","vtkErrorMacro","vtkPiecewiseFunction","publicAPI","model","classHierarchy","push","getSize","nodes","length","getType","value","prevValue","functionType","y","i","getDataPointer","size","function","x","getFirstNonZeroValue","allZero","Number","MAX_VALUE","clamping","getNodeValue","index","val","midpoint","sharpness","setNodeValue","oldX","sortAndUpdateRange","modified","addPoint","addPointLong","allowDuplicateScalars","removePoint","node","setNodes","sort","a","b","modifiedInvoked","updateRange","oldRange","range","slice","retVal","splice","removeAllPoints","addSegment","x1","y1","x2","y2","getValue","table","getTable","adjustRange","functionRange","getRange","estimateMinNumberOfSamples","d","findMinimumXDistance","Math","ceil","distance","currentDist","xStart","xEnd","stride","idx","numNodes","lastValue","tidx","s","ss","sss","h1","h2","h3","h4","slope","t","min","max","DEFAULT_VALUES","extend","initialValues","Object","assign","obj","setGet","setArray","getArray","newInstance"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Common/DataModel/PiecewiseFunction/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\n\nconst { vtkErrorMacro } = macro;\n\n// ----------------------------------------------------------------------------\n// vtkPiecewiseFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPiecewiseFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPiecewiseFunction');\n\n  // Return the number of points which specify this function\n  publicAPI.getSize = () => model.nodes.length;\n\n  // Return the type of function stored in object:\n  // Function Types:\n  //    0 : Constant        (No change in slope between end points)\n  //    1 : NonDecreasing   (Always increasing or zero slope)\n  //    2 : NonIncreasing   (Always decreasing or zero slope)\n  //    3 : Varied          (Contains both decreasing and increasing slopes)\n  //    4 : Unknown         (Error condition)\n  //\n  publicAPI.getType = () => {\n    let value;\n    let prevValue = 0.0;\n    let functionType = 0;\n\n    if (model.nodes.length > 0) {\n      prevValue = model.nodes[0].y;\n    }\n\n    for (let i = 1; i < model.nodes.length; i++) {\n      value = model.nodes[i].y;\n\n      // Do not change the function type if equal\n      if (value !== prevValue) {\n        if (value > prevValue) {\n          switch (functionType) {\n            case 0:\n            case 1:\n              // NonDecreasing\n              functionType = 1;\n              break;\n            case 2:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        } else {\n          // value < prev_value\n          switch (functionType) {\n            case 0:\n            case 2:\n              // NonIncreasing\n              functionType = 2;\n              break;\n            case 1:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        }\n      }\n\n      prevValue = value;\n\n      // Exit loop if we find a Varied function\n      if (functionType === 3) {\n        break;\n      }\n    }\n\n    switch (functionType) {\n      case 0:\n        return 'Constant';\n      case 1:\n        return 'NonDecreasing';\n      case 2:\n        return 'NonIncreasing';\n      case 3:\n      default:\n        return 'Varied';\n    }\n  };\n\n  // Since we no longer store the data in an array, we must\n  // copy out of the vector into an array. No modified check -\n  // could be added if performance is a problem\n  publicAPI.getDataPointer = () => {\n    const size = model.nodes.length;\n\n    model.function = null;\n\n    if (size > 0) {\n      model.function = [];\n      for (let i = 0; i < size; i++) {\n        model.function[2 * i] = model.nodes[i].x;\n        model.function[2 * i + 1] = model.nodes[i].y;\n      }\n    }\n    return model.function;\n  };\n\n  // Returns the first point location which starts a non-zero segment of the\n  // function. Note that the value at this point may be zero.\n  publicAPI.getFirstNonZeroValue = () => {\n    // Check if no points specified\n    if (model.nodes.length === 0) {\n      return 0;\n    }\n\n    let allZero = 1;\n    let x = 0.0;\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].y !== 0.0) {\n        allZero = 0;\n        break;\n      }\n    }\n\n    // If every specified point has a zero value then return\n    // a large value\n    if (allZero) {\n      x = Number.MAX_VALUE;\n    } else if (i > 0) {\n      // A point was found with a non-zero value\n      // Return the value of the point that precedes this one\n      x = model.nodes[i - 1].x;\n    } else if (model.clamping) {\n      // If this is the first point in the function, return its\n      // value is clamping is off, otherwise VTK_DOUBLE_MIN if\n      // clamping is on.\n      x = -Number.MAX_VALUE;\n    } else {\n      x = model.nodes[0].x;\n    }\n\n    return x;\n  };\n\n  // For a specified index value, get the node parameters\n  publicAPI.getNodeValue = (index, val) => {\n    const size = model.nodes.length;\n\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].y;\n    val[2] = model.nodes[index].midpoint;\n    val[3] = model.nodes[index].sharpness;\n\n    return 1;\n  };\n\n  // For a specified index value, get the node parameters\n  publicAPI.setNodeValue = (index, val) => {\n    const size = model.nodes.length;\n\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n\n    const oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].y = val[1];\n    model.nodes[index].midpoint = val[2];\n    model.nodes[index].sharpness = val[3];\n\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange();\n      // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n\n    return 1;\n  };\n\n  // Adds a point to the function. If a duplicate point is inserted\n  // then the function value at that location is set to the new value.\n  // This is the legacy version that assumes midpoint = 0.5 and\n  // sharpness = 0.0\n  publicAPI.addPoint = (x, y) => publicAPI.addPointLong(x, y, 0.5, 0.0);\n\n  // Adds a point to the function and returns the array index of the point.\n  publicAPI.addPointLong = (x, y, midpoint, sharpness) => {\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    // remove any node already at this X location\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    }\n\n    // Create the new node\n    const node = { x, y, midpoint, sharpness };\n\n    // Add it, then sort to get everything in order\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange();\n\n    // Now find this node so we can return the index\n    let i;\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If we didn't find it, something went horribly wrong so\n    // return -1\n    if (i < model.nodes.length) {\n      return i;\n    }\n\n    return -1;\n  };\n\n  publicAPI.setNodes = (nodes) => {\n    if (model.nodes !== nodes) {\n      model.nodes = nodes;\n      publicAPI.sortAndUpdateRange();\n    }\n  };\n\n  // Sort the vector in increasing order, then fill in\n  // the Range\n  publicAPI.sortAndUpdateRange = () => {\n    model.nodes.sort((a, b) => a.x - b.x);\n    const modifiedInvoked = publicAPI.updateRange();\n    // If range is updated, Modified() has been called, don't call it again.\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.updateRange = () => {\n    const oldRange = model.range.slice();\n\n    const size = model.nodes.length;\n    if (size) {\n      model.range[0] = model.nodes[0].x;\n      model.range[1] = model.nodes[size - 1].x;\n    } else {\n      model.range[0] = 0;\n      model.range[1] = 0;\n    }\n    // If the rage is the same, then no need to call Modified()\n    if (oldRange[0] === model.range[0] && oldRange[1] === model.range[1]) {\n      return false;\n    }\n\n    publicAPI.modified();\n    return true;\n  };\n\n  // Removes a point from the function. If no point is found then function\n  // remains the same.\n  publicAPI.removePoint = (x) => {\n    // First find the node since we need to know its\n    // index as our return value\n    let i;\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If the node doesn't exist, we return -1\n    if (i >= model.nodes.length) {\n      return -1;\n    }\n\n    const retVal = i;\n\n    // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n    let modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n\n    return retVal;\n  };\n\n  // Removes all points from the function.\n  publicAPI.removeAllPoints = () => {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  };\n\n  // Add in end points of line and remove any points between them\n  // Legacy method with no way to specify midpoint and sharpness\n  publicAPI.addSegment = (x1, y1, x2, y2) => {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length; ) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Now add the points\n    publicAPI.addPoint(x1, y1, 0.5, 0.0);\n    publicAPI.addPoint(x2, y2, 0.5, 0.0);\n  };\n\n  // Return the value of the function at a position\n  publicAPI.getValue = (x) => {\n    const table = [];\n    publicAPI.getTable(x, x, 1, table);\n    return table[0];\n  };\n\n  // Remove all points outside the range, and make sure a point\n  // exists at each end of the range. Used as a convenience method\n  // for transfer function editors\n  publicAPI.adjustRange = (range) => {\n    if (range.length < 2) {\n      return 0;\n    }\n\n    const functionRange = publicAPI.getRange();\n\n    // Make sure we have points at each end of the range\n    if (functionRange[0] < range[0]) {\n      publicAPI.addPoint(range[0], publicAPI.getValue(range[0]));\n    } else {\n      publicAPI.addPoint(range[0], publicAPI.getValue(functionRange[0]));\n    }\n\n    if (functionRange[1] > range[1]) {\n      publicAPI.addPoint(range[1], publicAPI.getValue(range[1]));\n    } else {\n      publicAPI.addPoint(range[1], publicAPI.getValue(functionRange[1]));\n    }\n\n    // Remove all points out-of-range\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length; ) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n\n    publicAPI.sortAndUpdateRange();\n    return 1;\n  };\n\n  //--------------------------------------------------------------------------\n  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {\n    const d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.findMinimumXDistance = () => {\n    const size = model.nodes.length;\n    if (size < 2) {\n      return -1.0;\n    }\n\n    let distance = model.nodes[1].x - model.nodes[0].x;\n    for (let i = 0; i < size - 1; i++) {\n      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n\n    return distance;\n  };\n\n  // Returns a table of function values evaluated at regular intervals\n  /* eslint-disable prefer-destructuring */\n  /* eslint-disable no-continue */\n  publicAPI.getTable = (xStart, xEnd, size, table, stride = 1) => {\n    let i;\n    let idx = 0;\n    const numNodes = model.nodes.length;\n\n    // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n    let lastValue = 0.0;\n    if (numNodes !== 0) {\n      lastValue = model.nodes[numNodes - 1].y;\n    }\n\n    let x = 0.0;\n    let x1 = 0.0;\n    let x2 = 0.0;\n    let y1 = 0.0;\n    let y2 = 0.0;\n    let midpoint = 0.0;\n    let sharpness = 0.0;\n\n    // For each table entry\n    for (i = 0; i < size; i++) {\n      // Find our location in the table\n      const tidx = stride * i;\n\n      // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n      if (size > 1) {\n        x = xStart + (i / (size - 1.0)) * (xEnd - xStart);\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      }\n\n      // Do we need to move to the next node?\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++;\n        // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n\n          y1 = model.nodes[idx - 1].y;\n          y2 = model.nodes[idx].y;\n\n          // We only need the previous midpoint and sharpness\n          // since these control this region\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness;\n\n          // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      }\n\n      // Are we at the end? If so, just use the last value\n      if (idx >= numNodes) {\n        table[tidx] = model.clamping ? lastValue : 0.0;\n      } else if (idx === 0) {\n        // Are we before the first node? If so, duplicate this nodes values\n        table[tidx] = model.clamping ? model.nodes[0].y : 0.0;\n      } else {\n        // Otherwise, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        let s = (x - x1) / (x2 - x1);\n\n        // Readjust based on the midpoint - linear adjustment\n        if (s < midpoint) {\n          s = (0.5 * s) / midpoint;\n        } else {\n          s = 0.5 + (0.5 * (s - midpoint)) / (1.0 - midpoint);\n        }\n\n        // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = y1;\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = y2;\n            continue;\n          }\n        }\n\n        // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          table[tidx] = (1 - s) * y1 + s * y2;\n          continue;\n        }\n\n        // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n        if (s < 0.5) {\n          s = 0.5 * (s * 2) ** (1.0 + 10 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10 * sharpness);\n        }\n\n        // Compute some coefficients we will need for the hermite curve\n        const ss = s * s;\n        const sss = ss * s;\n\n        const h1 = 2 * sss - 3 * ss + 1;\n        const h2 = -2 * sss + 3 * ss;\n        const h3 = sss - 2 * ss + s;\n        const h4 = sss - ss;\n\n        // Use one slope for both end points\n        const slope = y2 - y1;\n        const t = (1.0 - sharpness) * slope;\n\n        // Compute the value\n        table[tidx] = h1 * y1 + h2 * y2 + h3 * t + h4 * t;\n\n        // Final error check to make sure we don't go outside\n        // the Y range\n        const min = y1 < y2 ? y1 : y2;\n        const max = y1 > y2 ? y1 : y2;\n\n        table[tidx] = table[tidx] < min ? min : table[tidx];\n        table[tidx] = table[tidx] > max ? max : table[tidx];\n      }\n    }\n  };\n}\n/* eslint-enable prefer-destructuring */\n/* eslint-enable no-continue */\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // model.function = NULL;\n  range: [0, 0],\n  clamping: true,\n  allowDuplicateScalars: false,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n\n  // Internal objects initialization\n  model.nodes = [];\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['allowDuplicateScalars', 'clamping']);\n\n  macro.setArray(publicAPI, model, ['range'], 2);\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, ['range']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkPiecewiseFunction(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkPiecewiseFunction');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}