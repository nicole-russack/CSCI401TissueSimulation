{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport vtkWebGPUBufferManager from 'vtk.js/Sources/Rendering/WebGPU/BufferManager';\nimport vtkWebGPUTypes from 'vtk.js/Sources/Rendering/WebGPU/Types';\nconst {\n  BufferUsage\n} = vtkWebGPUBufferManager;\nconst {\n  vtkErrorMacro\n} = macro; // ----------------------------------------------------------------------------\n// vtkWebGPUUniformBuffer methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUUniformBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUUniformBuffer');\n\n  publicAPI.addEntry = (name, type) => {\n    if (model._bufferEntryNames.has(name)) {\n      vtkErrorMacro(`entry named ${name} already exists`);\n      return;\n    }\n\n    model.sortDirty = true;\n\n    model._bufferEntryNames.set(name, model.bufferEntries.length);\n\n    model.bufferEntries.push({\n      name,\n      type,\n      sizeInBytes: vtkWebGPUTypes.getByteStrideFromShaderFormat(type),\n      offset: -1,\n      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type),\n      packed: false\n    });\n  }; // UBOs have layout rules in terms of how memory is aligned so we\n  // have to be careful how we order the entries. For example a vec4<f32>\n  // must be aligned on a 16 byte offset, etc. See\n  // https://gpuweb.github.io/gpuweb/wgsl/#memory-layouts\n  // for more details. Right now you can create a situation that would fail\n  // in the future we could add dummy spacer entries where needed to\n  // handle alignment issues\n\n\n  publicAPI.sortBufferEntries = () => {\n    if (!model.sortDirty) {\n      return;\n    }\n\n    let currOffset = 0;\n    const newEntries = []; // compute the max alignment, this is required as WebGPU defines a UBO to have\n    // a size that is a multiple of the maxAlignment\n\n    let maxAlignment = 4;\n\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n\n      if (entry.sizeInBytes % 16 === 0) {\n        maxAlignment = Math.max(16, maxAlignment);\n      }\n\n      if (entry.sizeInBytes % 8 === 0) {\n        maxAlignment = Math.max(8, maxAlignment);\n      }\n    } // pack anything whose size is a multiple of 16 bytes first\n    // this includes a couple types that don't require 16 byte alignment\n    // such as mat2x2<f32> but that is OK\n\n\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n\n      if (entry.packed === false && entry.sizeInBytes % 16 === 0) {\n        entry.packed = true;\n        entry.offset = currOffset;\n        newEntries.push(entry);\n        currOffset += entry.sizeInBytes;\n      }\n    } // now it gets tough, we have the following common types (f32, i32, u32)\n    // - vec2<f32> 8 byte size, 8 byte alignment\n    // - vec3<f32> 12 byte size, 16 byte alignment\n    // - f32 4 byte size, 4 byte alignment\n    // try adding 12 byte, 4 byte pairs\n\n\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n\n      if (entry.packed === false && entry.sizeInBytes === 12) {\n        for (let i2 = 0; i2 < model.bufferEntries.length; i2++) {\n          const entry2 = model.bufferEntries[i2];\n\n          if (entry2.packed === false && entry2.sizeInBytes === 4) {\n            entry.packed = true;\n            entry.offset = currOffset;\n            newEntries.push(entry);\n            currOffset += entry.sizeInBytes;\n            entry2.packed = true;\n            entry2.offset = currOffset;\n            newEntries.push(entry2);\n            currOffset += entry2.sizeInBytes;\n            break;\n          }\n        }\n      }\n    } // try adding 8 byte, 8 byte pairs\n\n\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n\n      if (!entry.packed && entry.sizeInBytes % 8 === 0) {\n        for (let i2 = i + 1; i2 < model.bufferEntries.length; i2++) {\n          const entry2 = model.bufferEntries[i2];\n\n          if (!entry2.packed && entry2.sizeInBytes % 8 === 0) {\n            entry.packed = true;\n            entry.offset = currOffset;\n            newEntries.push(entry);\n            currOffset += entry.sizeInBytes;\n            entry2.packed = true;\n            entry2.offset = currOffset;\n            newEntries.push(entry2);\n            currOffset += entry2.sizeInBytes;\n            break;\n          }\n        }\n      }\n    } // try adding 8 byte, 4 byte 4 byte triplets\n\n\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n\n      if (!entry.packed && entry.sizeInBytes % 8 === 0) {\n        let found = false;\n\n        for (let i2 = 0; !found && i2 < model.bufferEntries.length; i2++) {\n          const entry2 = model.bufferEntries[i2];\n\n          if (!entry2.packed && entry2.sizeInBytes === 4) {\n            for (let i3 = i2 + 1; i3 < model.bufferEntries.length; i3++) {\n              const entry3 = model.bufferEntries[i3];\n\n              if (!entry3.packed && entry3.sizeInBytes === 4) {\n                entry.packed = true;\n                entry.offset = currOffset;\n                newEntries.push(entry);\n                currOffset += entry.sizeInBytes;\n                entry2.packed = true;\n                entry2.offset = currOffset;\n                newEntries.push(entry2);\n                currOffset += entry2.sizeInBytes;\n                entry3.packed = true;\n                entry3.offset = currOffset;\n                newEntries.push(entry3);\n                currOffset += entry3.sizeInBytes;\n                found = true;\n                break;\n              }\n            }\n          }\n        }\n      }\n    } // Add anything remaining that is larger than 4 bytes and hope we get lucky.\n    // Likely if there is more than one item added here it will result\n    // in a failed UBO\n\n\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n\n      if (!entry.packed && entry.sizeInBytes > 4) {\n        entry.packed = true;\n        entry.offset = currOffset;\n        newEntries.push(entry);\n        currOffset += entry.sizeInBytes;\n      }\n    } // finally add remaining 4 byte items\n\n\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n\n      if (!entry.packed) {\n        entry.packed = true;\n        entry.offset = currOffset;\n        newEntries.push(entry);\n        currOffset += entry.sizeInBytes;\n      }\n    } // update entries and entryNames\n\n\n    model.bufferEntries = newEntries;\n\n    model._bufferEntryNames.clear();\n\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      model._bufferEntryNames.set(model.bufferEntries[i].name, i);\n    }\n\n    model.sizeInBytes = currOffset;\n    model.sizeInBytes = maxAlignment * Math.ceil(model.sizeInBytes / maxAlignment);\n    model.sortDirty = false;\n  };\n\n  publicAPI.sendIfNeeded = device => {\n    if (!model.UBO) {\n      const req = {\n        nativeArray: model.Float32Array,\n        usage: BufferUsage.UniformArray,\n        label: model.label\n      };\n      model.UBO = device.getBufferManager().getBuffer(req);\n      model.bindGroupTime.modified();\n      model.sendDirty = false;\n    } // send data down if needed\n\n\n    if (model.sendDirty) {\n      device.getHandle().queue.writeBuffer(model.UBO.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes);\n      model.sendDirty = false;\n    } // always updated as mappers depend on this time\n    // it is more of a sentIfNeededTime\n\n\n    model.sendTime.modified();\n  };\n\n  publicAPI.createView = type => {\n    if (type in model === false) {\n      if (!model.arrayBuffer) {\n        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes);\n      }\n\n      model[type] = macro.newTypedArray(type, model.arrayBuffer);\n    }\n  };\n\n  publicAPI.setValue = (name, val) => {\n    publicAPI.sortBufferEntries();\n\n    const idx = model._bufferEntryNames.get(name);\n\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n\n    if (entry.lastValue !== val) {\n      view[entry.offset / view.BYTES_PER_ELEMENT] = val;\n      model.sendDirty = true;\n    }\n\n    entry.lastValue = val;\n  };\n\n  publicAPI.setArray = (name, arr) => {\n    publicAPI.sortBufferEntries();\n\n    const idx = model._bufferEntryNames.get(name);\n\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    let changed = false;\n\n    for (let i = 0; i < arr.length; i++) {\n      if (!entry.lastValue || entry.lastValue[i] !== arr[i]) {\n        view[entry.offset / view.BYTES_PER_ELEMENT + i] = arr[i];\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      model.sendDirty = true;\n      entry.lastValue = [...arr];\n    }\n  };\n\n  publicAPI.getBindGroupEntry = () => {\n    const foo = {\n      resource: {\n        buffer: model.UBO.getHandle()\n      }\n    };\n    return foo;\n  };\n\n  publicAPI.getSendTime = () => model.sendTime.getMTime();\n\n  publicAPI.getShaderCode = (binding, group) => {\n    // sort the entries\n    publicAPI.sortBufferEntries();\n    const lines = [`struct ${model.label}Struct\\n{`];\n\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      lines.push(`  ${entry.name}: ${entry.type},`);\n    }\n\n    lines.push(`};\\n@binding(${binding}) @group(${group}) var<uniform> ${model.label}: ${model.label}Struct;`);\n    return lines.join('\\n');\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  bufferEntries: null,\n  bufferEntryNames: null,\n  sizeInBytes: 0,\n  label: null,\n  bindGroupLayoutEntry: null,\n  bindGroupEntry: null\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model); // Internal objects\n\n  model._bufferEntryNames = new Map();\n  model.bufferEntries = []; // default UBO desc\n\n  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {\n    buffer: {\n      type: 'uniform'\n    }\n  };\n  model.sendTime = {};\n  macro.obj(model.sendTime, {\n    mtime: 0\n  });\n  model.bindGroupTime = {};\n  macro.obj(model.bindGroupTime, {\n    mtime: 0\n  });\n  model.sendDirty = true;\n  model.sortDirty = true;\n  macro.get(publicAPI, model, ['binding', 'bindGroupTime']);\n  macro.setGet(publicAPI, model, ['bindGroupLayoutEntry', 'device', 'label', 'sizeInBytes']); // Object methods\n\n  vtkWebGPUUniformBuffer(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkWebGPUUniformBuffer'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["macro","vtkWebGPUBufferManager","vtkWebGPUTypes","BufferUsage","vtkErrorMacro","vtkWebGPUUniformBuffer","publicAPI","model","classHierarchy","push","addEntry","name","type","_bufferEntryNames","has","sortDirty","set","bufferEntries","length","sizeInBytes","getByteStrideFromShaderFormat","offset","nativeType","getNativeTypeFromShaderFormat","packed","sortBufferEntries","currOffset","newEntries","maxAlignment","i","entry","Math","max","i2","entry2","found","i3","entry3","clear","ceil","sendIfNeeded","device","UBO","req","nativeArray","Float32Array","usage","UniformArray","label","getBufferManager","getBuffer","bindGroupTime","modified","sendDirty","getHandle","queue","writeBuffer","arrayBuffer","sendTime","createView","ArrayBuffer","newTypedArray","setValue","val","idx","get","undefined","view","lastValue","BYTES_PER_ELEMENT","setArray","arr","changed","getBindGroupEntry","foo","resource","buffer","getSendTime","getMTime","getShaderCode","binding","group","lines","join","DEFAULT_VALUES","bufferEntryNames","bindGroupLayoutEntry","bindGroupEntry","extend","initialValues","Object","assign","obj","Map","mtime","setGet","newInstance"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/WebGPU/UniformBuffer/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport vtkWebGPUBufferManager from 'vtk.js/Sources/Rendering/WebGPU/BufferManager';\nimport vtkWebGPUTypes from 'vtk.js/Sources/Rendering/WebGPU/Types';\n\nconst { BufferUsage } = vtkWebGPUBufferManager;\n\nconst { vtkErrorMacro } = macro;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUUniformBuffer methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUUniformBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUUniformBuffer');\n\n  publicAPI.addEntry = (name, type) => {\n    if (model._bufferEntryNames.has(name)) {\n      vtkErrorMacro(`entry named ${name} already exists`);\n      return;\n    }\n    model.sortDirty = true;\n    model._bufferEntryNames.set(name, model.bufferEntries.length);\n    model.bufferEntries.push({\n      name,\n      type,\n      sizeInBytes: vtkWebGPUTypes.getByteStrideFromShaderFormat(type),\n      offset: -1,\n      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type),\n      packed: false,\n    });\n  };\n\n  // UBOs have layout rules in terms of how memory is aligned so we\n  // have to be careful how we order the entries. For example a vec4<f32>\n  // must be aligned on a 16 byte offset, etc. See\n  // https://gpuweb.github.io/gpuweb/wgsl/#memory-layouts\n  // for more details. Right now you can create a situation that would fail\n  // in the future we could add dummy spacer entries where needed to\n  // handle alignment issues\n  publicAPI.sortBufferEntries = () => {\n    if (!model.sortDirty) {\n      return;\n    }\n\n    let currOffset = 0;\n    const newEntries = [];\n\n    // compute the max alignment, this is required as WebGPU defines a UBO to have\n    // a size that is a multiple of the maxAlignment\n    let maxAlignment = 4;\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (entry.sizeInBytes % 16 === 0) {\n        maxAlignment = Math.max(16, maxAlignment);\n      }\n      if (entry.sizeInBytes % 8 === 0) {\n        maxAlignment = Math.max(8, maxAlignment);\n      }\n    }\n\n    // pack anything whose size is a multiple of 16 bytes first\n    // this includes a couple types that don't require 16 byte alignment\n    // such as mat2x2<f32> but that is OK\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (entry.packed === false && entry.sizeInBytes % 16 === 0) {\n        entry.packed = true;\n        entry.offset = currOffset;\n        newEntries.push(entry);\n        currOffset += entry.sizeInBytes;\n      }\n    }\n\n    // now it gets tough, we have the following common types (f32, i32, u32)\n    // - vec2<f32> 8 byte size, 8 byte alignment\n    // - vec3<f32> 12 byte size, 16 byte alignment\n    // - f32 4 byte size, 4 byte alignment\n\n    // try adding 12 byte, 4 byte pairs\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (entry.packed === false && entry.sizeInBytes === 12) {\n        for (let i2 = 0; i2 < model.bufferEntries.length; i2++) {\n          const entry2 = model.bufferEntries[i2];\n          if (entry2.packed === false && entry2.sizeInBytes === 4) {\n            entry.packed = true;\n            entry.offset = currOffset;\n            newEntries.push(entry);\n            currOffset += entry.sizeInBytes;\n            entry2.packed = true;\n            entry2.offset = currOffset;\n            newEntries.push(entry2);\n            currOffset += entry2.sizeInBytes;\n            break;\n          }\n        }\n      }\n    }\n\n    // try adding 8 byte, 8 byte pairs\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (!entry.packed && entry.sizeInBytes % 8 === 0) {\n        for (let i2 = i + 1; i2 < model.bufferEntries.length; i2++) {\n          const entry2 = model.bufferEntries[i2];\n          if (!entry2.packed && entry2.sizeInBytes % 8 === 0) {\n            entry.packed = true;\n            entry.offset = currOffset;\n            newEntries.push(entry);\n            currOffset += entry.sizeInBytes;\n            entry2.packed = true;\n            entry2.offset = currOffset;\n            newEntries.push(entry2);\n            currOffset += entry2.sizeInBytes;\n            break;\n          }\n        }\n      }\n    }\n\n    // try adding 8 byte, 4 byte 4 byte triplets\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (!entry.packed && entry.sizeInBytes % 8 === 0) {\n        let found = false;\n        for (let i2 = 0; !found && i2 < model.bufferEntries.length; i2++) {\n          const entry2 = model.bufferEntries[i2];\n          if (!entry2.packed && entry2.sizeInBytes === 4) {\n            for (let i3 = i2 + 1; i3 < model.bufferEntries.length; i3++) {\n              const entry3 = model.bufferEntries[i3];\n              if (!entry3.packed && entry3.sizeInBytes === 4) {\n                entry.packed = true;\n                entry.offset = currOffset;\n                newEntries.push(entry);\n                currOffset += entry.sizeInBytes;\n                entry2.packed = true;\n                entry2.offset = currOffset;\n                newEntries.push(entry2);\n                currOffset += entry2.sizeInBytes;\n                entry3.packed = true;\n                entry3.offset = currOffset;\n                newEntries.push(entry3);\n                currOffset += entry3.sizeInBytes;\n                found = true;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Add anything remaining that is larger than 4 bytes and hope we get lucky.\n    // Likely if there is more than one item added here it will result\n    // in a failed UBO\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (!entry.packed && entry.sizeInBytes > 4) {\n        entry.packed = true;\n        entry.offset = currOffset;\n        newEntries.push(entry);\n        currOffset += entry.sizeInBytes;\n      }\n    }\n\n    // finally add remaining 4 byte items\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (!entry.packed) {\n        entry.packed = true;\n        entry.offset = currOffset;\n        newEntries.push(entry);\n        currOffset += entry.sizeInBytes;\n      }\n    }\n\n    // update entries and entryNames\n    model.bufferEntries = newEntries;\n    model._bufferEntryNames.clear();\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      model._bufferEntryNames.set(model.bufferEntries[i].name, i);\n    }\n    model.sizeInBytes = currOffset;\n    model.sizeInBytes =\n      maxAlignment * Math.ceil(model.sizeInBytes / maxAlignment);\n    model.sortDirty = false;\n  };\n\n  publicAPI.sendIfNeeded = (device) => {\n    if (!model.UBO) {\n      const req = {\n        nativeArray: model.Float32Array,\n        usage: BufferUsage.UniformArray,\n        label: model.label,\n      };\n      model.UBO = device.getBufferManager().getBuffer(req);\n      model.bindGroupTime.modified();\n      model.sendDirty = false;\n    }\n\n    // send data down if needed\n    if (model.sendDirty) {\n      device\n        .getHandle()\n        .queue.writeBuffer(\n          model.UBO.getHandle(),\n          0,\n          model.arrayBuffer,\n          0,\n          model.sizeInBytes\n        );\n      model.sendDirty = false;\n    }\n\n    // always updated as mappers depend on this time\n    // it is more of a sentIfNeededTime\n    model.sendTime.modified();\n  };\n\n  publicAPI.createView = (type) => {\n    if (type in model === false) {\n      if (!model.arrayBuffer) {\n        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes);\n      }\n      model[type] = macro.newTypedArray(type, model.arrayBuffer);\n    }\n  };\n\n  publicAPI.setValue = (name, val) => {\n    publicAPI.sortBufferEntries();\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    if (entry.lastValue !== val) {\n      view[entry.offset / view.BYTES_PER_ELEMENT] = val;\n      model.sendDirty = true;\n    }\n    entry.lastValue = val;\n  };\n\n  publicAPI.setArray = (name, arr) => {\n    publicAPI.sortBufferEntries();\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    let changed = false;\n    for (let i = 0; i < arr.length; i++) {\n      if (!entry.lastValue || entry.lastValue[i] !== arr[i]) {\n        view[entry.offset / view.BYTES_PER_ELEMENT + i] = arr[i];\n        changed = true;\n      }\n    }\n    if (changed) {\n      model.sendDirty = true;\n      entry.lastValue = [...arr];\n    }\n  };\n\n  publicAPI.getBindGroupEntry = () => {\n    const foo = {\n      resource: {\n        buffer: model.UBO.getHandle(),\n      },\n    };\n    return foo;\n  };\n\n  publicAPI.getSendTime = () => model.sendTime.getMTime();\n  publicAPI.getShaderCode = (binding, group) => {\n    // sort the entries\n    publicAPI.sortBufferEntries();\n\n    const lines = [`struct ${model.label}Struct\\n{`];\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      lines.push(`  ${entry.name}: ${entry.type},`);\n    }\n    lines.push(\n      `};\\n@binding(${binding}) @group(${group}) var<uniform> ${model.label}: ${model.label}Struct;`\n    );\n    return lines.join('\\n');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  bufferEntries: null,\n  bufferEntryNames: null,\n  sizeInBytes: 0,\n  label: null,\n  bindGroupLayoutEntry: null,\n  bindGroupEntry: null,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n\n  // Internal objects\n  model._bufferEntryNames = new Map();\n  model.bufferEntries = [];\n\n  // default UBO desc\n  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {\n    buffer: {\n      type: 'uniform',\n    },\n  };\n\n  model.sendTime = {};\n  macro.obj(model.sendTime, { mtime: 0 });\n\n  model.bindGroupTime = {};\n  macro.obj(model.bindGroupTime, { mtime: 0 });\n\n  model.sendDirty = true;\n  model.sortDirty = true;\n\n  macro.get(publicAPI, model, ['binding', 'bindGroupTime']);\n  macro.setGet(publicAPI, model, [\n    'bindGroupLayoutEntry',\n    'device',\n    'label',\n    'sizeInBytes',\n  ]);\n\n  // Object methods\n  vtkWebGPUUniformBuffer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkWebGPUUniformBuffer');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}