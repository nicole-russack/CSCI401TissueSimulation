{"ast":null,"code":"import { quat, vec3, vec4, mat4 } from 'gl-matrix';\nimport macro from 'vtk.js/Sources/macros';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nconst {\n  vtkDebugMacro\n} = macro;\n/* eslint-disable new-cap */\n\n/*\n * Convenience function to access elements of a gl-matrix.  If it turns\n * out I have rows and columns swapped everywhere, then I'll just change\n * the order of 'row' and 'col' parameters in this function\n */\n// function getMatrixElement(matrix, row, col) {\n//   const idx = (row * 4) + col;\n//   return matrix[idx];\n// }\n// ----------------------------------------------------------------------------\n// vtkCamera methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCamera(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCamera'); // Set up private variables and methods\n\n  const origin = new Float64Array(3);\n  const dopbasis = new Float64Array([0.0, 0.0, -1.0]);\n  const upbasis = new Float64Array([0.0, 1.0, 0.0]);\n  const tmpMatrix = mat4.identity(new Float64Array(16));\n  const tmpMatrix2 = mat4.identity(new Float64Array(16));\n  const tmpvec1 = new Float64Array(3);\n  const tmpvec2 = new Float64Array(3);\n  const tmpvec3 = new Float64Array(3);\n  const rotateMatrix = mat4.identity(new Float64Array(16));\n  const trans = mat4.identity(new Float64Array(16));\n  const newPosition = new Float64Array(3);\n  const newFocalPoint = new Float64Array(3); // Internal Functions that don't need to be public\n\n  function computeViewPlaneNormal() {\n    // VPN is -DOP\n    model.viewPlaneNormal[0] = -model.directionOfProjection[0];\n    model.viewPlaneNormal[1] = -model.directionOfProjection[1];\n    model.viewPlaneNormal[2] = -model.directionOfProjection[2];\n  }\n\n  publicAPI.orthogonalizeViewUp = () => {\n    const vt = publicAPI.getViewMatrix();\n    model.viewUp[0] = vt[4];\n    model.viewUp[1] = vt[5];\n    model.viewUp[2] = vt[6];\n    publicAPI.modified();\n  };\n\n  publicAPI.setPosition = (x, y, z) => {\n    if (x === model.position[0] && y === model.position[1] && z === model.position[2]) {\n      return;\n    }\n\n    model.position[0] = x;\n    model.position[1] = y;\n    model.position[2] = z; // recompute the focal distance\n\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n\n  publicAPI.setFocalPoint = (x, y, z) => {\n    if (x === model.focalPoint[0] && y === model.focalPoint[1] && z === model.focalPoint[2]) {\n      return;\n    }\n\n    model.focalPoint[0] = x;\n    model.focalPoint[1] = y;\n    model.focalPoint[2] = z; // recompute the focal distance\n\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n\n  publicAPI.setDistance = d => {\n    if (model.distance === d) {\n      return;\n    }\n\n    model.distance = d;\n\n    if (model.distance < 1e-20) {\n      model.distance = 1e-20;\n      vtkDebugMacro('Distance is set to minimum.');\n    } // we want to keep the camera pointing in the same direction\n\n\n    const vec = model.directionOfProjection; // recalculate FocalPoint\n\n    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    publicAPI.modified();\n  }; //----------------------------------------------------------------------------\n  // This method must be called when the focal point or camera position changes\n\n\n  publicAPI.computeDistance = () => {\n    const dx = model.focalPoint[0] - model.position[0];\n    const dy = model.focalPoint[1] - model.position[1];\n    const dz = model.focalPoint[2] - model.position[2];\n    model.distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n    if (model.distance < 1e-20) {\n      model.distance = 1e-20;\n      vtkDebugMacro('Distance is set to minimum.');\n      const vec = model.directionOfProjection; // recalculate FocalPoint\n\n      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    }\n\n    model.directionOfProjection[0] = dx / model.distance;\n    model.directionOfProjection[1] = dy / model.distance;\n    model.directionOfProjection[2] = dz / model.distance;\n    computeViewPlaneNormal();\n  }; //----------------------------------------------------------------------------\n  // Move the position of the camera along the view plane normal. Moving\n  // towards the focal point (e.g., > 1) is a dolly-in, moving away\n  // from the focal point (e.g., < 1) is a dolly-out.\n\n\n  publicAPI.dolly = amount => {\n    if (amount <= 0.0) {\n      return;\n    } // dolly moves the camera towards the focus\n\n\n    const d = model.distance / amount;\n    publicAPI.setPosition(model.focalPoint[0] - d * model.directionOfProjection[0], model.focalPoint[1] - d * model.directionOfProjection[1], model.focalPoint[2] - d * model.directionOfProjection[2]);\n  };\n\n  publicAPI.roll = angle => {\n    const eye = model.position;\n    const at = model.focalPoint;\n    const up = model.viewUp;\n    const viewUpVec4 = new Float64Array([up[0], up[1], up[2], 0.0]);\n    mat4.identity(rotateMatrix);\n    const viewDir = new Float64Array([at[0] - eye[0], at[1] - eye[1], at[2] - eye[2]]);\n    mat4.rotate(rotateMatrix, rotateMatrix, vtkMath.radiansFromDegrees(angle), viewDir);\n    vec4.transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);\n    model.viewUp[0] = viewUpVec4[0];\n    model.viewUp[1] = viewUpVec4[1];\n    model.viewUp[2] = viewUpVec4[2];\n    publicAPI.modified();\n  };\n\n  publicAPI.azimuth = angle => {\n    const fp = model.focalPoint;\n    mat4.identity(trans); // translate the focal point to the origin,\n    // rotate about view up,\n    // translate back again\n\n    mat4.translate(trans, trans, fp);\n    mat4.rotate(trans, trans, vtkMath.radiansFromDegrees(angle), model.viewUp);\n    mat4.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]); // apply the transform to the position\n\n    vec3.transformMat4(newPosition, model.position, trans);\n    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);\n  };\n\n  publicAPI.yaw = angle => {\n    const position = model.position;\n    mat4.identity(trans); // translate the camera to the origin,\n    // rotate about axis,\n    // translate back again\n\n    mat4.translate(trans, trans, position);\n    mat4.rotate(trans, trans, vtkMath.radiansFromDegrees(angle), model.viewUp);\n    mat4.translate(trans, trans, [-position[0], -position[1], -position[2]]); // apply the transform to the position\n\n    vec3.transformMat4(newFocalPoint, model.focalPoint, trans);\n    publicAPI.setFocalPoint(newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]);\n  };\n\n  publicAPI.elevation = angle => {\n    const fp = model.focalPoint; // get the eye / camera position from the viewMatrix\n\n    const vt = publicAPI.getViewMatrix();\n    const axis = [-vt[0], -vt[1], -vt[2]];\n    mat4.identity(trans); // translate the focal point to the origin,\n    // rotate about view up,\n    // translate back again\n\n    mat4.translate(trans, trans, fp);\n    mat4.rotate(trans, trans, vtkMath.radiansFromDegrees(angle), axis);\n    mat4.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]); // apply the transform to the position\n\n    vec3.transformMat4(newPosition, model.position, trans);\n    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);\n  };\n\n  publicAPI.pitch = angle => {\n    const position = model.position;\n    const vt = publicAPI.getViewMatrix();\n    const axis = [vt[0], vt[1], vt[2]];\n    mat4.identity(trans); // translate the camera to the origin,\n    // rotate about axis,\n    // translate back again\n\n    mat4.translate(trans, trans, position);\n    mat4.rotate(trans, trans, vtkMath.radiansFromDegrees(angle), axis);\n    mat4.translate(trans, trans, [-position[0], -position[1], -position[2]]); // apply the transform to the focal point\n\n    vec3.transformMat4(newFocalPoint, model.focalPoint, trans);\n    publicAPI.setFocalPoint(...newFocalPoint);\n  };\n\n  publicAPI.zoom = factor => {\n    if (factor <= 0) {\n      return;\n    }\n\n    if (model.parallelProjection) {\n      model.parallelScale /= factor;\n    } else {\n      model.viewAngle /= factor;\n    }\n\n    publicAPI.modified();\n  };\n\n  publicAPI.translate = (x, y, z) => {\n    const offset = [x, y, z];\n    vtkMath.add(model.position, offset, model.position);\n    vtkMath.add(model.focalPoint, offset, model.focalPoint);\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n\n  publicAPI.applyTransform = transformMat4 => {\n    const vuOld = [...model.viewUp, 1.0];\n    const posNew = [];\n    const fpNew = [];\n    const vuNew = [];\n    vuOld[0] += model.position[0];\n    vuOld[1] += model.position[1];\n    vuOld[2] += model.position[2];\n    vec4.transformMat4(posNew, [...model.position, 1.0], transformMat4);\n    vec4.transformMat4(fpNew, [...model.focalPoint, 1.0], transformMat4);\n    vec4.transformMat4(vuNew, vuOld, transformMat4);\n    vuNew[0] -= posNew[0];\n    vuNew[1] -= posNew[1];\n    vuNew[2] -= posNew[2];\n    publicAPI.setPosition(...posNew.slice(0, 3));\n    publicAPI.setFocalPoint(...fpNew.slice(0, 3));\n    publicAPI.setViewUp(...vuNew.slice(0, 3));\n  };\n\n  publicAPI.getThickness = () => model.clippingRange[1] - model.clippingRange[0];\n\n  publicAPI.setThickness = thickness => {\n    let t = thickness;\n\n    if (t < 1e-20) {\n      t = 1e-20;\n      vtkDebugMacro('Thickness is set to minimum.');\n    }\n\n    publicAPI.setClippingRange(model.clippingRange[0], model.clippingRange[0] + t);\n  };\n\n  publicAPI.setThicknessFromFocalPoint = thickness => {\n    let t = thickness;\n\n    if (t < 1e-20) {\n      t = 1e-20;\n      vtkDebugMacro('Thickness is set to minimum.');\n    }\n\n    publicAPI.setClippingRange(model.distance - t / 2, model.distance + t / 2);\n  }; // Unimplemented functions\n\n\n  publicAPI.setRoll = angle => {}; // dependency on GetOrientation() and a model.ViewTransform object, see https://github.com/Kitware/VTK/blob/master/Common/Transforms/vtkTransform.cxx and https://vtk.org/doc/nightly/html/classvtkTransform.html\n\n\n  publicAPI.getRoll = () => {};\n\n  publicAPI.setObliqueAngles = (alpha, beta) => {};\n\n  publicAPI.getOrientation = () => {};\n\n  publicAPI.getOrientationWXYZ = () => {};\n\n  publicAPI.getFrustumPlanes = aspect => {// Return array of 24 params (4 params for each of 6 plane equations)\n  };\n\n  publicAPI.getCameraLightTransformMatrix = matrix => {\n    mat4.copy(matrix, model.cameraLightTransform);\n    return matrix;\n  };\n\n  publicAPI.computeCameraLightTransform = () => {\n    // not sure if this is the correct transformation, based on the same funciton in VTK\n    mat4.copy(tmpMatrix, publicAPI.getViewMatrix());\n    mat4.invert(tmpMatrix, tmpMatrix);\n    mat4.fromScaling(tmpMatrix2, [model.distance, model.distance, model.distance]);\n    mat4.multiply(tmpMatrix, tmpMatrix, tmpMatrix2);\n    mat4.identity(model.cameraLightTransform);\n    mat4.translate(model.cameraLightTransform, tmpMatrix, [0.0, 0.0, -1.0]);\n  };\n\n  publicAPI.deepCopy = sourceCamera => {};\n\n  publicAPI.physicalOrientationToWorldDirection = ori => {\n    // push the x axis through the orientation quat\n    const oriq = quat.fromValues(ori[0], ori[1], ori[2], ori[3]);\n    const coriq = quat.create();\n    const qdir = quat.fromValues(0.0, 0.0, 1.0, 0.0);\n    quat.conjugate(coriq, oriq); // rotate the z axis by the quat\n\n    quat.multiply(qdir, oriq, qdir);\n    quat.multiply(qdir, qdir, coriq); // return the z axis in world coords\n\n    return [qdir[0], qdir[1], qdir[2]];\n  };\n\n  publicAPI.getPhysicalToWorldMatrix = result => {\n    publicAPI.getWorldToPhysicalMatrix(result);\n    mat4.invert(result, result);\n  };\n\n  publicAPI.getWorldToPhysicalMatrix = result => {\n    mat4.identity(result); // now the physical to vtk world rotation tform\n\n    const physVRight = [3];\n    vtkMath.cross(model.physicalViewNorth, model.physicalViewUp, physVRight);\n    result[0] = physVRight[0];\n    result[1] = physVRight[1];\n    result[2] = physVRight[2];\n    result[4] = model.physicalViewUp[0];\n    result[5] = model.physicalViewUp[1];\n    result[6] = model.physicalViewUp[2];\n    result[8] = -model.physicalViewNorth[0];\n    result[9] = -model.physicalViewNorth[1];\n    result[10] = -model.physicalViewNorth[2];\n    mat4.transpose(result, result);\n    vec3.set(tmpvec1, 1 / model.physicalScale, 1 / model.physicalScale, 1 / model.physicalScale);\n    mat4.scale(result, result, tmpvec1);\n    mat4.translate(result, result, model.physicalTranslation);\n  };\n\n  publicAPI.computeViewParametersFromViewMatrix = vmat => {\n    // invert to get view to world\n    mat4.invert(tmpMatrix, vmat); // note with glmatrix operations happen in\n    // the reverse order\n    // mat.scale\n    // mat.translate\n    // will result in the translation then the scale\n    // mat.mult(a,b)\n    // results in perform the B transformation then A\n    // then extract the params position, orientation\n    // push 0,0,0 through to get a translation\n\n    vec3.transformMat4(tmpvec1, origin, tmpMatrix);\n    publicAPI.computeDistance();\n    const oldDist = model.distance;\n    publicAPI.setPosition(tmpvec1[0], tmpvec1[1], tmpvec1[2]); // push basis vectors to get orientation\n\n    vec3.transformMat4(tmpvec2, dopbasis, tmpMatrix);\n    vec3.subtract(tmpvec2, tmpvec2, tmpvec1);\n    vec3.normalize(tmpvec2, tmpvec2);\n    publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);\n    vec3.transformMat4(tmpvec3, upbasis, tmpMatrix);\n    vec3.subtract(tmpvec3, tmpvec3, tmpvec1);\n    vec3.normalize(tmpvec3, tmpvec3);\n    publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);\n    publicAPI.setDistance(oldDist);\n  }; // the provided matrix should include\n  // translation and orientation only\n  // mat is physical to view\n\n\n  publicAPI.computeViewParametersFromPhysicalMatrix = mat => {\n    // get the WorldToPhysicalMatrix\n    publicAPI.getWorldToPhysicalMatrix(tmpMatrix); // first convert the physical -> view matrix to be\n    // world -> view\n\n    mat4.multiply(tmpMatrix, mat, tmpMatrix);\n    publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);\n  };\n\n  publicAPI.setViewMatrix = mat => {\n    model.viewMatrix = mat;\n\n    if (model.viewMatrix) {\n      mat4.copy(tmpMatrix, model.viewMatrix);\n      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);\n      mat4.transpose(model.viewMatrix, model.viewMatrix);\n    }\n  };\n\n  publicAPI.getViewMatrix = () => {\n    if (model.viewMatrix) {\n      return model.viewMatrix;\n    }\n\n    mat4.lookAt(tmpMatrix, model.position, // eye\n    model.focalPoint, // at\n    model.viewUp // up\n    );\n    mat4.transpose(tmpMatrix, tmpMatrix);\n    const result = new Float64Array(16);\n    mat4.copy(result, tmpMatrix);\n    return result;\n  };\n\n  publicAPI.setProjectionMatrix = mat => {\n    model.projectionMatrix = mat;\n  };\n\n  publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {\n    const result = new Float64Array(16);\n    mat4.identity(result);\n\n    if (model.projectionMatrix) {\n      const scale = 1 / model.physicalScale;\n      vec3.set(tmpvec1, scale, scale, scale);\n      mat4.copy(result, model.projectionMatrix);\n      mat4.scale(result, result, tmpvec1);\n      mat4.transpose(result, result);\n      return result;\n    }\n\n    mat4.identity(tmpMatrix); // FIXME: Not sure what to do about adjust z buffer here\n    // adjust Z-buffer range\n    // this->ProjectionTransform->AdjustZBuffer( -1, +1, nearz, farz );\n\n    const cWidth = model.clippingRange[1] - model.clippingRange[0];\n    const cRange = [model.clippingRange[0] + (nearz + 1) * cWidth / 2.0, model.clippingRange[0] + (farz + 1) * cWidth / 2.0];\n\n    if (model.parallelProjection) {\n      // set up a rectangular parallelipiped\n      const width = model.parallelScale * aspect;\n      const height = model.parallelScale;\n      const xmin = (model.windowCenter[0] - 1.0) * width;\n      const xmax = (model.windowCenter[0] + 1.0) * width;\n      const ymin = (model.windowCenter[1] - 1.0) * height;\n      const ymax = (model.windowCenter[1] + 1.0) * height;\n      mat4.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);\n      mat4.transpose(tmpMatrix, tmpMatrix);\n    } else if (model.useOffAxisProjection) {\n      throw new Error('Off-Axis projection is not supported at this time');\n    } else {\n      const tmp = Math.tan(vtkMath.radiansFromDegrees(model.viewAngle) / 2.0);\n      let width;\n      let height;\n\n      if (model.useHorizontalViewAngle === true) {\n        width = model.clippingRange[0] * tmp;\n        height = model.clippingRange[0] * tmp / aspect;\n      } else {\n        width = model.clippingRange[0] * tmp * aspect;\n        height = model.clippingRange[0] * tmp;\n      }\n\n      const xmin = (model.windowCenter[0] - 1.0) * width;\n      const xmax = (model.windowCenter[0] + 1.0) * width;\n      const ymin = (model.windowCenter[1] - 1.0) * height;\n      const ymax = (model.windowCenter[1] + 1.0) * height;\n      const znear = cRange[0];\n      const zfar = cRange[1];\n      tmpMatrix[0] = 2.0 * znear / (xmax - xmin);\n      tmpMatrix[5] = 2.0 * znear / (ymax - ymin);\n      tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);\n      tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);\n      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);\n      tmpMatrix[14] = -1.0;\n      tmpMatrix[11] = -2.0 * znear * zfar / (zfar - znear);\n      tmpMatrix[15] = 0.0;\n    }\n\n    mat4.copy(result, tmpMatrix);\n    return result;\n  };\n\n  publicAPI.getCompositeProjectionMatrix = (aspect, nearz, farz) => {\n    const vMat = publicAPI.getViewMatrix();\n    const pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz); // mats are transposed so the order is A then B\n    // we reuse pMat as it is a copy so we can do what we want with it\n\n    mat4.multiply(pMat, vMat, pMat);\n    return pMat;\n  };\n\n  publicAPI.setDirectionOfProjection = (x, y, z) => {\n    if (model.directionOfProjection[0] === x && model.directionOfProjection[1] === y && model.directionOfProjection[2] === z) {\n      return;\n    }\n\n    model.directionOfProjection[0] = x;\n    model.directionOfProjection[1] = y;\n    model.directionOfProjection[2] = z;\n    const vec = model.directionOfProjection; // recalculate FocalPoint\n\n    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    computeViewPlaneNormal();\n  }; // used to handle convert js device orientation angles\n  // when you use this method the camera will adjust to the\n  // device orientation such that the physicalViewUp you set\n  // in world coordinates looks up, and the physicalViewNorth\n  // you set in world coorindates will (maybe) point north\n  //\n  // NOTE WARNING - much of the documentation out there on how\n  // orientation works is seriously wrong. Even worse the Chrome\n  // device orientation simulator is completely wrong and should\n  // never be used. OMG it is so messed up.\n  //\n  // how it seems to work on iOS is that the device orientation\n  // is specified in extrinsic angles with a alpha, beta, gamma\n  // convention with axes of Z, X, Y (the code below substitutes\n  // the physical coordinate system for these axes to get the right\n  // modified coordinate system.\n\n\n  publicAPI.setDeviceAngles = (alpha, beta, gamma, screen) => {\n    const physVRight = [3];\n    vtkMath.cross(model.physicalViewNorth, model.physicalViewUp, physVRight); // phone to physical coordinates\n\n    const rotmat = mat4.identity(new Float64Array(16));\n    mat4.rotate(rotmat, rotmat, vtkMath.radiansFromDegrees(alpha), model.physicalViewUp);\n    mat4.rotate(rotmat, rotmat, vtkMath.radiansFromDegrees(beta), physVRight);\n    mat4.rotate(rotmat, rotmat, vtkMath.radiansFromDegrees(gamma), model.physicalViewNorth);\n    mat4.rotate(rotmat, rotmat, vtkMath.radiansFromDegrees(-screen), model.physicalViewUp);\n    const dop = new Float64Array([-model.physicalViewUp[0], -model.physicalViewUp[1], -model.physicalViewUp[2]]);\n    const vup = new Float64Array(model.physicalViewNorth);\n    vec3.transformMat4(dop, dop, rotmat);\n    vec3.transformMat4(vup, vup, rotmat);\n    publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);\n    publicAPI.setViewUp(vup[0], vup[1], vup[2]);\n    publicAPI.modified();\n  };\n\n  publicAPI.setOrientationWXYZ = (degrees, x, y, z) => {\n    const quatMat = mat4.identity(new Float64Array(16));\n\n    if (degrees !== 0.0 && (x !== 0.0 || y !== 0.0 || z !== 0.0)) {\n      // convert to radians\n      const angle = vtkMath.radiansFromDegrees(degrees);\n      const q = quat.create();\n      quat.setAxisAngle(q, [x, y, z], angle);\n      mat4.fromQuat(quatMat, q);\n    }\n\n    const newdop = new Float64Array(3);\n    vec3.transformMat4(newdop, [0.0, 0.0, -1.0], quatMat);\n    const newvup = new Float64Array(3);\n    vec3.transformMat4(newvup, [0.0, 1.0, 0.0], quatMat);\n    publicAPI.setDirectionOfProjection(...newdop);\n    publicAPI.setViewUp(...newvup);\n    publicAPI.modified();\n  };\n\n  publicAPI.computeClippingRange = bounds => {\n    let vn = null;\n    let position = null;\n    vn = model.viewPlaneNormal;\n    position = model.position;\n    const a = -vn[0];\n    const b = -vn[1];\n    const c = -vn[2];\n    const d = -(a * position[0] + b * position[1] + c * position[2]); // Set the max near clipping plane and the min far clipping plane\n\n    const range = [a * bounds[0] + b * bounds[2] + c * bounds[4] + d, 1e-18]; // Find the closest / farthest bounding box vertex\n\n    for (let k = 0; k < 2; k++) {\n      for (let j = 0; j < 2; j++) {\n        for (let i = 0; i < 2; i++) {\n          const dist = a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;\n          range[0] = dist < range[0] ? dist : range[0];\n          range[1] = dist > range[1] ? dist : range[1];\n        }\n      }\n    }\n\n    return range;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nexport const DEFAULT_VALUES = {\n  position: [0, 0, 1],\n  focalPoint: [0, 0, 0],\n  viewUp: [0, 1, 0],\n  directionOfProjection: [0, 0, -1],\n  parallelProjection: false,\n  useHorizontalViewAngle: false,\n  viewAngle: 30,\n  parallelScale: 1,\n  clippingRange: [0.01, 1000.01],\n  windowCenter: [0, 0],\n  viewPlaneNormal: [0, 0, 1],\n  useOffAxisProjection: false,\n  screenBottomLeft: [-0.5, -0.5, -0.5],\n  screenBottomRight: [0.5, -0.5, -0.5],\n  screenTopRight: [0.5, 0.5, -0.5],\n  freezeFocalPoint: false,\n  projectionMatrix: null,\n  viewMatrix: null,\n  cameraLightTransform: mat4.create(),\n  // used for world to physical transformations\n  physicalTranslation: [0, 0, 0],\n  physicalScale: 1.0,\n  physicalViewUp: [0, 1, 0],\n  physicalViewNorth: [0, 0, -1]\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['distance']);\n  macro.setGet(publicAPI, model, ['parallelProjection', 'useHorizontalViewAngle', 'viewAngle', 'parallelScale', 'useOffAxisProjection', 'freezeFocalPoint', 'physicalScale']);\n  macro.getArray(publicAPI, model, ['directionOfProjection', 'viewPlaneNormal', 'position', 'focalPoint']);\n  macro.setGetArray(publicAPI, model, ['clippingRange', 'windowCenter'], 2);\n  macro.setGetArray(publicAPI, model, ['viewUp', 'screenBottomLeft', 'screenBottomRight', 'screenTopRight', 'physicalTranslation', 'physicalViewUp', 'physicalViewNorth'], 3); // Object methods\n\n  vtkCamera(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkCamera'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["quat","vec3","vec4","mat4","macro","vtkMath","vtkDebugMacro","vtkCamera","publicAPI","model","classHierarchy","push","origin","Float64Array","dopbasis","upbasis","tmpMatrix","identity","tmpMatrix2","tmpvec1","tmpvec2","tmpvec3","rotateMatrix","trans","newPosition","newFocalPoint","computeViewPlaneNormal","viewPlaneNormal","directionOfProjection","orthogonalizeViewUp","vt","getViewMatrix","viewUp","modified","setPosition","x","y","z","position","computeDistance","setFocalPoint","focalPoint","setDistance","d","distance","vec","dx","dy","dz","Math","sqrt","dolly","amount","roll","angle","eye","at","up","viewUpVec4","viewDir","rotate","radiansFromDegrees","transformMat4","azimuth","fp","translate","yaw","elevation","axis","pitch","zoom","factor","parallelProjection","parallelScale","viewAngle","offset","add","applyTransform","vuOld","posNew","fpNew","vuNew","slice","setViewUp","getThickness","clippingRange","setThickness","thickness","t","setClippingRange","setThicknessFromFocalPoint","setRoll","getRoll","setObliqueAngles","alpha","beta","getOrientation","getOrientationWXYZ","getFrustumPlanes","aspect","getCameraLightTransformMatrix","matrix","copy","cameraLightTransform","computeCameraLightTransform","invert","fromScaling","multiply","deepCopy","sourceCamera","physicalOrientationToWorldDirection","ori","oriq","fromValues","coriq","create","qdir","conjugate","getPhysicalToWorldMatrix","result","getWorldToPhysicalMatrix","physVRight","cross","physicalViewNorth","physicalViewUp","transpose","set","physicalScale","scale","physicalTranslation","computeViewParametersFromViewMatrix","vmat","oldDist","subtract","normalize","setDirectionOfProjection","computeViewParametersFromPhysicalMatrix","mat","setViewMatrix","viewMatrix","lookAt","setProjectionMatrix","projectionMatrix","getProjectionMatrix","nearz","farz","cWidth","cRange","width","height","xmin","windowCenter","xmax","ymin","ymax","ortho","useOffAxisProjection","Error","tmp","tan","useHorizontalViewAngle","znear","zfar","getCompositeProjectionMatrix","vMat","pMat","setDeviceAngles","gamma","screen","rotmat","dop","vup","setOrientationWXYZ","degrees","quatMat","q","setAxisAngle","fromQuat","newdop","newvup","computeClippingRange","bounds","vn","a","b","c","range","k","j","i","dist","DEFAULT_VALUES","screenBottomLeft","screenBottomRight","screenTopRight","freezeFocalPoint","extend","initialValues","Object","assign","obj","get","setGet","getArray","setGetArray","newInstance"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/Core/Camera/index.js"],"sourcesContent":["import { quat, vec3, vec4, mat4 } from 'gl-matrix';\n\nimport macro from 'vtk.js/Sources/macros';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\n\nconst { vtkDebugMacro } = macro;\n\n/* eslint-disable new-cap */\n\n/*\n * Convenience function to access elements of a gl-matrix.  If it turns\n * out I have rows and columns swapped everywhere, then I'll just change\n * the order of 'row' and 'col' parameters in this function\n */\n// function getMatrixElement(matrix, row, col) {\n//   const idx = (row * 4) + col;\n//   return matrix[idx];\n// }\n\n// ----------------------------------------------------------------------------\n// vtkCamera methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCamera(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCamera');\n\n  // Set up private variables and methods\n  const origin = new Float64Array(3);\n  const dopbasis = new Float64Array([0.0, 0.0, -1.0]);\n  const upbasis = new Float64Array([0.0, 1.0, 0.0]);\n  const tmpMatrix = mat4.identity(new Float64Array(16));\n  const tmpMatrix2 = mat4.identity(new Float64Array(16));\n  const tmpvec1 = new Float64Array(3);\n  const tmpvec2 = new Float64Array(3);\n  const tmpvec3 = new Float64Array(3);\n\n  const rotateMatrix = mat4.identity(new Float64Array(16));\n  const trans = mat4.identity(new Float64Array(16));\n  const newPosition = new Float64Array(3);\n  const newFocalPoint = new Float64Array(3);\n\n  // Internal Functions that don't need to be public\n  function computeViewPlaneNormal() {\n    // VPN is -DOP\n    model.viewPlaneNormal[0] = -model.directionOfProjection[0];\n    model.viewPlaneNormal[1] = -model.directionOfProjection[1];\n    model.viewPlaneNormal[2] = -model.directionOfProjection[2];\n  }\n\n  publicAPI.orthogonalizeViewUp = () => {\n    const vt = publicAPI.getViewMatrix();\n    model.viewUp[0] = vt[4];\n    model.viewUp[1] = vt[5];\n    model.viewUp[2] = vt[6];\n\n    publicAPI.modified();\n  };\n\n  publicAPI.setPosition = (x, y, z) => {\n    if (\n      x === model.position[0] &&\n      y === model.position[1] &&\n      z === model.position[2]\n    ) {\n      return;\n    }\n\n    model.position[0] = x;\n    model.position[1] = y;\n    model.position[2] = z;\n\n    // recompute the focal distance\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n\n  publicAPI.setFocalPoint = (x, y, z) => {\n    if (\n      x === model.focalPoint[0] &&\n      y === model.focalPoint[1] &&\n      z === model.focalPoint[2]\n    ) {\n      return;\n    }\n\n    model.focalPoint[0] = x;\n    model.focalPoint[1] = y;\n    model.focalPoint[2] = z;\n\n    // recompute the focal distance\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n\n  publicAPI.setDistance = (d) => {\n    if (model.distance === d) {\n      return;\n    }\n\n    model.distance = d;\n\n    if (model.distance < 1e-20) {\n      model.distance = 1e-20;\n      vtkDebugMacro('Distance is set to minimum.');\n    }\n\n    // we want to keep the camera pointing in the same direction\n    const vec = model.directionOfProjection;\n\n    // recalculate FocalPoint\n    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  // This method must be called when the focal point or camera position changes\n  publicAPI.computeDistance = () => {\n    const dx = model.focalPoint[0] - model.position[0];\n    const dy = model.focalPoint[1] - model.position[1];\n    const dz = model.focalPoint[2] - model.position[2];\n\n    model.distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n    if (model.distance < 1e-20) {\n      model.distance = 1e-20;\n      vtkDebugMacro('Distance is set to minimum.');\n\n      const vec = model.directionOfProjection;\n\n      // recalculate FocalPoint\n      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    }\n\n    model.directionOfProjection[0] = dx / model.distance;\n    model.directionOfProjection[1] = dy / model.distance;\n    model.directionOfProjection[2] = dz / model.distance;\n\n    computeViewPlaneNormal();\n  };\n\n  //----------------------------------------------------------------------------\n  // Move the position of the camera along the view plane normal. Moving\n  // towards the focal point (e.g., > 1) is a dolly-in, moving away\n  // from the focal point (e.g., < 1) is a dolly-out.\n  publicAPI.dolly = (amount) => {\n    if (amount <= 0.0) {\n      return;\n    }\n\n    // dolly moves the camera towards the focus\n    const d = model.distance / amount;\n\n    publicAPI.setPosition(\n      model.focalPoint[0] - d * model.directionOfProjection[0],\n      model.focalPoint[1] - d * model.directionOfProjection[1],\n      model.focalPoint[2] - d * model.directionOfProjection[2]\n    );\n  };\n\n  publicAPI.roll = (angle) => {\n    const eye = model.position;\n    const at = model.focalPoint;\n    const up = model.viewUp;\n    const viewUpVec4 = new Float64Array([up[0], up[1], up[2], 0.0]);\n\n    mat4.identity(rotateMatrix);\n    const viewDir = new Float64Array([\n      at[0] - eye[0],\n      at[1] - eye[1],\n      at[2] - eye[2],\n    ]);\n    mat4.rotate(\n      rotateMatrix,\n      rotateMatrix,\n      vtkMath.radiansFromDegrees(angle),\n      viewDir\n    );\n    vec4.transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);\n\n    model.viewUp[0] = viewUpVec4[0];\n    model.viewUp[1] = viewUpVec4[1];\n    model.viewUp[2] = viewUpVec4[2];\n\n    publicAPI.modified();\n  };\n\n  publicAPI.azimuth = (angle) => {\n    const fp = model.focalPoint;\n\n    mat4.identity(trans);\n\n    // translate the focal point to the origin,\n    // rotate about view up,\n    // translate back again\n    mat4.translate(trans, trans, fp);\n    mat4.rotate(trans, trans, vtkMath.radiansFromDegrees(angle), model.viewUp);\n    mat4.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newPosition, model.position, trans);\n    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);\n  };\n\n  publicAPI.yaw = (angle) => {\n    const position = model.position;\n\n    mat4.identity(trans);\n\n    // translate the camera to the origin,\n    // rotate about axis,\n    // translate back again\n    mat4.translate(trans, trans, position);\n    mat4.rotate(trans, trans, vtkMath.radiansFromDegrees(angle), model.viewUp);\n    mat4.translate(trans, trans, [-position[0], -position[1], -position[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newFocalPoint, model.focalPoint, trans);\n    publicAPI.setFocalPoint(\n      newFocalPoint[0],\n      newFocalPoint[1],\n      newFocalPoint[2]\n    );\n  };\n\n  publicAPI.elevation = (angle) => {\n    const fp = model.focalPoint;\n\n    // get the eye / camera position from the viewMatrix\n    const vt = publicAPI.getViewMatrix();\n    const axis = [-vt[0], -vt[1], -vt[2]];\n\n    mat4.identity(trans);\n\n    // translate the focal point to the origin,\n    // rotate about view up,\n    // translate back again\n    mat4.translate(trans, trans, fp);\n    mat4.rotate(trans, trans, vtkMath.radiansFromDegrees(angle), axis);\n    mat4.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newPosition, model.position, trans);\n    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);\n  };\n\n  publicAPI.pitch = (angle) => {\n    const position = model.position;\n\n    const vt = publicAPI.getViewMatrix();\n    const axis = [vt[0], vt[1], vt[2]];\n\n    mat4.identity(trans);\n\n    // translate the camera to the origin,\n    // rotate about axis,\n    // translate back again\n    mat4.translate(trans, trans, position);\n    mat4.rotate(trans, trans, vtkMath.radiansFromDegrees(angle), axis);\n    mat4.translate(trans, trans, [-position[0], -position[1], -position[2]]);\n\n    // apply the transform to the focal point\n    vec3.transformMat4(newFocalPoint, model.focalPoint, trans);\n    publicAPI.setFocalPoint(...newFocalPoint);\n  };\n\n  publicAPI.zoom = (factor) => {\n    if (factor <= 0) {\n      return;\n    }\n    if (model.parallelProjection) {\n      model.parallelScale /= factor;\n    } else {\n      model.viewAngle /= factor;\n    }\n    publicAPI.modified();\n  };\n\n  publicAPI.translate = (x, y, z) => {\n    const offset = [x, y, z];\n\n    vtkMath.add(model.position, offset, model.position);\n    vtkMath.add(model.focalPoint, offset, model.focalPoint);\n\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n\n  publicAPI.applyTransform = (transformMat4) => {\n    const vuOld = [...model.viewUp, 1.0];\n    const posNew = [];\n    const fpNew = [];\n    const vuNew = [];\n\n    vuOld[0] += model.position[0];\n    vuOld[1] += model.position[1];\n    vuOld[2] += model.position[2];\n\n    vec4.transformMat4(posNew, [...model.position, 1.0], transformMat4);\n    vec4.transformMat4(fpNew, [...model.focalPoint, 1.0], transformMat4);\n    vec4.transformMat4(vuNew, vuOld, transformMat4);\n\n    vuNew[0] -= posNew[0];\n    vuNew[1] -= posNew[1];\n    vuNew[2] -= posNew[2];\n\n    publicAPI.setPosition(...posNew.slice(0, 3));\n    publicAPI.setFocalPoint(...fpNew.slice(0, 3));\n    publicAPI.setViewUp(...vuNew.slice(0, 3));\n  };\n\n  publicAPI.getThickness = () =>\n    model.clippingRange[1] - model.clippingRange[0];\n\n  publicAPI.setThickness = (thickness) => {\n    let t = thickness;\n    if (t < 1e-20) {\n      t = 1e-20;\n      vtkDebugMacro('Thickness is set to minimum.');\n    }\n    publicAPI.setClippingRange(\n      model.clippingRange[0],\n      model.clippingRange[0] + t\n    );\n  };\n\n  publicAPI.setThicknessFromFocalPoint = (thickness) => {\n    let t = thickness;\n    if (t < 1e-20) {\n      t = 1e-20;\n      vtkDebugMacro('Thickness is set to minimum.');\n    }\n    publicAPI.setClippingRange(model.distance - t / 2, model.distance + t / 2);\n  };\n\n  // Unimplemented functions\n  publicAPI.setRoll = (angle) => {}; // dependency on GetOrientation() and a model.ViewTransform object, see https://github.com/Kitware/VTK/blob/master/Common/Transforms/vtkTransform.cxx and https://vtk.org/doc/nightly/html/classvtkTransform.html\n  publicAPI.getRoll = () => {};\n  publicAPI.setObliqueAngles = (alpha, beta) => {};\n  publicAPI.getOrientation = () => {};\n  publicAPI.getOrientationWXYZ = () => {};\n  publicAPI.getFrustumPlanes = (aspect) => {\n    // Return array of 24 params (4 params for each of 6 plane equations)\n  };\n  publicAPI.getCameraLightTransformMatrix = (matrix) => {\n    mat4.copy(matrix, model.cameraLightTransform);\n    return matrix;\n  };\n\n  publicAPI.computeCameraLightTransform = () => {\n    // not sure if this is the correct transformation, based on the same funciton in VTK\n    mat4.copy(tmpMatrix, publicAPI.getViewMatrix());\n    mat4.invert(tmpMatrix, tmpMatrix);\n\n    mat4.fromScaling(tmpMatrix2, [\n      model.distance,\n      model.distance,\n      model.distance,\n    ]);\n    mat4.multiply(tmpMatrix, tmpMatrix, tmpMatrix2);\n    mat4.identity(model.cameraLightTransform);\n    mat4.translate(model.cameraLightTransform, tmpMatrix, [0.0, 0.0, -1.0]);\n  };\n\n  publicAPI.deepCopy = (sourceCamera) => {};\n\n  publicAPI.physicalOrientationToWorldDirection = (ori) => {\n    // push the x axis through the orientation quat\n    const oriq = quat.fromValues(ori[0], ori[1], ori[2], ori[3]);\n    const coriq = quat.create();\n    const qdir = quat.fromValues(0.0, 0.0, 1.0, 0.0);\n    quat.conjugate(coriq, oriq);\n\n    // rotate the z axis by the quat\n    quat.multiply(qdir, oriq, qdir);\n    quat.multiply(qdir, qdir, coriq);\n\n    // return the z axis in world coords\n    return [qdir[0], qdir[1], qdir[2]];\n  };\n\n  publicAPI.getPhysicalToWorldMatrix = (result) => {\n    publicAPI.getWorldToPhysicalMatrix(result);\n    mat4.invert(result, result);\n  };\n\n  publicAPI.getWorldToPhysicalMatrix = (result) => {\n    mat4.identity(result);\n\n    // now the physical to vtk world rotation tform\n    const physVRight = [3];\n    vtkMath.cross(model.physicalViewNorth, model.physicalViewUp, physVRight);\n    result[0] = physVRight[0];\n    result[1] = physVRight[1];\n    result[2] = physVRight[2];\n    result[4] = model.physicalViewUp[0];\n    result[5] = model.physicalViewUp[1];\n    result[6] = model.physicalViewUp[2];\n    result[8] = -model.physicalViewNorth[0];\n    result[9] = -model.physicalViewNorth[1];\n    result[10] = -model.physicalViewNorth[2];\n    mat4.transpose(result, result);\n\n    vec3.set(\n      tmpvec1,\n      1 / model.physicalScale,\n      1 / model.physicalScale,\n      1 / model.physicalScale\n    );\n\n    mat4.scale(result, result, tmpvec1);\n    mat4.translate(result, result, model.physicalTranslation);\n  };\n\n  publicAPI.computeViewParametersFromViewMatrix = (vmat) => {\n    // invert to get view to world\n    mat4.invert(tmpMatrix, vmat);\n\n    // note with glmatrix operations happen in\n    // the reverse order\n    // mat.scale\n    // mat.translate\n    // will result in the translation then the scale\n    // mat.mult(a,b)\n    // results in perform the B transformation then A\n\n    // then extract the params position, orientation\n    // push 0,0,0 through to get a translation\n    vec3.transformMat4(tmpvec1, origin, tmpMatrix);\n    publicAPI.computeDistance();\n    const oldDist = model.distance;\n    publicAPI.setPosition(tmpvec1[0], tmpvec1[1], tmpvec1[2]);\n\n    // push basis vectors to get orientation\n    vec3.transformMat4(tmpvec2, dopbasis, tmpMatrix);\n    vec3.subtract(tmpvec2, tmpvec2, tmpvec1);\n    vec3.normalize(tmpvec2, tmpvec2);\n    publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);\n\n    vec3.transformMat4(tmpvec3, upbasis, tmpMatrix);\n    vec3.subtract(tmpvec3, tmpvec3, tmpvec1);\n    vec3.normalize(tmpvec3, tmpvec3);\n    publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);\n\n    publicAPI.setDistance(oldDist);\n  };\n\n  // the provided matrix should include\n  // translation and orientation only\n  // mat is physical to view\n  publicAPI.computeViewParametersFromPhysicalMatrix = (mat) => {\n    // get the WorldToPhysicalMatrix\n    publicAPI.getWorldToPhysicalMatrix(tmpMatrix);\n\n    // first convert the physical -> view matrix to be\n    // world -> view\n    mat4.multiply(tmpMatrix, mat, tmpMatrix);\n\n    publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);\n  };\n\n  publicAPI.setViewMatrix = (mat) => {\n    model.viewMatrix = mat;\n    if (model.viewMatrix) {\n      mat4.copy(tmpMatrix, model.viewMatrix);\n      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);\n      mat4.transpose(model.viewMatrix, model.viewMatrix);\n    }\n  };\n\n  publicAPI.getViewMatrix = () => {\n    if (model.viewMatrix) {\n      return model.viewMatrix;\n    }\n\n    mat4.lookAt(\n      tmpMatrix,\n      model.position, // eye\n      model.focalPoint, // at\n      model.viewUp // up\n    );\n\n    mat4.transpose(tmpMatrix, tmpMatrix);\n\n    const result = new Float64Array(16);\n    mat4.copy(result, tmpMatrix);\n    return result;\n  };\n\n  publicAPI.setProjectionMatrix = (mat) => {\n    model.projectionMatrix = mat;\n  };\n\n  publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {\n    const result = new Float64Array(16);\n    mat4.identity(result);\n\n    if (model.projectionMatrix) {\n      const scale = 1 / model.physicalScale;\n      vec3.set(tmpvec1, scale, scale, scale);\n\n      mat4.copy(result, model.projectionMatrix);\n      mat4.scale(result, result, tmpvec1);\n      mat4.transpose(result, result);\n      return result;\n    }\n\n    mat4.identity(tmpMatrix);\n\n    // FIXME: Not sure what to do about adjust z buffer here\n    // adjust Z-buffer range\n    // this->ProjectionTransform->AdjustZBuffer( -1, +1, nearz, farz );\n    const cWidth = model.clippingRange[1] - model.clippingRange[0];\n    const cRange = [\n      model.clippingRange[0] + ((nearz + 1) * cWidth) / 2.0,\n      model.clippingRange[0] + ((farz + 1) * cWidth) / 2.0,\n    ];\n\n    if (model.parallelProjection) {\n      // set up a rectangular parallelipiped\n      const width = model.parallelScale * aspect;\n      const height = model.parallelScale;\n\n      const xmin = (model.windowCenter[0] - 1.0) * width;\n      const xmax = (model.windowCenter[0] + 1.0) * width;\n      const ymin = (model.windowCenter[1] - 1.0) * height;\n      const ymax = (model.windowCenter[1] + 1.0) * height;\n\n      mat4.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);\n      mat4.transpose(tmpMatrix, tmpMatrix);\n    } else if (model.useOffAxisProjection) {\n      throw new Error('Off-Axis projection is not supported at this time');\n    } else {\n      const tmp = Math.tan(vtkMath.radiansFromDegrees(model.viewAngle) / 2.0);\n      let width;\n      let height;\n      if (model.useHorizontalViewAngle === true) {\n        width = model.clippingRange[0] * tmp;\n        height = (model.clippingRange[0] * tmp) / aspect;\n      } else {\n        width = model.clippingRange[0] * tmp * aspect;\n        height = model.clippingRange[0] * tmp;\n      }\n\n      const xmin = (model.windowCenter[0] - 1.0) * width;\n      const xmax = (model.windowCenter[0] + 1.0) * width;\n      const ymin = (model.windowCenter[1] - 1.0) * height;\n      const ymax = (model.windowCenter[1] + 1.0) * height;\n      const znear = cRange[0];\n      const zfar = cRange[1];\n\n      tmpMatrix[0] = (2.0 * znear) / (xmax - xmin);\n      tmpMatrix[5] = (2.0 * znear) / (ymax - ymin);\n      tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);\n      tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);\n      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);\n      tmpMatrix[14] = -1.0;\n      tmpMatrix[11] = (-2.0 * znear * zfar) / (zfar - znear);\n      tmpMatrix[15] = 0.0;\n    }\n\n    mat4.copy(result, tmpMatrix);\n\n    return result;\n  };\n\n  publicAPI.getCompositeProjectionMatrix = (aspect, nearz, farz) => {\n    const vMat = publicAPI.getViewMatrix();\n    const pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz);\n    // mats are transposed so the order is A then B\n    // we reuse pMat as it is a copy so we can do what we want with it\n    mat4.multiply(pMat, vMat, pMat);\n    return pMat;\n  };\n\n  publicAPI.setDirectionOfProjection = (x, y, z) => {\n    if (\n      model.directionOfProjection[0] === x &&\n      model.directionOfProjection[1] === y &&\n      model.directionOfProjection[2] === z\n    ) {\n      return;\n    }\n\n    model.directionOfProjection[0] = x;\n    model.directionOfProjection[1] = y;\n    model.directionOfProjection[2] = z;\n\n    const vec = model.directionOfProjection;\n\n    // recalculate FocalPoint\n    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    computeViewPlaneNormal();\n  };\n\n  // used to handle convert js device orientation angles\n  // when you use this method the camera will adjust to the\n  // device orientation such that the physicalViewUp you set\n  // in world coordinates looks up, and the physicalViewNorth\n  // you set in world coorindates will (maybe) point north\n  //\n  // NOTE WARNING - much of the documentation out there on how\n  // orientation works is seriously wrong. Even worse the Chrome\n  // device orientation simulator is completely wrong and should\n  // never be used. OMG it is so messed up.\n  //\n  // how it seems to work on iOS is that the device orientation\n  // is specified in extrinsic angles with a alpha, beta, gamma\n  // convention with axes of Z, X, Y (the code below substitutes\n  // the physical coordinate system for these axes to get the right\n  // modified coordinate system.\n  publicAPI.setDeviceAngles = (alpha, beta, gamma, screen) => {\n    const physVRight = [3];\n    vtkMath.cross(model.physicalViewNorth, model.physicalViewUp, physVRight);\n\n    // phone to physical coordinates\n    const rotmat = mat4.identity(new Float64Array(16));\n    mat4.rotate(\n      rotmat,\n      rotmat,\n      vtkMath.radiansFromDegrees(alpha),\n      model.physicalViewUp\n    );\n    mat4.rotate(rotmat, rotmat, vtkMath.radiansFromDegrees(beta), physVRight);\n    mat4.rotate(\n      rotmat,\n      rotmat,\n      vtkMath.radiansFromDegrees(gamma),\n      model.physicalViewNorth\n    );\n\n    mat4.rotate(\n      rotmat,\n      rotmat,\n      vtkMath.radiansFromDegrees(-screen),\n      model.physicalViewUp\n    );\n\n    const dop = new Float64Array([\n      -model.physicalViewUp[0],\n      -model.physicalViewUp[1],\n      -model.physicalViewUp[2],\n    ]);\n    const vup = new Float64Array(model.physicalViewNorth);\n    vec3.transformMat4(dop, dop, rotmat);\n    vec3.transformMat4(vup, vup, rotmat);\n\n    publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);\n    publicAPI.setViewUp(vup[0], vup[1], vup[2]);\n    publicAPI.modified();\n  };\n\n  publicAPI.setOrientationWXYZ = (degrees, x, y, z) => {\n    const quatMat = mat4.identity(new Float64Array(16));\n\n    if (degrees !== 0.0 && (x !== 0.0 || y !== 0.0 || z !== 0.0)) {\n      // convert to radians\n      const angle = vtkMath.radiansFromDegrees(degrees);\n      const q = quat.create();\n      quat.setAxisAngle(q, [x, y, z], angle);\n      mat4.fromQuat(quatMat, q);\n    }\n\n    const newdop = new Float64Array(3);\n    vec3.transformMat4(newdop, [0.0, 0.0, -1.0], quatMat);\n\n    const newvup = new Float64Array(3);\n    vec3.transformMat4(newvup, [0.0, 1.0, 0.0], quatMat);\n\n    publicAPI.setDirectionOfProjection(...newdop);\n    publicAPI.setViewUp(...newvup);\n    publicAPI.modified();\n  };\n\n  publicAPI.computeClippingRange = (bounds) => {\n    let vn = null;\n    let position = null;\n\n    vn = model.viewPlaneNormal;\n    position = model.position;\n\n    const a = -vn[0];\n    const b = -vn[1];\n    const c = -vn[2];\n    const d = -(a * position[0] + b * position[1] + c * position[2]);\n\n    // Set the max near clipping plane and the min far clipping plane\n    const range = [a * bounds[0] + b * bounds[2] + c * bounds[4] + d, 1e-18];\n\n    // Find the closest / farthest bounding box vertex\n    for (let k = 0; k < 2; k++) {\n      for (let j = 0; j < 2; j++) {\n        for (let i = 0; i < 2; i++) {\n          const dist =\n            a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;\n          range[0] = dist < range[0] ? dist : range[0];\n          range[1] = dist > range[1] ? dist : range[1];\n        }\n      }\n    }\n\n    return range;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nexport const DEFAULT_VALUES = {\n  position: [0, 0, 1],\n  focalPoint: [0, 0, 0],\n  viewUp: [0, 1, 0],\n  directionOfProjection: [0, 0, -1],\n  parallelProjection: false,\n  useHorizontalViewAngle: false,\n  viewAngle: 30,\n  parallelScale: 1,\n  clippingRange: [0.01, 1000.01],\n  windowCenter: [0, 0],\n  viewPlaneNormal: [0, 0, 1],\n  useOffAxisProjection: false,\n  screenBottomLeft: [-0.5, -0.5, -0.5],\n  screenBottomRight: [0.5, -0.5, -0.5],\n  screenTopRight: [0.5, 0.5, -0.5],\n  freezeFocalPoint: false,\n  projectionMatrix: null,\n  viewMatrix: null,\n  cameraLightTransform: mat4.create(),\n\n  // used for world to physical transformations\n  physicalTranslation: [0, 0, 0],\n  physicalScale: 1.0,\n  physicalViewUp: [0, 1, 0],\n  physicalViewNorth: [0, 0, -1],\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n\n  macro.get(publicAPI, model, ['distance']);\n\n  macro.setGet(publicAPI, model, [\n    'parallelProjection',\n    'useHorizontalViewAngle',\n    'viewAngle',\n    'parallelScale',\n    'useOffAxisProjection',\n    'freezeFocalPoint',\n    'physicalScale',\n  ]);\n\n  macro.getArray(publicAPI, model, [\n    'directionOfProjection',\n    'viewPlaneNormal',\n    'position',\n    'focalPoint',\n  ]);\n\n  macro.setGetArray(publicAPI, model, ['clippingRange', 'windowCenter'], 2);\n\n  macro.setGetArray(\n    publicAPI,\n    model,\n    [\n      'viewUp',\n      'screenBottomLeft',\n      'screenBottomRight',\n      'screenTopRight',\n      'physicalTranslation',\n      'physicalViewUp',\n      'physicalViewNorth',\n    ],\n    3\n  );\n\n  // Object methods\n  vtkCamera(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkCamera');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}