{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkScalarsToColors from 'vtk.js/Sources/Common/Core/ScalarsToColors';\nimport Constants from 'vtk.js/Sources/Rendering/Core/ColorTransferFunction/Constants';\nconst {\n  ColorSpace,\n  Scale\n} = Constants;\nconst {\n  ScalarMappingTarget\n} = vtkScalarsToColors;\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n/* eslint-disable no-continue                                                */\n// Convert to and from a special polar version of CIELAB (useful for creating\n// continuous diverging color maps).\n\nfunction vtkColorTransferFunctionLabToMsh(lab, msh) {\n  const L = lab[0];\n  const a = lab[1];\n  const b = lab[2];\n  const M = Math.sqrt(L * L + a * a + b * b);\n  const s = M > 0.001 ? Math.acos(L / M) : 0.0;\n  const h = s > 0.001 ? Math.atan2(b, a) : 0.0;\n  msh[0] = M;\n  msh[1] = s;\n  msh[2] = h;\n}\n\nfunction vtkColorTransferFunctionMshToLab(msh, lab) {\n  const M = msh[0];\n  const s = msh[1];\n  const h = msh[2];\n  lab[0] = M * Math.cos(s);\n  lab[1] = M * Math.sin(s) * Math.cos(h);\n  lab[2] = M * Math.sin(s) * Math.sin(h);\n} // For the case when interpolating from a saturated color to an unsaturated\n// color, find a hue for the unsaturated color that makes sense.\n\n\nfunction vtkColorTransferFunctionAdjustHue(msh, unsatM) {\n  if (msh[0] >= unsatM - 0.1) {\n    // The best we can do is hold hue constant.\n    return msh[2];\n  } // This equation is designed to make the perceptual change of the\n  // interpolation to be close to constant.\n\n\n  const hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1])); // Spin hue away from 0 except in purple hues.\n\n  if (msh[2] > -0.3 * Math.PI) {\n    return msh[2] + hueSpin;\n  }\n\n  return msh[2] - hueSpin;\n}\n\nfunction vtkColorTransferFunctionAngleDiff(a1, a2) {\n  let adiff = a1 - a2;\n\n  if (adiff < 0.0) {\n    adiff = -adiff;\n  }\n\n  while (adiff >= 2.0 * Math.PI) {\n    adiff -= 2.0 * Math.PI;\n  }\n\n  if (adiff > Math.PI) {\n    adiff = 2.0 * Math.PI - adiff;\n  }\n\n  return adiff;\n} // Interpolate a diverging color map.\n\n\nfunction vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {\n  const lab1 = [];\n  const lab2 = [];\n  vtkMath.rgb2lab(rgb1, lab1);\n  vtkMath.rgb2lab(rgb2, lab2);\n  const msh1 = [];\n  const msh2 = [];\n  vtkColorTransferFunctionLabToMsh(lab1, msh1);\n  vtkColorTransferFunctionLabToMsh(lab2, msh2); // If the endpoints are distinct saturated colors, then place white in between\n  // them.\n\n  let localS = s;\n\n  if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {\n    // Insert the white midpoint by setting one end to white and adjusting the\n    // scalar value.\n    let Mmid = Math.max(msh1[0], msh2[0]);\n    Mmid = Math.max(88.0, Mmid);\n\n    if (s < 0.5) {\n      msh2[0] = Mmid;\n      msh2[1] = 0.0;\n      msh2[2] = 0.0;\n      localS *= 2.0;\n    } else {\n      msh1[0] = Mmid;\n      msh1[1] = 0.0;\n      msh1[2] = 0.0;\n      localS = 2.0 * localS - 1.0;\n    }\n  } // If one color has no saturation, then its hue value is invalid.  In this\n  // case, we want to set it to something logical so that the interpolation of\n  // hue makes sense.\n\n\n  if (msh1[1] < 0.05 && msh2[1] > 0.05) {\n    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);\n  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {\n    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);\n  }\n\n  const mshTmp = [];\n  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];\n  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];\n  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2]; // Now convert back to RGB\n\n  const labTmp = [];\n  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);\n  vtkMath.lab2rgb(labTmp, result);\n} // ----------------------------------------------------------------------------\n// vtkColorTransferFunction methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkColorTransferFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkColorTransferFunction'); // Return the number of points which specify this function\n\n  publicAPI.getSize = () => model.nodes.length; //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n\n\n  publicAPI.addRGBPoint = (x, r, g, b) => publicAPI.addRGBPointLong(x, r, g, b, 0.5, 0.0); //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n\n\n  publicAPI.addRGBPointLong = function (x, r, g, b) {\n    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    } // remove any node already at this X location\n\n\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    } // Create the new node\n\n\n    const node = {\n      x,\n      r,\n      g,\n      b,\n      midpoint,\n      sharpness\n    }; // Add it, then sort to get everything in order\n\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange(); // We need to find the index of the node we just added in order\n    // to return this value\n\n    let i = 0;\n\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    } // If we didn't find it, something went horribly wrong so\n    // return -1\n\n\n    if (i < model.nodes.length) {\n      return i;\n    }\n\n    return -1;\n  }; //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n\n\n  publicAPI.addHSVPoint = (x, h, s, v) => publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0.0); //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n\n\n  publicAPI.addHSVPointLong = function (x, h, s, v) {\n    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n    const rgb = [];\n    const hsv = [h, s, v];\n    vtkMath.hsv2rgb(hsv, rgb);\n    return publicAPI.addRGBPoint(x, rgb[0], rgb[1], rgb[2], midpoint, sharpness);\n  }; //----------------------------------------------------------------------------\n  // Set nodes directly\n\n\n  publicAPI.setNodes = nodes => {\n    if (model.nodes !== nodes) {\n      const before = JSON.stringify(model.nodes);\n      model.nodes = nodes;\n      const after = JSON.stringify(model.nodes);\n\n      if (publicAPI.sortAndUpdateRange() || before !== after) {\n        publicAPI.modified();\n        return true;\n      }\n    }\n\n    return false;\n  }; //----------------------------------------------------------------------------\n  // Sort the vector in increasing order, then fill in\n  // the Range\n\n\n  publicAPI.sortAndUpdateRange = () => {\n    const before = JSON.stringify(model.nodes);\n    model.nodes.sort((a, b) => a.x - b.x);\n    const after = JSON.stringify(model.nodes);\n    const modifiedInvoked = publicAPI.updateRange(); // If range is updated, Modified() has been called, don't call it again.\n\n    if (!modifiedInvoked && before !== after) {\n      publicAPI.modified();\n      return true;\n    }\n\n    return modifiedInvoked;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.updateRange = () => {\n    const oldRange = [2];\n    oldRange[0] = model.mappingRange[0];\n    oldRange[1] = model.mappingRange[1];\n    const size = model.nodes.length;\n\n    if (size) {\n      model.mappingRange[0] = model.nodes[0].x;\n      model.mappingRange[1] = model.nodes[size - 1].x;\n    } else {\n      model.mappingRange[0] = 0;\n      model.mappingRange[1] = 0;\n    } // If the range is the same, then no need to call Modified()\n\n\n    if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {\n      return false;\n    }\n\n    publicAPI.modified();\n    return true;\n  }; //----------------------------------------------------------------------------\n  // Remove a point\n\n\n  publicAPI.removePoint = x => {\n    // First find the node since we need to know its\n    // index as our return value\n    let i = 0;\n\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    const retVal = i; // If the node doesn't exist, we return -1\n\n    if (i >= model.nodes.length) {\n      return -1;\n    } // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n\n\n    let modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n\n    return retVal;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.movePoint = (oldX, newX) => {\n    if (oldX === newX) {\n      // Nothing to do.\n      return;\n    }\n\n    publicAPI.removePoint(newX);\n\n    for (let i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === oldX) {\n        model.nodes[i].x = newX;\n        publicAPI.sortAndUpdateRange();\n        break;\n      }\n    }\n  }; //----------------------------------------------------------------------------\n  // Remove all points\n\n\n  publicAPI.removeAllPoints = () => {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  }; //----------------------------------------------------------------------------\n  // Add a line defined in RGB\n\n\n  publicAPI.addRGBSegment = (x1, r1, g1, b1, x2, r2, g2, b2) => {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    } // Now add the points\n\n\n    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0.0);\n    publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0.0);\n    publicAPI.modified();\n  }; //----------------------------------------------------------------------------\n  // Add a line defined in HSV\n\n\n  publicAPI.addHSVSegment = (x1, h1, s1, v1, x2, h2, s2, v2) => {\n    const hsv1 = [h1, s1, v1];\n    const hsv2 = [h2, s2, v2];\n    const rgb1 = [];\n    const rgb2 = [];\n    vtkMath.hsv2rgb(hsv1, rgb1);\n    vtkMath.hsv2rgb(hsv2, rgb2);\n    publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);\n  }; //----------------------------------------------------------------------------\n  // Returns the RGBA color evaluated at the specified location\n\n\n  publicAPI.mapValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return [Math.floor(255.0 * rgb[0] + 0.5), Math.floor(255.0 * rgb[1] + 0.5), Math.floor(255.0 * rgb[2] + 0.5), 255];\n  }; //----------------------------------------------------------------------------\n  // Returns the RGB color evaluated at the specified location\n\n\n  publicAPI.getColor = (x, rgb) => {\n    if (model.indexedLookup) {\n      const numNodes = publicAPI.getSize(); // todo\n\n      const idx = publicAPI.getAnnotatedValueIndexInternal(x);\n\n      if (idx < 0 || numNodes === 0) {\n        publicAPI.getNanColor(rgb);\n      } else {\n        const nodeVal = [];\n        publicAPI.getNodeValue(idx % numNodes, nodeVal);\n        rgb[0] = nodeVal.r;\n        rgb[1] = nodeVal.g;\n        rgb[2] = nodeVal.b;\n      }\n\n      return;\n    }\n\n    publicAPI.getTable(x, x, 1, rgb);\n  }; //----------------------------------------------------------------------------\n  // Returns the red color evaluated at the specified location\n\n\n  publicAPI.getRedValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[0];\n  }; //----------------------------------------------------------------------------\n  // Returns the green color evaluated at the specified location\n\n\n  publicAPI.getGreenValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[1];\n  }; //----------------------------------------------------------------------------\n  // Returns the blue color evaluated at the specified location\n\n\n  publicAPI.getBlueValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[2];\n  }; //----------------------------------------------------------------------------\n  // Returns a table of RGB colors at regular intervals along the function\n\n\n  publicAPI.getTable = (xStart, xEnd, size, table) => {\n    // Special case: If either the start or end is a NaN, then all any\n    // interpolation done on them is also a NaN.  Therefore, fill the table with\n    // the NaN color.\n    if (vtkMath.isNan(xStart) || vtkMath.isNan(xEnd)) {\n      for (let i = 0; i < size; i++) {\n        table[i * 3 + 0] = model.nanColor[0];\n        table[i * 3 + 1] = model.nanColor[1];\n        table[i * 3 + 2] = model.nanColor[2];\n      }\n\n      return;\n    }\n\n    let idx = 0;\n    const numNodes = model.nodes.length; // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n\n    let lastR = 0.0;\n    let lastG = 0.0;\n    let lastB = 0.0;\n\n    if (numNodes !== 0) {\n      lastR = model.nodes[numNodes - 1].r;\n      lastG = model.nodes[numNodes - 1].g;\n      lastB = model.nodes[numNodes - 1].b;\n    }\n\n    let x = 0.0;\n    let x1 = 0.0;\n    let x2 = 0.0;\n    const rgb1 = [0.0, 0.0, 0.0];\n    const rgb2 = [0.0, 0.0, 0.0];\n    let midpoint = 0.0;\n    let sharpness = 0.0;\n    const tmpVec = []; // If the scale is logarithmic, make sure the range is valid.\n\n    let usingLogScale = model.scale === Scale.LOG10;\n\n    if (usingLogScale) {\n      // Note: This requires range[0] <= range[1].\n      usingLogScale = model.mappingRange[0] > 0.0;\n    }\n\n    let logStart = 0.0;\n    let logEnd = 0.0;\n    let logX = 0.0;\n\n    if (usingLogScale) {\n      logStart = Math.log10(xStart);\n      logEnd = Math.log10(xEnd);\n    } // For each table entry\n\n\n    for (let i = 0; i < size; i++) {\n      // Find our location in the table\n      const tidx = 3 * i; // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n\n      if (size > 1) {\n        if (usingLogScale) {\n          logX = logStart + i / (size - 1.0) * (logEnd - logStart);\n          x = 10.0 ** logX;\n        } else {\n          x = xStart + i / (size - 1.0) * (xEnd - xStart);\n        }\n      } else if (usingLogScale) {\n        logX = 0.5 * (logStart + logEnd);\n        x = 10.0 ** logX;\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      } // Linearly map x from mappingRange to [0, numberOfValues-1],\n      // discretize (round down to the closest integer),\n      // then map back to mappingRange\n\n\n      if (model.discretize) {\n        const range = model.mappingRange;\n\n        if (x >= range[0] && x <= range[1]) {\n          const numberOfValues = model.numberOfValues;\n          const deltaRange = range[1] - range[0];\n\n          if (numberOfValues <= 1) {\n            x = range[0] + deltaRange / 2.0;\n          } else {\n            // normalize x\n            const xn = (x - range[0]) / deltaRange; // discretize\n\n            const discretizeIndex = vtkMath.floor(numberOfValues * xn); // get discretized x\n\n            x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;\n          }\n        }\n      } // Do we need to move to the next node?\n\n\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++; // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n\n          if (usingLogScale) {\n            x1 = Math.log10(x1);\n            x2 = Math.log10(x2);\n          }\n\n          rgb1[0] = model.nodes[idx - 1].r;\n          rgb2[0] = model.nodes[idx].r;\n          rgb1[1] = model.nodes[idx - 1].g;\n          rgb2[1] = model.nodes[idx].g;\n          rgb1[2] = model.nodes[idx - 1].b;\n          rgb2[2] = model.nodes[idx].b; // We only need the previous midpoint and sharpness\n          // since these control this region\n\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness; // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      } // Are we at or past the end? If so, just use the last value\n\n\n      if (x > model.mappingRange[1]) {\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n\n        if (model.clamping) {\n          if (publicAPI.getUseAboveRangeColor()) {\n            table[tidx] = model.aboveRangeColor[0];\n            table[tidx + 1] = model.aboveRangeColor[1];\n            table[tidx + 2] = model.aboveRangeColor[2];\n          } else {\n            table[tidx] = lastR;\n            table[tidx + 1] = lastG;\n            table[tidx + 2] = lastB;\n          }\n        }\n      } else if (x < model.mappingRange[0] || vtkMath.isInf(x) && x < 0) {\n        // we are before the first node? If so, duplicate this node's values.\n        // We have to deal with -inf here\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n\n        if (model.clamping) {\n          if (publicAPI.getUseBelowRangeColor()) {\n            table[tidx] = model.belowRangeColor[0];\n            table[tidx + 1] = model.belowRangeColor[1];\n            table[tidx + 2] = model.belowRangeColor[2];\n          } else if (numNodes > 0) {\n            table[tidx] = model.nodes[0].r;\n            table[tidx + 1] = model.nodes[0].g;\n            table[tidx + 2] = model.nodes[0].b;\n          }\n        }\n      } else if (idx === 0 && (Math.abs(x - xStart) < 1e-6 || model.discretize)) {\n        if (numNodes > 0) {\n          table[tidx] = model.nodes[0].r;\n          table[tidx + 1] = model.nodes[0].g;\n          table[tidx + 2] = model.nodes[0].b;\n        } else {\n          table[tidx] = 0.0;\n          table[tidx + 1] = 0.0;\n          table[tidx + 2] = 0.0;\n        }\n      } else {\n        // OK, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        let s = 0.0;\n\n        if (usingLogScale) {\n          s = (logX - x1) / (x2 - x1);\n        } else {\n          s = (x - x1) / (x2 - x1);\n        } // Readjust based on the midpoint - linear adjustment\n\n\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        } // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n\n\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = rgb1[0];\n            table[tidx + 1] = rgb1[1];\n            table[tidx + 2] = rgb1[2];\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = rgb2[0];\n            table[tidx + 1] = rgb2[1];\n            table[tidx + 2] = rgb2[2];\n            continue;\n          }\n        } // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n\n\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          if (model.colorSpace === ColorSpace.RGB) {\n            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];\n            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];\n            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];\n          } else if (model.colorSpace === ColorSpace.HSV) {\n            const hsv1 = [];\n            const hsv2 = [];\n            vtkMath.rgb2hsv(rgb1, hsv1);\n            vtkMath.rgb2hsv(rgb2, hsv2);\n\n            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n              if (hsv1[0] > hsv2[0]) {\n                hsv1[0] -= 1.0;\n              } else {\n                hsv2[0] -= 1.0;\n              }\n            }\n\n            const hsvTmp = [];\n            hsvTmp[0] = (1.0 - s) * hsv1[0] + s * hsv2[0];\n\n            if (hsvTmp[0] < 0.0) {\n              hsvTmp[0] += 1.0;\n            }\n\n            hsvTmp[1] = (1.0 - s) * hsv1[1] + s * hsv2[1];\n            hsvTmp[2] = (1.0 - s) * hsv1[2] + s * hsv2[2]; // Now convert this back to RGB\n\n            vtkMath.hsv2rgb(hsvTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.LAB) {\n            const lab1 = [];\n            const lab2 = [];\n            vtkMath.rgb2lab(rgb1, lab1);\n            vtkMath.rgb2lab(rgb2, lab2);\n            const labTmp = [];\n            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];\n            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];\n            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2]; // Now convert back to RGB\n\n            vtkMath.lab2rgb(labTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.DIVERGING) {\n            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else {\n            vtkErrorMacro('ColorSpace set to invalid value.', model.colorSpace);\n          }\n\n          continue;\n        } // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n\n\n        if (s < 0.5) {\n          s = 0.5 * (s * 2.0) ** (1.0 + 10.0 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10.0 * sharpness);\n        } // Compute some coefficients we will need for the hermite curve\n\n\n        const ss = s * s;\n        const sss = ss * s;\n        const h1 = 2.0 * sss - 3 * ss + 1;\n        const h2 = -2 * sss + 3 * ss;\n        const h3 = sss - 2 * ss + s;\n        const h4 = sss - ss;\n        let slope;\n        let t;\n\n        if (model.colorSpace === ColorSpace.RGB) {\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = rgb2[j] - rgb1[j];\n            t = (1.0 - sharpness) * slope; // Compute the value\n\n            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;\n          }\n        } else if (model.colorSpace === ColorSpace.HSV) {\n          const hsv1 = [];\n          const hsv2 = [];\n          vtkMath.rgb2hsv(rgb1, hsv1);\n          vtkMath.rgb2hsv(rgb2, hsv2);\n\n          if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n            if (hsv1[0] > hsv2[0]) {\n              hsv1[0] -= 1.0;\n            } else {\n              hsv2[0] -= 1.0;\n            }\n          }\n\n          const hsvTmp = [];\n\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = hsv2[j] - hsv1[j];\n            t = (1.0 - sharpness) * slope; // Compute the value\n\n            hsvTmp[j] = h1 * hsv1[j] + h2 * hsv2[j] + h3 * t + h4 * t;\n\n            if (j === 0 && hsvTmp[j] < 0.0) {\n              hsvTmp[j] += 1.0;\n            }\n          } // Now convert this back to RGB\n\n\n          vtkMath.hsv2rgb(hsvTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.LAB) {\n          const lab1 = [];\n          const lab2 = [];\n          vtkMath.rgb2lab(rgb1, lab1);\n          vtkMath.rgb2lab(rgb2, lab2);\n          const labTmp = [];\n\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = lab2[j] - lab1[j];\n            t = (1.0 - sharpness) * slope; // Compute the value\n\n            labTmp[j] = h1 * lab1[j] + h2 * lab2[j] + h3 * t + h4 * t;\n          } // Now convert this back to RGB\n\n\n          vtkMath.lab2rgb(labTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.DIVERGING) {\n          // I have not implemented proper interpolation by a hermite curve for\n          // the diverging color map, but I cannot think of a good use case for\n          // that anyway.\n          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else {\n          vtkErrorMacro('ColorSpace set to invalid value.');\n        } // Final error check to make sure we don't go outside [0,1]\n\n\n        for (let j = 0; j < 3; j++) {\n          table[tidx + j] = table[tidx + j] < 0.0 ? 0.0 : table[tidx + j];\n          table[tidx + j] = table[tidx + j] > 1.0 ? 1.0 : table[tidx + j];\n        }\n      }\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getUint8Table = function (xStart, xEnd, size) {\n    let withAlpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size && model.tableWithAlpha !== withAlpha) {\n      return model.table;\n    }\n\n    if (model.nodes.length === 0) {\n      vtkErrorMacro('Attempting to lookup a value with no points in the function');\n      return model.table;\n    }\n\n    const nbChannels = withAlpha ? 4 : 3;\n\n    if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {\n      model.table = new Uint8Array(size * nbChannels);\n      model.tableSize = size;\n      model.tableWithAlpha = withAlpha;\n    }\n\n    const tmpTable = [];\n    publicAPI.getTable(xStart, xEnd, size, tmpTable);\n\n    for (let i = 0; i < size; i++) {\n      model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255.0 + 0.5);\n      model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255.0 + 0.5);\n      model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255.0 + 0.5);\n\n      if (withAlpha) {\n        model.table[i * nbChannels + 3] = 255;\n      }\n    }\n\n    model.buildTime.modified();\n    return model.table;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.buildFunctionFromTable = (xStart, xEnd, size, table) => {\n    let inc = 0.0;\n    publicAPI.removeAllPoints();\n\n    if (size > 1) {\n      inc = (xEnd - xStart) / (size - 1.0);\n    }\n\n    for (let i = 0; i < size; i++) {\n      const node = {\n        x: xStart + inc * i,\n        r: table[i * 3],\n        g: table[i * 3 + 1],\n        b: table[i * 3 + 2],\n        sharpness: 0.0,\n        midpoint: 0.5\n      };\n      model.nodes.push(node);\n    }\n\n    publicAPI.sortAndUpdateRange();\n  }; //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n\n\n  publicAPI.getNodeValue = (index, val) => {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].r;\n    val[2] = model.nodes[index].g;\n    val[3] = model.nodes[index].b;\n    val[4] = model.nodes[index].midpoint;\n    val[5] = model.nodes[index].sharpness;\n    return 1;\n  }; //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n\n\n  publicAPI.setNodeValue = (index, val) => {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n\n    const oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].r = val[1];\n    model.nodes[index].g = val[2];\n    model.nodes[index].b = val[3];\n    model.nodes[index].midpoint = val[4];\n    model.nodes[index].sharpness = val[5];\n\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange(); // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n\n    return 1;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getNumberOfAvailableColors = () => {\n    if (model.indexedLookup && publicAPI.getSize()) {\n      return publicAPI.getSize();\n    }\n\n    if (model.tableSize) {\n      // Not sure if this is correct since it is only set if\n      // \"const unsigned char *::GetTable(double xStart, double xEnd,int size)\"\n      // has been called.\n      return model.tableSize;\n    }\n\n    return 16777216; // 2^24\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getIndexedColor = (idx, rgba) => {\n    const n = publicAPI.getSize();\n\n    if (n > 0 && idx >= 0) {\n      const nodeValue = [];\n      publicAPI.getNodeValue(idx % n, nodeValue);\n\n      for (let j = 0; j < 3; ++j) {\n        rgba[j] = nodeValue[j + 1];\n      }\n\n      rgba[3] = 1.0; // NodeColor is RGB-only.\n\n      return;\n    }\n\n    publicAPI.getNanColor(rgba);\n    rgba[3] = 1.0; // NanColor is RGB-only.\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.fillFromDataPointer = (nb, ptr) => {\n    if (nb <= 0 || !ptr) {\n      return;\n    }\n\n    publicAPI.removeAllPoints();\n\n    for (let i = 0; i < nb; i++) {\n      publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.setMappingRange = (min, max) => {\n    const range = [min, max];\n    const originalRange = publicAPI.getRange();\n\n    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {\n      return;\n    }\n\n    if (range[1] === range[0]) {\n      vtkErrorMacro('attempt to set zero width color range');\n      return;\n    }\n\n    const scale = (range[1] - range[0]) / (originalRange[1] - originalRange[0]);\n    const shift = range[0] - originalRange[0] * scale;\n\n    for (let i = 0; i < model.nodes.length; ++i) {\n      model.nodes[i].x = model.nodes[i].x * scale + shift;\n    }\n\n    model.mappingRange[0] = range[0];\n    model.mappingRange[1] = range[1];\n    publicAPI.modified();\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.adjustRange = range => {\n    const functionRange = publicAPI.getRange(); // Make sure we have points at each end of the range\n\n    const rgb = [];\n\n    if (functionRange[0] < range[0]) {\n      publicAPI.getColor(range[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    }\n\n    if (functionRange[1] > range[1]) {\n      publicAPI.getColor(range[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    } // Remove all points out-of-range\n\n\n    publicAPI.sortAndUpdateRange();\n\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n\n    return 1;\n  }; //--------------------------------------------------------------------------\n\n\n  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {\n    const d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.findMinimumXDistance = () => {\n    if (model.nodes.length < 2) {\n      return -1.0;\n    }\n\n    let distance = Number.MAX_VALUE;\n\n    for (let i = 0; i < model.nodes.length - 1; i++) {\n      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n\n    return distance;\n  };\n\n  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {\n    if (publicAPI.getSize() === 0) {\n      vtkDebugMacro('Transfer Function Has No Points!');\n      return;\n    }\n\n    if (model.indexedLookup) {\n      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);\n    } else {\n      publicAPI.mapData(input, output, outFormat, inputOffset);\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.mapData = (input, output, outFormat, inputOffset) => {\n    if (publicAPI.getSize() === 0) {\n      vtkWarningMacro('Transfer Function Has No Points!');\n      return;\n    }\n\n    const alpha = Math.floor(publicAPI.getAlpha() * 255.0 + 0.5);\n    const length = input.getNumberOfTuples();\n    const inIncr = input.getNumberOfComponents();\n    const outputV = output.getData();\n    const inputV = input.getData();\n    const rgb = [];\n\n    if (outFormat === ScalarMappingTarget.RGBA) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 4] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n        outputV[i * 4 + 3] = alpha;\n      }\n    }\n\n    if (outFormat === ScalarMappingTarget.RGB) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 3] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 3 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 3 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n      }\n    }\n\n    if (outFormat === ScalarMappingTarget.LUMINANCE) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n      }\n    }\n\n    if (outFormat === ScalarMappingTarget.LUMINANCE_ALPHA) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 2] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n        outputV[i * 2 + 1] = alpha;\n      }\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.applyColorMap = colorMap => {\n    if (colorMap.ColorSpace) {\n      model.colorSpace = ColorSpace[colorMap.ColorSpace.toUpperCase()];\n\n      if (model.colorSpace === undefined) {\n        vtkErrorMacro(`ColorSpace ${colorMap.ColorSpace} not supported, using RGB instead`);\n        model.colorSpace = ColorSpace.RGB;\n      }\n    }\n\n    if (colorMap.NanColor) {\n      model.nanColor = [].concat(colorMap.NanColor);\n\n      while (model.nanColor.length < 4) {\n        model.nanColor.push(1.0);\n      }\n    }\n\n    if (colorMap.RGBPoints) {\n      const size = colorMap.RGBPoints.length;\n      model.nodes = [];\n      const midpoint = 0.5;\n      const sharpness = 0.0;\n\n      for (let i = 0; i < size; i += 4) {\n        model.nodes.push({\n          x: colorMap.RGBPoints[i],\n          r: colorMap.RGBPoints[i + 1],\n          g: colorMap.RGBPoints[i + 2],\n          b: colorMap.RGBPoints[i + 3],\n          midpoint,\n          sharpness\n        });\n      }\n    } // FIXME: not supported ?\n    // if (colorMap.IndexedColors) {\n    // }\n    // if (colorMap.Annotations) {\n    // }\n\n\n    publicAPI.sortAndUpdateRange();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  clamping: true,\n  colorSpace: ColorSpace.RGB,\n  hSVWrap: true,\n  scale: Scale.LINEAR,\n  nanColor: null,\n  belowRangeColor: null,\n  aboveRangeColor: null,\n  useAboveRangeColor: false,\n  useBelowRangeColor: false,\n  allowDuplicateScalars: false,\n  table: null,\n  tableSize: 0,\n  buildTime: null,\n  nodes: null,\n  discretize: false,\n  numberOfValues: 256\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkScalarsToColors.extend(publicAPI, model, initialValues); // Internal objects initialization\n\n  model.table = [];\n  model.nodes = [];\n  model.nanColor = [0.5, 0.0, 0.0, 1.0];\n  model.belowRangeColor = [0.0, 0.0, 0.0, 1.0];\n  model.aboveRangeColor = [1.0, 1.0, 1.0, 1.0];\n  model.buildTime = {};\n  macro.obj(model.buildTime); // Create get-only macros\n\n  macro.get(publicAPI, model, ['buildTime', 'mappingRange']); // Create get-set macros\n\n  macro.setGet(publicAPI, model, ['useAboveRangeColor', 'useBelowRangeColor', 'colorSpace', 'discretize', 'numberOfValues']);\n  macro.setArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor'], 4); // Create get macros for array\n\n  macro.getArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkColorTransferFunction(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkColorTransferFunction'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend,\n  ...Constants\n};","map":{"version":3,"names":["macro","vtkMath","vtkScalarsToColors","Constants","ColorSpace","Scale","ScalarMappingTarget","vtkDebugMacro","vtkErrorMacro","vtkWarningMacro","vtkColorTransferFunctionLabToMsh","lab","msh","L","a","b","M","Math","sqrt","s","acos","h","atan2","vtkColorTransferFunctionMshToLab","cos","sin","vtkColorTransferFunctionAdjustHue","unsatM","hueSpin","PI","vtkColorTransferFunctionAngleDiff","a1","a2","adiff","vtkColorTransferFunctionInterpolateDiverging","rgb1","rgb2","result","lab1","lab2","rgb2lab","msh1","msh2","localS","Mmid","max","mshTmp","labTmp","lab2rgb","vtkColorTransferFunction","publicAPI","model","classHierarchy","push","getSize","nodes","length","addRGBPoint","x","r","g","addRGBPointLong","midpoint","sharpness","allowDuplicateScalars","removePoint","node","sortAndUpdateRange","i","addHSVPoint","v","addHSVPointLong","rgb","hsv","hsv2rgb","setNodes","before","JSON","stringify","after","modified","sort","modifiedInvoked","updateRange","oldRange","mappingRange","size","retVal","splice","movePoint","oldX","newX","removeAllPoints","addRGBSegment","x1","r1","g1","b1","x2","r2","g2","b2","addHSVSegment","h1","s1","v1","h2","s2","v2","hsv1","hsv2","mapValue","getColor","floor","indexedLookup","numNodes","idx","getAnnotatedValueIndexInternal","getNanColor","nodeVal","getNodeValue","getTable","getRedValue","getGreenValue","getBlueValue","xStart","xEnd","table","isNan","nanColor","lastR","lastG","lastB","tmpVec","usingLogScale","scale","LOG10","logStart","logEnd","logX","log10","tidx","discretize","range","numberOfValues","deltaRange","xn","discretizeIndex","clamping","getUseAboveRangeColor","aboveRangeColor","isInf","getUseBelowRangeColor","belowRangeColor","abs","colorSpace","RGB","HSV","rgb2hsv","hSVWrap","hsvTmp","LAB","DIVERGING","ss","sss","h3","h4","slope","t","j","getUint8Table","withAlpha","getMTime","buildTime","tableSize","tableWithAlpha","nbChannels","Uint8Array","tmpTable","buildFunctionFromTable","inc","index","val","setNodeValue","getNumberOfAvailableColors","getIndexedColor","rgba","n","nodeValue","fillFromDataPointer","nb","ptr","setMappingRange","min","originalRange","getRange","shift","adjustRange","functionRange","estimateMinNumberOfSamples","d","findMinimumXDistance","ceil","distance","Number","MAX_VALUE","currentDist","mapScalarsThroughTable","input","output","outFormat","inputOffset","mapDataIndexed","mapData","alpha","getAlpha","getNumberOfTuples","inIncr","getNumberOfComponents","outputV","getData","inputV","RGBA","LUMINANCE","LUMINANCE_ALPHA","applyColorMap","colorMap","toUpperCase","undefined","NanColor","concat","RGBPoints","DEFAULT_VALUES","LINEAR","useAboveRangeColor","useBelowRangeColor","extend","initialValues","Object","assign","obj","get","setGet","setArray","getArray","newInstance"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/Core/ColorTransferFunction/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkScalarsToColors from 'vtk.js/Sources/Common/Core/ScalarsToColors';\nimport Constants from 'vtk.js/Sources/Rendering/Core/ColorTransferFunction/Constants';\n\nconst { ColorSpace, Scale } = Constants;\nconst { ScalarMappingTarget } = vtkScalarsToColors;\nconst { vtkDebugMacro, vtkErrorMacro, vtkWarningMacro } = macro;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n/* eslint-disable no-continue                                                */\n\n// Convert to and from a special polar version of CIELAB (useful for creating\n// continuous diverging color maps).\nfunction vtkColorTransferFunctionLabToMsh(lab, msh) {\n  const L = lab[0];\n  const a = lab[1];\n  const b = lab[2];\n  const M = Math.sqrt(L * L + a * a + b * b);\n  const s = M > 0.001 ? Math.acos(L / M) : 0.0;\n  const h = s > 0.001 ? Math.atan2(b, a) : 0.0;\n  msh[0] = M;\n  msh[1] = s;\n  msh[2] = h;\n}\n\nfunction vtkColorTransferFunctionMshToLab(msh, lab) {\n  const M = msh[0];\n  const s = msh[1];\n  const h = msh[2];\n\n  lab[0] = M * Math.cos(s);\n  lab[1] = M * Math.sin(s) * Math.cos(h);\n  lab[2] = M * Math.sin(s) * Math.sin(h);\n}\n\n// For the case when interpolating from a saturated color to an unsaturated\n// color, find a hue for the unsaturated color that makes sense.\nfunction vtkColorTransferFunctionAdjustHue(msh, unsatM) {\n  if (msh[0] >= unsatM - 0.1) {\n    // The best we can do is hold hue constant.\n    return msh[2];\n  }\n\n  // This equation is designed to make the perceptual change of the\n  // interpolation to be close to constant.\n  const hueSpin =\n    (msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0])) /\n    (msh[0] * Math.sin(msh[1]));\n  // Spin hue away from 0 except in purple hues.\n  if (msh[2] > -0.3 * Math.PI) {\n    return msh[2] + hueSpin;\n  }\n\n  return msh[2] - hueSpin;\n}\n\nfunction vtkColorTransferFunctionAngleDiff(a1, a2) {\n  let adiff = a1 - a2;\n  if (adiff < 0.0) {\n    adiff = -adiff;\n  }\n  while (adiff >= 2.0 * Math.PI) {\n    adiff -= 2.0 * Math.PI;\n  }\n  if (adiff > Math.PI) {\n    adiff = 2.0 * Math.PI - adiff;\n  }\n  return adiff;\n}\n\n// Interpolate a diverging color map.\nfunction vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {\n  const lab1 = [];\n  const lab2 = [];\n  vtkMath.rgb2lab(rgb1, lab1);\n  vtkMath.rgb2lab(rgb2, lab2);\n\n  const msh1 = [];\n  const msh2 = [];\n  vtkColorTransferFunctionLabToMsh(lab1, msh1);\n  vtkColorTransferFunctionLabToMsh(lab2, msh2);\n\n  // If the endpoints are distinct saturated colors, then place white in between\n  // them.\n  let localS = s;\n  if (\n    msh1[1] > 0.05 &&\n    msh2[1] > 0.05 &&\n    vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI\n  ) {\n    // Insert the white midpoint by setting one end to white and adjusting the\n    // scalar value.\n    let Mmid = Math.max(msh1[0], msh2[0]);\n    Mmid = Math.max(88.0, Mmid);\n    if (s < 0.5) {\n      msh2[0] = Mmid;\n      msh2[1] = 0.0;\n      msh2[2] = 0.0;\n      localS *= 2.0;\n    } else {\n      msh1[0] = Mmid;\n      msh1[1] = 0.0;\n      msh1[2] = 0.0;\n      localS = 2.0 * localS - 1.0;\n    }\n  }\n\n  // If one color has no saturation, then its hue value is invalid.  In this\n  // case, we want to set it to something logical so that the interpolation of\n  // hue makes sense.\n  if (msh1[1] < 0.05 && msh2[1] > 0.05) {\n    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);\n  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {\n    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);\n  }\n\n  const mshTmp = [];\n  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];\n  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];\n  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2];\n\n  // Now convert back to RGB\n  const labTmp = [];\n  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);\n  vtkMath.lab2rgb(labTmp, result);\n}\n\n// ----------------------------------------------------------------------------\n// vtkColorTransferFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkColorTransferFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkColorTransferFunction');\n\n  // Return the number of points which specify this function\n  publicAPI.getSize = () => model.nodes.length;\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n  publicAPI.addRGBPoint = (x, r, g, b) =>\n    publicAPI.addRGBPointLong(x, r, g, b, 0.5, 0.0);\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n  publicAPI.addRGBPointLong = (x, r, g, b, midpoint = 0.5, sharpness = 0.0) => {\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    // remove any node already at this X location\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    }\n\n    // Create the new node\n    const node = { x, r, g, b, midpoint, sharpness };\n\n    // Add it, then sort to get everything in order\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange();\n\n    // We need to find the index of the node we just added in order\n    // to return this value\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If we didn't find it, something went horribly wrong so\n    // return -1\n    if (i < model.nodes.length) {\n      return i;\n    }\n\n    return -1;\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n  publicAPI.addHSVPoint = (x, h, s, v) =>\n    publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0.0);\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n  publicAPI.addHSVPointLong = (x, h, s, v, midpoint = 0.5, sharpness = 0.0) => {\n    const rgb = [];\n    const hsv = [h, s, v];\n\n    vtkMath.hsv2rgb(hsv, rgb);\n    return publicAPI.addRGBPoint(\n      x,\n      rgb[0],\n      rgb[1],\n      rgb[2],\n      midpoint,\n      sharpness\n    );\n  };\n\n  //----------------------------------------------------------------------------\n  // Set nodes directly\n  publicAPI.setNodes = (nodes) => {\n    if (model.nodes !== nodes) {\n      const before = JSON.stringify(model.nodes);\n      model.nodes = nodes;\n      const after = JSON.stringify(model.nodes);\n      if (publicAPI.sortAndUpdateRange() || before !== after) {\n        publicAPI.modified();\n        return true;\n      }\n    }\n    return false;\n  };\n\n  //----------------------------------------------------------------------------\n  // Sort the vector in increasing order, then fill in\n  // the Range\n  publicAPI.sortAndUpdateRange = () => {\n    const before = JSON.stringify(model.nodes);\n    model.nodes.sort((a, b) => a.x - b.x);\n    const after = JSON.stringify(model.nodes);\n\n    const modifiedInvoked = publicAPI.updateRange();\n    // If range is updated, Modified() has been called, don't call it again.\n    if (!modifiedInvoked && before !== after) {\n      publicAPI.modified();\n      return true;\n    }\n    return modifiedInvoked;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.updateRange = () => {\n    const oldRange = [2];\n    oldRange[0] = model.mappingRange[0];\n    oldRange[1] = model.mappingRange[1];\n\n    const size = model.nodes.length;\n    if (size) {\n      model.mappingRange[0] = model.nodes[0].x;\n      model.mappingRange[1] = model.nodes[size - 1].x;\n    } else {\n      model.mappingRange[0] = 0;\n      model.mappingRange[1] = 0;\n    }\n\n    // If the range is the same, then no need to call Modified()\n    if (\n      oldRange[0] === model.mappingRange[0] &&\n      oldRange[1] === model.mappingRange[1]\n    ) {\n      return false;\n    }\n\n    publicAPI.modified();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  // Remove a point\n  publicAPI.removePoint = (x) => {\n    // First find the node since we need to know its\n    // index as our return value\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    const retVal = i;\n\n    // If the node doesn't exist, we return -1\n    if (i >= model.nodes.length) {\n      return -1;\n    }\n\n    // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n    let modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n\n    return retVal;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.movePoint = (oldX, newX) => {\n    if (oldX === newX) {\n      // Nothing to do.\n      return;\n    }\n\n    publicAPI.removePoint(newX);\n    for (let i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === oldX) {\n        model.nodes[i].x = newX;\n        publicAPI.sortAndUpdateRange();\n        break;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  // Remove all points\n  publicAPI.removeAllPoints = () => {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a line defined in RGB\n  publicAPI.addRGBSegment = (x1, r1, g1, b1, x2, r2, g2, b2) => {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length; ) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Now add the points\n    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0.0);\n    publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0.0);\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a line defined in HSV\n  publicAPI.addHSVSegment = (x1, h1, s1, v1, x2, h2, s2, v2) => {\n    const hsv1 = [h1, s1, v1];\n    const hsv2 = [h2, s2, v2];\n    const rgb1 = [];\n    const rgb2 = [];\n\n    vtkMath.hsv2rgb(hsv1, rgb1);\n    vtkMath.hsv2rgb(hsv2, rgb2);\n    publicAPI.addRGBSegment(\n      x1,\n      rgb1[0],\n      rgb1[1],\n      rgb1[2],\n      x2,\n      rgb2[0],\n      rgb2[1],\n      rgb2[2]\n    );\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the RGBA color evaluated at the specified location\n  publicAPI.mapValue = (x) => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n\n    return [\n      Math.floor(255.0 * rgb[0] + 0.5),\n      Math.floor(255.0 * rgb[1] + 0.5),\n      Math.floor(255.0 * rgb[2] + 0.5),\n      255,\n    ];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the RGB color evaluated at the specified location\n  publicAPI.getColor = (x, rgb) => {\n    if (model.indexedLookup) {\n      const numNodes = publicAPI.getSize();\n      // todo\n      const idx = publicAPI.getAnnotatedValueIndexInternal(x);\n      if (idx < 0 || numNodes === 0) {\n        publicAPI.getNanColor(rgb);\n      } else {\n        const nodeVal = [];\n        publicAPI.getNodeValue(idx % numNodes, nodeVal);\n        rgb[0] = nodeVal.r;\n        rgb[1] = nodeVal.g;\n        rgb[2] = nodeVal.b;\n      }\n      return;\n    }\n    publicAPI.getTable(x, x, 1, rgb);\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the red color evaluated at the specified location\n  publicAPI.getRedValue = (x) => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[0];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the green color evaluated at the specified location\n  publicAPI.getGreenValue = (x) => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[1];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the blue color evaluated at the specified location\n  publicAPI.getBlueValue = (x) => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[2];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns a table of RGB colors at regular intervals along the function\n  publicAPI.getTable = (xStart, xEnd, size, table) => {\n    // Special case: If either the start or end is a NaN, then all any\n    // interpolation done on them is also a NaN.  Therefore, fill the table with\n    // the NaN color.\n    if (vtkMath.isNan(xStart) || vtkMath.isNan(xEnd)) {\n      for (let i = 0; i < size; i++) {\n        table[i * 3 + 0] = model.nanColor[0];\n        table[i * 3 + 1] = model.nanColor[1];\n        table[i * 3 + 2] = model.nanColor[2];\n      }\n      return;\n    }\n\n    let idx = 0;\n    const numNodes = model.nodes.length;\n\n    // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n    let lastR = 0.0;\n    let lastG = 0.0;\n    let lastB = 0.0;\n    if (numNodes !== 0) {\n      lastR = model.nodes[numNodes - 1].r;\n      lastG = model.nodes[numNodes - 1].g;\n      lastB = model.nodes[numNodes - 1].b;\n    }\n\n    let x = 0.0;\n    let x1 = 0.0;\n    let x2 = 0.0;\n    const rgb1 = [0.0, 0.0, 0.0];\n    const rgb2 = [0.0, 0.0, 0.0];\n    let midpoint = 0.0;\n    let sharpness = 0.0;\n\n    const tmpVec = [];\n\n    // If the scale is logarithmic, make sure the range is valid.\n    let usingLogScale = model.scale === Scale.LOG10;\n    if (usingLogScale) {\n      // Note: This requires range[0] <= range[1].\n      usingLogScale = model.mappingRange[0] > 0.0;\n    }\n\n    let logStart = 0.0;\n    let logEnd = 0.0;\n    let logX = 0.0;\n    if (usingLogScale) {\n      logStart = Math.log10(xStart);\n      logEnd = Math.log10(xEnd);\n    }\n\n    // For each table entry\n    for (let i = 0; i < size; i++) {\n      // Find our location in the table\n      const tidx = 3 * i;\n\n      // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n      if (size > 1) {\n        if (usingLogScale) {\n          logX = logStart + (i / (size - 1.0)) * (logEnd - logStart);\n          x = 10.0 ** logX;\n        } else {\n          x = xStart + (i / (size - 1.0)) * (xEnd - xStart);\n        }\n      } else if (usingLogScale) {\n        logX = 0.5 * (logStart + logEnd);\n        x = 10.0 ** logX;\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      }\n\n      // Linearly map x from mappingRange to [0, numberOfValues-1],\n      // discretize (round down to the closest integer),\n      // then map back to mappingRange\n      if (model.discretize) {\n        const range = model.mappingRange;\n        if (x >= range[0] && x <= range[1]) {\n          const numberOfValues = model.numberOfValues;\n          const deltaRange = range[1] - range[0];\n          if (numberOfValues <= 1) {\n            x = range[0] + deltaRange / 2.0;\n          } else {\n            // normalize x\n            const xn = (x - range[0]) / deltaRange;\n            // discretize\n            const discretizeIndex = vtkMath.floor(numberOfValues * xn);\n            // get discretized x\n            x =\n              range[0] + (discretizeIndex / (numberOfValues - 1)) * deltaRange;\n          }\n        }\n      }\n\n      // Do we need to move to the next node?\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++;\n        // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n          if (usingLogScale) {\n            x1 = Math.log10(x1);\n            x2 = Math.log10(x2);\n          }\n\n          rgb1[0] = model.nodes[idx - 1].r;\n          rgb2[0] = model.nodes[idx].r;\n\n          rgb1[1] = model.nodes[idx - 1].g;\n          rgb2[1] = model.nodes[idx].g;\n\n          rgb1[2] = model.nodes[idx - 1].b;\n          rgb2[2] = model.nodes[idx].b;\n\n          // We only need the previous midpoint and sharpness\n          // since these control this region\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness;\n\n          // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      }\n\n      // Are we at or past the end? If so, just use the last value\n      if (x > model.mappingRange[1]) {\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n        if (model.clamping) {\n          if (publicAPI.getUseAboveRangeColor()) {\n            table[tidx] = model.aboveRangeColor[0];\n            table[tidx + 1] = model.aboveRangeColor[1];\n            table[tidx + 2] = model.aboveRangeColor[2];\n          } else {\n            table[tidx] = lastR;\n            table[tidx + 1] = lastG;\n            table[tidx + 2] = lastB;\n          }\n        }\n      } else if (x < model.mappingRange[0] || (vtkMath.isInf(x) && x < 0)) {\n        // we are before the first node? If so, duplicate this node's values.\n        // We have to deal with -inf here\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n        if (model.clamping) {\n          if (publicAPI.getUseBelowRangeColor()) {\n            table[tidx] = model.belowRangeColor[0];\n            table[tidx + 1] = model.belowRangeColor[1];\n            table[tidx + 2] = model.belowRangeColor[2];\n          } else if (numNodes > 0) {\n            table[tidx] = model.nodes[0].r;\n            table[tidx + 1] = model.nodes[0].g;\n            table[tidx + 2] = model.nodes[0].b;\n          }\n        }\n      } else if (\n        idx === 0 &&\n        (Math.abs(x - xStart) < 1e-6 || model.discretize)\n      ) {\n        if (numNodes > 0) {\n          table[tidx] = model.nodes[0].r;\n          table[tidx + 1] = model.nodes[0].g;\n          table[tidx + 2] = model.nodes[0].b;\n        } else {\n          table[tidx] = 0.0;\n          table[tidx + 1] = 0.0;\n          table[tidx + 2] = 0.0;\n        }\n      } else {\n        // OK, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        let s = 0.0;\n        if (usingLogScale) {\n          s = (logX - x1) / (x2 - x1);\n        } else {\n          s = (x - x1) / (x2 - x1);\n        }\n\n        // Readjust based on the midpoint - linear adjustment\n        if (s < midpoint) {\n          s = (0.5 * s) / midpoint;\n        } else {\n          s = 0.5 + (0.5 * (s - midpoint)) / (1.0 - midpoint);\n        }\n\n        // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = rgb1[0];\n            table[tidx + 1] = rgb1[1];\n            table[tidx + 2] = rgb1[2];\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = rgb2[0];\n            table[tidx + 1] = rgb2[1];\n            table[tidx + 2] = rgb2[2];\n            continue;\n          }\n        }\n\n        // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          if (model.colorSpace === ColorSpace.RGB) {\n            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];\n            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];\n            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];\n          } else if (model.colorSpace === ColorSpace.HSV) {\n            const hsv1 = [];\n            const hsv2 = [];\n            vtkMath.rgb2hsv(rgb1, hsv1);\n            vtkMath.rgb2hsv(rgb2, hsv2);\n\n            if (\n              model.hSVWrap &&\n              (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)\n            ) {\n              if (hsv1[0] > hsv2[0]) {\n                hsv1[0] -= 1.0;\n              } else {\n                hsv2[0] -= 1.0;\n              }\n            }\n\n            const hsvTmp = [];\n            hsvTmp[0] = (1.0 - s) * hsv1[0] + s * hsv2[0];\n            if (hsvTmp[0] < 0.0) {\n              hsvTmp[0] += 1.0;\n            }\n            hsvTmp[1] = (1.0 - s) * hsv1[1] + s * hsv2[1];\n            hsvTmp[2] = (1.0 - s) * hsv1[2] + s * hsv2[2];\n\n            // Now convert this back to RGB\n            vtkMath.hsv2rgb(hsvTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.LAB) {\n            const lab1 = [];\n            const lab2 = [];\n            vtkMath.rgb2lab(rgb1, lab1);\n            vtkMath.rgb2lab(rgb2, lab2);\n\n            const labTmp = [];\n            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];\n            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];\n            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2];\n\n            // Now convert back to RGB\n            vtkMath.lab2rgb(labTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.DIVERGING) {\n            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else {\n            vtkErrorMacro('ColorSpace set to invalid value.', model.colorSpace);\n          }\n          continue;\n        }\n\n        // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n        if (s < 0.5) {\n          s = 0.5 * (s * 2.0) ** (1.0 + 10.0 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10.0 * sharpness);\n        }\n\n        // Compute some coefficients we will need for the hermite curve\n        const ss = s * s;\n        const sss = ss * s;\n\n        const h1 = 2.0 * sss - 3 * ss + 1;\n        const h2 = -2 * sss + 3 * ss;\n        const h3 = sss - 2 * ss + s;\n        const h4 = sss - ss;\n\n        let slope;\n        let t;\n\n        if (model.colorSpace === ColorSpace.RGB) {\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = rgb2[j] - rgb1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;\n          }\n        } else if (model.colorSpace === ColorSpace.HSV) {\n          const hsv1 = [];\n          const hsv2 = [];\n          vtkMath.rgb2hsv(rgb1, hsv1);\n          vtkMath.rgb2hsv(rgb2, hsv2);\n\n          if (\n            model.hSVWrap &&\n            (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)\n          ) {\n            if (hsv1[0] > hsv2[0]) {\n              hsv1[0] -= 1.0;\n            } else {\n              hsv2[0] -= 1.0;\n            }\n          }\n\n          const hsvTmp = [];\n\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = hsv2[j] - hsv1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            hsvTmp[j] = h1 * hsv1[j] + h2 * hsv2[j] + h3 * t + h4 * t;\n            if (j === 0 && hsvTmp[j] < 0.0) {\n              hsvTmp[j] += 1.0;\n            }\n          }\n          // Now convert this back to RGB\n          vtkMath.hsv2rgb(hsvTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.LAB) {\n          const lab1 = [];\n          const lab2 = [];\n          vtkMath.rgb2lab(rgb1, lab1);\n          vtkMath.rgb2lab(rgb2, lab2);\n\n          const labTmp = [];\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = lab2[j] - lab1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            labTmp[j] = h1 * lab1[j] + h2 * lab2[j] + h3 * t + h4 * t;\n          }\n          // Now convert this back to RGB\n          vtkMath.lab2rgb(labTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.DIVERGING) {\n          // I have not implemented proper interpolation by a hermite curve for\n          // the diverging color map, but I cannot think of a good use case for\n          // that anyway.\n          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else {\n          vtkErrorMacro('ColorSpace set to invalid value.');\n        }\n\n        // Final error check to make sure we don't go outside [0,1]\n        for (let j = 0; j < 3; j++) {\n          table[tidx + j] = table[tidx + j] < 0.0 ? 0.0 : table[tidx + j];\n          table[tidx + j] = table[tidx + j] > 1.0 ? 1.0 : table[tidx + j];\n        }\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getUint8Table = (xStart, xEnd, size, withAlpha = false) => {\n    if (\n      publicAPI.getMTime() <= model.buildTime &&\n      model.tableSize === size &&\n      model.tableWithAlpha !== withAlpha\n    ) {\n      return model.table;\n    }\n\n    if (model.nodes.length === 0) {\n      vtkErrorMacro(\n        'Attempting to lookup a value with no points in the function'\n      );\n      return model.table;\n    }\n\n    const nbChannels = withAlpha ? 4 : 3;\n    if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {\n      model.table = new Uint8Array(size * nbChannels);\n      model.tableSize = size;\n      model.tableWithAlpha = withAlpha;\n    }\n\n    const tmpTable = [];\n    publicAPI.getTable(xStart, xEnd, size, tmpTable);\n\n    for (let i = 0; i < size; i++) {\n      model.table[i * nbChannels + 0] = Math.floor(\n        tmpTable[i * 3 + 0] * 255.0 + 0.5\n      );\n      model.table[i * nbChannels + 1] = Math.floor(\n        tmpTable[i * 3 + 1] * 255.0 + 0.5\n      );\n      model.table[i * nbChannels + 2] = Math.floor(\n        tmpTable[i * 3 + 2] * 255.0 + 0.5\n      );\n      if (withAlpha) {\n        model.table[i * nbChannels + 3] = 255;\n      }\n    }\n\n    model.buildTime.modified();\n    return model.table;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.buildFunctionFromTable = (xStart, xEnd, size, table) => {\n    let inc = 0.0;\n\n    publicAPI.removeAllPoints();\n\n    if (size > 1) {\n      inc = (xEnd - xStart) / (size - 1.0);\n    }\n\n    for (let i = 0; i < size; i++) {\n      const node = {\n        x: xStart + inc * i,\n        r: table[i * 3],\n        g: table[i * 3 + 1],\n        b: table[i * 3 + 2],\n        sharpness: 0.0,\n        midpoint: 0.5,\n      };\n      model.nodes.push(node);\n    }\n\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n  publicAPI.getNodeValue = (index, val) => {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].r;\n    val[2] = model.nodes[index].g;\n    val[3] = model.nodes[index].b;\n    val[4] = model.nodes[index].midpoint;\n    val[5] = model.nodes[index].sharpness;\n\n    return 1;\n  };\n\n  //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n  publicAPI.setNodeValue = (index, val) => {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n\n    const oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].r = val[1];\n    model.nodes[index].g = val[2];\n    model.nodes[index].b = val[3];\n    model.nodes[index].midpoint = val[4];\n    model.nodes[index].sharpness = val[5];\n\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange();\n      // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n\n    return 1;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getNumberOfAvailableColors = () => {\n    if (model.indexedLookup && publicAPI.getSize()) {\n      return publicAPI.getSize();\n    }\n    if (model.tableSize) {\n      // Not sure if this is correct since it is only set if\n      // \"const unsigned char *::GetTable(double xStart, double xEnd,int size)\"\n      // has been called.\n      return model.tableSize;\n    }\n    return 16777216; // 2^24\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getIndexedColor = (idx, rgba) => {\n    const n = publicAPI.getSize();\n    if (n > 0 && idx >= 0) {\n      const nodeValue = [];\n      publicAPI.getNodeValue(idx % n, nodeValue);\n      for (let j = 0; j < 3; ++j) {\n        rgba[j] = nodeValue[j + 1];\n      }\n      rgba[3] = 1.0; // NodeColor is RGB-only.\n      return;\n    }\n    publicAPI.getNanColor(rgba);\n    rgba[3] = 1.0; // NanColor is RGB-only.\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.fillFromDataPointer = (nb, ptr) => {\n    if (nb <= 0 || !ptr) {\n      return;\n    }\n\n    publicAPI.removeAllPoints();\n\n    for (let i = 0; i < nb; i++) {\n      publicAPI.addRGBPoint(\n        ptr[i * 4],\n        ptr[i * 4 + 1],\n        ptr[i * 4 + 2],\n        ptr[i * 4 + 3]\n      );\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.setMappingRange = (min, max) => {\n    const range = [min, max];\n    const originalRange = publicAPI.getRange();\n    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {\n      return;\n    }\n\n    if (range[1] === range[0]) {\n      vtkErrorMacro('attempt to set zero width color range');\n      return;\n    }\n\n    const scale = (range[1] - range[0]) / (originalRange[1] - originalRange[0]);\n    const shift = range[0] - originalRange[0] * scale;\n\n    for (let i = 0; i < model.nodes.length; ++i) {\n      model.nodes[i].x = model.nodes[i].x * scale + shift;\n    }\n\n    model.mappingRange[0] = range[0];\n    model.mappingRange[1] = range[1];\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.adjustRange = (range) => {\n    const functionRange = publicAPI.getRange();\n\n    // Make sure we have points at each end of the range\n    const rgb = [];\n    if (functionRange[0] < range[0]) {\n      publicAPI.getColor(range[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    }\n\n    if (functionRange[1] > range[1]) {\n      publicAPI.getColor(range[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    }\n\n    // Remove all points out-of-range\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length; ) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n\n    return 1;\n  };\n\n  //--------------------------------------------------------------------------\n  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {\n    const d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.findMinimumXDistance = () => {\n    if (model.nodes.length < 2) {\n      return -1.0;\n    }\n\n    let distance = Number.MAX_VALUE;\n    for (let i = 0; i < model.nodes.length - 1; i++) {\n      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n\n    return distance;\n  };\n\n  publicAPI.mapScalarsThroughTable = (\n    input,\n    output,\n    outFormat,\n    inputOffset\n  ) => {\n    if (publicAPI.getSize() === 0) {\n      vtkDebugMacro('Transfer Function Has No Points!');\n      return;\n    }\n\n    if (model.indexedLookup) {\n      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);\n    } else {\n      publicAPI.mapData(input, output, outFormat, inputOffset);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.mapData = (input, output, outFormat, inputOffset) => {\n    if (publicAPI.getSize() === 0) {\n      vtkWarningMacro('Transfer Function Has No Points!');\n      return;\n    }\n\n    const alpha = Math.floor(publicAPI.getAlpha() * 255.0 + 0.5);\n    const length = input.getNumberOfTuples();\n    const inIncr = input.getNumberOfComponents();\n\n    const outputV = output.getData();\n    const inputV = input.getData();\n    const rgb = [];\n\n    if (outFormat === ScalarMappingTarget.RGBA) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 4] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n        outputV[i * 4 + 3] = alpha;\n      }\n    }\n\n    if (outFormat === ScalarMappingTarget.RGB) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 3] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 3 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 3 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n      }\n    }\n\n    if (outFormat === ScalarMappingTarget.LUMINANCE) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i] = Math.floor(\n          rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5\n        );\n      }\n    }\n\n    if (outFormat === ScalarMappingTarget.LUMINANCE_ALPHA) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 2] = Math.floor(\n          rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5\n        );\n        outputV[i * 2 + 1] = alpha;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.applyColorMap = (colorMap) => {\n    if (colorMap.ColorSpace) {\n      model.colorSpace = ColorSpace[colorMap.ColorSpace.toUpperCase()];\n      if (model.colorSpace === undefined) {\n        vtkErrorMacro(\n          `ColorSpace ${colorMap.ColorSpace} not supported, using RGB instead`\n        );\n        model.colorSpace = ColorSpace.RGB;\n      }\n    }\n    if (colorMap.NanColor) {\n      model.nanColor = [].concat(colorMap.NanColor);\n      while (model.nanColor.length < 4) {\n        model.nanColor.push(1.0);\n      }\n    }\n    if (colorMap.RGBPoints) {\n      const size = colorMap.RGBPoints.length;\n      model.nodes = [];\n      const midpoint = 0.5;\n      const sharpness = 0.0;\n      for (let i = 0; i < size; i += 4) {\n        model.nodes.push({\n          x: colorMap.RGBPoints[i],\n          r: colorMap.RGBPoints[i + 1],\n          g: colorMap.RGBPoints[i + 2],\n          b: colorMap.RGBPoints[i + 3],\n          midpoint,\n          sharpness,\n        });\n      }\n    }\n    // FIXME: not supported ?\n    // if (colorMap.IndexedColors) {\n    // }\n    // if (colorMap.Annotations) {\n    // }\n\n    publicAPI.sortAndUpdateRange();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  clamping: true,\n  colorSpace: ColorSpace.RGB,\n  hSVWrap: true,\n  scale: Scale.LINEAR,\n\n  nanColor: null,\n  belowRangeColor: null,\n  aboveRangeColor: null,\n  useAboveRangeColor: false,\n  useBelowRangeColor: false,\n\n  allowDuplicateScalars: false,\n\n  table: null,\n  tableSize: 0,\n  buildTime: null,\n\n  nodes: null,\n\n  discretize: false,\n  numberOfValues: 256,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkScalarsToColors.extend(publicAPI, model, initialValues);\n\n  // Internal objects initialization\n  model.table = [];\n  model.nodes = [];\n\n  model.nanColor = [0.5, 0.0, 0.0, 1.0];\n  model.belowRangeColor = [0.0, 0.0, 0.0, 1.0];\n  model.aboveRangeColor = [1.0, 1.0, 1.0, 1.0];\n\n  model.buildTime = {};\n  macro.obj(model.buildTime);\n\n  // Create get-only macros\n  macro.get(publicAPI, model, ['buildTime', 'mappingRange']);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, [\n    'useAboveRangeColor',\n    'useBelowRangeColor',\n    'colorSpace',\n    'discretize',\n    'numberOfValues',\n  ]);\n\n  macro.setArray(\n    publicAPI,\n    model,\n    ['nanColor', 'belowRangeColor', 'aboveRangeColor'],\n    4\n  );\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, [\n    'nanColor',\n    'belowRangeColor',\n    'aboveRangeColor',\n  ]);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkColorTransferFunction(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(\n  extend,\n  'vtkColorTransferFunction'\n);\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend, ...Constants };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}