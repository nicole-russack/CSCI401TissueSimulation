{"ast":null,"code":"import * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkPlane from 'vtk.js/Sources/Common/DataModel/Plane';\nconst INIT_BOUNDS = [Number.MAX_VALUE, -Number.MAX_VALUE, // X\nNumber.MAX_VALUE, -Number.MAX_VALUE, // Y\nNumber.MAX_VALUE, -Number.MAX_VALUE // Z\n]; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nexport function equals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\n}\nexport function isValid(bounds) {\n  return bounds[0] <= bounds[1] && bounds[2] <= bounds[3] && bounds[4] <= bounds[5];\n}\nexport function setBounds(bounds, otherBounds) {\n  bounds[0] = otherBounds[0];\n  bounds[1] = otherBounds[1];\n  bounds[2] = otherBounds[2];\n  bounds[3] = otherBounds[3];\n  bounds[4] = otherBounds[4];\n  bounds[5] = otherBounds[5];\n  return bounds;\n}\nexport function reset(bounds) {\n  return setBounds(bounds, INIT_BOUNDS);\n}\nexport function addPoint(bounds) {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  bounds[0] = xMin < (arguments.length <= 1 ? undefined : arguments[1]) ? xMin : arguments.length <= 1 ? undefined : arguments[1];\n  bounds[1] = xMax > (arguments.length <= 1 ? undefined : arguments[1]) ? xMax : arguments.length <= 1 ? undefined : arguments[1];\n  bounds[2] = yMin < (arguments.length <= 2 ? undefined : arguments[2]) ? yMin : arguments.length <= 2 ? undefined : arguments[2];\n  bounds[3] = yMax > (arguments.length <= 2 ? undefined : arguments[2]) ? yMax : arguments.length <= 2 ? undefined : arguments[2];\n  bounds[4] = zMin < (arguments.length <= 3 ? undefined : arguments[3]) ? zMin : arguments.length <= 3 ? undefined : arguments[3];\n  bounds[5] = zMax > (arguments.length <= 3 ? undefined : arguments[3]) ? zMax : arguments.length <= 3 ? undefined : arguments[3];\n  return bounds;\n}\nexport function addPoints(bounds, points) {\n  if (points.length === 0) {\n    return bounds;\n  }\n\n  if (Array.isArray(points[0])) {\n    for (let i = 0; i < points.length; ++i) {\n      addPoint(bounds, points[i]);\n    }\n  } else {\n    for (let i = 0; i < points.length; i += 3) {\n      addPoint(bounds, points.slice(i, i + 3));\n    }\n  }\n\n  return bounds;\n}\nexport function addBounds(bounds, xMin, xMax, yMin, yMax, zMin, zMax) {\n  const [_xMin, _xMax, _yMin, _yMax, _zMin, _zMax] = bounds;\n\n  if (zMax === undefined) {\n    bounds[0] = Math.min(xMin[0], _xMin);\n    bounds[1] = Math.max(xMin[1], _xMax);\n    bounds[2] = Math.min(xMin[2], _yMin);\n    bounds[3] = Math.max(xMin[3], _yMax);\n    bounds[4] = Math.min(xMin[4], _zMin);\n    bounds[5] = Math.max(xMin[5], _zMax);\n  } else {\n    bounds[0] = Math.min(xMin, _xMin);\n    bounds[1] = Math.max(xMax, _xMax);\n    bounds[2] = Math.min(yMin, _yMin);\n    bounds[3] = Math.max(yMax, _yMax);\n    bounds[4] = Math.min(zMin, _zMin);\n    bounds[5] = Math.max(zMax, _zMax);\n  }\n\n  return bounds;\n}\nexport function setMinPoint(bounds, x, y, z) {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  bounds[0] = x;\n  bounds[1] = x > xMax ? x : xMax;\n  bounds[2] = y;\n  bounds[3] = y > yMax ? y : yMax;\n  bounds[4] = z;\n  bounds[5] = z > zMax ? z : zMax;\n  return xMin !== x || yMin !== y || zMin !== z;\n}\nexport function setMaxPoint(bounds, x, y, z) {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  bounds[0] = x < xMin ? x : xMin;\n  bounds[1] = x;\n  bounds[2] = y < yMin ? y : yMin;\n  bounds[3] = y;\n  bounds[4] = z < zMin ? z : zMin;\n  bounds[5] = z;\n  return xMax !== x || yMax !== y || zMax !== z;\n}\nexport function inflate(bounds, delta) {\n  bounds[0] -= delta;\n  bounds[1] += delta;\n  bounds[2] -= delta;\n  bounds[3] += delta;\n  bounds[4] -= delta;\n  bounds[5] += delta;\n  return bounds;\n}\nexport function scale(bounds, sx, sy, sz) {\n  if (!isValid(bounds)) {\n    return false;\n  }\n\n  if (sx >= 0.0) {\n    bounds[0] *= sx;\n    bounds[1] *= sx;\n  } else {\n    bounds[0] = sx * bounds[1];\n    bounds[1] = sx * bounds[0];\n  }\n\n  if (sy >= 0.0) {\n    bounds[2] *= sy;\n    bounds[3] *= sy;\n  } else {\n    bounds[2] = sy * bounds[3];\n    bounds[3] = sy * bounds[2];\n  }\n\n  if (sz >= 0.0) {\n    bounds[4] *= sz;\n    bounds[5] *= sz;\n  } else {\n    bounds[4] = sz * bounds[5];\n    bounds[5] = sz * bounds[4];\n  }\n\n  return true;\n}\nexport function getCenter(bounds) {\n  return [0.5 * (bounds[0] + bounds[1]), 0.5 * (bounds[2] + bounds[3]), 0.5 * (bounds[4] + bounds[5])];\n}\nexport function scaleAboutCenter(bounds, sx, sy, sz) {\n  if (!isValid(bounds)) {\n    return false;\n  }\n\n  const center = getCenter(bounds);\n  bounds[0] -= center[0];\n  bounds[1] -= center[0];\n  bounds[2] -= center[1];\n  bounds[3] -= center[1];\n  bounds[4] -= center[2];\n  bounds[5] -= center[2];\n  scale(bounds, sx, sy, sz);\n  bounds[0] += center[0];\n  bounds[1] += center[0];\n  bounds[2] += center[1];\n  bounds[3] += center[1];\n  bounds[4] += center[2];\n  bounds[5] += center[2];\n  return true;\n}\nexport function getLength(bounds, index) {\n  return bounds[index * 2 + 1] - bounds[index * 2];\n}\nexport function getLengths(bounds) {\n  return [getLength(bounds, 0), getLength(bounds, 1), getLength(bounds, 2)];\n}\nexport function getXRange(bounds) {\n  return bounds.slice(0, 2);\n}\nexport function getYRange(bounds) {\n  return bounds.slice(2, 4);\n}\nexport function getZRange(bounds) {\n  return bounds.slice(4, 6);\n}\nexport function getMaxLength(bounds) {\n  const l = getLengths(bounds);\n\n  if (l[0] > l[1]) {\n    if (l[0] > l[2]) {\n      return l[0];\n    }\n\n    return l[2];\n  }\n\n  if (l[1] > l[2]) {\n    return l[1];\n  }\n\n  return l[2];\n}\nexport function getDiagonalLength(bounds) {\n  if (isValid(bounds)) {\n    const l = getLengths(bounds);\n    return Math.sqrt(l[0] * l[0] + l[1] * l[1] + l[2] * l[2]);\n  }\n\n  return null;\n}\nexport function getMinPoint(bounds) {\n  return [bounds[0], bounds[2], bounds[4]];\n}\nexport function getMaxPoint(bounds) {\n  return [bounds[1], bounds[3], bounds[5]];\n}\n\nfunction oppositeSign(a, b) {\n  return a <= 0 && b >= 0 || a >= 0 && b <= 0;\n}\n\nexport function getCorners(bounds, corners) {\n  let count = 0;\n\n  for (let ix = 0; ix < 2; ix++) {\n    for (let iy = 2; iy < 4; iy++) {\n      for (let iz = 4; iz < 6; iz++) {\n        corners[count] = [bounds[ix], bounds[iy], bounds[iz]];\n        count++;\n      }\n    }\n  }\n\n  return corners;\n} // Computes the two corners with minimal and miximal coordinates\n\nexport function computeCornerPoints(bounds, point1, point2) {\n  point1[0] = bounds[0];\n  point1[1] = bounds[2];\n  point1[2] = bounds[4];\n  point2[0] = bounds[1];\n  point2[1] = bounds[3];\n  point2[2] = bounds[5];\n  return point1;\n}\nexport function computeScale3(bounds) {\n  let scale3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  scale3[0] = 0.5 * (bounds[1] - bounds[0]);\n  scale3[1] = 0.5 * (bounds[3] - bounds[2]);\n  scale3[2] = 0.5 * (bounds[5] - bounds[4]);\n  return scale3;\n}\n/**\n * Compute local bounds.\n * Not as fast as vtkPoints.getBounds() if u, v, w form a natural basis.\n * @param {vtkPoints} points\n * @param {array} u first vector\n * @param {array} v second vector\n * @param {array} w third vector\n */\n\nexport function computeLocalBounds(points, u, v, w) {\n  const bounds = [].concat(INIT_BOUNDS);\n  const pointsData = points.getData();\n\n  for (let i = 0; i < pointsData.length; i += 3) {\n    const point = [pointsData[i], pointsData[i + 1], pointsData[i + 2]];\n    const du = vtkMath.dot(point, u);\n    bounds[0] = Math.min(du, bounds[0]);\n    bounds[1] = Math.max(du, bounds[1]);\n    const dv = vtkMath.dot(point, v);\n    bounds[2] = Math.min(dv, bounds[2]);\n    bounds[3] = Math.max(dv, bounds[3]);\n    const dw = vtkMath.dot(point, w);\n    bounds[4] = Math.min(dw, bounds[4]);\n    bounds[5] = Math.max(dw, bounds[5]);\n  }\n\n  return bounds;\n} // The method returns a non-zero value if the bounding box is hit.\n// Origin[3] starts the ray, dir[3] is the vector components of the ray in the x-y-z\n// directions, coord[3] is the location of hit, and t is the parametric\n// coordinate along line. (Notes: the intersection ray dir[3] is NOT\n// normalized.  Valid intersections will only occur between 0<=t<=1.)\n\nexport function intersectBox(bounds, origin, dir, coord, tolerance) {\n  let inside = true;\n  const quadrant = [];\n  let whichPlane = 0;\n  const maxT = [];\n  const candidatePlane = [0.0, 0.0, 0.0];\n  const RIGHT = 0;\n  const LEFT = 1;\n  const MIDDLE = 2; // First find closest planes\n\n  for (let i = 0; i < 3; i++) {\n    if (origin[i] < bounds[2 * i]) {\n      quadrant[i] = LEFT;\n      candidatePlane[i] = bounds[2 * i];\n      inside = false;\n    } else if (origin[i] > bounds[2 * i + 1]) {\n      quadrant[i] = RIGHT;\n      candidatePlane[i] = bounds[2 * i + 1];\n      inside = false;\n    } else {\n      quadrant[i] = MIDDLE;\n    }\n  } // Check whether origin of ray is inside bbox\n\n\n  if (inside) {\n    coord[0] = origin[0];\n    coord[1] = origin[1];\n    coord[2] = origin[2];\n    tolerance[0] = 0;\n    return 1;\n  } // Calculate parametric distance to plane\n\n\n  for (let i = 0; i < 3; i++) {\n    if (quadrant[i] !== MIDDLE && dir[i] !== 0.0) {\n      maxT[i] = (candidatePlane[i] - origin[i]) / dir[i];\n    } else {\n      maxT[i] = -1.0;\n    }\n  } // Find the largest parametric value of intersection\n\n\n  for (let i = 0; i < 3; i++) {\n    if (maxT[whichPlane] < maxT[i]) {\n      whichPlane = i;\n    }\n  } // Check for valie intersection along line\n\n\n  if (maxT[whichPlane] > 1.0 || maxT[whichPlane] < 0.0) {\n    return 0;\n  }\n\n  tolerance[0] = maxT[whichPlane]; // Intersection point along line is okay. Check bbox.\n\n  for (let i = 0; i < 3; i++) {\n    if (whichPlane !== i) {\n      coord[i] = origin[i] + maxT[whichPlane] * dir[i];\n\n      if (coord[i] < bounds[2 * i] || coord[i] > bounds[2 * i + 1]) {\n        return 0;\n      }\n    } else {\n      coord[i] = candidatePlane[i];\n    }\n  }\n\n  return 1;\n} // Plane intersection with box\n// The plane is infinite in extent and defined by an origin and normal.The function indicates\n// whether the plane intersects, not the particulars of intersection points and such\n// The function returns non-zero if the plane and box intersect; zero otherwise.\n\nexport function intersectPlane(bounds, origin, normal) {\n  const p = [];\n  let d = 0;\n  let sign = 1;\n  let firstOne = 1; // Evaluate the eight points. If there is a sign change, there is an intersection\n\n  for (let z = 4; z <= 5; ++z) {\n    p[2] = bounds[z];\n\n    for (let y = 2; y <= 3; ++y) {\n      p[1] = bounds[y];\n\n      for (let x = 0; x <= 1; ++x) {\n        p[0] = bounds[x];\n        d = vtkPlane.evaluate(normal, origin, p);\n\n        if (firstOne) {\n          sign = d >= 0 ? 1 : -1;\n          firstOne = 0;\n        }\n\n        if (d === 0.0 || sign > 0 && d < 0.0 || sign < 0 && d > 0.0) {\n          return 1;\n        }\n      }\n    }\n  }\n\n  return 0; // no intersection\n}\nexport function intersect(bounds, bBounds) {\n  if (!(isValid(bounds) && isValid(bBounds))) {\n    return false;\n  }\n\n  const newBounds = [0, 0, 0, 0, 0, 0];\n  let intersection;\n\n  for (let i = 0; i < 3; i++) {\n    intersection = false;\n\n    if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {\n      intersection = true;\n      newBounds[i * 2] = bBounds[i * 2];\n    } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {\n      intersection = true;\n      newBounds[i * 2] = bounds[i * 2];\n    }\n\n    if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {\n      intersection = true;\n      newBounds[i * 2 + 1] = bBounds[2 * i + 1];\n    } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {\n      intersection = true;\n      newBounds[i * 2 + 1] = bounds[i * 2 + 1];\n    }\n\n    if (!intersection) {\n      return false;\n    }\n  } // OK they did intersect - set the box to be the result\n\n\n  bounds[0] = newBounds[0];\n  bounds[1] = newBounds[1];\n  bounds[2] = newBounds[2];\n  bounds[3] = newBounds[3];\n  bounds[4] = newBounds[4];\n  bounds[5] = newBounds[5];\n  return true;\n}\nexport function intersects(bounds, bBounds) {\n  if (!(isValid(bounds) && isValid(bBounds))) {\n    return false;\n  }\n  /* eslint-disable no-continue */\n\n\n  for (let i = 0; i < 3; i++) {\n    if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {\n      continue;\n    } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {\n      continue;\n    }\n\n    if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {\n      continue;\n    } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {\n      continue;\n    }\n\n    return false;\n  }\n  /* eslint-enable no-continue */\n\n\n  return true;\n}\nexport function containsPoint(bounds, x, y, z) {\n  if (x < bounds[0] || x > bounds[1]) {\n    return false;\n  }\n\n  if (y < bounds[2] || y > bounds[3]) {\n    return false;\n  }\n\n  if (z < bounds[4] || z > bounds[5]) {\n    return false;\n  }\n\n  return true;\n}\nexport function contains(bounds, otherBounds) {\n  // if either box is not valid or they don't intersect\n  if (!intersects(bounds, otherBounds)) {\n    return false;\n  }\n\n  if (!containsPoint(bounds, ...getMinPoint(otherBounds))) {\n    return false;\n  }\n\n  if (!containsPoint(bounds, ...getMaxPoint(otherBounds))) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Returns true if plane intersects bounding box.\n * If so, the box is cut by the plane\n * @param {array} origin\n * @param {array} normal\n */\n\nexport function cutWithPlane(bounds, origin, normal) {\n  // Index[0..2] represents the order of traversing the corners of a cube\n  // in (x,y,z), (y,x,z) and (z,x,y) ordering, respectively\n  const index = [[0, 1, 2, 3, 4, 5, 6, 7], [0, 1, 4, 5, 2, 3, 6, 7], [0, 2, 4, 6, 1, 3, 5, 7]]; // stores the signed distance to a plane\n\n  const d = [0, 0, 0, 0, 0, 0, 0, 0];\n  let idx = 0;\n\n  for (let ix = 0; ix < 2; ix++) {\n    for (let iy = 2; iy < 4; iy++) {\n      for (let iz = 4; iz < 6; iz++) {\n        const x = [bounds[ix], bounds[iy], bounds[iz]];\n        d[idx++] = vtkPlane.evaluate(normal, origin, x);\n      }\n    }\n  }\n\n  let dir = 2;\n\n  while (dir--) {\n    // in each direction, we test if the vertices of two orthogonal faces\n    // are on either side of the plane\n    if (oppositeSign(d[index[dir][0]], d[index[dir][4]]) && oppositeSign(d[index[dir][1]], d[index[dir][5]]) && oppositeSign(d[index[dir][2]], d[index[dir][6]]) && oppositeSign(d[index[dir][3]], d[index[dir][7]])) {\n      break;\n    }\n  }\n\n  if (dir < 0) {\n    return false;\n  }\n\n  const sign = Math.sign(normal[dir]);\n  const size = Math.abs((bounds[dir * 2 + 1] - bounds[dir * 2]) * normal[dir]);\n  let t = sign > 0 ? 1 : 0;\n  /* eslint-disable no-continue */\n\n  for (let i = 0; i < 4; i++) {\n    if (size === 0) {\n      continue; // shouldn't happen\n    }\n\n    const ti = Math.abs(d[index[dir][i]]) / size;\n\n    if (sign > 0 && ti < t) {\n      t = ti;\n    }\n\n    if (sign < 0 && ti > t) {\n      t = ti;\n    }\n  }\n  /* eslint-enable no-continue */\n\n\n  const bound = (1.0 - t) * bounds[dir * 2] + t * bounds[dir * 2 + 1];\n\n  if (sign > 0) {\n    bounds[dir * 2] = bound;\n  } else {\n    bounds[dir * 2 + 1] = bound;\n  }\n\n  return true;\n} // ----------------------------------------------------------------------------\n// Light Weight class\n// ----------------------------------------------------------------------------\n\nclass BoundingBox {\n  constructor(refBounds) {\n    this.bounds = refBounds;\n\n    if (!this.bounds) {\n      this.bounds = new Float64Array(INIT_BOUNDS);\n    }\n  }\n\n  getBounds() {\n    return this.bounds;\n  }\n\n  equals(otherBounds) {\n    return equals(this.bounds, otherBounds);\n  }\n\n  isValid() {\n    return isValid(this.bounds);\n  }\n\n  setBounds(otherBounds) {\n    return setBounds(this.bounds, otherBounds);\n  }\n\n  reset() {\n    return reset(this.bounds);\n  }\n\n  addPoint() {\n    for (var _len = arguments.length, xyz = new Array(_len), _key = 0; _key < _len; _key++) {\n      xyz[_key] = arguments[_key];\n    }\n\n    return addPoint(this.bounds, xyz);\n  }\n\n  addPoints(points) {\n    return addPoints(this.bounds, points);\n  }\n\n  addBounds(xMin, xMax, yMin, yMax, zMin, zMax) {\n    return addBounds(this.bounds, xMin, xMax, yMin, yMax, zMin, zMax);\n  }\n\n  setMinPoint(x, y, z) {\n    return setMinPoint(this.bounds, x, y, z);\n  }\n\n  setMaxPoint(x, y, z) {\n    return setMaxPoint(this.bounds, x, y, z);\n  }\n\n  inflate(delta) {\n    return inflate(this.bounds, delta);\n  }\n\n  scale(sx, sy, sz) {\n    return scale(this.bounds, sx, sy, sz);\n  }\n\n  getCenter() {\n    return getCenter(this.bounds);\n  }\n\n  getLength(index) {\n    return getLength(this.bounds, index);\n  }\n\n  getLengths() {\n    return getLengths(this.bounds);\n  }\n\n  getMaxLength() {\n    return getMaxLength(this.bounds);\n  }\n\n  getDiagonalLength() {\n    return getDiagonalLength(this.bounds);\n  }\n\n  getMinPoint() {\n    return getMinPoint(this.bounds);\n  }\n\n  getMaxPoint() {\n    return getMaxPoint(this.bounds);\n  }\n\n  getXRange() {\n    return getXRange(this.bounds);\n  }\n\n  getYRange() {\n    return getYRange(this.bounds);\n  }\n\n  getZRange() {\n    return getZRange(this.bounds);\n  }\n\n  getCorners(corners) {\n    return getCorners(this.bounds, corners);\n  }\n\n  computeCornerPoints(point1, point2) {\n    return computeCornerPoints(this.bounds, point1, point2);\n  }\n\n  computeLocalBounds(u, v, w) {\n    return computeLocalBounds(this.bounds, u, v, w);\n  }\n\n  computeScale3(scale3) {\n    return computeScale3(this.bounds, scale3);\n  }\n\n  cutWithPlane(origin, normal) {\n    return cutWithPlane(this.bounds, origin, normal);\n  }\n\n  intersectBox(origin, dir, coord, tolerance) {\n    return intersectBox(this.bounds, origin, dir, coord, tolerance);\n  }\n\n  intersectPlane(origin, normal) {\n    return intersectPlane(this.bounds, origin, normal);\n  }\n\n  intersect(otherBounds) {\n    return intersect(this.bounds, otherBounds);\n  }\n\n  intersects(otherBounds) {\n    return intersects(this.bounds, otherBounds);\n  }\n\n  containsPoint(x, y, z) {\n    return containsPoint(this.bounds, x, y, z);\n  }\n\n  contains(otherBounds) {\n    return intersects(this.bounds, otherBounds);\n  }\n\n}\n\nfunction newInstance(initialValues) {\n  const bounds = initialValues && initialValues.bounds;\n  return new BoundingBox(bounds);\n} // ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\n\nexport const STATIC = {\n  equals,\n  isValid,\n  setBounds,\n  reset,\n  addPoint,\n  addPoints,\n  addBounds,\n  setMinPoint,\n  setMaxPoint,\n  inflate,\n  scale,\n  scaleAboutCenter,\n  getCenter,\n  getLength,\n  getLengths,\n  getMaxLength,\n  getDiagonalLength,\n  getMinPoint,\n  getMaxPoint,\n  getXRange,\n  getYRange,\n  getZRange,\n  getCorners,\n  computeCornerPoints,\n  computeLocalBounds,\n  computeScale3,\n  cutWithPlane,\n  intersectBox,\n  intersectPlane,\n  intersect,\n  intersects,\n  containsPoint,\n  contains,\n  INIT_BOUNDS\n};\nexport default {\n  newInstance,\n  ...STATIC\n};","map":{"version":3,"names":["vtkMath","vtkPlane","INIT_BOUNDS","Number","MAX_VALUE","equals","a","b","isValid","bounds","setBounds","otherBounds","reset","addPoint","xMin","xMax","yMin","yMax","zMin","zMax","addPoints","points","length","Array","isArray","i","slice","addBounds","_xMin","_xMax","_yMin","_yMax","_zMin","_zMax","undefined","Math","min","max","setMinPoint","x","y","z","setMaxPoint","inflate","delta","scale","sx","sy","sz","getCenter","scaleAboutCenter","center","getLength","index","getLengths","getXRange","getYRange","getZRange","getMaxLength","l","getDiagonalLength","sqrt","getMinPoint","getMaxPoint","oppositeSign","getCorners","corners","count","ix","iy","iz","computeCornerPoints","point1","point2","computeScale3","scale3","computeLocalBounds","u","v","w","concat","pointsData","getData","point","du","dot","dv","dw","intersectBox","origin","dir","coord","tolerance","inside","quadrant","whichPlane","maxT","candidatePlane","RIGHT","LEFT","MIDDLE","intersectPlane","normal","p","d","sign","firstOne","evaluate","intersect","bBounds","newBounds","intersection","intersects","containsPoint","contains","cutWithPlane","idx","size","abs","t","ti","bound","BoundingBox","constructor","refBounds","Float64Array","getBounds","xyz","newInstance","initialValues","STATIC"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Common/DataModel/BoundingBox/index.js"],"sourcesContent":["import * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkPlane from 'vtk.js/Sources/Common/DataModel/Plane';\n\nconst INIT_BOUNDS = [\n  Number.MAX_VALUE,\n  -Number.MAX_VALUE, // X\n  Number.MAX_VALUE,\n  -Number.MAX_VALUE, // Y\n  Number.MAX_VALUE,\n  -Number.MAX_VALUE, // Z\n];\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nexport function equals(a, b) {\n  return (\n    a[0] === b[0] &&\n    a[1] === b[1] &&\n    a[2] === b[2] &&\n    a[3] === b[3] &&\n    a[4] === b[4] &&\n    a[5] === b[5]\n  );\n}\n\nexport function isValid(bounds) {\n  return (\n    bounds[0] <= bounds[1] && bounds[2] <= bounds[3] && bounds[4] <= bounds[5]\n  );\n}\n\nexport function setBounds(bounds, otherBounds) {\n  bounds[0] = otherBounds[0];\n  bounds[1] = otherBounds[1];\n  bounds[2] = otherBounds[2];\n  bounds[3] = otherBounds[3];\n  bounds[4] = otherBounds[4];\n  bounds[5] = otherBounds[5];\n  return bounds;\n}\n\nexport function reset(bounds) {\n  return setBounds(bounds, INIT_BOUNDS);\n}\n\nexport function addPoint(bounds, ...xyz) {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  bounds[0] = xMin < xyz[0] ? xMin : xyz[0];\n  bounds[1] = xMax > xyz[0] ? xMax : xyz[0];\n  bounds[2] = yMin < xyz[1] ? yMin : xyz[1];\n  bounds[3] = yMax > xyz[1] ? yMax : xyz[1];\n  bounds[4] = zMin < xyz[2] ? zMin : xyz[2];\n  bounds[5] = zMax > xyz[2] ? zMax : xyz[2];\n  return bounds;\n}\n\nexport function addPoints(bounds, points) {\n  if (points.length === 0) {\n    return bounds;\n  }\n  if (Array.isArray(points[0])) {\n    for (let i = 0; i < points.length; ++i) {\n      addPoint(bounds, points[i]);\n    }\n  } else {\n    for (let i = 0; i < points.length; i += 3) {\n      addPoint(bounds, points.slice(i, i + 3));\n    }\n  }\n  return bounds;\n}\n\nexport function addBounds(bounds, xMin, xMax, yMin, yMax, zMin, zMax) {\n  const [_xMin, _xMax, _yMin, _yMax, _zMin, _zMax] = bounds;\n  if (zMax === undefined) {\n    bounds[0] = Math.min(xMin[0], _xMin);\n    bounds[1] = Math.max(xMin[1], _xMax);\n    bounds[2] = Math.min(xMin[2], _yMin);\n    bounds[3] = Math.max(xMin[3], _yMax);\n    bounds[4] = Math.min(xMin[4], _zMin);\n    bounds[5] = Math.max(xMin[5], _zMax);\n  } else {\n    bounds[0] = Math.min(xMin, _xMin);\n    bounds[1] = Math.max(xMax, _xMax);\n    bounds[2] = Math.min(yMin, _yMin);\n    bounds[3] = Math.max(yMax, _yMax);\n    bounds[4] = Math.min(zMin, _zMin);\n    bounds[5] = Math.max(zMax, _zMax);\n  }\n  return bounds;\n}\n\nexport function setMinPoint(bounds, x, y, z) {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  bounds[0] = x;\n  bounds[1] = x > xMax ? x : xMax;\n  bounds[2] = y;\n  bounds[3] = y > yMax ? y : yMax;\n  bounds[4] = z;\n  bounds[5] = z > zMax ? z : zMax;\n  return xMin !== x || yMin !== y || zMin !== z;\n}\n\nexport function setMaxPoint(bounds, x, y, z) {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  bounds[0] = x < xMin ? x : xMin;\n  bounds[1] = x;\n  bounds[2] = y < yMin ? y : yMin;\n  bounds[3] = y;\n  bounds[4] = z < zMin ? z : zMin;\n  bounds[5] = z;\n\n  return xMax !== x || yMax !== y || zMax !== z;\n}\n\nexport function inflate(bounds, delta) {\n  bounds[0] -= delta;\n  bounds[1] += delta;\n  bounds[2] -= delta;\n  bounds[3] += delta;\n  bounds[4] -= delta;\n  bounds[5] += delta;\n  return bounds;\n}\n\nexport function scale(bounds, sx, sy, sz) {\n  if (!isValid(bounds)) {\n    return false;\n  }\n  if (sx >= 0.0) {\n    bounds[0] *= sx;\n    bounds[1] *= sx;\n  } else {\n    bounds[0] = sx * bounds[1];\n    bounds[1] = sx * bounds[0];\n  }\n\n  if (sy >= 0.0) {\n    bounds[2] *= sy;\n    bounds[3] *= sy;\n  } else {\n    bounds[2] = sy * bounds[3];\n    bounds[3] = sy * bounds[2];\n  }\n\n  if (sz >= 0.0) {\n    bounds[4] *= sz;\n    bounds[5] *= sz;\n  } else {\n    bounds[4] = sz * bounds[5];\n    bounds[5] = sz * bounds[4];\n  }\n\n  return true;\n}\n\nexport function getCenter(bounds) {\n  return [\n    0.5 * (bounds[0] + bounds[1]),\n    0.5 * (bounds[2] + bounds[3]),\n    0.5 * (bounds[4] + bounds[5]),\n  ];\n}\n\nexport function scaleAboutCenter(bounds, sx, sy, sz) {\n  if (!isValid(bounds)) {\n    return false;\n  }\n  const center = getCenter(bounds);\n  bounds[0] -= center[0];\n  bounds[1] -= center[0];\n  bounds[2] -= center[1];\n  bounds[3] -= center[1];\n  bounds[4] -= center[2];\n  bounds[5] -= center[2];\n  scale(bounds, sx, sy, sz);\n  bounds[0] += center[0];\n  bounds[1] += center[0];\n  bounds[2] += center[1];\n  bounds[3] += center[1];\n  bounds[4] += center[2];\n  bounds[5] += center[2];\n\n  return true;\n}\n\nexport function getLength(bounds, index) {\n  return bounds[index * 2 + 1] - bounds[index * 2];\n}\n\nexport function getLengths(bounds) {\n  return [getLength(bounds, 0), getLength(bounds, 1), getLength(bounds, 2)];\n}\n\nexport function getXRange(bounds) {\n  return bounds.slice(0, 2);\n}\n\nexport function getYRange(bounds) {\n  return bounds.slice(2, 4);\n}\n\nexport function getZRange(bounds) {\n  return bounds.slice(4, 6);\n}\n\nexport function getMaxLength(bounds) {\n  const l = getLengths(bounds);\n  if (l[0] > l[1]) {\n    if (l[0] > l[2]) {\n      return l[0];\n    }\n    return l[2];\n  }\n\n  if (l[1] > l[2]) {\n    return l[1];\n  }\n\n  return l[2];\n}\n\nexport function getDiagonalLength(bounds) {\n  if (isValid(bounds)) {\n    const l = getLengths(bounds);\n    return Math.sqrt(l[0] * l[0] + l[1] * l[1] + l[2] * l[2]);\n  }\n  return null;\n}\n\nexport function getMinPoint(bounds) {\n  return [bounds[0], bounds[2], bounds[4]];\n}\n\nexport function getMaxPoint(bounds) {\n  return [bounds[1], bounds[3], bounds[5]];\n}\n\nfunction oppositeSign(a, b) {\n  return (a <= 0 && b >= 0) || (a >= 0 && b <= 0);\n}\n\nexport function getCorners(bounds, corners) {\n  let count = 0;\n  for (let ix = 0; ix < 2; ix++) {\n    for (let iy = 2; iy < 4; iy++) {\n      for (let iz = 4; iz < 6; iz++) {\n        corners[count] = [bounds[ix], bounds[iy], bounds[iz]];\n        count++;\n      }\n    }\n  }\n  return corners;\n}\n\n// Computes the two corners with minimal and miximal coordinates\nexport function computeCornerPoints(bounds, point1, point2) {\n  point1[0] = bounds[0];\n  point1[1] = bounds[2];\n  point1[2] = bounds[4];\n\n  point2[0] = bounds[1];\n  point2[1] = bounds[3];\n  point2[2] = bounds[5];\n  return point1;\n}\n\nexport function computeScale3(bounds, scale3 = []) {\n  scale3[0] = 0.5 * (bounds[1] - bounds[0]);\n  scale3[1] = 0.5 * (bounds[3] - bounds[2]);\n  scale3[2] = 0.5 * (bounds[5] - bounds[4]);\n  return scale3;\n}\n\n/**\n * Compute local bounds.\n * Not as fast as vtkPoints.getBounds() if u, v, w form a natural basis.\n * @param {vtkPoints} points\n * @param {array} u first vector\n * @param {array} v second vector\n * @param {array} w third vector\n */\nexport function computeLocalBounds(points, u, v, w) {\n  const bounds = [].concat(INIT_BOUNDS);\n  const pointsData = points.getData();\n  for (let i = 0; i < pointsData.length; i += 3) {\n    const point = [pointsData[i], pointsData[i + 1], pointsData[i + 2]];\n    const du = vtkMath.dot(point, u);\n    bounds[0] = Math.min(du, bounds[0]);\n    bounds[1] = Math.max(du, bounds[1]);\n    const dv = vtkMath.dot(point, v);\n    bounds[2] = Math.min(dv, bounds[2]);\n    bounds[3] = Math.max(dv, bounds[3]);\n    const dw = vtkMath.dot(point, w);\n    bounds[4] = Math.min(dw, bounds[4]);\n    bounds[5] = Math.max(dw, bounds[5]);\n  }\n  return bounds;\n}\n\n// The method returns a non-zero value if the bounding box is hit.\n// Origin[3] starts the ray, dir[3] is the vector components of the ray in the x-y-z\n// directions, coord[3] is the location of hit, and t is the parametric\n// coordinate along line. (Notes: the intersection ray dir[3] is NOT\n// normalized.  Valid intersections will only occur between 0<=t<=1.)\nexport function intersectBox(bounds, origin, dir, coord, tolerance) {\n  let inside = true;\n  const quadrant = [];\n  let whichPlane = 0;\n  const maxT = [];\n  const candidatePlane = [0.0, 0.0, 0.0];\n  const RIGHT = 0;\n  const LEFT = 1;\n  const MIDDLE = 2;\n\n  // First find closest planes\n  for (let i = 0; i < 3; i++) {\n    if (origin[i] < bounds[2 * i]) {\n      quadrant[i] = LEFT;\n      candidatePlane[i] = bounds[2 * i];\n      inside = false;\n    } else if (origin[i] > bounds[2 * i + 1]) {\n      quadrant[i] = RIGHT;\n      candidatePlane[i] = bounds[2 * i + 1];\n      inside = false;\n    } else {\n      quadrant[i] = MIDDLE;\n    }\n  }\n\n  // Check whether origin of ray is inside bbox\n  if (inside) {\n    coord[0] = origin[0];\n    coord[1] = origin[1];\n    coord[2] = origin[2];\n    tolerance[0] = 0;\n    return 1;\n  }\n\n  // Calculate parametric distance to plane\n  for (let i = 0; i < 3; i++) {\n    if (quadrant[i] !== MIDDLE && dir[i] !== 0.0) {\n      maxT[i] = (candidatePlane[i] - origin[i]) / dir[i];\n    } else {\n      maxT[i] = -1.0;\n    }\n  }\n\n  // Find the largest parametric value of intersection\n  for (let i = 0; i < 3; i++) {\n    if (maxT[whichPlane] < maxT[i]) {\n      whichPlane = i;\n    }\n  }\n\n  // Check for valie intersection along line\n  if (maxT[whichPlane] > 1.0 || maxT[whichPlane] < 0.0) {\n    return 0;\n  }\n\n  tolerance[0] = maxT[whichPlane];\n\n  // Intersection point along line is okay. Check bbox.\n  for (let i = 0; i < 3; i++) {\n    if (whichPlane !== i) {\n      coord[i] = origin[i] + maxT[whichPlane] * dir[i];\n      if (coord[i] < bounds[2 * i] || coord[i] > bounds[2 * i + 1]) {\n        return 0;\n      }\n    } else {\n      coord[i] = candidatePlane[i];\n    }\n  }\n\n  return 1;\n}\n\n// Plane intersection with box\n// The plane is infinite in extent and defined by an origin and normal.The function indicates\n// whether the plane intersects, not the particulars of intersection points and such\n// The function returns non-zero if the plane and box intersect; zero otherwise.\nexport function intersectPlane(bounds, origin, normal) {\n  const p = [];\n  let d = 0;\n  let sign = 1;\n  let firstOne = 1;\n\n  // Evaluate the eight points. If there is a sign change, there is an intersection\n  for (let z = 4; z <= 5; ++z) {\n    p[2] = bounds[z];\n    for (let y = 2; y <= 3; ++y) {\n      p[1] = bounds[y];\n      for (let x = 0; x <= 1; ++x) {\n        p[0] = bounds[x];\n        d = vtkPlane.evaluate(normal, origin, p);\n        if (firstOne) {\n          sign = d >= 0 ? 1 : -1;\n          firstOne = 0;\n        }\n        if (d === 0.0 || (sign > 0 && d < 0.0) || (sign < 0 && d > 0.0)) {\n          return 1;\n        }\n      }\n    }\n  }\n\n  return 0; // no intersection\n}\n\nexport function intersect(bounds, bBounds) {\n  if (!(isValid(bounds) && isValid(bBounds))) {\n    return false;\n  }\n\n  const newBounds = [0, 0, 0, 0, 0, 0];\n  let intersection;\n  for (let i = 0; i < 3; i++) {\n    intersection = false;\n    if (\n      bBounds[i * 2] >= bounds[i * 2] &&\n      bBounds[i * 2] <= bounds[i * 2 + 1]\n    ) {\n      intersection = true;\n      newBounds[i * 2] = bBounds[i * 2];\n    } else if (\n      bounds[i * 2] >= bBounds[i * 2] &&\n      bounds[i * 2] <= bBounds[i * 2 + 1]\n    ) {\n      intersection = true;\n      newBounds[i * 2] = bounds[i * 2];\n    }\n\n    if (\n      bBounds[i * 2 + 1] >= bounds[i * 2] &&\n      bBounds[i * 2 + 1] <= bounds[i * 2 + 1]\n    ) {\n      intersection = true;\n      newBounds[i * 2 + 1] = bBounds[2 * i + 1];\n    } else if (\n      bounds[i * 2 + 1] >= bBounds[i * 2] &&\n      bounds[i * 2 + 1] <= bBounds[i * 2 + 1]\n    ) {\n      intersection = true;\n      newBounds[i * 2 + 1] = bounds[i * 2 + 1];\n    }\n\n    if (!intersection) {\n      return false;\n    }\n  }\n\n  // OK they did intersect - set the box to be the result\n  bounds[0] = newBounds[0];\n  bounds[1] = newBounds[1];\n  bounds[2] = newBounds[2];\n  bounds[3] = newBounds[3];\n  bounds[4] = newBounds[4];\n  bounds[5] = newBounds[5];\n  return true;\n}\n\nexport function intersects(bounds, bBounds) {\n  if (!(isValid(bounds) && isValid(bBounds))) {\n    return false;\n  }\n  /* eslint-disable no-continue */\n  for (let i = 0; i < 3; i++) {\n    if (\n      bBounds[i * 2] >= bounds[i * 2] &&\n      bBounds[i * 2] <= bounds[i * 2 + 1]\n    ) {\n      continue;\n    } else if (\n      bounds[i * 2] >= bBounds[i * 2] &&\n      bounds[i * 2] <= bBounds[i * 2 + 1]\n    ) {\n      continue;\n    }\n\n    if (\n      bBounds[i * 2 + 1] >= bounds[i * 2] &&\n      bBounds[i * 2 + 1] <= bounds[i * 2 + 1]\n    ) {\n      continue;\n    } else if (\n      bounds[i * 2 + 1] >= bBounds[i * 2] &&\n      bounds[i * 2 + 1] <= bBounds[i * 2 + 1]\n    ) {\n      continue;\n    }\n    return false;\n  }\n  /* eslint-enable no-continue */\n\n  return true;\n}\n\nexport function containsPoint(bounds, x, y, z) {\n  if (x < bounds[0] || x > bounds[1]) {\n    return false;\n  }\n\n  if (y < bounds[2] || y > bounds[3]) {\n    return false;\n  }\n\n  if (z < bounds[4] || z > bounds[5]) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function contains(bounds, otherBounds) {\n  // if either box is not valid or they don't intersect\n  if (!intersects(bounds, otherBounds)) {\n    return false;\n  }\n\n  if (!containsPoint(bounds, ...getMinPoint(otherBounds))) {\n    return false;\n  }\n\n  if (!containsPoint(bounds, ...getMaxPoint(otherBounds))) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Returns true if plane intersects bounding box.\n * If so, the box is cut by the plane\n * @param {array} origin\n * @param {array} normal\n */\nexport function cutWithPlane(bounds, origin, normal) {\n  // Index[0..2] represents the order of traversing the corners of a cube\n  // in (x,y,z), (y,x,z) and (z,x,y) ordering, respectively\n  const index = [\n    [0, 1, 2, 3, 4, 5, 6, 7],\n    [0, 1, 4, 5, 2, 3, 6, 7],\n    [0, 2, 4, 6, 1, 3, 5, 7],\n  ];\n\n  // stores the signed distance to a plane\n  const d = [0, 0, 0, 0, 0, 0, 0, 0];\n  let idx = 0;\n  for (let ix = 0; ix < 2; ix++) {\n    for (let iy = 2; iy < 4; iy++) {\n      for (let iz = 4; iz < 6; iz++) {\n        const x = [bounds[ix], bounds[iy], bounds[iz]];\n        d[idx++] = vtkPlane.evaluate(normal, origin, x);\n      }\n    }\n  }\n\n  let dir = 2;\n  while (dir--) {\n    // in each direction, we test if the vertices of two orthogonal faces\n    // are on either side of the plane\n    if (\n      oppositeSign(d[index[dir][0]], d[index[dir][4]]) &&\n      oppositeSign(d[index[dir][1]], d[index[dir][5]]) &&\n      oppositeSign(d[index[dir][2]], d[index[dir][6]]) &&\n      oppositeSign(d[index[dir][3]], d[index[dir][7]])\n    ) {\n      break;\n    }\n  }\n\n  if (dir < 0) {\n    return false;\n  }\n\n  const sign = Math.sign(normal[dir]);\n  const size = Math.abs((bounds[dir * 2 + 1] - bounds[dir * 2]) * normal[dir]);\n  let t = sign > 0 ? 1 : 0;\n  /* eslint-disable no-continue */\n  for (let i = 0; i < 4; i++) {\n    if (size === 0) {\n      continue; // shouldn't happen\n    }\n    const ti = Math.abs(d[index[dir][i]]) / size;\n    if (sign > 0 && ti < t) {\n      t = ti;\n    }\n\n    if (sign < 0 && ti > t) {\n      t = ti;\n    }\n  }\n  /* eslint-enable no-continue */\n  const bound = (1.0 - t) * bounds[dir * 2] + t * bounds[dir * 2 + 1];\n\n  if (sign > 0) {\n    bounds[dir * 2] = bound;\n  } else {\n    bounds[dir * 2 + 1] = bound;\n  }\n\n  return true;\n}\n\n// ----------------------------------------------------------------------------\n// Light Weight class\n// ----------------------------------------------------------------------------\n\nclass BoundingBox {\n  constructor(refBounds) {\n    this.bounds = refBounds;\n    if (!this.bounds) {\n      this.bounds = new Float64Array(INIT_BOUNDS);\n    }\n  }\n\n  getBounds() {\n    return this.bounds;\n  }\n\n  equals(otherBounds) {\n    return equals(this.bounds, otherBounds);\n  }\n\n  isValid() {\n    return isValid(this.bounds);\n  }\n\n  setBounds(otherBounds) {\n    return setBounds(this.bounds, otherBounds);\n  }\n\n  reset() {\n    return reset(this.bounds);\n  }\n\n  addPoint(...xyz) {\n    return addPoint(this.bounds, xyz);\n  }\n\n  addPoints(points) {\n    return addPoints(this.bounds, points);\n  }\n\n  addBounds(xMin, xMax, yMin, yMax, zMin, zMax) {\n    return addBounds(this.bounds, xMin, xMax, yMin, yMax, zMin, zMax);\n  }\n\n  setMinPoint(x, y, z) {\n    return setMinPoint(this.bounds, x, y, z);\n  }\n\n  setMaxPoint(x, y, z) {\n    return setMaxPoint(this.bounds, x, y, z);\n  }\n\n  inflate(delta) {\n    return inflate(this.bounds, delta);\n  }\n\n  scale(sx, sy, sz) {\n    return scale(this.bounds, sx, sy, sz);\n  }\n\n  getCenter() {\n    return getCenter(this.bounds);\n  }\n\n  getLength(index) {\n    return getLength(this.bounds, index);\n  }\n\n  getLengths() {\n    return getLengths(this.bounds);\n  }\n\n  getMaxLength() {\n    return getMaxLength(this.bounds);\n  }\n\n  getDiagonalLength() {\n    return getDiagonalLength(this.bounds);\n  }\n\n  getMinPoint() {\n    return getMinPoint(this.bounds);\n  }\n\n  getMaxPoint() {\n    return getMaxPoint(this.bounds);\n  }\n\n  getXRange() {\n    return getXRange(this.bounds);\n  }\n\n  getYRange() {\n    return getYRange(this.bounds);\n  }\n\n  getZRange() {\n    return getZRange(this.bounds);\n  }\n\n  getCorners(corners) {\n    return getCorners(this.bounds, corners);\n  }\n\n  computeCornerPoints(point1, point2) {\n    return computeCornerPoints(this.bounds, point1, point2);\n  }\n\n  computeLocalBounds(u, v, w) {\n    return computeLocalBounds(this.bounds, u, v, w);\n  }\n\n  computeScale3(scale3) {\n    return computeScale3(this.bounds, scale3);\n  }\n\n  cutWithPlane(origin, normal) {\n    return cutWithPlane(this.bounds, origin, normal);\n  }\n\n  intersectBox(origin, dir, coord, tolerance) {\n    return intersectBox(this.bounds, origin, dir, coord, tolerance);\n  }\n\n  intersectPlane(origin, normal) {\n    return intersectPlane(this.bounds, origin, normal);\n  }\n\n  intersect(otherBounds) {\n    return intersect(this.bounds, otherBounds);\n  }\n\n  intersects(otherBounds) {\n    return intersects(this.bounds, otherBounds);\n  }\n\n  containsPoint(x, y, z) {\n    return containsPoint(this.bounds, x, y, z);\n  }\n\n  contains(otherBounds) {\n    return intersects(this.bounds, otherBounds);\n  }\n}\n\nfunction newInstance(initialValues) {\n  const bounds = initialValues && initialValues.bounds;\n  return new BoundingBox(bounds);\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nexport const STATIC = {\n  equals,\n  isValid,\n  setBounds,\n  reset,\n  addPoint,\n  addPoints,\n  addBounds,\n  setMinPoint,\n  setMaxPoint,\n  inflate,\n  scale,\n  scaleAboutCenter,\n  getCenter,\n  getLength,\n  getLengths,\n  getMaxLength,\n  getDiagonalLength,\n  getMinPoint,\n  getMaxPoint,\n  getXRange,\n  getYRange,\n  getZRange,\n  getCorners,\n  computeCornerPoints,\n  computeLocalBounds,\n  computeScale3,\n  cutWithPlane,\n  intersectBox,\n  intersectPlane,\n  intersect,\n  intersects,\n  containsPoint,\n  contains,\n  INIT_BOUNDS,\n};\n\nexport default { newInstance, ...STATIC };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}