{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport vtkOpenGLFramebuffer from 'vtk.js/Sources/Rendering/OpenGL/Framebuffer';\nimport vtkRenderPass from 'vtk.js/Sources/Rendering/SceneGraph/RenderPass';\nimport vtkOpenGLOrderIndependentTranslucentPass from 'vtk.js/Sources/Rendering/OpenGL/OrderIndependentTranslucentPass'; // ----------------------------------------------------------------------------\n\nfunction vtkForwardPass(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkForwardPass'); // this pass implements a forward rendering pipeline\n  // if both volumes and opaque geometry are present\n  // it will mix the two together by capturing a zbuffer\n  // first\n\n  publicAPI.traverse = function (viewNode) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (model.deleted) {\n      return;\n    } // we just render our delegates in order\n\n\n    model.currentParent = parent; // build\n\n    publicAPI.setCurrentOperation('buildPass');\n    viewNode.traverse(publicAPI);\n    const numlayers = viewNode.getRenderable().getNumberOfLayers(); // iterate over renderers\n\n    const renderers = viewNode.getChildren();\n\n    for (let i = 0; i < numlayers; i++) {\n      for (let index = 0; index < renderers.length; index++) {\n        const renNode = renderers[index];\n        const ren = viewNode.getRenderable().getRenderers()[index];\n\n        if (ren.getDraw() && ren.getLayer() === i) {\n          // check for both opaque and volume actors\n          model.opaqueActorCount = 0;\n          model.translucentActorCount = 0;\n          model.volumeCount = 0;\n          model.overlayActorCount = 0;\n          publicAPI.setCurrentOperation('queryPass');\n          renNode.traverse(publicAPI); // do we need to capture a zbuffer?\n\n          if (model.opaqueActorCount > 0 && model.volumeCount > 0 || model.depthRequested) {\n            const size = viewNode.getFramebufferSize(); // make sure the framebuffer is setup\n\n            if (model.framebuffer === null) {\n              model.framebuffer = vtkOpenGLFramebuffer.newInstance();\n            }\n\n            model.framebuffer.setOpenGLRenderWindow(viewNode);\n            model.framebuffer.saveCurrentBindingsAndBuffers();\n            const fbSize = model.framebuffer.getSize();\n\n            if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {\n              model.framebuffer.create(size[0], size[1]);\n              model.framebuffer.populateFramebuffer();\n            }\n\n            model.framebuffer.bind();\n            publicAPI.setCurrentOperation('opaqueZBufferPass');\n            renNode.traverse(publicAPI);\n            model.framebuffer.restorePreviousBindingsAndBuffers(); // reset now that we have done it\n\n            model.depthRequested = false;\n          }\n\n          publicAPI.setCurrentOperation('cameraPass');\n          renNode.traverse(publicAPI);\n\n          if (model.opaqueActorCount > 0) {\n            publicAPI.setCurrentOperation('opaquePass');\n            renNode.traverse(publicAPI);\n          }\n\n          if (model.translucentActorCount > 0) {\n            if (!model.translucentPass) {\n              model.translucentPass = vtkOpenGLOrderIndependentTranslucentPass.newInstance();\n            }\n\n            model.translucentPass.traverse(viewNode, renNode, publicAPI);\n          }\n\n          if (model.volumeCount > 0) {\n            publicAPI.setCurrentOperation('volumePass');\n            renNode.traverse(publicAPI);\n          }\n\n          if (model.overlayActorCount > 0) {\n            publicAPI.setCurrentOperation('overlayPass');\n            renNode.traverse(publicAPI);\n          }\n        }\n      }\n    }\n  };\n\n  publicAPI.getZBufferTexture = () => {\n    if (model.framebuffer) {\n      return model.framebuffer.getColorTexture();\n    }\n\n    return null;\n  };\n\n  publicAPI.requestDepth = () => {\n    model.depthRequested = true;\n  };\n\n  publicAPI.incrementOpaqueActorCount = () => model.opaqueActorCount++;\n\n  publicAPI.incrementTranslucentActorCount = () => model.translucentActorCount++;\n\n  publicAPI.incrementVolumeCount = () => model.volumeCount++;\n\n  publicAPI.incrementOverlayActorCount = () => model.overlayActorCount++;\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  opaqueActorCount: 0,\n  translucentActorCount: 0,\n  volumeCount: 0,\n  overlayActorCount: 0,\n  framebuffer: null,\n  depthRequested: false\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  vtkRenderPass.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['framebuffer', 'opaqueActorCount', 'translucentActorCount', 'volumeCount']); // Object methods\n\n  vtkForwardPass(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkForwardPass'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["macro","vtkOpenGLFramebuffer","vtkRenderPass","vtkOpenGLOrderIndependentTranslucentPass","vtkForwardPass","publicAPI","model","classHierarchy","push","traverse","viewNode","parent","deleted","currentParent","setCurrentOperation","numlayers","getRenderable","getNumberOfLayers","renderers","getChildren","i","index","length","renNode","ren","getRenderers","getDraw","getLayer","opaqueActorCount","translucentActorCount","volumeCount","overlayActorCount","depthRequested","size","getFramebufferSize","framebuffer","newInstance","setOpenGLRenderWindow","saveCurrentBindingsAndBuffers","fbSize","getSize","create","populateFramebuffer","bind","restorePreviousBindingsAndBuffers","translucentPass","getZBufferTexture","getColorTexture","requestDepth","incrementOpaqueActorCount","incrementTranslucentActorCount","incrementVolumeCount","incrementOverlayActorCount","DEFAULT_VALUES","extend","initialValues","Object","assign","get"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/OpenGL/ForwardPass/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport vtkOpenGLFramebuffer from 'vtk.js/Sources/Rendering/OpenGL/Framebuffer';\nimport vtkRenderPass from 'vtk.js/Sources/Rendering/SceneGraph/RenderPass';\nimport vtkOpenGLOrderIndependentTranslucentPass from 'vtk.js/Sources/Rendering/OpenGL/OrderIndependentTranslucentPass';\n\n// ----------------------------------------------------------------------------\n\nfunction vtkForwardPass(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkForwardPass');\n\n  // this pass implements a forward rendering pipeline\n  // if both volumes and opaque geometry are present\n  // it will mix the two together by capturing a zbuffer\n  // first\n  publicAPI.traverse = (viewNode, parent = null) => {\n    if (model.deleted) {\n      return;\n    }\n\n    // we just render our delegates in order\n    model.currentParent = parent;\n\n    // build\n    publicAPI.setCurrentOperation('buildPass');\n    viewNode.traverse(publicAPI);\n\n    const numlayers = viewNode.getRenderable().getNumberOfLayers();\n\n    // iterate over renderers\n    const renderers = viewNode.getChildren();\n    for (let i = 0; i < numlayers; i++) {\n      for (let index = 0; index < renderers.length; index++) {\n        const renNode = renderers[index];\n        const ren = viewNode.getRenderable().getRenderers()[index];\n\n        if (ren.getDraw() && ren.getLayer() === i) {\n          // check for both opaque and volume actors\n          model.opaqueActorCount = 0;\n          model.translucentActorCount = 0;\n          model.volumeCount = 0;\n          model.overlayActorCount = 0;\n          publicAPI.setCurrentOperation('queryPass');\n\n          renNode.traverse(publicAPI);\n\n          // do we need to capture a zbuffer?\n          if (\n            (model.opaqueActorCount > 0 && model.volumeCount > 0) ||\n            model.depthRequested\n          ) {\n            const size = viewNode.getFramebufferSize();\n            // make sure the framebuffer is setup\n            if (model.framebuffer === null) {\n              model.framebuffer = vtkOpenGLFramebuffer.newInstance();\n            }\n            model.framebuffer.setOpenGLRenderWindow(viewNode);\n            model.framebuffer.saveCurrentBindingsAndBuffers();\n            const fbSize = model.framebuffer.getSize();\n            if (\n              fbSize === null ||\n              fbSize[0] !== size[0] ||\n              fbSize[1] !== size[1]\n            ) {\n              model.framebuffer.create(size[0], size[1]);\n              model.framebuffer.populateFramebuffer();\n            }\n            model.framebuffer.bind();\n            publicAPI.setCurrentOperation('opaqueZBufferPass');\n            renNode.traverse(publicAPI);\n            model.framebuffer.restorePreviousBindingsAndBuffers();\n\n            // reset now that we have done it\n            model.depthRequested = false;\n          }\n\n          publicAPI.setCurrentOperation('cameraPass');\n          renNode.traverse(publicAPI);\n          if (model.opaqueActorCount > 0) {\n            publicAPI.setCurrentOperation('opaquePass');\n            renNode.traverse(publicAPI);\n          }\n          if (model.translucentActorCount > 0) {\n            if (!model.translucentPass) {\n              model.translucentPass =\n                vtkOpenGLOrderIndependentTranslucentPass.newInstance();\n            }\n            model.translucentPass.traverse(viewNode, renNode, publicAPI);\n          }\n          if (model.volumeCount > 0) {\n            publicAPI.setCurrentOperation('volumePass');\n            renNode.traverse(publicAPI);\n          }\n          if (model.overlayActorCount > 0) {\n            publicAPI.setCurrentOperation('overlayPass');\n            renNode.traverse(publicAPI);\n          }\n        }\n      }\n    }\n  };\n\n  publicAPI.getZBufferTexture = () => {\n    if (model.framebuffer) {\n      return model.framebuffer.getColorTexture();\n    }\n    return null;\n  };\n\n  publicAPI.requestDepth = () => {\n    model.depthRequested = true;\n  };\n\n  publicAPI.incrementOpaqueActorCount = () => model.opaqueActorCount++;\n  publicAPI.incrementTranslucentActorCount = () =>\n    model.translucentActorCount++;\n  publicAPI.incrementVolumeCount = () => model.volumeCount++;\n  publicAPI.incrementOverlayActorCount = () => model.overlayActorCount++;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  opaqueActorCount: 0,\n  translucentActorCount: 0,\n  volumeCount: 0,\n  overlayActorCount: 0,\n  framebuffer: null,\n  depthRequested: false,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  vtkRenderPass.extend(publicAPI, model, initialValues);\n\n  macro.get(publicAPI, model, [\n    'framebuffer',\n    'opaqueActorCount',\n    'translucentActorCount',\n    'volumeCount',\n  ]);\n\n  // Object methods\n  vtkForwardPass(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkForwardPass');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}