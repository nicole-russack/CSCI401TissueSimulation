{"ast":null,"code":"import macro from 'vtk.js/Sources/macros';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkBoundingBox from 'vtk.js/Sources/Common/DataModel/BoundingBox';\nimport vtkDataSet from 'vtk.js/Sources/Common/DataModel/DataSet';\nimport vtkStructuredData from 'vtk.js/Sources/Common/DataModel/StructuredData';\nimport { StructuredType } from 'vtk.js/Sources/Common/DataModel/StructuredData/Constants';\nimport { vec3, mat3, mat4 } from 'gl-matrix';\nconst {\n  vtkErrorMacro\n} = macro; // ----------------------------------------------------------------------------\n// vtkImageData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageData');\n\n  publicAPI.setExtent = function () {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n\n    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {\n      inExtent[_key] = arguments[_key];\n    }\n\n    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;\n\n    if (extentArray.length !== 6) {\n      return false;\n    }\n\n    const changeDetected = model.extent.some((item, index) => item !== extentArray[index]);\n\n    if (changeDetected) {\n      model.extent = extentArray.slice();\n      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);\n      publicAPI.modified();\n    }\n\n    return changeDetected;\n  };\n\n  publicAPI.setDimensions = function () {\n    let i;\n    let j;\n    let k;\n\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n\n    if (arguments.length === 1) {\n      const array = arguments.length <= 0 ? undefined : arguments[0];\n      i = array[0];\n      j = array[1];\n      k = array[2];\n    } else if (arguments.length === 3) {\n      i = arguments.length <= 0 ? undefined : arguments[0];\n      j = arguments.length <= 1 ? undefined : arguments[1];\n      k = arguments.length <= 2 ? undefined : arguments[2];\n    } else {\n      vtkErrorMacro('Bad dimension specification');\n      return;\n    }\n\n    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);\n  };\n\n  publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];\n\n  publicAPI.getNumberOfCells = () => {\n    const dims = publicAPI.getDimensions();\n    let nCells = 1;\n\n    for (let i = 0; i < 3; i++) {\n      if (dims[i] === 0) {\n        return 0;\n      }\n\n      if (dims[i] > 1) {\n        nCells *= dims[i] - 1;\n      }\n    }\n\n    return nCells;\n  };\n\n  publicAPI.getNumberOfPoints = () => {\n    const dims = publicAPI.getDimensions();\n    return dims[0] * dims[1] * dims[2];\n  };\n\n  publicAPI.getPoint = index => {\n    const dims = publicAPI.getDimensions();\n\n    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {\n      vtkErrorMacro('Requesting a point from an empty image.');\n      return null;\n    }\n\n    const ijk = new Float64Array(3);\n\n    switch (model.dataDescription) {\n      case StructuredType.EMPTY:\n        return null;\n\n      case StructuredType.SINGLE_POINT:\n        break;\n\n      case StructuredType.X_LINE:\n        ijk[0] = index;\n        break;\n\n      case StructuredType.Y_LINE:\n        ijk[1] = index;\n        break;\n\n      case StructuredType.Z_LINE:\n        ijk[2] = index;\n        break;\n\n      case StructuredType.XY_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0];\n        break;\n\n      case StructuredType.YZ_PLANE:\n        ijk[1] = index % dims[1];\n        ijk[2] = index / dims[1];\n        break;\n\n      case StructuredType.XZ_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[2] = index / dims[0];\n        break;\n\n      case StructuredType.XYZ_GRID:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0] % dims[1];\n        ijk[2] = index / (dims[0] * dims[1]);\n        break;\n\n      default:\n        vtkErrorMacro('Invalid dataDescription');\n        break;\n    }\n\n    const coords = [0, 0, 0];\n    publicAPI.indexToWorld(ijk, coords);\n    return coords;\n  }; // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;\n  // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;\n  // virtual vtkIdType FindPoint(double x, double y, double z)\n  // {\n  //   return this->vtkDataSet::FindPoint(x, y, z);\n  // }\n  // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,\n  //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkGenericCell *gencell,\n  //   vtkIdType cellId, double tol2, int& subId,\n  //   double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,\n  //                                 double tol2, int& subId, double pcoords[3],\n  //                                 double *weights) VTK_OVERRIDE;\n  // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,\n  //                                     this->GetDimensions());}\n  // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}\n  // void ComputeBounds() VTK_OVERRIDE;\n  // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest\n\n\n  publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());\n\n  publicAPI.extentToBounds = ex => {\n    // prettier-ignore\n    const corners = [[ex[0], ex[2], ex[4]], [ex[1], ex[2], ex[4]], [ex[0], ex[3], ex[4]], [ex[1], ex[3], ex[4]], [ex[0], ex[2], ex[5]], [ex[1], ex[2], ex[5]], [ex[0], ex[3], ex[5]], [ex[1], ex[3], ex[5]]];\n    const bounds = [...vtkBoundingBox.INIT_BOUNDS];\n    const vout = [];\n\n    for (let i = 0; i < 8; ++i) {\n      publicAPI.indexToWorld(corners[i], vout);\n      vtkBoundingBox.addPoint(bounds, ...vout);\n    }\n\n    return bounds;\n  };\n\n  publicAPI.getSpatialExtent = () => vtkBoundingBox.inflate([...model.extent], 0.5); // Internal, shouldn't need to call this manually.\n\n\n  publicAPI.computeTransforms = () => {\n    mat4.fromTranslation(model.indexToWorld, model.origin);\n    model.indexToWorld[0] = model.direction[0];\n    model.indexToWorld[1] = model.direction[1];\n    model.indexToWorld[2] = model.direction[2];\n    model.indexToWorld[4] = model.direction[3];\n    model.indexToWorld[5] = model.direction[4];\n    model.indexToWorld[6] = model.direction[5];\n    model.indexToWorld[8] = model.direction[6];\n    model.indexToWorld[9] = model.direction[7];\n    model.indexToWorld[10] = model.direction[8];\n    mat4.scale(model.indexToWorld, model.indexToWorld, model.spacing);\n    mat4.invert(model.worldToIndex, model.indexToWorld);\n  }; //\n  // The direction matrix is a 3x3 basis for the I, J, K axes\n  // of the image. The rows of the matrix correspond to the\n  // axes directions in world coordinates. Direction must\n  // form an orthonormal basis, results are undefined if\n  // it is not.\n  //\n\n\n  publicAPI.setDirection = function () {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    let array = args; // allow an array passed as a single arg.\n\n    if (array.length === 1 && (Array.isArray(array[0]) || array[0].constructor === Float32Array || array[0].constructor === Float64Array)) {\n      array = array[0];\n    }\n\n    if (array.length !== 9) {\n      throw new RangeError('Invalid number of values for array setter');\n    }\n\n    let changeDetected = false;\n    model.direction.forEach((item, index) => {\n      if (item !== array[index]) {\n        if (changeDetected) {\n          return;\n        }\n\n        changeDetected = true;\n      }\n    });\n\n    if (changeDetected) {\n      for (let i = 0; i < 9; ++i) {\n        model.direction[i] = array[i];\n      }\n\n      publicAPI.modified();\n    }\n\n    return true;\n  };\n\n  publicAPI.indexToWorld = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.indexToWorld);\n    return aout;\n  };\n\n  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;\n\n  publicAPI.worldToIndex = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.worldToIndex);\n    return aout;\n  };\n\n  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;\n\n  publicAPI.indexToWorldBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const in1 = [0, 0, 0];\n    const in2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bin, in1, in2);\n    const out1 = [0, 0, 0];\n    const out2 = [0, 0, 0];\n    vec3.transformMat4(out1, in1, model.indexToWorld);\n    vec3.transformMat4(out2, in2, model.indexToWorld);\n    return vtkMath.computeBoundsFromPoints(out1, out2, bout);\n  };\n\n  publicAPI.worldToIndexBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const in1 = [0, 0, 0];\n    const in2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bin, in1, in2);\n    const out1 = [0, 0, 0];\n    const out2 = [0, 0, 0];\n    vec3.transformMat4(out1, in1, model.worldToIndex);\n    vec3.transformMat4(out2, in2, model.worldToIndex);\n    return vtkMath.computeBoundsFromPoints(out1, out2, bout);\n  }; // Make sure the transform is correct\n\n\n  publicAPI.onModified(publicAPI.computeTransforms);\n  publicAPI.computeTransforms();\n\n  publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());\n\n  publicAPI.computeHistogram = function (worldBounds) {\n    let voxelFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const bounds = [0, 0, 0, 0, 0, 0];\n    publicAPI.worldToIndexBounds(worldBounds, bounds);\n    const point1 = [0, 0, 0];\n    const point2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);\n    vtkMath.roundVector(point1, point1);\n    vtkMath.roundVector(point2, point2);\n    const dimensions = publicAPI.getDimensions();\n    vtkMath.clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);\n    vtkMath.clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);\n    const yStride = dimensions[0];\n    const zStride = dimensions[0] * dimensions[1];\n    const pixels = publicAPI.getPointData().getScalars().getData();\n    let maximum = -Infinity;\n    let minimum = Infinity;\n    let sumOfSquares = 0;\n    let isum = 0;\n    let inum = 0;\n\n    for (let z = point1[2]; z <= point2[2]; z++) {\n      for (let y = point1[1]; y <= point2[1]; y++) {\n        let index = point1[0] + y * yStride + z * zStride;\n\n        for (let x = point1[0]; x <= point2[0]; x++) {\n          if (!voxelFunc || voxelFunc([x, y, z], bounds)) {\n            const pixel = pixels[index];\n            if (pixel > maximum) maximum = pixel;\n            if (pixel < minimum) minimum = pixel;\n            sumOfSquares += pixel * pixel;\n            isum += pixel;\n            inum += 1;\n          }\n\n          ++index;\n        }\n      }\n    }\n\n    const average = inum > 0 ? isum / inum : 0;\n    const variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;\n    const sigma = Math.sqrt(variance);\n    return {\n      minimum,\n      maximum,\n      average,\n      variance,\n      sigma,\n      count: inum\n    };\n  }; // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).\n  // Scalar data could be tuples for color information?\n\n\n  publicAPI.computeIncrements = function (extent) {\n    let numberOfComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const increments = [];\n    let incr = numberOfComponents; // Calculate array increment offsets\n    // similar to c++ vtkImageData::ComputeIncrements\n\n    for (let idx = 0; idx < 3; ++idx) {\n      increments[idx] = incr;\n      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;\n    }\n\n    return increments;\n  };\n  /**\n   * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.\n   * @return {Number} the corresponding flattened index in the scalar array\n   */\n\n\n  publicAPI.computeOffsetIndex = _ref => {\n    let [i, j, k] = _ref;\n    const extent = publicAPI.getExtent();\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    const increments = publicAPI.computeIncrements(extent, numberOfComponents); // Use the array increments to find the pixel index\n    // similar to c++ vtkImageData::GetArrayPointer\n    // Math.floor to catch \"practically 0\" e^-15 scenarios.\n\n    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @return {Number|NaN} the corresponding pixel's index in the scalar array\n   */\n\n\n  publicAPI.getOffsetIndexFromWorld = xyz => {\n    const extent = publicAPI.getExtent();\n    const index = publicAPI.worldToIndex(xyz); // Confirm indexed i,j,k coords are within the bounds of the volume\n\n    for (let idx = 0; idx < 3; ++idx) {\n      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {\n        vtkErrorMacro(`GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`);\n        return NaN;\n      }\n    } // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream\n\n\n    return publicAPI.computeOffsetIndex(index);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @param {Number?} comp the scalar component index for multi-component scalars\n   * @return {Number|NaN} the corresponding pixel's scalar value\n   */\n\n\n  publicAPI.getScalarValueFromWorld = function (xyz) {\n    let comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n\n    if (comp < 0 || comp >= numberOfComponents) {\n      vtkErrorMacro(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);\n      return NaN;\n    }\n\n    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);\n\n    if (Number.isNaN(offsetIndex)) {\n      // VTK Error Macro will have been tripped already, no need to do it again,\n      return offsetIndex;\n    }\n\n    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  direction: null,\n  // a mat3\n  indexToWorld: null,\n  // a mat4\n  worldToIndex: null,\n  // a mat4\n  spacing: [1.0, 1.0, 1.0],\n  origin: [0.0, 0.0, 0.0],\n  extent: [0, -1, 0, -1, 0, -1],\n  dataDescription: StructuredType.EMPTY\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkDataSet.extend(publicAPI, model, initialValues);\n\n  if (!model.direction) {\n    model.direction = mat3.identity(new Float64Array(9));\n  } else if (Array.isArray(model.direction)) {\n    model.direction = new Float64Array(model.direction.slice(0, 9));\n  }\n\n  model.indexToWorld = new Float64Array(16);\n  model.worldToIndex = new Float64Array(16); // Set/Get methods\n\n  macro.get(publicAPI, model, ['direction', 'indexToWorld', 'worldToIndex']);\n  macro.setGetArray(publicAPI, model, ['origin', 'spacing'], 3);\n  macro.getArray(publicAPI, model, ['extent'], 6); // Object specific methods\n\n  vtkImageData(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkImageData'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["macro","vtkMath","vtkBoundingBox","vtkDataSet","vtkStructuredData","StructuredType","vec3","mat3","mat4","vtkErrorMacro","vtkImageData","publicAPI","model","classHierarchy","push","setExtent","deleted","inExtent","extentArray","length","changeDetected","extent","some","item","index","slice","dataDescription","getDataDescriptionFromExtent","modified","setDimensions","i","j","k","array","getDimensions","getNumberOfCells","dims","nCells","getNumberOfPoints","getPoint","ijk","Float64Array","EMPTY","SINGLE_POINT","X_LINE","Y_LINE","Z_LINE","XY_PLANE","YZ_PLANE","XZ_PLANE","XYZ_GRID","coords","indexToWorld","getBounds","extentToBounds","getSpatialExtent","ex","corners","bounds","INIT_BOUNDS","vout","addPoint","inflate","computeTransforms","fromTranslation","origin","direction","scale","spacing","invert","worldToIndex","setDirection","args","Array","isArray","constructor","Float32Array","RangeError","forEach","ain","aout","transformMat4","indexToWorldVec3","worldToIndexVec3","indexToWorldBounds","bin","bout","in1","in2","computeCornerPoints","out1","out2","computeBoundsFromPoints","worldToIndexBounds","onModified","getCenter","computeHistogram","worldBounds","voxelFunc","point1","point2","roundVector","dimensions","clampVector","yStride","zStride","pixels","getPointData","getScalars","getData","maximum","Infinity","minimum","sumOfSquares","isum","inum","z","y","x","pixel","average","variance","Math","abs","sigma","sqrt","count","computeIncrements","numberOfComponents","increments","incr","idx","computeOffsetIndex","getExtent","getNumberOfComponents","floor","round","getOffsetIndexFromWorld","xyz","NaN","getScalarValueFromWorld","comp","offsetIndex","Number","isNaN","getComponent","DEFAULT_VALUES","extend","initialValues","Object","assign","identity","get","setGetArray","getArray","newInstance"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Common/DataModel/ImageData/index.js"],"sourcesContent":["import macro from 'vtk.js/Sources/macros';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkBoundingBox from 'vtk.js/Sources/Common/DataModel/BoundingBox';\nimport vtkDataSet from 'vtk.js/Sources/Common/DataModel/DataSet';\nimport vtkStructuredData from 'vtk.js/Sources/Common/DataModel/StructuredData';\nimport { StructuredType } from 'vtk.js/Sources/Common/DataModel/StructuredData/Constants';\nimport { vec3, mat3, mat4 } from 'gl-matrix';\n\nconst { vtkErrorMacro } = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageData');\n\n  publicAPI.setExtent = (...inExtent) => {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n\n    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;\n\n    if (extentArray.length !== 6) {\n      return false;\n    }\n\n    const changeDetected = model.extent.some(\n      (item, index) => item !== extentArray[index]\n    );\n\n    if (changeDetected) {\n      model.extent = extentArray.slice();\n      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(\n        model.extent\n      );\n      publicAPI.modified();\n    }\n    return changeDetected;\n  };\n\n  publicAPI.setDimensions = (...dims) => {\n    let i;\n    let j;\n    let k;\n\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n\n    if (dims.length === 1) {\n      const array = dims[0];\n      i = array[0];\n      j = array[1];\n      k = array[2];\n    } else if (dims.length === 3) {\n      i = dims[0];\n      j = dims[1];\n      k = dims[2];\n    } else {\n      vtkErrorMacro('Bad dimension specification');\n      return;\n    }\n\n    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);\n  };\n\n  publicAPI.getDimensions = () => [\n    model.extent[1] - model.extent[0] + 1,\n    model.extent[3] - model.extent[2] + 1,\n    model.extent[5] - model.extent[4] + 1,\n  ];\n\n  publicAPI.getNumberOfCells = () => {\n    const dims = publicAPI.getDimensions();\n    let nCells = 1;\n\n    for (let i = 0; i < 3; i++) {\n      if (dims[i] === 0) {\n        return 0;\n      }\n      if (dims[i] > 1) {\n        nCells *= dims[i] - 1;\n      }\n    }\n\n    return nCells;\n  };\n\n  publicAPI.getNumberOfPoints = () => {\n    const dims = publicAPI.getDimensions();\n    return dims[0] * dims[1] * dims[2];\n  };\n\n  publicAPI.getPoint = (index) => {\n    const dims = publicAPI.getDimensions();\n\n    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {\n      vtkErrorMacro('Requesting a point from an empty image.');\n      return null;\n    }\n\n    const ijk = new Float64Array(3);\n\n    switch (model.dataDescription) {\n      case StructuredType.EMPTY:\n        return null;\n\n      case StructuredType.SINGLE_POINT:\n        break;\n\n      case StructuredType.X_LINE:\n        ijk[0] = index;\n        break;\n\n      case StructuredType.Y_LINE:\n        ijk[1] = index;\n        break;\n\n      case StructuredType.Z_LINE:\n        ijk[2] = index;\n        break;\n\n      case StructuredType.XY_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0];\n        break;\n\n      case StructuredType.YZ_PLANE:\n        ijk[1] = index % dims[1];\n        ijk[2] = index / dims[1];\n        break;\n\n      case StructuredType.XZ_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[2] = index / dims[0];\n        break;\n\n      case StructuredType.XYZ_GRID:\n        ijk[0] = index % dims[0];\n        ijk[1] = (index / dims[0]) % dims[1];\n        ijk[2] = index / (dims[0] * dims[1]);\n        break;\n\n      default:\n        vtkErrorMacro('Invalid dataDescription');\n        break;\n    }\n\n    const coords = [0, 0, 0];\n    publicAPI.indexToWorld(ijk, coords);\n    return coords;\n  };\n\n  // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;\n  // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;\n  // virtual vtkIdType FindPoint(double x, double y, double z)\n  // {\n  //   return this->vtkDataSet::FindPoint(x, y, z);\n  // }\n  // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,\n  //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkGenericCell *gencell,\n  //   vtkIdType cellId, double tol2, int& subId,\n  //   double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,\n  //                                 double tol2, int& subId, double pcoords[3],\n  //                                 double *weights) VTK_OVERRIDE;\n  // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,\n  //                                     this->GetDimensions());}\n  // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}\n  // void ComputeBounds() VTK_OVERRIDE;\n  // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest\n\n  publicAPI.getBounds = () =>\n    publicAPI.extentToBounds(publicAPI.getSpatialExtent());\n\n  publicAPI.extentToBounds = (ex) => {\n    // prettier-ignore\n    const corners = [\n      [ex[0], ex[2], ex[4]],\n      [ex[1], ex[2], ex[4]],\n      [ex[0], ex[3], ex[4]],\n      [ex[1], ex[3], ex[4]],\n      [ex[0], ex[2], ex[5]],\n      [ex[1], ex[2], ex[5]],\n      [ex[0], ex[3], ex[5]],\n      [ex[1], ex[3], ex[5]]\n    ];\n\n    const bounds = [...vtkBoundingBox.INIT_BOUNDS];\n    const vout = [];\n    for (let i = 0; i < 8; ++i) {\n      publicAPI.indexToWorld(corners[i], vout);\n      vtkBoundingBox.addPoint(bounds, ...vout);\n    }\n    return bounds;\n  };\n\n  publicAPI.getSpatialExtent = () =>\n    vtkBoundingBox.inflate([...model.extent], 0.5);\n\n  // Internal, shouldn't need to call this manually.\n  publicAPI.computeTransforms = () => {\n    mat4.fromTranslation(model.indexToWorld, model.origin);\n\n    model.indexToWorld[0] = model.direction[0];\n    model.indexToWorld[1] = model.direction[1];\n    model.indexToWorld[2] = model.direction[2];\n\n    model.indexToWorld[4] = model.direction[3];\n    model.indexToWorld[5] = model.direction[4];\n    model.indexToWorld[6] = model.direction[5];\n\n    model.indexToWorld[8] = model.direction[6];\n    model.indexToWorld[9] = model.direction[7];\n    model.indexToWorld[10] = model.direction[8];\n\n    mat4.scale(model.indexToWorld, model.indexToWorld, model.spacing);\n\n    mat4.invert(model.worldToIndex, model.indexToWorld);\n  };\n\n  //\n  // The direction matrix is a 3x3 basis for the I, J, K axes\n  // of the image. The rows of the matrix correspond to the\n  // axes directions in world coordinates. Direction must\n  // form an orthonormal basis, results are undefined if\n  // it is not.\n  //\n  publicAPI.setDirection = (...args) => {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n\n    let array = args;\n    // allow an array passed as a single arg.\n    if (\n      array.length === 1 &&\n      (Array.isArray(array[0]) ||\n        array[0].constructor === Float32Array ||\n        array[0].constructor === Float64Array)\n    ) {\n      array = array[0];\n    }\n\n    if (array.length !== 9) {\n      throw new RangeError('Invalid number of values for array setter');\n    }\n    let changeDetected = false;\n    model.direction.forEach((item, index) => {\n      if (item !== array[index]) {\n        if (changeDetected) {\n          return;\n        }\n        changeDetected = true;\n      }\n    });\n\n    if (changeDetected) {\n      for (let i = 0; i < 9; ++i) {\n        model.direction[i] = array[i];\n      }\n      publicAPI.modified();\n    }\n    return true;\n  };\n\n  publicAPI.indexToWorld = (ain, aout = []) => {\n    vec3.transformMat4(aout, ain, model.indexToWorld);\n    return aout;\n  };\n  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;\n\n  publicAPI.worldToIndex = (ain, aout = []) => {\n    vec3.transformMat4(aout, ain, model.worldToIndex);\n    return aout;\n  };\n  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;\n\n  publicAPI.indexToWorldBounds = (bin, bout = []) => {\n    const in1 = [0, 0, 0];\n    const in2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bin, in1, in2);\n\n    const out1 = [0, 0, 0];\n    const out2 = [0, 0, 0];\n    vec3.transformMat4(out1, in1, model.indexToWorld);\n    vec3.transformMat4(out2, in2, model.indexToWorld);\n\n    return vtkMath.computeBoundsFromPoints(out1, out2, bout);\n  };\n\n  publicAPI.worldToIndexBounds = (bin, bout = []) => {\n    const in1 = [0, 0, 0];\n    const in2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bin, in1, in2);\n\n    const out1 = [0, 0, 0];\n    const out2 = [0, 0, 0];\n    vec3.transformMat4(out1, in1, model.worldToIndex);\n    vec3.transformMat4(out2, in2, model.worldToIndex);\n\n    return vtkMath.computeBoundsFromPoints(out1, out2, bout);\n  };\n\n  // Make sure the transform is correct\n  publicAPI.onModified(publicAPI.computeTransforms);\n  publicAPI.computeTransforms();\n\n  publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());\n\n  publicAPI.computeHistogram = (worldBounds, voxelFunc = null) => {\n    const bounds = [0, 0, 0, 0, 0, 0];\n    publicAPI.worldToIndexBounds(worldBounds, bounds);\n\n    const point1 = [0, 0, 0];\n    const point2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);\n\n    vtkMath.roundVector(point1, point1);\n    vtkMath.roundVector(point2, point2);\n\n    const dimensions = publicAPI.getDimensions();\n\n    vtkMath.clampVector(\n      point1,\n      [0, 0, 0],\n      [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1],\n      point1\n    );\n    vtkMath.clampVector(\n      point2,\n      [0, 0, 0],\n      [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1],\n      point2\n    );\n\n    const yStride = dimensions[0];\n    const zStride = dimensions[0] * dimensions[1];\n\n    const pixels = publicAPI.getPointData().getScalars().getData();\n\n    let maximum = -Infinity;\n    let minimum = Infinity;\n    let sumOfSquares = 0;\n    let isum = 0;\n    let inum = 0;\n\n    for (let z = point1[2]; z <= point2[2]; z++) {\n      for (let y = point1[1]; y <= point2[1]; y++) {\n        let index = point1[0] + y * yStride + z * zStride;\n        for (let x = point1[0]; x <= point2[0]; x++) {\n          if (!voxelFunc || voxelFunc([x, y, z], bounds)) {\n            const pixel = pixels[index];\n\n            if (pixel > maximum) maximum = pixel;\n            if (pixel < minimum) minimum = pixel;\n            sumOfSquares += pixel * pixel;\n            isum += pixel;\n            inum += 1;\n          }\n\n          ++index;\n        }\n      }\n    }\n\n    const average = inum > 0 ? isum / inum : 0;\n    const variance = inum\n      ? Math.abs(sumOfSquares / inum - average * average)\n      : 0;\n    const sigma = Math.sqrt(variance);\n\n    return {\n      minimum,\n      maximum,\n      average,\n      variance,\n      sigma,\n      count: inum,\n    };\n  };\n\n  // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).\n  // Scalar data could be tuples for color information?\n  publicAPI.computeIncrements = (extent, numberOfComponents = 1) => {\n    const increments = [];\n    let incr = numberOfComponents;\n\n    // Calculate array increment offsets\n    // similar to c++ vtkImageData::ComputeIncrements\n    for (let idx = 0; idx < 3; ++idx) {\n      increments[idx] = incr;\n      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;\n    }\n    return increments;\n  };\n\n  /**\n   * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.\n   * @return {Number} the corresponding flattened index in the scalar array\n   */\n  publicAPI.computeOffsetIndex = ([i, j, k]) => {\n    const extent = publicAPI.getExtent();\n    const numberOfComponents = publicAPI\n      .getPointData()\n      .getScalars()\n      .getNumberOfComponents();\n    const increments = publicAPI.computeIncrements(extent, numberOfComponents);\n    // Use the array increments to find the pixel index\n    // similar to c++ vtkImageData::GetArrayPointer\n    // Math.floor to catch \"practically 0\" e^-15 scenarios.\n    return Math.floor(\n      (Math.round(i) - extent[0]) * increments[0] +\n        (Math.round(j) - extent[2]) * increments[1] +\n        (Math.round(k) - extent[4]) * increments[2]\n    );\n  };\n\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @return {Number|NaN} the corresponding pixel's index in the scalar array\n   */\n  publicAPI.getOffsetIndexFromWorld = (xyz) => {\n    const extent = publicAPI.getExtent();\n    const index = publicAPI.worldToIndex(xyz);\n\n    // Confirm indexed i,j,k coords are within the bounds of the volume\n    for (let idx = 0; idx < 3; ++idx) {\n      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {\n        vtkErrorMacro(\n          `GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`\n        );\n        return NaN;\n      }\n    }\n\n    // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream\n    return publicAPI.computeOffsetIndex(index);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @param {Number?} comp the scalar component index for multi-component scalars\n   * @return {Number|NaN} the corresponding pixel's scalar value\n   */\n  publicAPI.getScalarValueFromWorld = (xyz, comp = 0) => {\n    const numberOfComponents = publicAPI\n      .getPointData()\n      .getScalars()\n      .getNumberOfComponents();\n    if (comp < 0 || comp >= numberOfComponents) {\n      vtkErrorMacro(\n        `GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`\n      );\n      return NaN;\n    }\n    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);\n    if (Number.isNaN(offsetIndex)) {\n      // VTK Error Macro will have been tripped already, no need to do it again,\n      return offsetIndex;\n    }\n\n    return publicAPI\n      .getPointData()\n      .getScalars()\n      .getComponent(offsetIndex, comp);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  direction: null, // a mat3\n  indexToWorld: null, // a mat4\n  worldToIndex: null, // a mat4\n  spacing: [1.0, 1.0, 1.0],\n  origin: [0.0, 0.0, 0.0],\n  extent: [0, -1, 0, -1, 0, -1],\n  dataDescription: StructuredType.EMPTY,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkDataSet.extend(publicAPI, model, initialValues);\n\n  if (!model.direction) {\n    model.direction = mat3.identity(new Float64Array(9));\n  } else if (Array.isArray(model.direction)) {\n    model.direction = new Float64Array(model.direction.slice(0, 9));\n  }\n\n  model.indexToWorld = new Float64Array(16);\n  model.worldToIndex = new Float64Array(16);\n\n  // Set/Get methods\n  macro.get(publicAPI, model, ['direction', 'indexToWorld', 'worldToIndex']);\n  macro.setGetArray(publicAPI, model, ['origin', 'spacing'], 3);\n  macro.getArray(publicAPI, model, ['extent'], 6);\n\n  // Object specific methods\n  vtkImageData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkImageData');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}