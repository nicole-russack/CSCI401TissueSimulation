{"ast":null,"code":"import vtk from 'vtk.js/Sources/vtk';\nimport macro from 'vtk.js/Sources/macros';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nconst {\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro; // ----------------------------------------------------------------------------\n// vtkFieldData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkFieldData(publicAPI, model) {\n  model.classHierarchy.push('vtkFieldData');\n  const superGetState = publicAPI.getState; // Decode serialized data if any\n\n  if (model.arrays) {\n    model.arrays = model.arrays.map(item => ({\n      data: vtk(item.data)\n    }));\n  }\n\n  publicAPI.initialize = () => {\n    publicAPI.initializeFields();\n    publicAPI.copyAllOn();\n    publicAPI.clearFieldFlags();\n  };\n\n  publicAPI.initializeFields = () => {\n    model.arrays = [];\n    model.copyFieldFlags = {};\n    publicAPI.modified();\n  };\n\n  publicAPI.copyStructure = other => {\n    publicAPI.initializeFields();\n    model.copyFieldFlags = other.getCopyFieldFlags().map(x => x); // Deep-copy\n\n    model.arrays = other.arrays().map(x => ({\n      array: x\n    })); // Deep-copy\n    // TODO: Copy array information objects (once we support information objects)\n  };\n\n  publicAPI.getNumberOfArrays = () => model.arrays.length;\n\n  publicAPI.getNumberOfActiveArrays = () => model.arrays.length;\n\n  publicAPI.addArray = arr => {\n    const name = arr.getName();\n    const {\n      array,\n      index\n    } = publicAPI.getArrayWithIndex(name);\n\n    if (array != null) {\n      model.arrays[index] = {\n        data: arr\n      };\n      return index;\n    }\n\n    model.arrays = [].concat(model.arrays, {\n      data: arr\n    });\n    return model.arrays.length - 1;\n  };\n\n  publicAPI.removeAllArrays = () => {\n    model.arrays = [];\n  };\n\n  publicAPI.removeArray = arrayName => {\n    model.arrays = model.arrays.filter(entry => arrayName !== entry.data.getName());\n  };\n\n  publicAPI.removeArrayByIndex = arrayIdx => {\n    model.arrays = model.arrays.filter((entry, idx) => idx !== arrayIdx);\n  };\n\n  publicAPI.getArrays = () => model.arrays.map(entry => entry.data);\n\n  publicAPI.getArray = arraySpec => typeof arraySpec === 'number' ? publicAPI.getArrayByIndex(arraySpec) : publicAPI.getArrayByName(arraySpec);\n\n  publicAPI.getArrayByName = arrayName => model.arrays.reduce((a, b, i) => b.data.getName() === arrayName ? b.data : a, null);\n\n  publicAPI.getArrayWithIndex = arrayName => model.arrays.reduce((a, b, i) => b.data && b.data.getName() === arrayName ? {\n    array: b.data,\n    index: i\n  } : a, {\n    array: null,\n    index: -1\n  });\n\n  publicAPI.getArrayByIndex = idx => idx >= 0 && idx < model.arrays.length ? model.arrays[idx].data : null;\n\n  publicAPI.hasArray = arrayName => publicAPI.getArrayWithIndex(arrayName).index >= 0;\n\n  publicAPI.getArrayName = idx => {\n    const arr = model.arrays[idx];\n    return arr ? arr.data.getName() : '';\n  };\n\n  publicAPI.getCopyFieldFlags = () => model.copyFieldFlags;\n\n  publicAPI.getFlag = arrayName => model.copyFieldFlags[arrayName];\n\n  publicAPI.passData = function (other) {\n    let fromId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    let toId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n    other.getArrays().forEach(arr => {\n      const copyFlag = publicAPI.getFlag(arr.getName());\n\n      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {\n        let destArr = publicAPI.getArrayByName(arr.getName());\n\n        if (!destArr) {\n          if (fromId < 0 || fromId > arr.getNumberOfTuples()) {\n            // TBD: should this be a deep or a shallow copy?\n            publicAPI.addArray(arr);\n            other.getAttributes(arr).forEach(attrType => {\n              publicAPI.setAttribute(arr, attrType);\n            });\n          } else {\n            const ncomps = arr.getNumberOfComponents();\n            let newSize = arr.getNumberOfValues();\n            const tId = toId > -1 ? toId : fromId;\n\n            if (newSize <= tId * ncomps) {\n              newSize = (tId + 1) * ncomps;\n            }\n\n            destArr = vtkDataArray.newInstance({\n              name: arr.getName(),\n              dataType: arr.getDataType(),\n              numberOfComponents: ncomps,\n              values: macro.newTypedArray(arr.getDataType(), newSize),\n              size: 0\n            });\n            destArr.insertTuple(tId, arr.getTuple(fromId));\n            publicAPI.addArray(destArr);\n            other.getAttributes(arr).forEach(attrType => {\n              publicAPI.setAttribute(destArr, attrType);\n            });\n          }\n        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {\n          if (fromId > -1 && fromId < arr.getNumberOfTuples()) {\n            const tId = toId > -1 ? toId : fromId;\n            destArr.insertTuple(tId, arr.getTuple(fromId));\n          } else {\n            // if `fromId` is not provided, just copy all (or as much possible)\n            // from `arr` to `destArr`.\n            destArr.insertTuples(0, arr.getTuples());\n          }\n        } else {\n          vtkErrorMacro('Unhandled case in passData');\n        }\n      }\n    });\n  };\n\n  publicAPI.interpolateData = function (other) {\n    let fromId1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    let fromId2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n    let toId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n    let t = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    other.getArrays().forEach(arr => {\n      const copyFlag = publicAPI.getFlag(arr.getName());\n\n      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {\n        let destArr = publicAPI.getArrayByName(arr.getName());\n\n        if (!destArr) {\n          if (fromId1 < 0 || fromId2 < 0 || fromId1 > arr.getNumberOfTuples()) {\n            // TBD: should this be a deep or a shallow copy?\n            publicAPI.addArray(arr);\n            other.getAttributes(arr).forEach(attrType => {\n              publicAPI.setAttribute(arr, attrType);\n            });\n          } else {\n            const ncomps = arr.getNumberOfComponents();\n            let newSize = arr.getNumberOfValues(); // TODO: Is this supposed to happen?\n\n            const tId = toId > -1 ? toId : fromId1;\n\n            if (newSize <= tId * ncomps) {\n              newSize = (tId + 1) * ncomps;\n            }\n\n            destArr = vtkDataArray.newInstance({\n              name: arr.getName(),\n              dataType: arr.getDataType(),\n              numberOfComponents: ncomps,\n              values: macro.newTypedArray(arr.getDataType(), newSize),\n              size: 0\n            });\n            destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);\n            publicAPI.addArray(destArr);\n            other.getAttributes(arr).forEach(attrType => {\n              publicAPI.setAttribute(destArr, attrType);\n            });\n          }\n        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {\n          if (fromId1 > -1 && fromId1 < arr.getNumberOfTuples()) {\n            const tId = toId > -1 ? toId : fromId1;\n            destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);\n            vtkWarningMacro('Unexpected case in interpolateData');\n          } else {\n            // if `fromId` is not provided, just copy all (or as much possible)\n            // from `arr` to `destArr`.\n            destArr.insertTuples(arr.getTuples());\n          }\n        } else {\n          vtkErrorMacro('Unhandled case in interpolateData');\n        }\n      }\n    });\n  };\n\n  publicAPI.copyFieldOn = arrayName => {\n    model.copyFieldFlags[arrayName] = true;\n  };\n\n  publicAPI.copyFieldOff = arrayName => {\n    model.copyFieldFlags[arrayName] = false;\n  };\n\n  publicAPI.copyAllOn = () => {\n    if (!model.doCopyAllOn || model.doCopyAllOff) {\n      model.doCopyAllOn = true;\n      model.doCopyAllOff = false;\n      publicAPI.modified();\n    }\n  };\n\n  publicAPI.copyAllOff = () => {\n    if (model.doCopyAllOn || !model.doCopyAllOff) {\n      model.doCopyAllOn = false;\n      model.doCopyAllOff = true;\n      publicAPI.modified();\n    }\n  };\n\n  publicAPI.clearFieldFlags = () => {\n    model.copyFieldFlags = {};\n  };\n\n  publicAPI.deepCopy = other => {\n    model.arrays = other.getArrays().map(arr => {\n      const arrNew = arr.newClone();\n      arrNew.deepCopy(arr);\n      return {\n        data: arrNew\n      };\n    });\n  };\n\n  publicAPI.copyFlags = other => other.getCopyFieldFlags().map(x => x); // TODO: publicAPI.squeeze = () => model.arrays.forEach(entry => entry.data.squeeze());\n\n\n  publicAPI.reset = () => model.arrays.forEach(entry => entry.data.reset()); // TODO: getActualMemorySize\n\n\n  publicAPI.getMTime = () => model.arrays.reduce((a, b) => b.data.getMTime() > a ? b.data.getMTime() : a, model.mtime); // TODO: publicAPI.getField = (ids, other) => { copy ids from other into this model's arrays }\n  // TODO: publicAPI.getArrayContainingComponent = (component) => ...\n\n\n  publicAPI.getNumberOfComponents = () => model.arrays.reduce((a, b) => a + b.data.getNumberOfComponents(), 0);\n\n  publicAPI.getNumberOfTuples = () => model.arrays.length > 0 ? model.arrays[0].getNumberOfTuples() : 0;\n\n  publicAPI.getState = () => {\n    const result = superGetState();\n\n    if (result) {\n      result.arrays = model.arrays.map(item => ({\n        data: item.data.getState()\n      }));\n    }\n\n    return result;\n  };\n}\n\nconst DEFAULT_VALUES = {\n  arrays: [],\n  copyFieldFlags: [],\n  // fields not to copy\n  doCopyAllOn: true,\n  doCopyAllOff: false\n};\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  vtkFieldData(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkFieldData'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["vtk","macro","vtkDataArray","vtkErrorMacro","vtkWarningMacro","vtkFieldData","publicAPI","model","classHierarchy","push","superGetState","getState","arrays","map","item","data","initialize","initializeFields","copyAllOn","clearFieldFlags","copyFieldFlags","modified","copyStructure","other","getCopyFieldFlags","x","array","getNumberOfArrays","length","getNumberOfActiveArrays","addArray","arr","name","getName","index","getArrayWithIndex","concat","removeAllArrays","removeArray","arrayName","filter","entry","removeArrayByIndex","arrayIdx","idx","getArrays","getArray","arraySpec","getArrayByIndex","getArrayByName","reduce","a","b","i","hasArray","getArrayName","getFlag","passData","fromId","toId","forEach","copyFlag","doCopyAllOff","destArr","getNumberOfTuples","getAttributes","attrType","setAttribute","ncomps","getNumberOfComponents","newSize","getNumberOfValues","tId","newInstance","dataType","getDataType","numberOfComponents","values","newTypedArray","size","insertTuple","getTuple","insertTuples","getTuples","interpolateData","fromId1","fromId2","t","interpolateTuple","copyFieldOn","copyFieldOff","doCopyAllOn","copyAllOff","deepCopy","arrNew","newClone","copyFlags","reset","getMTime","mtime","result","DEFAULT_VALUES","extend","initialValues","Object","assign","obj"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Common/DataModel/DataSetAttributes/FieldData.js"],"sourcesContent":["import vtk from 'vtk.js/Sources/vtk';\nimport macro from 'vtk.js/Sources/macros';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\n\nconst { vtkErrorMacro, vtkWarningMacro } = macro;\n\n// ----------------------------------------------------------------------------\n// vtkFieldData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkFieldData(publicAPI, model) {\n  model.classHierarchy.push('vtkFieldData');\n  const superGetState = publicAPI.getState;\n\n  // Decode serialized data if any\n  if (model.arrays) {\n    model.arrays = model.arrays.map((item) => ({ data: vtk(item.data) }));\n  }\n\n  publicAPI.initialize = () => {\n    publicAPI.initializeFields();\n    publicAPI.copyAllOn();\n    publicAPI.clearFieldFlags();\n  };\n\n  publicAPI.initializeFields = () => {\n    model.arrays = [];\n    model.copyFieldFlags = {};\n    publicAPI.modified();\n  };\n\n  publicAPI.copyStructure = (other) => {\n    publicAPI.initializeFields();\n    model.copyFieldFlags = other.getCopyFieldFlags().map((x) => x); // Deep-copy\n    model.arrays = other.arrays().map((x) => ({ array: x })); // Deep-copy\n    // TODO: Copy array information objects (once we support information objects)\n  };\n\n  publicAPI.getNumberOfArrays = () => model.arrays.length;\n  publicAPI.getNumberOfActiveArrays = () => model.arrays.length;\n  publicAPI.addArray = (arr) => {\n    const name = arr.getName();\n    const { array, index } = publicAPI.getArrayWithIndex(name);\n    if (array != null) {\n      model.arrays[index] = { data: arr };\n      return index;\n    }\n    model.arrays = [].concat(model.arrays, { data: arr });\n    return model.arrays.length - 1;\n  };\n  publicAPI.removeAllArrays = () => {\n    model.arrays = [];\n  };\n  publicAPI.removeArray = (arrayName) => {\n    model.arrays = model.arrays.filter(\n      (entry) => arrayName !== entry.data.getName()\n    );\n  };\n  publicAPI.removeArrayByIndex = (arrayIdx) => {\n    model.arrays = model.arrays.filter((entry, idx) => idx !== arrayIdx);\n  };\n  publicAPI.getArrays = () => model.arrays.map((entry) => entry.data);\n  publicAPI.getArray = (arraySpec) =>\n    typeof arraySpec === 'number'\n      ? publicAPI.getArrayByIndex(arraySpec)\n      : publicAPI.getArrayByName(arraySpec);\n  publicAPI.getArrayByName = (arrayName) =>\n    model.arrays.reduce(\n      (a, b, i) => (b.data.getName() === arrayName ? b.data : a),\n      null\n    );\n  publicAPI.getArrayWithIndex = (arrayName) =>\n    model.arrays.reduce(\n      (a, b, i) =>\n        b.data && b.data.getName() === arrayName\n          ? { array: b.data, index: i }\n          : a,\n      { array: null, index: -1 }\n    );\n  publicAPI.getArrayByIndex = (idx) =>\n    idx >= 0 && idx < model.arrays.length ? model.arrays[idx].data : null;\n  publicAPI.hasArray = (arrayName) =>\n    publicAPI.getArrayWithIndex(arrayName).index >= 0;\n  publicAPI.getArrayName = (idx) => {\n    const arr = model.arrays[idx];\n    return arr ? arr.data.getName() : '';\n  };\n  publicAPI.getCopyFieldFlags = () => model.copyFieldFlags;\n  publicAPI.getFlag = (arrayName) => model.copyFieldFlags[arrayName];\n  publicAPI.passData = (other, fromId = -1, toId = -1) => {\n    other.getArrays().forEach((arr) => {\n      const copyFlag = publicAPI.getFlag(arr.getName());\n      if (\n        copyFlag !== false &&\n        !(model.doCopyAllOff && copyFlag !== true) &&\n        arr\n      ) {\n        let destArr = publicAPI.getArrayByName(arr.getName());\n        if (!destArr) {\n          if (fromId < 0 || fromId > arr.getNumberOfTuples()) {\n            // TBD: should this be a deep or a shallow copy?\n            publicAPI.addArray(arr);\n            other.getAttributes(arr).forEach((attrType) => {\n              publicAPI.setAttribute(arr, attrType);\n            });\n          } else {\n            const ncomps = arr.getNumberOfComponents();\n            let newSize = arr.getNumberOfValues();\n            const tId = toId > -1 ? toId : fromId;\n            if (newSize <= tId * ncomps) {\n              newSize = (tId + 1) * ncomps;\n            }\n            destArr = vtkDataArray.newInstance({\n              name: arr.getName(),\n              dataType: arr.getDataType(),\n              numberOfComponents: ncomps,\n              values: macro.newTypedArray(arr.getDataType(), newSize),\n              size: 0,\n            });\n            destArr.insertTuple(tId, arr.getTuple(fromId));\n            publicAPI.addArray(destArr);\n            other.getAttributes(arr).forEach((attrType) => {\n              publicAPI.setAttribute(destArr, attrType);\n            });\n          }\n        } else if (\n          arr.getNumberOfComponents() === destArr.getNumberOfComponents()\n        ) {\n          if (fromId > -1 && fromId < arr.getNumberOfTuples()) {\n            const tId = toId > -1 ? toId : fromId;\n            destArr.insertTuple(tId, arr.getTuple(fromId));\n          } else {\n            // if `fromId` is not provided, just copy all (or as much possible)\n            // from `arr` to `destArr`.\n            destArr.insertTuples(0, arr.getTuples());\n          }\n        } else {\n          vtkErrorMacro('Unhandled case in passData');\n        }\n      }\n    });\n  };\n\n  publicAPI.interpolateData = (\n    other,\n    fromId1 = -1,\n    fromId2 = -1,\n    toId = -1,\n    t = 0.5\n  ) => {\n    other.getArrays().forEach((arr) => {\n      const copyFlag = publicAPI.getFlag(arr.getName());\n      if (\n        copyFlag !== false &&\n        !(model.doCopyAllOff && copyFlag !== true) &&\n        arr\n      ) {\n        let destArr = publicAPI.getArrayByName(arr.getName());\n        if (!destArr) {\n          if (fromId1 < 0 || fromId2 < 0 || fromId1 > arr.getNumberOfTuples()) {\n            // TBD: should this be a deep or a shallow copy?\n            publicAPI.addArray(arr);\n            other.getAttributes(arr).forEach((attrType) => {\n              publicAPI.setAttribute(arr, attrType);\n            });\n          } else {\n            const ncomps = arr.getNumberOfComponents();\n            let newSize = arr.getNumberOfValues();\n            // TODO: Is this supposed to happen?\n            const tId = toId > -1 ? toId : fromId1;\n            if (newSize <= tId * ncomps) {\n              newSize = (tId + 1) * ncomps;\n            }\n            destArr = vtkDataArray.newInstance({\n              name: arr.getName(),\n              dataType: arr.getDataType(),\n              numberOfComponents: ncomps,\n              values: macro.newTypedArray(arr.getDataType(), newSize),\n              size: 0,\n            });\n            destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);\n            publicAPI.addArray(destArr);\n            other.getAttributes(arr).forEach((attrType) => {\n              publicAPI.setAttribute(destArr, attrType);\n            });\n          }\n        } else if (\n          arr.getNumberOfComponents() === destArr.getNumberOfComponents()\n        ) {\n          if (fromId1 > -1 && fromId1 < arr.getNumberOfTuples()) {\n            const tId = toId > -1 ? toId : fromId1;\n            destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);\n            vtkWarningMacro('Unexpected case in interpolateData');\n          } else {\n            // if `fromId` is not provided, just copy all (or as much possible)\n            // from `arr` to `destArr`.\n            destArr.insertTuples(arr.getTuples());\n          }\n        } else {\n          vtkErrorMacro('Unhandled case in interpolateData');\n        }\n      }\n    });\n  };\n  publicAPI.copyFieldOn = (arrayName) => {\n    model.copyFieldFlags[arrayName] = true;\n  };\n  publicAPI.copyFieldOff = (arrayName) => {\n    model.copyFieldFlags[arrayName] = false;\n  };\n  publicAPI.copyAllOn = () => {\n    if (!model.doCopyAllOn || model.doCopyAllOff) {\n      model.doCopyAllOn = true;\n      model.doCopyAllOff = false;\n      publicAPI.modified();\n    }\n  };\n  publicAPI.copyAllOff = () => {\n    if (model.doCopyAllOn || !model.doCopyAllOff) {\n      model.doCopyAllOn = false;\n      model.doCopyAllOff = true;\n      publicAPI.modified();\n    }\n  };\n  publicAPI.clearFieldFlags = () => {\n    model.copyFieldFlags = {};\n  };\n  publicAPI.deepCopy = (other) => {\n    model.arrays = other.getArrays().map((arr) => {\n      const arrNew = arr.newClone();\n      arrNew.deepCopy(arr);\n      return { data: arrNew };\n    });\n  };\n  publicAPI.copyFlags = (other) => other.getCopyFieldFlags().map((x) => x);\n  // TODO: publicAPI.squeeze = () => model.arrays.forEach(entry => entry.data.squeeze());\n  publicAPI.reset = () => model.arrays.forEach((entry) => entry.data.reset());\n  // TODO: getActualMemorySize\n  publicAPI.getMTime = () =>\n    model.arrays.reduce(\n      (a, b) => (b.data.getMTime() > a ? b.data.getMTime() : a),\n      model.mtime\n    );\n  // TODO: publicAPI.getField = (ids, other) => { copy ids from other into this model's arrays }\n  // TODO: publicAPI.getArrayContainingComponent = (component) => ...\n  publicAPI.getNumberOfComponents = () =>\n    model.arrays.reduce((a, b) => a + b.data.getNumberOfComponents(), 0);\n  publicAPI.getNumberOfTuples = () =>\n    model.arrays.length > 0 ? model.arrays[0].getNumberOfTuples() : 0;\n\n  publicAPI.getState = () => {\n    const result = superGetState();\n    if (result) {\n      result.arrays = model.arrays.map((item) => ({\n        data: item.data.getState(),\n      }));\n    }\n    return result;\n  };\n}\n\nconst DEFAULT_VALUES = {\n  arrays: [],\n  copyFieldFlags: [], // fields not to copy\n  doCopyAllOn: true,\n  doCopyAllOff: false,\n};\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  macro.obj(publicAPI, model);\n\n  vtkFieldData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkFieldData');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}