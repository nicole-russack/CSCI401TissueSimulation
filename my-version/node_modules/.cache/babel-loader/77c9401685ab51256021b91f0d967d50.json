{"ast":null,"code":"import { mat4 } from 'gl-matrix';\nimport Constants from 'vtk.js/Sources/Rendering/Core/ImageMapper/Constants';\nimport * as macro from 'vtk.js/Sources/macros';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nimport { VtkDataTypes } from 'vtk.js/Sources/Common/Core/DataArray/Constants';\nimport vtkHelper from 'vtk.js/Sources/Rendering/OpenGL/Helper';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkOpenGLTexture from 'vtk.js/Sources/Rendering/OpenGL/Texture';\nimport vtkShaderProgram from 'vtk.js/Sources/Rendering/OpenGL/ShaderProgram';\nimport vtkViewNode from 'vtk.js/Sources/Rendering/SceneGraph/ViewNode';\nimport { Representation } from 'vtk.js/Sources/Rendering/Core/Property/Constants';\nimport { Wrap, Filter } from 'vtk.js/Sources/Rendering/OpenGL/Texture/Constants';\nimport { InterpolationType } from 'vtk.js/Sources/Rendering/Core/ImageProperty/Constants';\nimport vtkPolyDataVS from 'vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataVS.glsl';\nimport vtkPolyDataFS from 'vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl';\nimport vtkReplacementShaderMapper from 'vtk.js/Sources/Rendering/OpenGL/ReplacementShaderMapper';\nimport { registerOverride } from 'vtk.js/Sources/Rendering/OpenGL/ViewNodeFactory';\nconst {\n  vtkErrorMacro\n} = macro;\nconst {\n  SlicingMode\n} = Constants; // ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n\nfunction computeFnToString(property, fn, numberOfComponents) {\n  const pwfun = fn.apply(property);\n\n  if (pwfun) {\n    const iComps = property.getIndependentComponents();\n    return `${property.getMTime()}-${iComps}-${numberOfComponents}`;\n  }\n\n  return '0';\n} // ----------------------------------------------------------------------------\n// vtkOpenGLImageMapper methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkOpenGLImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLImageMapper');\n\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model.openGLImageSlice = publicAPI.getFirstAncestorOfType('vtkOpenGLImageSlice');\n      model.openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model.openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      const ren = model.openGLRenderer.getRenderable();\n      model.openGLCamera = model.openGLRenderer.getViewNodeFor(ren.getActiveCamera()); // is slice set by the camera\n\n      if (model.renderable.getSliceAtFocalPoint()) {\n        model.renderable.setSliceFromCamera(ren.getActiveCamera());\n      }\n    }\n  };\n\n  publicAPI.translucentPass = (prepass, renderPass) => {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n\n  publicAPI.opaqueZBufferPass = prepass => {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n\n  publicAPI.getCoincidentParameters = (ren, actor) => {\n    if (model.renderable.getResolveCoincidentTopology()) {\n      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n    }\n\n    return null;\n  }; // Renders myself\n\n\n  publicAPI.render = () => {\n    const actor = model.openGLImageSlice.getRenderable();\n    const ren = model.openGLRenderer.getRenderable();\n    publicAPI.renderPiece(ren, actor);\n  };\n\n  publicAPI.buildShaders = (shaders, ren, actor) => {\n    publicAPI.getShaderTemplate(shaders, ren, actor); // apply any renderPassReplacements\n\n    if (model.lastRenderPassShaderReplacement) {\n      model.lastRenderPassShaderReplacement(shaders);\n    }\n\n    publicAPI.replaceShaderValues(shaders, ren, actor);\n  };\n\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkPolyDataVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', 'tcoordVCVSOutput = tcoordMC;').result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;').result;\n    const tNumComp = model.openGLTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n    let tcoordDec = ['varying vec2 tcoordVCVSOutput;', // color shift and scale\n    'uniform float cshift0;', 'uniform float cscale0;', // pwf shift and scale\n    'uniform float pwfshift0;', 'uniform float pwfscale0;', 'uniform sampler2D texture1;', 'uniform sampler2D colorTexture1;', 'uniform sampler2D pwfTexture1;', 'uniform float opacity;'];\n\n    if (iComps) {\n      for (let comp = 1; comp < tNumComp; comp++) {\n        tcoordDec = tcoordDec.concat([// color shift and scale\n        `uniform float cshift${comp};`, `uniform float cscale${comp};`, // weighting shift and scale\n        `uniform float pwfshift${comp};`, `uniform float pwfscale${comp};`]);\n      } // the heights defined below are the locations\n      // for the up to four components of the tfuns\n      // the tfuns have a height of 2XnumComps pixels so the\n      // values are computed to hit the middle of the two rows\n      // for that component\n\n\n      switch (tNumComp) {\n        case 1:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', '#define height0 0.5']);\n          break;\n\n        case 2:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', '#define height0 0.25', '#define height1 0.75']);\n          break;\n\n        case 3:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', '#define height0 0.17', '#define height1 0.5', '#define height2 0.83']);\n          break;\n\n        case 4:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', 'uniform float mix3;', '#define height0 0.125', '#define height1 0.375', '#define height2 0.625', '#define height3 0.875']);\n          break;\n\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    }\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', tcoordDec).result;\n\n    if (iComps) {\n      const rgba = ['r', 'g', 'b', 'a'];\n      let tcoordImpl = ['vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);'];\n\n      for (let comp = 0; comp < tNumComp; comp++) {\n        tcoordImpl = tcoordImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);\n      }\n\n      switch (tNumComp) {\n        case 1:\n          tcoordImpl = tcoordImpl.concat(['gl_FragData[0] = vec4(tcolor0.rgb, opacity);']);\n          break;\n\n        case 2:\n          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);']);\n          break;\n\n        case 3:\n          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);']);\n          break;\n\n        case 4:\n          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);']);\n          break;\n\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', tcoordImpl).result;\n    } else {\n      // dependent components\n      switch (tNumComp) {\n        case 1:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['float intensity = texture2D(texture1, tcoordVCVSOutput).r;', 'vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;', 'float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;', 'gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);']).result;\n          break;\n\n        case 2:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', 'float intensity = tcolor.r*cscale0 + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);']).result;\n          break;\n\n        case 3:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);']).result;\n          break;\n\n        default:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);']).result;\n      }\n    }\n\n    if (model.haveSeenDepthRequest) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n    }\n\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    publicAPI.replaceShaderClip(shaders, ren, actor);\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n  };\n\n  publicAPI.replaceShaderClip = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n\n      if (numClipPlanes > 6) {\n        macro.vtkErrorMacro('OpenGL has a limit of 6 clipping planes');\n        numClipPlanes = 6;\n      }\n\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'uniform vec4 clipPlanes[6];', 'varying float clipDistancesVSOutput[6];']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'varying float clipDistancesVSOutput[6];']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;\n    }\n\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n  };\n\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    const tNumComp = model.openGLTexture.getComponents();\n    const iComp = actor.getProperty().getIndependentComponents(); // has the render pass shader replacement changed? Two options\n\n    let needRebuild = false;\n\n    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement) {\n      needRebuild = true;\n      model.lastRenderPassShaderReplacement = null;\n    }\n\n    if (model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {\n      model.lastRenderPassShaderReplacement = model.currentRenderPass.getShaderReplacement();\n      needRebuild = true;\n    }\n\n    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      model.lastTextureComponents = tNumComp;\n      model.lastIndependentComponents = iComp;\n      return true;\n    }\n\n    return false;\n  };\n\n  publicAPI.updateShaders = (cellBO, ren, actor) => {\n    model.lastBoundBO = cellBO; // has something changed that would require us to recreate the shader?\n\n    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {\n      const shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      publicAPI.buildShaders(shaders, ren, actor); // compile and bind the program if needed\n\n      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry); // if the shader changed reinitialize the VAO\n\n\n      if (newShader !== cellBO.getProgram()) {\n        cellBO.setProgram(newShader); // reset the VAO as the shader has changed\n\n        cellBO.getVAO().releaseGraphicsResources();\n      }\n\n      cellBO.getShaderSourceTime().modified();\n    } else {\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());\n    }\n\n    cellBO.getVAO().bind();\n    publicAPI.setMapperShaderParameters(cellBO, ren, actor);\n    publicAPI.setCameraShaderParameters(cellBO, ren, actor);\n    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);\n  };\n\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    // Now to update the VAO too, if necessary.\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexMC in shader VAO.');\n        }\n      }\n\n      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), model.context.FALSE)) {\n          vtkErrorMacro('Error setting tcoordMC in shader VAO.');\n        }\n      }\n\n      cellBO.getAttributeUpdateTime().modified();\n    }\n\n    const texUnit = model.openGLTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('texture1', texUnit);\n    const numComp = model.openGLTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n\n    if (iComps) {\n      for (let i = 0; i < numComp; i++) {\n        cellBO.getProgram().setUniformf(`mix${i}`, actor.getProperty().getComponentWeight(i));\n      }\n    }\n\n    const oglShiftScale = model.openGLTexture.getShiftAndScale(); // three levels of shift scale combined into one\n    // for performance in the fragment shader\n\n    for (let i = 0; i < numComp; i++) {\n      let cw = actor.getProperty().getColorWindow();\n      let cl = actor.getProperty().getColorLevel();\n      const target = iComps ? i : 0;\n      const cfun = actor.getProperty().getRGBTransferFunction(target);\n\n      if (cfun && actor.getProperty().getUseLookupTableScalarRange()) {\n        const cRange = cfun.getRange();\n        cw = cRange[1] - cRange[0];\n        cl = 0.5 * (cRange[1] + cRange[0]);\n      }\n\n      const scale = oglShiftScale.scale / cw;\n      const shift = (oglShiftScale.shift - cl) / cw + 0.5;\n      cellBO.getProgram().setUniformf(`cshift${i}`, shift);\n      cellBO.getProgram().setUniformf(`cscale${i}`, scale);\n    } // pwf shift/scale\n\n\n    for (let i = 0; i < numComp; i++) {\n      let pwfScale = 1.0;\n      let pwfShift = 0.0;\n      const target = iComps ? i : 0;\n      const pwfun = actor.getProperty().getPiecewiseFunction(target);\n\n      if (pwfun) {\n        const pwfRange = pwfun.getRange();\n        const length = pwfRange[1] - pwfRange[0];\n        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);\n        pwfScale = oglShiftScale.scale / length;\n        pwfShift = (oglShiftScale.shift - mid) / length + 0.5;\n      }\n\n      cellBO.getProgram().setUniformf(`pwfshift${i}`, pwfShift);\n      cellBO.getProgram().setUniformf(`pwfscale${i}`, pwfScale);\n    }\n\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    } // handle coincident\n\n\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      const cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset); // cfactor isn't always used when coffset is.\n\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    }\n\n    const texColorUnit = model.colorTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('colorTexture1', texColorUnit);\n    const texOpacityUnit = model.pwfTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('pwfTexture1', texOpacityUnit);\n\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      // add all the clipping planes\n      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n\n      if (numClipPlanes > 6) {\n        macro.vtkErrorMacro('OpenGL has a limit of 6 clipping planes');\n        numClipPlanes = 6;\n      }\n\n      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n      const mat = inverseShiftScaleMatrix ? mat4.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();\n\n      if (inverseShiftScaleMatrix) {\n        mat4.transpose(mat, mat);\n        mat4.multiply(mat, mat, inverseShiftScaleMatrix);\n        mat4.transpose(mat, mat);\n      } // transform crop plane normal with transpose(inverse(worldToIndex))\n\n\n      mat4.transpose(model.imagemat, model.currentInput.getIndexToWorld());\n      mat4.multiply(model.imagematinv, mat, model.imagemat);\n      const planeEquations = [];\n\n      for (let i = 0; i < numClipPlanes; i++) {\n        const planeEquation = [];\n        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, i, planeEquation);\n\n        for (let j = 0; j < 4; j++) {\n          planeEquations.push(planeEquation[j]);\n        }\n      }\n\n      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);\n      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);\n    }\n  };\n\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    const actMats = model.openGLImageSlice.getKeyMatrices();\n    const image = model.currentInput;\n    const i2wmat4 = image.getIndexToWorld();\n    mat4.multiply(model.imagemat, actMats.mcwc, i2wmat4);\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    mat4.multiply(model.imagemat, keyMats.wcpc, model.imagemat);\n\n    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {\n      const inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();\n      mat4.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);\n    }\n\n    program.setUniformMatrix('MCPCMatrix', model.imagemat);\n  };\n\n  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    const ppty = actor.getProperty();\n    const opacity = ppty.getOpacity();\n    program.setUniformf('opacity', opacity);\n  };\n\n  publicAPI.renderPieceStart = (ren, actor) => {\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor); // Bind the OpenGL, this is shared between the different primitive/cell types.\n\n    model.lastBoundBO = null;\n  };\n\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const gl = model.context; // activate the texture\n\n    model.openGLTexture.activate();\n    model.colorTexture.activate();\n    model.pwfTexture.activate(); // draw polygons\n\n    if (model.tris.getCABO().getElementCount()) {\n      // First we do the triangles, update the shader, set uniforms, etc.\n      publicAPI.updateShaders(model.tris, ren, actor);\n      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n      model.tris.getVAO().release();\n    }\n\n    model.openGLTexture.deactivate();\n    model.colorTexture.deactivate();\n    model.pwfTexture.deactivate();\n  };\n\n  publicAPI.renderPieceFinish = (ren, actor) => {};\n\n  publicAPI.renderPiece = (ren, actor) => {\n    // Make sure that we have been properly initialized.\n    // if (ren.getRenderWindow().checkAbortStatus()) {\n    //   return;\n    // }\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    });\n    model.renderable.update();\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    });\n\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n\n  publicAPI.computeBounds = (ren, actor) => {\n    if (!publicAPI.getInput()) {\n      vtkMath.uninitializeBounds(model.bounds);\n      return;\n    }\n\n    model.bounds = publicAPI.getInput().getBounds();\n  };\n\n  publicAPI.updateBufferObjects = (ren, actor) => {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {\n    // first do a coarse check\n    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime()) {\n      return true;\n    }\n\n    return false;\n  };\n\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const image = model.currentInput;\n\n    if (!image) {\n      return;\n    }\n\n    const imgScalars = image.getPointData() && image.getPointData().getScalars();\n\n    if (!imgScalars) {\n      return;\n    }\n\n    const actorProperty = actor.getProperty(); // set interpolation on the texture based on property setting\n\n    const iType = actorProperty.getInterpolationType();\n\n    if (iType === InterpolationType.NEAREST) {\n      model.colorTexture.setMinificationFilter(Filter.NEAREST);\n      model.colorTexture.setMagnificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMinificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMagnificationFilter(Filter.NEAREST);\n    } else {\n      model.colorTexture.setMinificationFilter(Filter.LINEAR);\n      model.colorTexture.setMagnificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMinificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMagnificationFilter(Filter.LINEAR);\n    }\n\n    const numComp = imgScalars.getNumberOfComponents();\n    const iComps = actorProperty.getIndependentComponents();\n    const numIComps = iComps ? numComp : 1;\n    const textureHeight = iComps ? 2 * numIComps : 1;\n    const cfunToString = computeFnToString(actorProperty, actorProperty.getRGBTransferFunction, numIComps);\n\n    if (model.colorTextureString !== cfunToString) {\n      const cWidth = 1024;\n      const cSize = cWidth * textureHeight * 3;\n      const cTable = new Uint8Array(cSize);\n      let cfun = actorProperty.getRGBTransferFunction();\n\n      if (cfun) {\n        const tmpTable = new Float32Array(cWidth * 3);\n\n        for (let c = 0; c < numIComps; c++) {\n          cfun = actorProperty.getRGBTransferFunction(c);\n          const cRange = cfun.getRange();\n          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);\n\n          if (iComps) {\n            for (let i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];\n            }\n          } else {\n            for (let i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n            }\n          }\n        }\n\n        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      } else {\n        for (let i = 0; i < cWidth * 3; ++i) {\n          cTable[i] = 255.0 * i / ((cWidth - 1) * 3);\n          cTable[i + 1] = 255.0 * i / ((cWidth - 1) * 3);\n          cTable[i + 2] = 255.0 * i / ((cWidth - 1) * 3);\n        }\n\n        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      }\n\n      model.colorTextureString = cfunToString;\n    } // Build piecewise function buffer.  This buffer is used either\n    // for component weighting or opacity, depending on whether we're\n    // rendering components independently or not.\n\n\n    const pwfunToString = computeFnToString(actorProperty, actorProperty.getPiecewiseFunction, numIComps);\n\n    if (model.pwfTextureString !== pwfunToString) {\n      const pwfWidth = 1024;\n      const pwfSize = pwfWidth * textureHeight;\n      const pwfTable = new Uint8Array(pwfSize);\n      let pwfun = actorProperty.getPiecewiseFunction(); // support case where pwfun is added/removed\n\n      model.pwfTexture.resetFormatAndType();\n\n      if (pwfun) {\n        const pwfFloatTable = new Float32Array(pwfSize);\n        const tmpTable = new Float32Array(pwfWidth);\n\n        for (let c = 0; c < numIComps; ++c) {\n          pwfun = actorProperty.getPiecewiseFunction(c);\n\n          if (pwfun === null) {\n            // Piecewise constant max if no function supplied for this component\n            pwfFloatTable.fill(1.0);\n          } else {\n            const pwfRange = pwfun.getRange();\n            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1); // adjust for sample distance etc\n\n            if (iComps) {\n              for (let i = 0; i < pwfWidth; i++) {\n                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];\n                pwfFloatTable[c * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];\n              }\n            } else {\n              for (let i = 0; i < pwfWidth; i++) {\n                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];\n              }\n            }\n          }\n        }\n\n        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);\n      } else {\n        // default is opaque\n        pwfTable.fill(255.0);\n        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);\n      }\n\n      model.pwfTextureString = pwfunToString;\n    } // Find what IJK axis and what direction to slice along\n\n\n    const {\n      ijkMode\n    } = model.renderable.getClosestIJKAxis(); // Find the IJK slice\n\n    let slice = model.renderable.getSlice();\n\n    if (ijkMode !== model.renderable.getSlicingMode()) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      slice = model.renderable.getSliceAtPosition(slice);\n    }\n\n    const nSlice = Math.round(slice); // Find sliceOffset\n\n    const ext = image.getExtent();\n    let sliceOffset;\n\n    if (ijkMode === SlicingMode.I) {\n      sliceOffset = nSlice - ext[0];\n    }\n\n    if (ijkMode === SlicingMode.J) {\n      sliceOffset = nSlice - ext[2];\n    }\n\n    if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {\n      sliceOffset = nSlice - ext[4];\n    } // rebuild the VBO if the data has changed\n\n\n    const toString = `${slice}A${image.getMTime()}A${imgScalars.getMTime()}B${publicAPI.getMTime()}C${model.renderable.getSlicingMode()}D${actor.getProperty().getMTime()}`;\n\n    if (model.VBOBuildString !== toString) {\n      // Build the VBOs\n      const dims = image.getDimensions();\n\n      if (iType === InterpolationType.NEAREST) {\n        if (numComp === 4) {\n          model.openGLTexture.setGenerateMipmap(true);\n          model.openGLTexture.setMinificationFilter(Filter.NEAREST);\n        } else {\n          model.openGLTexture.setMinificationFilter(Filter.NEAREST);\n        }\n\n        model.openGLTexture.setMagnificationFilter(Filter.NEAREST);\n      } else {\n        if (numComp === 4) {\n          model.openGLTexture.setGenerateMipmap(true);\n          model.openGLTexture.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        } else {\n          model.openGLTexture.setMinificationFilter(Filter.LINEAR);\n        }\n\n        model.openGLTexture.setMagnificationFilter(Filter.LINEAR);\n      }\n\n      model.openGLTexture.setWrapS(Wrap.CLAMP_TO_EDGE);\n      model.openGLTexture.setWrapT(Wrap.CLAMP_TO_EDGE);\n      const sliceSize = dims[0] * dims[1] * numComp;\n      const ptsArray = new Float32Array(12);\n      const tcoordArray = new Float32Array(8);\n\n      for (let i = 0; i < 4; i++) {\n        tcoordArray[i * 2] = i % 2 ? 1.0 : 0.0;\n        tcoordArray[i * 2 + 1] = i > 1 ? 1.0 : 0.0;\n      } // Determine depth position of the slicing plane in the scene.\n      // Slicing modes X, Y, and Z use a continuous axis position, whereas\n      // slicing modes I, J, and K should use discrete positions.\n\n\n      const sliceDepth = [SlicingMode.X, SlicingMode.Y, SlicingMode.Z].includes(model.renderable.getSlicingMode()) ? slice : nSlice;\n      const spatialExt = image.getSpatialExtent();\n      const basicScalars = imgScalars.getData();\n      let scalars = null; // Get right scalars according to slicing mode\n\n      if (ijkMode === SlicingMode.I) {\n        scalars = new basicScalars.constructor(dims[2] * dims[1] * numComp);\n        let id = 0;\n\n        for (let k = 0; k < dims[2]; k++) {\n          for (let j = 0; j < dims[1]; j++) {\n            const bsIdx = (sliceOffset + j * dims[0] + k * dims[0] * dims[1]) * numComp;\n            id = (k * dims[1] + j) * numComp;\n            scalars.set(basicScalars.subarray(bsIdx, bsIdx + numComp), id);\n          }\n        }\n\n        dims[0] = dims[1];\n        dims[1] = dims[2];\n        ptsArray[0] = sliceDepth;\n        ptsArray[1] = spatialExt[2];\n        ptsArray[2] = spatialExt[4];\n        ptsArray[3] = sliceDepth;\n        ptsArray[4] = spatialExt[3];\n        ptsArray[5] = spatialExt[4];\n        ptsArray[6] = sliceDepth;\n        ptsArray[7] = spatialExt[2];\n        ptsArray[8] = spatialExt[5];\n        ptsArray[9] = sliceDepth;\n        ptsArray[10] = spatialExt[3];\n        ptsArray[11] = spatialExt[5];\n      } else if (ijkMode === SlicingMode.J) {\n        scalars = new basicScalars.constructor(dims[2] * dims[0] * numComp);\n        let id = 0;\n\n        for (let k = 0; k < dims[2]; k++) {\n          for (let i = 0; i < dims[0]; i++) {\n            const bsIdx = (i + sliceOffset * dims[0] + k * dims[0] * dims[1]) * numComp;\n            id = (k * dims[0] + i) * numComp;\n            scalars.set(basicScalars.subarray(bsIdx, bsIdx + numComp), id);\n          }\n        }\n\n        dims[1] = dims[2];\n        ptsArray[0] = spatialExt[0];\n        ptsArray[1] = sliceDepth;\n        ptsArray[2] = spatialExt[4];\n        ptsArray[3] = spatialExt[1];\n        ptsArray[4] = sliceDepth;\n        ptsArray[5] = spatialExt[4];\n        ptsArray[6] = spatialExt[0];\n        ptsArray[7] = sliceDepth;\n        ptsArray[8] = spatialExt[5];\n        ptsArray[9] = spatialExt[1];\n        ptsArray[10] = sliceDepth;\n        ptsArray[11] = spatialExt[5];\n      } else if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {\n        scalars = basicScalars.subarray(sliceOffset * sliceSize, (sliceOffset + 1) * sliceSize);\n        ptsArray[0] = spatialExt[0];\n        ptsArray[1] = spatialExt[2];\n        ptsArray[2] = sliceDepth;\n        ptsArray[3] = spatialExt[1];\n        ptsArray[4] = spatialExt[2];\n        ptsArray[5] = sliceDepth;\n        ptsArray[6] = spatialExt[0];\n        ptsArray[7] = spatialExt[3];\n        ptsArray[8] = sliceDepth;\n        ptsArray[9] = spatialExt[1];\n        ptsArray[10] = spatialExt[3];\n        ptsArray[11] = sliceDepth;\n      } else {\n        vtkErrorMacro('Reformat slicing not yet supported.');\n      }\n\n      model.openGLTexture.create2DFromRaw(dims[0], dims[1], numComp, imgScalars.getDataType(), scalars);\n      model.openGLTexture.activate();\n      model.openGLTexture.sendParameters();\n      model.openGLTexture.deactivate();\n      const points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray\n      });\n      points.setName('points');\n      const tcoords = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        values: tcoordArray\n      });\n      tcoords.setName('tcoords');\n      const cellArray = new Uint16Array(8);\n      cellArray[0] = 3;\n      cellArray[1] = 0;\n      cellArray[2] = 1;\n      cellArray[3] = 3;\n      cellArray[4] = 3;\n      cellArray[5] = 0;\n      cellArray[6] = 3;\n      cellArray[7] = 2;\n      const cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray\n      });\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points,\n        tcoords,\n        cellOffset: 0\n      });\n      model.VBOBuildTime.modified();\n      model.VBOBuildString = toString;\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nconst DEFAULT_VALUES = {\n  VBOBuildTime: 0,\n  VBOBuildString: null,\n  openGLTexture: null,\n  tris: null,\n  imagemat: null,\n  imagematinv: null,\n  colorTexture: null,\n  pwfTexture: null,\n  lastHaveSeenDepthRequest: false,\n  haveSeenDepthRequest: false,\n  lastTextureComponents: 0\n}; // ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n  model.tris = vtkHelper.newInstance();\n  model.openGLTexture = vtkOpenGLTexture.newInstance();\n  model.colorTexture = vtkOpenGLTexture.newInstance();\n  model.pwfTexture = vtkOpenGLTexture.newInstance();\n  model.imagemat = mat4.identity(new Float64Array(16));\n  model.imagematinv = mat4.identity(new Float64Array(16)); // Build VTK API\n\n  macro.setGet(publicAPI, model, []);\n  model.VBOBuildTime = {};\n  macro.obj(model.VBOBuildTime); // Object methods\n\n  vtkOpenGLImageMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkOpenGLImageMapper'); // ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkImageMapper', newInstance);","map":{"version":3,"names":["mat4","Constants","macro","vtkDataArray","VtkDataTypes","vtkHelper","vtkMath","vtkOpenGLTexture","vtkShaderProgram","vtkViewNode","Representation","Wrap","Filter","InterpolationType","vtkPolyDataVS","vtkPolyDataFS","vtkReplacementShaderMapper","registerOverride","vtkErrorMacro","SlicingMode","computeFnToString","property","fn","numberOfComponents","pwfun","apply","iComps","getIndependentComponents","getMTime","vtkOpenGLImageMapper","publicAPI","model","classHierarchy","push","buildPass","prepass","currentRenderPass","openGLImageSlice","getFirstAncestorOfType","openGLRenderer","_openGLRenderWindow","getParent","context","getContext","tris","setOpenGLRenderWindow","openGLTexture","colorTexture","pwfTexture","ren","getRenderable","openGLCamera","getViewNodeFor","getActiveCamera","renderable","getSliceAtFocalPoint","setSliceFromCamera","translucentPass","renderPass","render","opaqueZBufferPass","haveSeenDepthRequest","renderDepth","opaquePass","getCoincidentParameters","actor","getResolveCoincidentTopology","getCoincidentTopologyPolygonOffsetParameters","renderPiece","buildShaders","shaders","getShaderTemplate","lastRenderPassShaderReplacement","replaceShaderValues","Vertex","Fragment","Geometry","VSSource","FSSource","substitute","result","tNumComp","getComponents","getProperty","tcoordDec","comp","concat","rgba","tcoordImpl","replaceShaderClip","replaceShaderCoincidentOffset","getNumberOfClippingPlanes","numClipPlanes","getNeedToRebuildShaders","cellBO","iComp","needRebuild","getShaderReplacement","lastHaveSeenDepthRequest","getProgram","lastTextureComponents","lastIndependentComponents","updateShaders","lastBoundBO","newShader","getShaderCache","readyShaderProgramArray","setProgram","getVAO","releaseGraphicsResources","getShaderSourceTime","modified","readyShaderProgram","bind","setMapperShaderParameters","setCameraShaderParameters","setPropertyShaderParameters","getCABO","getElementCount","VBOBuildTime","getAttributeUpdateTime","isAttributeUsed","addAttributeArray","getVertexOffset","getStride","FLOAT","FALSE","getTCoordOffset","getTCoordComponents","texUnit","getTextureUnit","setUniformi","numComp","i","setUniformf","getComponentWeight","oglShiftScale","getShiftAndScale","cw","getColorWindow","cl","getColorLevel","target","cfun","getRGBTransferFunction","getUseLookupTableScalarRange","cRange","getRange","scale","shift","pwfScale","pwfShift","getPiecewiseFunction","pwfRange","length","mid","isUniformUsed","cp","offset","factor","texColorUnit","texOpacityUnit","shiftScaleEnabled","getCoordShiftAndScaleEnabled","inverseShiftScaleMatrix","getInverseShiftAndScaleMatrix","mat","copy","imagematinv","getMatrix","transpose","multiply","imagemat","currentInput","getIndexToWorld","planeEquations","planeEquation","getClippingPlaneInDataCoords","j","setUniform4fv","program","actMats","getKeyMatrices","image","i2wmat4","mcwc","keyMats","wcpc","inverseShiftScaleMat","setUniformMatrix","ppty","opacity","getOpacity","renderPieceStart","updateBufferObjects","renderPieceDraw","gl","activate","drawArrays","TRIANGLES","release","deactivate","renderPieceFinish","invokeEvent","type","update","getInputData","computeBounds","getInput","uninitializeBounds","bounds","getBounds","getNeedToRebuildBufferObjects","buildBufferObjects","imgScalars","getPointData","getScalars","actorProperty","iType","getInterpolationType","NEAREST","setMinificationFilter","setMagnificationFilter","LINEAR","getNumberOfComponents","numIComps","textureHeight","cfunToString","colorTextureString","cWidth","cSize","cTable","Uint8Array","tmpTable","Float32Array","c","getTable","create2DFromRaw","UNSIGNED_CHAR","pwfunToString","pwfTextureString","pwfWidth","pwfSize","pwfTable","resetFormatAndType","pwfFloatTable","fill","ijkMode","getClosestIJKAxis","slice","getSlice","getSlicingMode","getSliceAtPosition","nSlice","Math","round","ext","getExtent","sliceOffset","I","J","K","NONE","toString","VBOBuildString","dims","getDimensions","setGenerateMipmap","LINEAR_MIPMAP_LINEAR","setWrapS","CLAMP_TO_EDGE","setWrapT","sliceSize","ptsArray","tcoordArray","sliceDepth","X","Y","Z","includes","spatialExt","getSpatialExtent","basicScalars","getData","scalars","constructor","id","k","bsIdx","set","subarray","getDataType","sendParameters","points","newInstance","values","setName","tcoords","cellArray","Uint16Array","cells","createVBO","SURFACE","cellOffset","DEFAULT_VALUES","extend","initialValues","Object","assign","implementReplaceShaderCoincidentOffset","identity","Float64Array","setGet","obj"],"sources":["/Users/nicolerussack/CSCI401/CSCI401TissueSimulation/my-version/node_modules/vtk.js/Sources/Rendering/OpenGL/ImageMapper/index.js"],"sourcesContent":["import { mat4 } from 'gl-matrix';\nimport Constants from 'vtk.js/Sources/Rendering/Core/ImageMapper/Constants';\nimport * as macro from 'vtk.js/Sources/macros';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nimport { VtkDataTypes } from 'vtk.js/Sources/Common/Core/DataArray/Constants';\nimport vtkHelper from 'vtk.js/Sources/Rendering/OpenGL/Helper';\nimport * as vtkMath from 'vtk.js/Sources/Common/Core/Math';\nimport vtkOpenGLTexture from 'vtk.js/Sources/Rendering/OpenGL/Texture';\nimport vtkShaderProgram from 'vtk.js/Sources/Rendering/OpenGL/ShaderProgram';\nimport vtkViewNode from 'vtk.js/Sources/Rendering/SceneGraph/ViewNode';\nimport { Representation } from 'vtk.js/Sources/Rendering/Core/Property/Constants';\nimport {\n  Wrap,\n  Filter,\n} from 'vtk.js/Sources/Rendering/OpenGL/Texture/Constants';\nimport { InterpolationType } from 'vtk.js/Sources/Rendering/Core/ImageProperty/Constants';\n\nimport vtkPolyDataVS from 'vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataVS.glsl';\nimport vtkPolyDataFS from 'vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl';\nimport vtkReplacementShaderMapper from 'vtk.js/Sources/Rendering/OpenGL/ReplacementShaderMapper';\n\nimport { registerOverride } from 'vtk.js/Sources/Rendering/OpenGL/ViewNodeFactory';\n\nconst { vtkErrorMacro } = macro;\n\nconst { SlicingMode } = Constants;\n\n// ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n\nfunction computeFnToString(property, fn, numberOfComponents) {\n  const pwfun = fn.apply(property);\n  if (pwfun) {\n    const iComps = property.getIndependentComponents();\n    return `${property.getMTime()}-${iComps}-${numberOfComponents}`;\n  }\n  return '0';\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLImageMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLImageMapper');\n\n  publicAPI.buildPass = (prepass) => {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model.openGLImageSlice = publicAPI.getFirstAncestorOfType(\n        'vtkOpenGLImageSlice'\n      );\n      model.openGLRenderer =\n        publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model.openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      const ren = model.openGLRenderer.getRenderable();\n      model.openGLCamera = model.openGLRenderer.getViewNodeFor(\n        ren.getActiveCamera()\n      );\n      // is slice set by the camera\n      if (model.renderable.getSliceAtFocalPoint()) {\n        model.renderable.setSliceFromCamera(ren.getActiveCamera());\n      }\n    }\n  };\n\n  publicAPI.translucentPass = (prepass, renderPass) => {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n\n  publicAPI.opaqueZBufferPass = (prepass) => {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n\n  publicAPI.opaquePass = (prepass) => {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n\n  publicAPI.getCoincidentParameters = (ren, actor) => {\n    if (model.renderable.getResolveCoincidentTopology()) {\n      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n    }\n    return null;\n  };\n\n  // Renders myself\n  publicAPI.render = () => {\n    const actor = model.openGLImageSlice.getRenderable();\n    const ren = model.openGLRenderer.getRenderable();\n    publicAPI.renderPiece(ren, actor);\n  };\n\n  publicAPI.buildShaders = (shaders, ren, actor) => {\n    publicAPI.getShaderTemplate(shaders, ren, actor);\n\n    // apply any renderPassReplacements\n    if (model.lastRenderPassShaderReplacement) {\n      model.lastRenderPassShaderReplacement(shaders);\n    }\n\n    publicAPI.replaceShaderValues(shaders, ren, actor);\n  };\n\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkPolyDataVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', [\n      'uniform mat4 MCPCMatrix;',\n    ]).result;\n    VSSource = vtkShaderProgram.substitute(\n      VSSource,\n      '//VTK::PositionVC::Impl',\n      ['  gl_Position = MCPCMatrix * vertexMC;']\n    ).result;\n\n    VSSource = vtkShaderProgram.substitute(\n      VSSource,\n      '//VTK::TCoord::Impl',\n      'tcoordVCVSOutput = tcoordMC;'\n    ).result;\n\n    VSSource = vtkShaderProgram.substitute(\n      VSSource,\n      '//VTK::TCoord::Dec',\n      'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;'\n    ).result;\n\n    const tNumComp = model.openGLTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n\n    let tcoordDec = [\n      'varying vec2 tcoordVCVSOutput;',\n      // color shift and scale\n      'uniform float cshift0;',\n      'uniform float cscale0;',\n      // pwf shift and scale\n      'uniform float pwfshift0;',\n      'uniform float pwfscale0;',\n      'uniform sampler2D texture1;',\n      'uniform sampler2D colorTexture1;',\n      'uniform sampler2D pwfTexture1;',\n      'uniform float opacity;',\n    ];\n    if (iComps) {\n      for (let comp = 1; comp < tNumComp; comp++) {\n        tcoordDec = tcoordDec.concat([\n          // color shift and scale\n          `uniform float cshift${comp};`,\n          `uniform float cscale${comp};`,\n          // weighting shift and scale\n          `uniform float pwfshift${comp};`,\n          `uniform float pwfscale${comp};`,\n        ]);\n      }\n      // the heights defined below are the locations\n      // for the up to four components of the tfuns\n      // the tfuns have a height of 2XnumComps pixels so the\n      // values are computed to hit the middle of the two rows\n      // for that component\n      switch (tNumComp) {\n        case 1:\n          tcoordDec = tcoordDec.concat([\n            'uniform float mix0;',\n            '#define height0 0.5',\n          ]);\n          break;\n        case 2:\n          tcoordDec = tcoordDec.concat([\n            'uniform float mix0;',\n            'uniform float mix1;',\n            '#define height0 0.25',\n            '#define height1 0.75',\n          ]);\n          break;\n        case 3:\n          tcoordDec = tcoordDec.concat([\n            'uniform float mix0;',\n            'uniform float mix1;',\n            'uniform float mix2;',\n            '#define height0 0.17',\n            '#define height1 0.5',\n            '#define height2 0.83',\n          ]);\n          break;\n        case 4:\n          tcoordDec = tcoordDec.concat([\n            'uniform float mix0;',\n            'uniform float mix1;',\n            'uniform float mix2;',\n            'uniform float mix3;',\n            '#define height0 0.125',\n            '#define height1 0.375',\n            '#define height2 0.625',\n            '#define height3 0.875',\n          ]);\n          break;\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    }\n    FSSource = vtkShaderProgram.substitute(\n      FSSource,\n      '//VTK::TCoord::Dec',\n      tcoordDec\n    ).result;\n\n    if (iComps) {\n      const rgba = ['r', 'g', 'b', 'a'];\n      let tcoordImpl = ['vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);'];\n      for (let comp = 0; comp < tNumComp; comp++) {\n        tcoordImpl = tcoordImpl.concat([\n          `vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`,\n          `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`,\n        ]);\n      }\n      switch (tNumComp) {\n        case 1:\n          tcoordImpl = tcoordImpl.concat([\n            'gl_FragData[0] = vec4(tcolor0.rgb, opacity);',\n          ]);\n          break;\n        case 2:\n          tcoordImpl = tcoordImpl.concat([\n            'float weightSum = compWeight0 + compWeight1;',\n            'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);',\n          ]);\n          break;\n        case 3:\n          tcoordImpl = tcoordImpl.concat([\n            'float weightSum = compWeight0 + compWeight1 + compWeight2;',\n            'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);',\n          ]);\n          break;\n        case 4:\n          tcoordImpl = tcoordImpl.concat([\n            'float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;',\n            'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);',\n          ]);\n          break;\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n      FSSource = vtkShaderProgram.substitute(\n        FSSource,\n        '//VTK::TCoord::Impl',\n        tcoordImpl\n      ).result;\n    } else {\n      // dependent components\n      switch (tNumComp) {\n        case 1:\n          FSSource = vtkShaderProgram.substitute(\n            FSSource,\n            '//VTK::TCoord::Impl',\n            [\n              'float intensity = texture2D(texture1, tcoordVCVSOutput).r;',\n              'vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;',\n              'float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;',\n              'gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);',\n            ]\n          ).result;\n          break;\n        case 2:\n          FSSource = vtkShaderProgram.substitute(\n            FSSource,\n            '//VTK::TCoord::Impl',\n            [\n              'vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);',\n              'float intensity = tcolor.r*cscale0 + cshift0;',\n              'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);',\n            ]\n          ).result;\n          break;\n        case 3:\n          FSSource = vtkShaderProgram.substitute(\n            FSSource,\n            '//VTK::TCoord::Impl',\n            [\n              'vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;',\n              'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,',\n              '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,',\n              '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);',\n            ]\n          ).result;\n          break;\n        default:\n          FSSource = vtkShaderProgram.substitute(\n            FSSource,\n            '//VTK::TCoord::Impl',\n            [\n              'vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;',\n              'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,',\n              '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,',\n              '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);',\n            ]\n          ).result;\n      }\n    }\n\n    if (model.haveSeenDepthRequest) {\n      FSSource = vtkShaderProgram.substitute(\n        FSSource,\n        '//VTK::ZBuffer::Dec',\n        'uniform int depthRequest;'\n      ).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', [\n        'if (depthRequest == 1) {',\n        'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);',\n        'float rf = floor(iz/256.0)/255.0;',\n        'float gf = mod(iz,256.0)/255.0;',\n        'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }',\n      ]).result;\n    }\n\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n\n    publicAPI.replaceShaderClip(shaders, ren, actor);\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n  };\n\n  publicAPI.replaceShaderClip = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      if (numClipPlanes > 6) {\n        macro.vtkErrorMacro('OpenGL has a limit of 6 clipping planes');\n        numClipPlanes = 6;\n      }\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Dec', [\n        'uniform int numClipPlanes;',\n        'uniform vec4 clipPlanes[6];',\n        'varying float clipDistancesVSOutput[6];',\n      ]).result;\n\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Impl', [\n        'for (int planeNum = 0; planeNum < 6; planeNum++)',\n        '    {',\n        '    if (planeNum >= numClipPlanes)',\n        '        {',\n        '        break;',\n        '        }',\n        '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);',\n        '    }',\n      ]).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Dec', [\n        'uniform int numClipPlanes;',\n        'varying float clipDistancesVSOutput[6];',\n      ]).result;\n\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Impl', [\n        'for (int planeNum = 0; planeNum < 6; planeNum++)',\n        '    {',\n        '    if (planeNum >= numClipPlanes)',\n        '        {',\n        '        break;',\n        '        }',\n        '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;',\n        '    }',\n      ]).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n  };\n\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n\n    const tNumComp = model.openGLTexture.getComponents();\n    const iComp = actor.getProperty().getIndependentComponents();\n\n    // has the render pass shader replacement changed? Two options\n    let needRebuild = false;\n    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement) {\n      needRebuild = true;\n      model.lastRenderPassShaderReplacement = null;\n    }\n    if (\n      model.currentRenderPass &&\n      model.currentRenderPass.getShaderReplacement() !==\n        model.lastRenderPassShaderReplacement\n    ) {\n      model.lastRenderPassShaderReplacement =\n        model.currentRenderPass.getShaderReplacement();\n      needRebuild = true;\n    }\n\n    if (\n      needRebuild ||\n      model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest ||\n      cellBO.getProgram() === 0 ||\n      model.lastTextureComponents !== tNumComp ||\n      model.lastIndependentComponents !== iComp\n    ) {\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      model.lastTextureComponents = tNumComp;\n      model.lastIndependentComponents = iComp;\n      return true;\n    }\n\n    return false;\n  };\n\n  publicAPI.updateShaders = (cellBO, ren, actor) => {\n    model.lastBoundBO = cellBO;\n\n    // has something changed that would require us to recreate the shader?\n    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {\n      const shaders = { Vertex: null, Fragment: null, Geometry: null };\n\n      publicAPI.buildShaders(shaders, ren, actor);\n\n      // compile and bind the program if needed\n      const newShader = model._openGLRenderWindow\n        .getShaderCache()\n        .readyShaderProgramArray(\n          shaders.Vertex,\n          shaders.Fragment,\n          shaders.Geometry\n        );\n\n      // if the shader changed reinitialize the VAO\n      if (newShader !== cellBO.getProgram()) {\n        cellBO.setProgram(newShader);\n        // reset the VAO as the shader has changed\n        cellBO.getVAO().releaseGraphicsResources();\n      }\n\n      cellBO.getShaderSourceTime().modified();\n    } else {\n      model._openGLRenderWindow\n        .getShaderCache()\n        .readyShaderProgram(cellBO.getProgram());\n    }\n\n    cellBO.getVAO().bind();\n    publicAPI.setMapperShaderParameters(cellBO, ren, actor);\n    publicAPI.setCameraShaderParameters(cellBO, ren, actor);\n    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);\n  };\n\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    // Now to update the VAO too, if necessary.\n\n    if (\n      cellBO.getCABO().getElementCount() &&\n      (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() ||\n        cellBO.getShaderSourceTime().getMTime() >\n          cellBO.getAttributeUpdateTime().getMTime())\n    ) {\n      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {\n        if (\n          !cellBO\n            .getVAO()\n            .addAttributeArray(\n              cellBO.getProgram(),\n              cellBO.getCABO(),\n              'vertexMC',\n              cellBO.getCABO().getVertexOffset(),\n              cellBO.getCABO().getStride(),\n              model.context.FLOAT,\n              3,\n              model.context.FALSE\n            )\n        ) {\n          vtkErrorMacro('Error setting vertexMC in shader VAO.');\n        }\n      }\n      if (\n        cellBO.getProgram().isAttributeUsed('tcoordMC') &&\n        cellBO.getCABO().getTCoordOffset()\n      ) {\n        if (\n          !cellBO\n            .getVAO()\n            .addAttributeArray(\n              cellBO.getProgram(),\n              cellBO.getCABO(),\n              'tcoordMC',\n              cellBO.getCABO().getTCoordOffset(),\n              cellBO.getCABO().getStride(),\n              model.context.FLOAT,\n              cellBO.getCABO().getTCoordComponents(),\n              model.context.FALSE\n            )\n        ) {\n          vtkErrorMacro('Error setting tcoordMC in shader VAO.');\n        }\n      }\n      cellBO.getAttributeUpdateTime().modified();\n    }\n\n    const texUnit = model.openGLTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('texture1', texUnit);\n\n    const numComp = model.openGLTexture.getComponents();\n    const iComps = actor.getProperty().getIndependentComponents();\n    if (iComps) {\n      for (let i = 0; i < numComp; i++) {\n        cellBO\n          .getProgram()\n          .setUniformf(`mix${i}`, actor.getProperty().getComponentWeight(i));\n      }\n    }\n\n    const oglShiftScale = model.openGLTexture.getShiftAndScale();\n\n    // three levels of shift scale combined into one\n    // for performance in the fragment shader\n    for (let i = 0; i < numComp; i++) {\n      let cw = actor.getProperty().getColorWindow();\n      let cl = actor.getProperty().getColorLevel();\n      const target = iComps ? i : 0;\n      const cfun = actor.getProperty().getRGBTransferFunction(target);\n      if (cfun && actor.getProperty().getUseLookupTableScalarRange()) {\n        const cRange = cfun.getRange();\n        cw = cRange[1] - cRange[0];\n        cl = 0.5 * (cRange[1] + cRange[0]);\n      }\n\n      const scale = oglShiftScale.scale / cw;\n      const shift = (oglShiftScale.shift - cl) / cw + 0.5;\n      cellBO.getProgram().setUniformf(`cshift${i}`, shift);\n      cellBO.getProgram().setUniformf(`cscale${i}`, scale);\n    }\n\n    // pwf shift/scale\n    for (let i = 0; i < numComp; i++) {\n      let pwfScale = 1.0;\n      let pwfShift = 0.0;\n      const target = iComps ? i : 0;\n      const pwfun = actor.getProperty().getPiecewiseFunction(target);\n      if (pwfun) {\n        const pwfRange = pwfun.getRange();\n        const length = pwfRange[1] - pwfRange[0];\n        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);\n        pwfScale = oglShiftScale.scale / length;\n        pwfShift = (oglShiftScale.shift - mid) / length + 0.5;\n      }\n      cellBO.getProgram().setUniformf(`pwfshift${i}`, pwfShift);\n      cellBO.getProgram().setUniformf(`pwfscale${i}`, pwfScale);\n    }\n\n    if (model.haveSeenDepthRequest) {\n      cellBO\n        .getProgram()\n        .setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    }\n\n    // handle coincident\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      const cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset);\n      // cfactor isn't always used when coffset is.\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    }\n\n    const texColorUnit = model.colorTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('colorTexture1', texColorUnit);\n\n    const texOpacityUnit = model.pwfTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('pwfTexture1', texOpacityUnit);\n\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      // add all the clipping planes\n      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      if (numClipPlanes > 6) {\n        macro.vtkErrorMacro('OpenGL has a limit of 6 clipping planes');\n        numClipPlanes = 6;\n      }\n\n      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      const inverseShiftScaleMatrix = shiftScaleEnabled\n        ? cellBO.getCABO().getInverseShiftAndScaleMatrix()\n        : null;\n      const mat = inverseShiftScaleMatrix\n        ? mat4.copy(model.imagematinv, actor.getMatrix())\n        : actor.getMatrix();\n      if (inverseShiftScaleMatrix) {\n        mat4.transpose(mat, mat);\n        mat4.multiply(mat, mat, inverseShiftScaleMatrix);\n        mat4.transpose(mat, mat);\n      }\n\n      // transform crop plane normal with transpose(inverse(worldToIndex))\n      mat4.transpose(model.imagemat, model.currentInput.getIndexToWorld());\n      mat4.multiply(model.imagematinv, mat, model.imagemat);\n\n      const planeEquations = [];\n      for (let i = 0; i < numClipPlanes; i++) {\n        const planeEquation = [];\n        model.renderable.getClippingPlaneInDataCoords(\n          model.imagematinv,\n          i,\n          planeEquation\n        );\n\n        for (let j = 0; j < 4; j++) {\n          planeEquations.push(planeEquation[j]);\n        }\n      }\n      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);\n      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);\n    }\n  };\n\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n\n    const actMats = model.openGLImageSlice.getKeyMatrices();\n    const image = model.currentInput;\n    const i2wmat4 = image.getIndexToWorld();\n    mat4.multiply(model.imagemat, actMats.mcwc, i2wmat4);\n\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    mat4.multiply(model.imagemat, keyMats.wcpc, model.imagemat);\n\n    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {\n      const inverseShiftScaleMat = cellBO\n        .getCABO()\n        .getInverseShiftAndScaleMatrix();\n      mat4.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);\n    }\n\n    program.setUniformMatrix('MCPCMatrix', model.imagemat);\n  };\n\n  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n\n    const ppty = actor.getProperty();\n\n    const opacity = ppty.getOpacity();\n    program.setUniformf('opacity', opacity);\n  };\n\n  publicAPI.renderPieceStart = (ren, actor) => {\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor);\n\n    // Bind the OpenGL, this is shared between the different primitive/cell types.\n    model.lastBoundBO = null;\n  };\n\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const gl = model.context;\n\n    // activate the texture\n    model.openGLTexture.activate();\n    model.colorTexture.activate();\n    model.pwfTexture.activate();\n\n    // draw polygons\n    if (model.tris.getCABO().getElementCount()) {\n      // First we do the triangles, update the shader, set uniforms, etc.\n      publicAPI.updateShaders(model.tris, ren, actor);\n      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n      model.tris.getVAO().release();\n    }\n\n    model.openGLTexture.deactivate();\n    model.colorTexture.deactivate();\n    model.pwfTexture.deactivate();\n  };\n\n  publicAPI.renderPieceFinish = (ren, actor) => {};\n\n  publicAPI.renderPiece = (ren, actor) => {\n    // Make sure that we have been properly initialized.\n    // if (ren.getRenderWindow().checkAbortStatus()) {\n    //   return;\n    // }\n\n    publicAPI.invokeEvent({ type: 'StartEvent' });\n    model.renderable.update();\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.invokeEvent({ type: 'EndEvent' });\n\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n\n  publicAPI.computeBounds = (ren, actor) => {\n    if (!publicAPI.getInput()) {\n      vtkMath.uninitializeBounds(model.bounds);\n      return;\n    }\n    model.bounds = publicAPI.getInput().getBounds();\n  };\n\n  publicAPI.updateBufferObjects = (ren, actor) => {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {\n    // first do a coarse check\n    if (\n      model.VBOBuildTime.getMTime() < publicAPI.getMTime() ||\n      model.VBOBuildTime.getMTime() < actor.getMTime() ||\n      model.VBOBuildTime.getMTime() < model.renderable.getMTime() ||\n      model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() ||\n      model.VBOBuildTime.getMTime() < model.currentInput.getMTime()\n    ) {\n      return true;\n    }\n    return false;\n  };\n\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const image = model.currentInput;\n\n    if (!image) {\n      return;\n    }\n\n    const imgScalars =\n      image.getPointData() && image.getPointData().getScalars();\n    if (!imgScalars) {\n      return;\n    }\n\n    const actorProperty = actor.getProperty();\n\n    // set interpolation on the texture based on property setting\n    const iType = actorProperty.getInterpolationType();\n    if (iType === InterpolationType.NEAREST) {\n      model.colorTexture.setMinificationFilter(Filter.NEAREST);\n      model.colorTexture.setMagnificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMinificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMagnificationFilter(Filter.NEAREST);\n    } else {\n      model.colorTexture.setMinificationFilter(Filter.LINEAR);\n      model.colorTexture.setMagnificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMinificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMagnificationFilter(Filter.LINEAR);\n    }\n\n    const numComp = imgScalars.getNumberOfComponents();\n    const iComps = actorProperty.getIndependentComponents();\n    const numIComps = iComps ? numComp : 1;\n    const textureHeight = iComps ? 2 * numIComps : 1;\n\n    const cfunToString = computeFnToString(\n      actorProperty,\n      actorProperty.getRGBTransferFunction,\n      numIComps\n    );\n\n    if (model.colorTextureString !== cfunToString) {\n      const cWidth = 1024;\n      const cSize = cWidth * textureHeight * 3;\n      const cTable = new Uint8Array(cSize);\n      let cfun = actorProperty.getRGBTransferFunction();\n      if (cfun) {\n        const tmpTable = new Float32Array(cWidth * 3);\n\n        for (let c = 0; c < numIComps; c++) {\n          cfun = actorProperty.getRGBTransferFunction(c);\n          const cRange = cfun.getRange();\n          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);\n          if (iComps) {\n            for (let i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];\n            }\n          } else {\n            for (let i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n            }\n          }\n        }\n        model.colorTexture.create2DFromRaw(\n          cWidth,\n          textureHeight,\n          3,\n          VtkDataTypes.UNSIGNED_CHAR,\n          cTable\n        );\n      } else {\n        for (let i = 0; i < cWidth * 3; ++i) {\n          cTable[i] = (255.0 * i) / ((cWidth - 1) * 3);\n          cTable[i + 1] = (255.0 * i) / ((cWidth - 1) * 3);\n          cTable[i + 2] = (255.0 * i) / ((cWidth - 1) * 3);\n        }\n        model.colorTexture.create2DFromRaw(\n          cWidth,\n          1,\n          3,\n          VtkDataTypes.UNSIGNED_CHAR,\n          cTable\n        );\n      }\n\n      model.colorTextureString = cfunToString;\n    }\n\n    // Build piecewise function buffer.  This buffer is used either\n    // for component weighting or opacity, depending on whether we're\n    // rendering components independently or not.\n    const pwfunToString = computeFnToString(\n      actorProperty,\n      actorProperty.getPiecewiseFunction,\n      numIComps\n    );\n\n    if (model.pwfTextureString !== pwfunToString) {\n      const pwfWidth = 1024;\n      const pwfSize = pwfWidth * textureHeight;\n      const pwfTable = new Uint8Array(pwfSize);\n      let pwfun = actorProperty.getPiecewiseFunction();\n      // support case where pwfun is added/removed\n      model.pwfTexture.resetFormatAndType();\n      if (pwfun) {\n        const pwfFloatTable = new Float32Array(pwfSize);\n        const tmpTable = new Float32Array(pwfWidth);\n\n        for (let c = 0; c < numIComps; ++c) {\n          pwfun = actorProperty.getPiecewiseFunction(c);\n          if (pwfun === null) {\n            // Piecewise constant max if no function supplied for this component\n            pwfFloatTable.fill(1.0);\n          } else {\n            const pwfRange = pwfun.getRange();\n            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);\n            // adjust for sample distance etc\n            if (iComps) {\n              for (let i = 0; i < pwfWidth; i++) {\n                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];\n                pwfFloatTable[c * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];\n              }\n            } else {\n              for (let i = 0; i < pwfWidth; i++) {\n                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];\n              }\n            }\n          }\n        }\n        model.pwfTexture.create2DFromRaw(\n          pwfWidth,\n          textureHeight,\n          1,\n          VtkDataTypes.FLOAT,\n          pwfFloatTable\n        );\n      } else {\n        // default is opaque\n        pwfTable.fill(255.0);\n        model.pwfTexture.create2DFromRaw(\n          pwfWidth,\n          1,\n          1,\n          VtkDataTypes.UNSIGNED_CHAR,\n          pwfTable\n        );\n      }\n\n      model.pwfTextureString = pwfunToString;\n    }\n\n    // Find what IJK axis and what direction to slice along\n    const { ijkMode } = model.renderable.getClosestIJKAxis();\n\n    // Find the IJK slice\n    let slice = model.renderable.getSlice();\n    if (ijkMode !== model.renderable.getSlicingMode()) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      slice = model.renderable.getSliceAtPosition(slice);\n    }\n\n    const nSlice = Math.round(slice);\n\n    // Find sliceOffset\n    const ext = image.getExtent();\n    let sliceOffset;\n    if (ijkMode === SlicingMode.I) {\n      sliceOffset = nSlice - ext[0];\n    }\n    if (ijkMode === SlicingMode.J) {\n      sliceOffset = nSlice - ext[2];\n    }\n    if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {\n      sliceOffset = nSlice - ext[4];\n    }\n\n    // rebuild the VBO if the data has changed\n    const toString = `${slice}A${image.getMTime()}A${imgScalars.getMTime()}B${publicAPI.getMTime()}C${model.renderable.getSlicingMode()}D${actor\n      .getProperty()\n      .getMTime()}`;\n    if (model.VBOBuildString !== toString) {\n      // Build the VBOs\n      const dims = image.getDimensions();\n      if (iType === InterpolationType.NEAREST) {\n        if (numComp === 4) {\n          model.openGLTexture.setGenerateMipmap(true);\n          model.openGLTexture.setMinificationFilter(Filter.NEAREST);\n        } else {\n          model.openGLTexture.setMinificationFilter(Filter.NEAREST);\n        }\n        model.openGLTexture.setMagnificationFilter(Filter.NEAREST);\n      } else {\n        if (numComp === 4) {\n          model.openGLTexture.setGenerateMipmap(true);\n          model.openGLTexture.setMinificationFilter(\n            Filter.LINEAR_MIPMAP_LINEAR\n          );\n        } else {\n          model.openGLTexture.setMinificationFilter(Filter.LINEAR);\n        }\n        model.openGLTexture.setMagnificationFilter(Filter.LINEAR);\n      }\n      model.openGLTexture.setWrapS(Wrap.CLAMP_TO_EDGE);\n      model.openGLTexture.setWrapT(Wrap.CLAMP_TO_EDGE);\n      const sliceSize = dims[0] * dims[1] * numComp;\n\n      const ptsArray = new Float32Array(12);\n      const tcoordArray = new Float32Array(8);\n      for (let i = 0; i < 4; i++) {\n        tcoordArray[i * 2] = i % 2 ? 1.0 : 0.0;\n        tcoordArray[i * 2 + 1] = i > 1 ? 1.0 : 0.0;\n      }\n\n      // Determine depth position of the slicing plane in the scene.\n      // Slicing modes X, Y, and Z use a continuous axis position, whereas\n      // slicing modes I, J, and K should use discrete positions.\n      const sliceDepth = [SlicingMode.X, SlicingMode.Y, SlicingMode.Z].includes(\n        model.renderable.getSlicingMode()\n      )\n        ? slice\n        : nSlice;\n\n      const spatialExt = image.getSpatialExtent();\n      const basicScalars = imgScalars.getData();\n      let scalars = null;\n      // Get right scalars according to slicing mode\n      if (ijkMode === SlicingMode.I) {\n        scalars = new basicScalars.constructor(dims[2] * dims[1] * numComp);\n        let id = 0;\n        for (let k = 0; k < dims[2]; k++) {\n          for (let j = 0; j < dims[1]; j++) {\n            const bsIdx =\n              (sliceOffset + j * dims[0] + k * dims[0] * dims[1]) * numComp;\n            id = (k * dims[1] + j) * numComp;\n            scalars.set(basicScalars.subarray(bsIdx, bsIdx + numComp), id);\n          }\n        }\n        dims[0] = dims[1];\n        dims[1] = dims[2];\n        ptsArray[0] = sliceDepth;\n        ptsArray[1] = spatialExt[2];\n        ptsArray[2] = spatialExt[4];\n        ptsArray[3] = sliceDepth;\n        ptsArray[4] = spatialExt[3];\n        ptsArray[5] = spatialExt[4];\n        ptsArray[6] = sliceDepth;\n        ptsArray[7] = spatialExt[2];\n        ptsArray[8] = spatialExt[5];\n        ptsArray[9] = sliceDepth;\n        ptsArray[10] = spatialExt[3];\n        ptsArray[11] = spatialExt[5];\n      } else if (ijkMode === SlicingMode.J) {\n        scalars = new basicScalars.constructor(dims[2] * dims[0] * numComp);\n        let id = 0;\n        for (let k = 0; k < dims[2]; k++) {\n          for (let i = 0; i < dims[0]; i++) {\n            const bsIdx =\n              (i + sliceOffset * dims[0] + k * dims[0] * dims[1]) * numComp;\n            id = (k * dims[0] + i) * numComp;\n            scalars.set(basicScalars.subarray(bsIdx, bsIdx + numComp), id);\n          }\n        }\n        dims[1] = dims[2];\n        ptsArray[0] = spatialExt[0];\n        ptsArray[1] = sliceDepth;\n        ptsArray[2] = spatialExt[4];\n        ptsArray[3] = spatialExt[1];\n        ptsArray[4] = sliceDepth;\n        ptsArray[5] = spatialExt[4];\n        ptsArray[6] = spatialExt[0];\n        ptsArray[7] = sliceDepth;\n        ptsArray[8] = spatialExt[5];\n        ptsArray[9] = spatialExt[1];\n        ptsArray[10] = sliceDepth;\n        ptsArray[11] = spatialExt[5];\n      } else if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {\n        scalars = basicScalars.subarray(\n          sliceOffset * sliceSize,\n          (sliceOffset + 1) * sliceSize\n        );\n        ptsArray[0] = spatialExt[0];\n        ptsArray[1] = spatialExt[2];\n        ptsArray[2] = sliceDepth;\n        ptsArray[3] = spatialExt[1];\n        ptsArray[4] = spatialExt[2];\n        ptsArray[5] = sliceDepth;\n        ptsArray[6] = spatialExt[0];\n        ptsArray[7] = spatialExt[3];\n        ptsArray[8] = sliceDepth;\n        ptsArray[9] = spatialExt[1];\n        ptsArray[10] = spatialExt[3];\n        ptsArray[11] = sliceDepth;\n      } else {\n        vtkErrorMacro('Reformat slicing not yet supported.');\n      }\n\n      model.openGLTexture.create2DFromRaw(\n        dims[0],\n        dims[1],\n        numComp,\n        imgScalars.getDataType(),\n        scalars\n      );\n      model.openGLTexture.activate();\n      model.openGLTexture.sendParameters();\n      model.openGLTexture.deactivate();\n\n      const points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray,\n      });\n      points.setName('points');\n      const tcoords = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        values: tcoordArray,\n      });\n      tcoords.setName('tcoords');\n\n      const cellArray = new Uint16Array(8);\n      cellArray[0] = 3;\n      cellArray[1] = 0;\n      cellArray[2] = 1;\n      cellArray[3] = 3;\n      cellArray[4] = 3;\n      cellArray[5] = 0;\n      cellArray[6] = 3;\n      cellArray[7] = 2;\n      const cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray,\n      });\n\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points,\n        tcoords,\n        cellOffset: 0,\n      });\n      model.VBOBuildTime.modified();\n      model.VBOBuildString = toString;\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  VBOBuildTime: 0,\n  VBOBuildString: null,\n  openGLTexture: null,\n  tris: null,\n  imagemat: null,\n  imagematinv: null,\n  colorTexture: null,\n  pwfTexture: null,\n  lastHaveSeenDepthRequest: false,\n  haveSeenDepthRequest: false,\n  lastTextureComponents: 0,\n};\n\n// ----------------------------------------------------------------------------\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(\n    publicAPI,\n    model,\n    initialValues\n  );\n\n  model.tris = vtkHelper.newInstance();\n  model.openGLTexture = vtkOpenGLTexture.newInstance();\n  model.colorTexture = vtkOpenGLTexture.newInstance();\n  model.pwfTexture = vtkOpenGLTexture.newInstance();\n\n  model.imagemat = mat4.identity(new Float64Array(16));\n  model.imagematinv = mat4.identity(new Float64Array(16));\n\n  // Build VTK API\n  macro.setGet(publicAPI, model, []);\n\n  model.VBOBuildTime = {};\n  macro.obj(model.VBOBuildTime);\n\n  // Object methods\n  vtkOpenGLImageMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkOpenGLImageMapper');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkImageMapper', newInstance);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}